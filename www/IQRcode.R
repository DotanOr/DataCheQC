### IQRtools 1.8.0 source code
#### with some alterations to allow repacking using packrat
#'@export
packageR_IQRtools <- function () {
  info <- list()
  info$R$platform <- version$platform
  info$R$version <- paste0(version$major,".",version$minor)
  info$R$packages <- data.frame(
    PACKAGE = utils::installed.packages()[,"Package"],
    VERSION = utils::installed.packages()[,"Version"],
    stringsAsFactors = FALSE,
    row.names = NULL
  )
  content <- aux_fileread(paste0(getRepos(),"/src/contrib"))
  filenames <- sapply(info$R$packages$PACKAGE, function (pkg) {
    m <- gregexpr(paste0("\"",pkg,"_[^>]+"),content)
    filename <- regmatches(content,m)[[1]]
    suppressWarnings(filename <- max(filename))
    filename <- gsub("\"","",filename)
    filename
  })
  info$R$packages$FILENAME <- filenames
  Probable_RBASE_packages_NA <- info$R$packages[is.na(info$R$packages$FILENAME) & info$R$packages$VERSION == info$R$version,]
  NON_RBASE_packages_NA <- info$R$packages[is.na(info$R$packages$FILENAME) & info$R$packages$VERSION != info$R$version,]
  if (nrow(Probable_RBASE_packages_NA) > 0) {
    cat("The following packages are not available for download (seem to be BASE R packages):\n")
    print(Probable_RBASE_packages_NA)
  }
  if (nrow(NON_RBASE_packages_NA) > 0) {
    cat("The following packages are not available for download (please check it should be OK):\n")
    print(NON_RBASE_packages_NA)
  }
  info$R$packages <- info$R$packages[!is.na(info$R$packages$FILENAME),]
  aux_mkdir("rrepo")
  aux_mkdir("rrepo/src/contrib")
  dummy <- lapply(info$R$packages$FILENAME, function (file) {
    url <- paste0(getRepos(),"/src/contrib/",file)
    utils::download.file(url,destfile = paste0("rrepo/src/contrib/",file),mode = "wb")
  })
  aux_mkdir("rrepo/src/base/")
  url <- paste0(getRepos(),"/src/base/R-",version$major,"/R-",info$R$version,".tar.gz")
  utils::download.file(url,destfile = paste0("rrepo/src/base/","R-",info$R$version,".tar.gz"),mode = "wb")
  url <- paste0(getRepos(),"/src/base/INSTALL")
  utils::download.file(url,destfile = paste0("rrepo/src/base/INSTALL.txt"),mode = "wb")
  aux_mkdir("rrepo/bin/base")
  url <- paste0(getRepos(),"/bin/windows/base/R-",info$R$version,"-win.exe")
  utils::download.file(url,destfile = paste0("rrepo/bin/base/","R-",info$R$version,"-win.exe"),mode = "wb")
  rtoolsFile <- paste0("Rtools",version$major,floor(as.numeric(version$minor)),".exe")
  url <- paste0("https://cran.r-project.org/bin/windows/Rtools/",rtoolsFile)
  aux_mkdir("rrepo/Rtools/")
  utils::download.file(url,destfile = paste0("rrepo/Rtools/",rtoolsFile),mode = "wb")
  versionIQR <- aux_strrep(aux_version("IQRtools"),".9000","")
  url <- paste0("http://iqrtools.intiquan.com/rrepo/src/contrib/IQRtools_",versionIQR,".tar.gz")
  utils::download.file(url,destfile = paste0("rrepo/src/contrib/IQRtools_",versionIQR,".tar.gz"),mode = "wb")
  aux_mkdir("rrepo/dll/")
  file <- paste0("IQRtools_",versionIQR)
  url <- paste0("http://iqrtools.intiquan.com/rrepo/src/contrib/IQRtools_",versionIQR,".tar.gz")
  utils::download.file(paste0("http://iqrtools.intiquan.com/rrepo/dll/",file,".dll"),
                paste0("rrepo/dll/IQRtools_",versionIQR,".dll"),mode = "wb")
  utils::download.file(paste0("http://iqrtools.intiquan.com/rrepo/dll/",file,".so"),
                paste0("rrepo/dll/IQRtools_",versionIQR,".so"),mode = "wb")
  utils::download.file(paste0("http://iqrtools.intiquan.com/rrepo/dll/",file,".so_mac"),
                paste0("rrepo/dll/IQRtools_",versionIQR,".so_mac"),mode = "wb")
  utils::download.file(paste0("http://iqrtools.intiquan.com/rrepo/dll/",file,".so_centos6"),
                paste0("rrepo/dll/IQRtools_",versionIQR,".so_centos6"),mode = "wb")
  oldpath <- getwd()
  setwd("rrepo/src/contrib/")
  tools::write_PACKAGES(".", type="source")
  setwd(oldpath)
  utils::zip(zipfile = "rrepo.zip",files = "rrepo")
  unlink("rrepo",recursive = TRUE)
}
#' #'@export
#' support <- function () {
#'   utils::browseURL("https://groups.google.com/a/intiquan.com/g/iqr-tools-users-group")
#' }
#'@export
install_MIDDmodule <- function (module_number) {
  if (.Platform$OS.type=="windows") {
    methodDownload = "wininet"
  } else {
    methodDownload = "libcurl"
  }
  url <- paste0("https://training.intiquan.com/MIDDmodules/M",module_number,".zip")
  if (!url_exists(url)) stopIQR("Requested webinar module does not exist on server.")
  aux_mkdir("~/IntiQuan/Webinars")
  setwd("~/IntiQuan/Webinars")
  utils::download.file(url = url,
                       destfile = "webinardownload.zip",
                       mode="wb",
                       method=methodDownload)
  utils::unzip(zipfile = "webinardownload.zip",overwrite = TRUE)
  unlink("webinardownload.zip",force = TRUE)
  message(paste0("The Webinar Module ",module_number," material is installed in '~/IntiQuan/Webinars/",module_number,"'.\n\nEnjoy It!\n"))
}
#'@export
install_workshop <- function (workshop) {
  if (.Platform$OS.type=="windows") {
    methodDownload = "wininet"
  } else {
    methodDownload = "libcurl"
  }
  url <- paste0("https://training.intiquan.com/",workshop,"/material.zip")
  if (!url_exists(url)) stopIQR("Requested workshop does not exist on server.")
  setwd("~")
  utils::download.file(url = url,
                       destfile = "IntiQuan.zip",
                       mode="wb",
                       method=methodDownload)
  utils::unzip(zipfile = "IntiQuan.zip",overwrite = TRUE)
  unlink("IntiQuan.zip",force = TRUE)
  message(paste0("The workshop material is installed in '~/IntiQuan/.\n\nHappy Workshopping!\n"))
}
#' #'@export
#' doc_IQRtools <- function () {
#'   if (file.exists(system.file(package="IQRtools",paste0("docs/book/index.html")))) {
#'     location <- system.file(package="IQRtools",paste0("docs/book/index.html"))
#'   } else {
#'     location <- "https://iqrtools.intiquan.com"
#'   }
#'   utils::browseURL(location)
#' }
#'@export
examples_IQRtools <- function(path="~/IntiQuan"){
  dir <- NULL
  dir1 <- system.file(package="IQRtools","docs/material")
  dir2 <- "/IQDESKTOP/.help/iqrtools/docs/material/"
  if (dir.exists(dir1)) {
    dir <- dir1
  } else if (dir.exists(dir2)) {
    dir <- dir2
  }
  if (is.null(dir)) {
    message("Due to CRAN limitations the material is not available inside the public IQR Tools package.")
    message("To get all the examples in this manner, run IQR Tools from within IQ Desktop (https://iqdesktop.intiquan.com).")
    return()
  }
  if (grepl(" ",path)) {
    stopIQR("The path contains spaces. Choose a different path")
  }
  aux_mkdir(path)
  file.copy(from=dir, to=path,recursive=TRUE)
  setwd(path)
  message(paste0("IQR Tools documentation example material copied to: ",path))
  message(paste0("Working directory set to: ",path))
}
is_installed_PACKAGE <- function (pkg) {
  pkg %in% rownames(utils::installed.packages())
}
showStartupMessage <- function () {
  version <- aux_version("IQRtools")
  if (version=="99.0.0") version <- "PUBLIC"
  message <- paste0("\n",aux_strrep(crayon::bold(crayon::green("IQR"),crayon::silver("tools"))," ",""),": ",
                    "Supporting Efficient Model-Informed Drug Development\n\n             ",
                    crayon::bold("Version:",version),"\n\n","          Open Source (GNU AGPL-3) - Provided to You by IntiQuan\n\n")
  cat(message)
  loadSetupOptions_IQRtools()
  if (.COMPLIANCE_MODE) {
    cat(crayon::bold(crayon::green("          Compliance mode is ON\n\n")))
  } else {
    cat(crayon::bold(crayon::red("          Compliance mode is OFF\n\n")))
  }
  cat(crayon::bold(crayon::cyan("          Support: https://support.intiquan.com/iqrtools\n\n")))
  return(invisible(NULL))
}
#'@export
getRepos <- function () {
  Rversion <- paste0(version$major,".",version$minor)
  repos <- "https://cran.rstudio.com"
  if (Rversion == "3.6.3") repos <- "https://cran.intiquan.com/snapshot/2020-03-15"
  if (Rversion == "3.6.2") repos <- "https://cran.microsoft.com/snapshot/2019-04-15"
  if (Rversion == "3.6.1") repos <- "https://cran.microsoft.com/snapshot/2019-04-15"
  if (Rversion == "3.6.0") repos <- "https://cran.microsoft.com/snapshot/2019-04-15"
  if (Rversion == "3.5.3") repos <- "https://cran.microsoft.com/snapshot/2019-04-15"
  if (Rversion == "3.5.2") repos <- "https://cran.microsoft.com/snapshot/2019-02-01"
  if (Rversion == "3.5.1") repos <- "https://cran.microsoft.com/snapshot/2018-08-01"
  if (Rversion == "3.5.0") repos <- "https://cran.microsoft.com/snapshot/2018-06-01"
  if (Rversion == "3.4.4") repos <- "https://cran.microsoft.com/snapshot/2018-04-01"
  if (Rversion == "3.4.3") repos <- "https://cran.microsoft.com/snapshot/2018-01-01"
  if (Rversion == "3.4.2") repos <- "https://cran.microsoft.com/snapshot/2017-10-15"
  if (Rversion == "3.4.1") repos <- "https://cran.microsoft.com/snapshot/2017-09-01"
  if (Rversion == "3.4.0") repos <- "https://cran.microsoft.com/snapshot/2017-05-01"
  if (Rversion == "3.3.3") repos <- "https://cran.microsoft.com/snapshot/2017-03-15"
  if (Rversion == "3.3.2") repos <- "https://cran.microsoft.com/snapshot/2016-11-01"
  if (Rversion == "3.3.1") repos <- "https://cran.microsoft.com/snapshot/2016-07-01"
  if (Rversion == "3.3.0") repos <- "https://cran.microsoft.com/snapshot/2016-06-01"
  if (Rversion == "3.2.4") repos <- "https://cran.microsoft.com/snapshot/2016-04-01"
  if (repos=="https://cran.rstudio.com") warningIQR("Using official CRAN repo - results might not be reproducible!")
  return(repos)
}
#'@export
setup_IQRtools <- function(local=FALSE){
  if (!local) {
    file.edit(system.file(package="IQRtools","setup_options_IQRtools.R"))
  } else {
    loadSetupOptions_IQRtools()
    if (!.ALLOW_USER_SETTINGS_FILE) {
      stopIQR("The use of a local setup_options_IQRtools.R file has been disabled")
    }
    home__ <- Sys.getenv("HOME")
    file__ <- paste0(home__,"/setup_options_IQRtools.R")
    file.edit(file__)
  }
}
exit <- function() {
  .Internal(.invokeRestart(list(NULL, NULL), NULL))
}
#'@export
test_IQRtools <- function() {
  model <- IQRmodel(system.file(package="IQRtools","models/NovakTyson.txt"))
  sim_IQRmodel(model,seq(0:0.1:1))
}
#'@export
test_IQReport <- function() {
  oldpath <- getwd()
  if (.Platform$OS.type=="windows") {
    folder <- "C:/LOCAL/IQReport/test"
  } else {
    folder <- "~/IntiQuan/IQReport/test"
  }
  aux_mkdir(folder)
  setwd(folder)
  df <- cbind(cars=rownames(datasets::mtcars),datasets::mtcars)
  rmd <- rmdTITLE(template="DefaultStyle.rmdt",title = "TEST") +
    rmdSECTION("A table") +
    rmdTABLEDF(df,"Some table")
  export_IQRrmd(rmd,"test.rmd")
  message("Generating test Word document ...")
  IQReport("test.rmd")
  if (.Platform$OS.type=="windows") {
    system(paste0("openDocx.bat . test"))
  }
  message(paste0("Word document generated in ",getwd()))
  setwd(oldpath)
}
#'@export
test_IQRsbml <- function() {
  message("Importing a larger SBML model ...")
  model <- IQRmodel(system.file(package = "IQRtools","models/model.xml"))
  print(model)
  message("Simulating the model ...")
  res <- sim_IQRmodel(model)
  message("Plotting results ...")
  plotres <- tidyr::gather(res,NAME,VALUE,-TIME)
  IQRggplot(plotres, aes(x=TIME,y=VALUE,GROUP=NAME)) + geom_line()
}
#'@export
test_MONOLIX <- function() {
  loadSetupOptions_IQRtools()
  if (.Platform$OS.type=="windows") {
    a <- system(paste0(.PATH_SYSTEM_MONOLIX[[1]],"/bin/monolix.bat"))
  } else {
    a <- system(paste0(.PATH_SYSTEM_MONOLIX[[1]],"/bin/monolix.sh"))
  }
  if (a!=0) {
    stopIQR("MONOLIX path has not been setup correctly. Execute setup_IQRtools() and update the path to MONOLIX")
  } else {
    message("MONOLIX is set up correctly")
  }
}
#'@export
test_NONMEM <- function() {
  loadSetupOptions_IQRtools()
  a <- system(paste0(.PATH_SYSTEM_NONMEM[[1]]))
  if (a==127) {
    stopIQR("NONMEM path has not been setup correctly. Execute setup_IQRtools() and update the path to NONMEM")
  } else {
    message("NONMEM is set up correctly")
  }
}
#'@export
getOSIQR <- function(){
  i <- Sys.info()[["sysname"]]
  if (i=="Windows") return("windows")
  if (i=="Darwin") return("mac")
  if (i=="Linux") return("unix")
  stopIQR("Unknown operating system")
}
#'@export
libraryPK_IQRtools <- function(pathname = "Resources") {
  libraryPath <- system.file("docs/material/ModelLibraryPK", package = "IQRtools")
  if (!file.exists(pathname)) dir.create(pathname)
  check <- file.copy(from = libraryPath, to = pathname, recursive = TRUE, overwrite = TRUE)
  if (check) message(paste0("IQR Tools PK model library was copied to ", pathname)) else warningIQR(paste0("IQR Tools PK model library could not be copied to ", pathname))
}
checkPackage_IQRtools <- function(package,requiredVersion=NULL) {
  if (!(package %in% rownames(utils::installed.packages()))) {
    if (is.null(requiredVersion)) {
      stopIQR(paste0("Package '",package,"' is not installed but required for this functionality."))
    } else {
      stopIQR(paste0("Package '",package,"' is not installed but required (Version: '",requiredVersion,"') for this functionality."))
    }
  }
  if (!is.null(requiredVersion)) {
    if (aux_version(package)!=requiredVersion)
      stopIQR(paste0("Package '",package,"' is installed but required version is: '",requiredVersion,"'."))
  }
}
url_exists <- function(x, non_2xx_return_value = FALSE, quiet = TRUE,...) {
  suppressPackageStartupMessages({
    require("httr", quietly = FALSE, warn.conflicts = FALSE)
  })
  capture_error <- function(code, otherwise = NULL, quiet = TRUE) {
    tryCatch(
      list(result = code, error = NULL),
      error = function(e) {
        if (!quiet)
          message("Error: ", e$message)
        list(result = otherwise, error = e)
      },
      interrupt = function(e) {
        stop("Terminated by user", call. = FALSE)
      }
    )
  }
  safely <- function(.f, otherwise = NULL, quiet = TRUE) {
    function(...) capture_error(.f(...), otherwise, quiet)
  }
  sHEAD <- safely(httr::HEAD)
  sGET <- safely(httr::GET)
  res <- sHEAD(x, ...)
  if (is.null(res$result) ||
      ((httr::status_code(res$result) %/% 200) != 1)) {
    res <- sGET(x, ...)
    if (is.null(res$result)) return(NA) 
    if (((httr::status_code(res$result) %/% 200) != 1)) {
      if (!quiet) warning(sprintf("Requests for [%s] responded but without an HTTP status code in the 200-299 range", x))
      return(non_2xx_return_value)
    }
    return(TRUE)
  } else {
    return(TRUE)
  }
}
allowed_spaces_IQR <- function () {
  loadSetupOptions_IQRtools()
  return(.ALLOW_SPACES_IN_PATH)
}
#'@export
createSubmissionPack <- function(
  specification,
  analysisname,
  pathroot = ".",
  programExtension = ".txt",
  extensionChange = c("_lower","_", "-lower","-", "none"),
  allowedProgExt = c(".txt", ".lua", ".sas", ".r", ".ctl"),
  fullpathData = FALSE,
  logfile = "logfile.txt",
  substituteUpper = TRUE,
  substituteUnderscore = FALSE,
  allowSubfolder = FALSE,
  overwrite = FALSE,
  calcMD5 = FALSE,
  copyAttributes = FALSE
) {
  idxDatasets <- which(specification$Type %in% c("model", "dataset"))
  idxPrograms <- which(specification$Type %in% c("model", "program"))
  accepttype__ <- c("model", "program", "dataset")
  if (!all(specification$Type %in% accepttype__)) stopIQR(paste0("Only ", paste0(accepttype__, collapse = ", "), " allowed as type (of file/folder) to be packed."))
  if (any(specification$Type == "model" & (specification$Name == "" | is.na(specification$Name)))) stopIQR("Name must be given for all models.")
  genPath <- file.path("m5/datasets",analysisname,"analysis/legacy")
  if (dir.exists(file.path(pathroot, genPath))) {
    if (overwrite) {
      warningIQR("A folder for this analysis already exits and will be overwritten.")
      unlink(file.path(pathroot, "m5/datasets",analysisname), recursive = TRUE)
    } else {
      stopIQR("A folder for this analysis already exits. Set overwrite=TRUE if you want to overwrite the existing analysis path.")
    }
  }
  dir.create(file.path(pathroot, genPath, "datasets"), recursive = TRUE)
  dir.create(file.path(pathroot, genPath, "programs"))
  extensionChange = match.arg(extensionChange, c("_lower","_", "-lower","-", "none"))
  if (length(idxDatasets) > 0) {
    infoD__ <- purrr::map_dfr(idxDatasets, function(k) {
      if (specification$Type[k] == "dataset") {
        dataPath__        <- specification$Source[k]
        dataDescription__ <- specification$Description[k]
        dataNote__        <- "other dataset"
        dataName__        <- ifelse(is.na(specification$Name[k]), aux_fileparts(dataPath__)$filename, specification$Name[k])
        dataSource__      <- dataPath__
        modelFolder__     <- "null"
      } else {
        dataSource__      <- getHeader_IQRnlmeProject(specification$Source[k])$DATA
        dataPath__        <- aux_simplifypath(file.path(specification$Source[k], dataSource__))
        dataDescription__ <- paste0("Modeling data set for ", specification$Description[k])
        dataNote__        <- "modeling dataset; from nlme project"
        dataName__        <- ifelse(is.na(specification$Name[k]), aux_fileparts(dataPath__)$filename, specification$Name[k])
        modelFolder__     <- specification$Source[k]
      }
      if (is.na(specification$defineRMD[k])) {
        defineRMD__ <- gsub(".csv$", "_define.rmd", dataPath__)
      } else {
        defineRMD__ <- specification$defineRMD[k]
      }
      if (substituteUpper) {
        dataName__ <- tolower(dataName__)
      }
      if (substituteUnderscore) {
        dataName__ <- gsub("[_]","-",dataName__)
      }
      data.frame(name = dataName__,
                 path = dataPath__,
                 source = dataSource__,
                 description = dataDescription__,
                 note = dataNote__,
                 destination = paste0(dataName__, ".xpt"),
                 project = modelFolder__,
                 rmdPath = defineRMD__,
                 stringsAsFactors = FALSE)
    })
    infoD__ <- infoD__ %>%
      mutate(xptPath = gsub("csv$","xpt",path),
             atrPath = gsub("csv$","atr",path),
             checkXPT = file.exists(xptPath),
             checkRMD = file.exists(rmdPath),
             checkATR = file.exists(atrPath),
             checkCSV = file.exists(path))
    if (any(duplicated(infoD__$name))) {
      stopIQR("Duplicated dataset names:", paste0(unique(infoD__$name[duplicated(infoD__$name)]), collapse = ", "),
              "\nPlease specify different `Name`")
    }
    infoD__$xptInfo <- ""
    for (kdat__ in 1:nrow(infoD__)) {
      if (!infoD__$checkXPT[kdat__]) {
        if (infoD__$checkCSV[kdat__]) {
          dataTmp <- IQRloadCSVdata(infoD__$path[kdat__])
          if (!infoD__$checkATR[kdat__]) {
            covInfoAdd <- NULL
            catInfoAdd <- NULL
            infoD__$xptInfo[kdat__] <- "unannotated XPT created"
          } else {
            covInfoAdd <- attr(dataTmp, "covInfo")
            catInfoAdd <- attr(dataTmp, "catInfo")
            infoD__$xptInfo[kdat__] <- "annotated XPT created"
          }
          IQRoutputXPT(dataTmp, filename = file.path(pathroot, genPath, "datasets", infoD__$destination[[kdat__]]),
                       covInfoAdd = covInfoAdd, catInfoAdd = catInfoAdd)
          unlink(file.path(pathroot, genPath, "datasets", paste0(infoD__$destination[[kdat__]], ".log")))
        } else {
          infoD__$xptInfo[kdat__] <- "dataset does not exist (neither as original or as xpt)"
        }
      } else {
        file.copy(infoD__$xptPath[[kdat__]],
                  file.path(pathroot, genPath, "datasets", infoD__$destination[[kdat__]]))
        infoD__$xptInfo[kdat__] <- "existing XPT copied"
        if (!infoD__$checkCSV[kdat__]) {
          infoD__$xptInfo[kdat__] <-  paste0(infoD__$xptInfo[kdat__], " (original dataset does not exist)")
        }
      }
    }
    defineInfo__ <- lapply(1:nrow(infoD__), function(kdat__) {
      if ( !infoD__$checkRMD[kdat__] & !infoD__$checkATR[kdat__] ) {
        warningIQR(paste0(infoD__$path[kdat__], ": Define file does not exist and cannot be created automatically (attribute file missing).\n"))
        defineInfo__ <- "No define table available or created (missing attributes)."
        contLines__  <- NULL
        tableLine__  <- NULL
      } else {
        if (infoD__$checkRMD[kdat__]) {
          contentRMD__ <- aux_fileread(infoD__$rmdPath[kdat__], collapserows = FALSE)
          defineInfo__ <- "Define table parsed from existing rmd file."
        } else {
          dataTmp <- IQRloadCSVdata(infoD__$path[[kdat__]])
          class(dataTmp) <- c("IQRdataGENERAL", "data.frame")
          exportDEFINE_IQRdataGENERAL(
            dataTmp,
            datasetName = infoD__$name[kdat__],
            datasetLocation = file.path(pathroot, genPath, "datasets", infoD__$destination[[kdat__]]),
            datasetDescription = infoD__$description[kdat__],
            filename = "./defineTMP"
          )
          contentRMD__ <- aux_fileread("defineTMP.rmd", collapserows = FALSE)
          unlink("defineTMP.rmd")
          unlink("defineTMP.docx")
          defineInfo__ <- "Define table created based on attribute information."
        }
        idxSpecSec__  <- intersect(grep("#[*]", contentRMD__), grep("specification", contentRMD__))
        idxTableEnd__ <- max(grep("^[|]", contentRMD__))
        if (fullpathData) {
          tableLine__ <- paste0("| [",infoD__$name[kdat__],"](#spec",kdat__,") | ",infoD__$description[kdat__]," | ",file.path(genPath, "datasets", infoD__$destination[kdat__]), " | ", infoD__$source[kdat__]," |")
        } else {
          tableLine__ <- paste0("| [",infoD__$name[kdat__],"](#spec",kdat__,") | ",infoD__$description[kdat__]," | ",infoD__$destination[kdat__], " | ", infoD__$source[kdat__]," |")
        }
        contLines__ <- c(
          paste0("#* ", infoD__$name[kdat__], " specification {#spec", kdat__,"}"),
          contentRMD__[(idxSpecSec__+1):(idxTableEnd__+1)]
        )
        contLines__ <- gsub("size:8", "size:10", contLines__)
      }
      list(defineInfo = defineInfo__,
           contLines = contLines__,
           tableLine = tableLine__)
    })
    rmdHead__ <- c(
      "=====",
      "TITLE:    Define file",
      "SUBTITLE: ",
      "DATE:     ",
      "TEMPLATE: DefaultStyle.rmdt",
      "=====",
      "", "",
      "!NOINTRO",
      "!BLOCKSTART[keepNext](block_kwnext)",
      "",
      "#* Dataset name, description, and location",
      "",
      "!TABINLINE[Dataset information,size:10,label:overview,ignoreCaption:true,valueTable:false]",
      "| Dataset Name     | Description              | Location                           | Source                             |",
      "| ---------------- | ------------------------ | ---------------------------------- | ---------------------------------- |"
    )
    rmdContent__ <- c(rmdHead__,
                      do.call(c,lapply(defineInfo__, function(hh) hh$tableLine)),
                      do.call(c,lapply(defineInfo__, function(hh) c("","!NEWPAGE","", hh$contLines))),
                      "","!BLOCKEND(block_kwnext)","")
    aux_filewrite(rmdContent__, filename = file.path(pathroot, genPath, "datasets", "define.rmd"))
    IQReport(file.path(pathroot, genPath, "datasets", "define.rmd"))
    infoD__$defineInfo <- do.call(c, lapply(defineInfo__, function(hh) hh$defineInfo))
    if (any(infoD__$checkATR) && copyAttributes) {
      infoA__ <- purrr::map_dfr(which(infoD__$checkATR), function(idx__) {
        data.frame(
          path = infoD__$atrPath[idx__],
          description = paste0("Metadata for dataset *", basename(infoD__$destination[idx__]),"*"),
          note = "attribute file",
          destination = file.path("Resources", paste0(basename(infoD__$atrPath[idx__]), ".txt")),
          stringsAsFactors = FALSE
        )
      })
    }
  } else {
    colInfoD <- c("name", "path", "source", "description", "note", "destination", "project",
                  "rmdPath", "xptPath", "atrPath",
                  "checkXPT", "checkRMD", "checkATR", "checkCSV",
                  "xptInfo", "defineInfo")
    infoD__ <- data.frame(matrix(ncol=length(colInfoD),nrow=0, dimnames=list(NULL, colInfoD)))
  }
  if (length(idxPrograms) > 0) {
    infoP__ <- purrr::map_dfr(idxPrograms, function(k) {
      if (specification$Type[k] == "program") {
        progPath__        <- specification$Source[k]
        if (is.na(specification$Name[k]) || specification$Name[k] == "") {
          progDestination__ <- aux_simplifypath(file.path(specification$SubFolder[k],
                                                          basename(specification$Source[k])))
        } else {
          progDestination__ <- aux_simplifypath(file.path(specification$SubFolder[k],
                                                          specification$Name[k]))
        }
        if (aux_fileparts(progDestination__)$fileext == "") {
          progDestination__ <- paste0(progDestination__, aux_fileparts(progPath__)$fileext)
        }
        if (!aux_fileparts(progDestination__)$fileext %in% allowedProgExt) {
          nametmp <- file.path(aux_fileparts(progDestination__)$pathname,aux_fileparts(progDestination__)$filename)
          exttmp <- aux_fileparts(progDestination__)$fileext
          progDestination__ <- switch(extensionChange,
                                      none = paste0(progDestination__, ".txt"),
                                      `_lower` = paste0(nametmp, gsub("[.]","_", tolower(exttmp)), ".txt"),
                                      `_`      = paste0(nametmp, gsub("[.]","_", exttmp), ".txt"),
                                      `-lower` = paste0(nametmp, gsub("[.]","-", tolower(exttmp)), ".txt"),
                                      `-`      = paste0(nametmp, gsub("[.]","-", exttmp), ".txt"))
        }
        if (!(is.na(specification$Description[k]) || specification$Description[k]=="")) {
          progDescription__ <- specification$Description[k]
          progNote__        <- "user defined description"
        } else {
          scrcont__ <- aux_fileread(specification$Source[k], collapserows = FALSE)
          ixdheadl__ <- grep("^[#]",scrcont__, invert = TRUE)[1]-1
          scrhead__ <- scrcont__[1:(grep("^[#]",scrcont__, invert = TRUE)[1]-1)]
          scrhead__ <- gsub("^[#']+","", scrhead__)
          scrhead__ <- trimws(scrhead__)
          if (length(scrhead__) == 0) {
            progDescription__ <- "!RED(Please add script documentation.)"
            progNote__ <- "no script header detected"
          } else {
            idxPurpose__ <- grep("[PURPOSE]", scrhead__, fixed = TRUE)
            if (length(idxPurpose__) == 0) {
              progDescription__ <- paste0(scrhead__[1:(which(scrhead__ == "")[1]-1)], collapse = " ")
              progNote__ <- "description as all lines at beginning until first empty line"
            } else {
              idxItems__ <- grep("^[[]", scrhead__)
              i0__ <- idxItems__[which(idxItems__==idxPurpose__)]+1
              i1__ <- idxItems__[which(idxItems__==idxPurpose__)+1]-1
              progDescription__ <- paste0(scrhead__[i0__:i1__], collapse = " ")
              progNote__ <- "description from purpose section"
            }
          }
        }
        data.frame(path = progPath__,
                   description = progDescription__,
                   note = progNote__,
                   destination = progDestination__,
                   stringsAsFactors = FALSE)
      } else {
        modelName__ <- ifelse(is.na(specification$Name[k]), aux_fileparts(specification$Source[k])$filename, specification$Name[k])
        dataName__  <- infoD__$destination[infoD__$project == specification$Source[k]]
        if (is_NONMEM_IQRnlmeProject(specification$Source[k])) {
          progPath__ <- c(
            file.path(specification$Source[k], "project.nmctl"),
            file.path(specification$Source[k], "RESULTSORIG", "project.nmlog"))
          progDestination__ <- c(
            aux_simplifypath(file.path(specification$SubFolder[k], paste0(modelName__,".nmclt"))),
            aux_simplifypath(file.path(specification$SubFolder[k], paste0(modelName__,".nmlog"))))
          progDescription__ <- c(
            paste0(specification$Description[k], " - Input file (NONMEM); analysis data: ",dataName__),
            paste0(specification$Description[k], " - Output file (NONMEM)"))
          progNote__ <- c("nonmem model", "nonmem model")
        } else if (is_MONOLIX_IQRnlmeProject(specification$Source[k])) {
          progPath__ <- c(
            file.path(specification$Source[k], "project.mlxtran"),
            file.path(specification$Source[k], "project_model.txt"),
            file.path(specification$Source[k], "RESULTSORIG", "summary.txt"))
          progDestination__ <- c(
            aux_simplifypath(file.path(specification$SubFolder[k], paste0(modelName__,".mlxtran"))),
            aux_simplifypath(file.path(specification$SubFolder[k], paste0(modelName__,"_model.txt"))),
            aux_simplifypath(file.path(specification$SubFolder[k], paste0(modelName__,"_summary.txt"))))
          progDescription__ <- c(
            paste0(specification$Description[k], " - Input file (Monolix); analysis data: ",dataName__),
            paste0(specification$Description[k], " - Model definition file (Monolix)"),
            paste0(specification$Description[k], " - Output file (Monolix)"))
          progNote__ <- c("monolix model", "monolix model", "monolix model")
        } else {
          progPath__ <- specification$Source[k]
          progDestination__ <- NA
          progDescription__ <- NA
          progNote__ <- "file does not exist"
        }
        for (k in seq_along(progDestination__)) {
          if (!aux_fileparts(progDestination__[k])$fileext %in% allowedProgExt) {
            nametmp <- aux_fileparts(progDestination__[k])$filename
            exttmp <- aux_fileparts(progDestination__[k])$fileext
            progDestination__[k] <- switch(extensionChange,
                                           none = paste0(progDestination__, ".txt"),
                                           `_lower` = paste0(nametmp, gsub("[.]","_", tolower(exttmp)), ".txt"),
                                           `_`      = paste0(nametmp, gsub("[.]","_", exttmp), ".txt"),
                                           `-lower` = paste0(nametmp, gsub("[.]","-", tolower(exttmp)), ".txt"),
                                           `-`      = paste0(nametmp, gsub("[.]","-", exttmp), ".txt"))
          }
        }
        data.frame(path = progPath__,
                   description = progDescription__,
                   note = progNote__,
                   destination = progDestination__,
                   stringsAsFactors = FALSE)
      }
    })
    if (substituteUpper) {
      infoP__$destination <- tolower(infoP__$destination)
    }
    if (substituteUnderscore) {
      infoP__$destination <- gsub("[_]","-",infoP__$destination)
    }
    if (exists("infoA__")) {
      infoP__ <- bind_rows(infoP__, infoA__)
    }
    if (!allowSubfolder) {
      infoP__$destination <- sapply(infoP__$destination, function(dest) gsub("/","_",aux_simplifypath(dest), fixed = TRUE))
    }
    for (kprog__ in 1:nrow(infoP__)) {
      file.copy(from = infoP__$path[[kprog__]],
                to   = file.path(pathroot, genPath, "programs", infoP__$destination[[kprog__]]))
    }
    if (length(list.files(file.path(pathroot, genPath, "programs", "Resources"))) == 0) {
      unlink(file.path(pathroot, genPath, "programs", "Resources"), recursive = TRUE)
    }
    rmdHead__ <- c(
      "=====",
      "TITLE:    Define file",
      "SUBTITLE: ",
      "DATE:     ",
      "TEMPLATE: DefaultStyle.rmdt",
      "=====",
      "", "",
      "!NOINTRO",
      "",
      "#* Notes on script execution",
      "",
      "NLME models and R analysis scripts cannot be executed in the format provided in this package.",
      "To run the parameter estimation or execute the analysis, at least the following steps need to be conducted.",
      "",
      "* __NLME models__",
      "    - Data xpt file(s) in *datasets* need(s) to be converted to csv file(s).",
      "    - .csv file(s) need to be located in the relative path given in the model control file(s).",
      "      Move file or adjust relative path.",
      "    - File extensions may need to be converted to original.",
      "* __R scripts__",
      "    - Data xpt file(s) in *datasets* need(s) to be converted to csv file(s)",
      "    - If attribute files for csv files exists (usually found in *Resources* or stored with the *Resources_* prefix), these need to be placed in the same location as the .csv file.",
      "    - Paths to data files and files with additional information are given in the R scripts as relative paths",
      "      which is different from the path in which they are submitted. Please make sure to adjust the path or",
      "      create folders and place the files appropriately.",
      "    - File extensions may need to be converted to original.",
      "",
      "#* Program file description",
      "",
      "!TABINLINE[caption:Program information,size:8,label:overview,ignoreCaption:true,valueTable:false]",
      "| File             | Description              |",
      "| ---------------- | ------------------------ |"
    )
    tableLines__ <- purrr::map_chr(1:nrow(infoP__), function(k) {
      paste0("| ", infoP__$destination[k], " | ", infoP__$description[k], " |")
    })
    rmdContent__ <- c(rmdHead__, tableLines__, "")
    aux_filewrite(rmdContent__, filename = file.path(pathroot, genPath, "programs", "Reviewersguide.rmd"))
    IQReport(file.path(pathroot, genPath, "programs", "Reviewersguide.rmd"))
  } else {
    colInfoP <- c("path", "description", "note", "destination")
    infoP__ <- data.frame(matrix(ncol=length(colInfoP),nrow=0, dimnames=list(NULL, colInfoP)))
  }
  if (calcMD5) {
    allFiles <- c(file.path(pathroot, genPath, "datasets", infoD__$destination),
                  file.path(pathroot, genPath, "programs", infoP__$destination))
    checksums <- tools::md5sum(allFiles)
    checksumTable <- data.frame(
      File = gsub("^[/]","",gsub(pathroot,"", allFiles, fixed = TRUE)),
      MD5  = checksums,
      stringsAsFactors = FALSE
    )
    rownames(checksumTable) <- NULL
    IQRoutputCSV(checksumTable, file.path(pathroot, "checksums.csv"))
  }
  dataTab <- infoD__ %>% select(`Dataset` = path,
                                `Submission File` = destination,
                                Type = note,
                                `Note on XPT` = xptInfo,
                                `Note on define file` = defineInfo)
  progTab <- infoP__ %>% select(`Program` = path,
                                Type = note,
                                `Submission File` = destination)
  nameCheck <- data.frame(name = c(infoD__$destination, infoP__$destination, analysisname),
                          type = c(rep("dataset", length(infoD__$destination)),
                                   rep("program", length(infoP__$destination)),
                                   "analysisname"),
                          stringsAsFactors = FALSE)
  nameCheck$namebase <- sapply(nameCheck$name, function(f) aux_fileparts(f)$filename)
  msgTooLong <- " * All folder and file names have at most 64 characters."
  idxTooLong <- nchar(nameCheck$name) > 64
  if (any(idxTooLong)) {
    msgTooLong <- " * The following files or folders have too long filename (more than 65 characters):"
    msgTooLong <- c(msgTooLong, with(nameCheck[idxTooLong,], paste0("    * '",name,"' (", type,")")))
  }
  msgAllowChar <- " * All folder and file names have only lower case characters, hyphen, or underscores."
  idxBadChar <- stringr::str_count(nameCheck$namebase, "[[:digit:][:lower:][_][-]]") != nchar(nameCheck$namebase)
  if (any(idxBadChar)) {
    msgAllowChar <- " * The following file or folder names contain not only lower case, hyphen, or underscores."
    msgAllowChar <- c(msgAllowChar,with(nameCheck[idxBadChar,], paste0("    * '",name,"' (", type,")")))
  }
  msgFileext <- " * Unique file extension for all files"
  idxMulitext <- sapply(nameCheck$namebase, function(f) aux_fileparts(f)$fileext) != ""
  if (any(idxMulitext)) {
    msgFileext <- " * The following file or folder names have multiple extensions:"
    msgFileext <- c(msgFileext, with(nameCheck[idxMulitext,], paste0("    * '",name,"' (", type,")")))
  }
  notes__ <- c(
    strrep("~", 45+nchar(analysisname)),
    paste0(" Creation of submission package of analysis ", analysisname, " "),
    strrep("~", 45+nchar(analysisname)),
    "",
    "Manual post-processing is probably needed. Please check notes below for TODO items.",
    "",
    paste0("- Destination path was ", file.path(pathroot, genPath)),
    "- Datasets (also datasets belonging to NLME models) were copied to subfolder 'datasets'",
    "- A common define file was created as (rmd and word document)",
    "- If a *Name* was given for models, it was used for the copied dataset as well as for the model program files, otherwise the original dataset filename and the project folder name were used for copied data file and model program files respectvely.",
    "- Programs (and NLME model files) were copied to subfolder 'programs'",
    {if (allowSubfolder) "    * programs were also copied to subfolders if specified" else "    * programs were also not copied to subfolders if specified but a suffix created correspondingly."},
    {if (copyAttributes) "    * attibutes for datasets were copied to programs as well"},
    paste0("    * Program extension were turned in to '", programExtension, "' with the exception of ", paste0(allowedProgExt, collapse = ", "), " that were kept as is."),
    switch(extensionChange,
           none = paste0("'",programExtension,"' was appended to unchanged file extension" ),
           `_lower` = paste0("    * '",programExtension,"' was appended to lower cased file extension and with '_' substituting the '.'"),
           `_`      = paste0("    * '",programExtension,"' was appended to file extension and with '_' substituting the '.'" ),
           `-lower` = paste0("    * '",programExtension,"' was appended to lower cased file extension and with '-' substituting the '.'" ),
           `-`      = paste0("    * '",programExtension,"' was appended to file extension and with '-' substituting the '.'" )),
    {if (copyAttributes) "    * attributes for datasets were copied to programs as well"},
    {if (substituteUpper) "- Upper case letters in all filenames were turned into lower case."},
    {if (substituteUnderscore) "- Underscores were substituted by `-` in all filenames"},
    "- Reviewer's guide for the programs was created (rmd and word document)",
    {if (calcMD5) "- Checksums (MD5) were calculated and are available in 'checksums.csv' in the given root folder."},
    "",
    "----- Checks -----",
    "File or folder names were checked whether they comply to FDA guidelines.",
    "",
    msgAllowChar,
    msgTooLong,
    msgFileext,
    "",
    "----- Handled datasets -----",
    "",
    {
      if (nrow(dataTab) > 0) {
        c(text_IQRoutputTable(IQRoutputTable(dataTab, report = FALSE)),
        "",
        "   --->>> TODO:",
        "    - Check define file and save as PDF with fast web access enabled",
        "      * If required add page numbers to word document before saving as PDF.",
        "      * Check whether hyper text links are functional",
        "      * No annotations are allowed",
        "      * Check that font sizes are 9 to 12 points for text 9 to 10 points for tables, 10 points for footnotes.",
        "      * Remove the rmd file when not needed anymore.",
        {if (any(dataTab$`Note on define file` == "No define table available or created (missing attributes)."))
          "    - Provide missing define information." },
        {if (any(grepl("dataset does not exist", dataTab$`Note on XPT`)))
          "    - Check missing original datasets" })
      } else {
        "No datasets included."
      }
    },
    "",
    "----- Notes on programs -----",
    "",
    {
      if (nrow(progTab) > 0) {
        c(text_IQRoutputTable(IQRoutputTable(progTab, report = FALSE)),
        "",
        "   --->>> TODO:",
        "    - Check reviewer's guide and store as PDF with fast web access enabled",
        "      * If required add page numbers to word document before saving as PDF.",
        "      * Check whether hyper text links are functional.",
        "      * No annotations are allowed.",
        "      * Check that font sizes are 9 to 12 points for text 9 to 10 points for tables, 10 points for footnotes.",
        "      * Remove the rmd file when not needed anymore.",
        {if (any(progTab$Note == "no script header detected"))
          "    - Provide missing description for programs."},
        {if (any(progTab$Note == "file does not exist"))
          "    - Check non-existing program files"})
      } else {
        "No programs included."
      }
    }
  )
  IQRoutputFile(notes__, logfile)
}
#'@export
getProgramSpecification <- function(folder,
                                    extensions = c(".R", ".txt", ".r"),
                                    recursive = TRUE) {
  keepPattern__ <- paste0("[.]", paste0(gsub("^[.]","",extensions), collapse = "$|[.]"), "$")
  filesFull__ <- list.files(folder, full.names = TRUE, recursive = recursive, pattern = keepPattern__)
  filesRel__  <- list.files(folder, full.names = FALSE, recursive = recursive, pattern = keepPattern__)
  subfolders__ <- aux_fileparts(filesRel__)$pathname
  out__ <- data.frame(
    Source = filesFull__,
    Subfolder = subfolders__,
    Name = NA,
    Type = "program",
    Description = NA,
    defineRMD = NA,
    stringsAsFactors = FALSE
  )
  out__
}
#'@export
getModelSpecification <- function(modelList) {
  purrr::imap_dfr(modelList, function(mod, nam) {
    data.frame(
      Source = mod,
      Name = nam,
      Type = "model",
      Description = NA,
      defineRMD = NA,
      SubFolder = NA,
      stringsAsFactors = FALSE
    )
  })
}
#'@export
IQRoutputValueTable <- function(value,label,description="",path="../Output/00_ValueTable") {
  if (length(value) > 1) stopIQR("Value has to be of length 1")
  if (nchar(gsub("\\W","",label)) != nchar(label)) stopIQR("label argument only allowed to contain characters: A-Z, a-z, 0-9")
  if (file.exists(path)) {
    vTpre <- load_ValueTable(path)
    if (any(grepl(label,vTpre$label))) stopIQR("Label argument is already present in value table elements")
  }
  vTelement <- data.frame(
    label = label,
    value = value,
    description = description,
    stringsAsFactors = FALSE
  )
  filename <- paste0(path,"/vT_",label,".rds")
  if (file.exists(filename)) stopIQR("Valuetable element with same filename already exists.")
  IQRoutputRDS(vTelement,filename)
  filenameVT <- paste0(path,"/TAB01_ValueTable.txt")
  tab <- load_ValueTable(path)
  IQRoutputTable(xtable = tab,xtitle = "Value table for lookup and reporting purposes",filename = filenameVT)
  return(invisible(NULL))
}
load_ValueTable <- function(path="../Output/00_ValueTable") {
  if (!dir.exists(path)) stopIQR("Value table folder does not exist")
  files <- list.files(path,pattern = "*.rds",full.names = TRUE)
  files <- files[!grepl(".rds.log",files)]
  do.call(rbind,lapply(files, function (file) {
    out__ <- readRDS(file)
    logInfo <- parseLogfile(paste0(file,".log"))
    if (!is.null(logInfo)) {
      out__$log <- paste0(logInfo$outputfile,"; ",logInfo$analysisfile,"; ",logInfo$date)
    } else {
      out__$log <- ""
    }
    out__
  }))
}
parseLogfile <- function (path) {
  if (!file.exists(path)) return(NULL)
  content <- aux_fileread(path,collapserows = FALSE)
  list(
    username = aux_strtrim(aux_explode(content[grepl("Username",content)],"\\|")[2]),
    analysisfile = aux_strtrim(aux_explode(content[grepl("Analysis file",content)],"\\|")[2]),
    date = aux_strtrim(aux_explode(content[grepl("Date of creation",content)],"\\|")[2]),
    outputfile = aux_strtrim(aux_explode(content[grepl("File (relative to calling function)",content,fixed = TRUE)],"\\|")[2])
  )
}
#'@export
is_enabled_complianceMode <- function(){
  loadSetupOptions_IQRtools()
  test <- globalenv()$IQRTOOLS_OVERRIDE_SETTING_COMPLIANCE_MODE
  test <- ifelse(is.null(test),FALSE,test)
  if (exists("IQRTOOLS_OVERRIDE_SETTING_COMPLIANCE_MODE")) return(IQRTOOLS_OVERRIDE_SETTING_COMPLIANCE_MODE)
  return(F)
}
#'@export
is_enabled_rdsMode <- function(){
  loadSetupOptions_IQRtools()
  return(F)
}
#'@export
IQRinitCompliance <- function(scriptname){
  e__ <- globalenv()
  e__$COMPLIANCE_MODE_SCRIPT_NAME <- scriptname
}
genComplianceLog <- function(outputfilename, FLAGshort = FALSE, FLAGsession = FALSE) {
  if (!is_enabled_complianceMode()) return()
  if (is.null(outputfilename)) return()
  e__ <- globalenv()
  if (!("COMPLIANCE_MODE_SCRIPT_NAME" %in% ls(e__)))
    stopIQR("Compliance mode is enabled but the COMPLIANCE_MODE_SCRIPT_NAME variable has not\nbeen defined in the global environment (by the user). You can use the function IQRinitCompliance to do so")
  COMPLIANCE_MODE_SCRIPT_NAME <- e__$COMPLIANCE_MODE_SCRIPT_NAME
  logt__ <- "<TT>   File generation log"
  logfilepath__ <- paste(outputfilename,'.log',sep='')
  outputfilename <- gsub('//','/',outputfilename)
  userrow__ <- Sys.info()[['user']]
  timerow__ <- Sys.time()
  short__ <- paste0(COMPLIANCE_MODE_SCRIPT_NAME, " | User: ", userrow__, " | Date: ", timerow__)
  callr__   <- paste('<TR>   Analysis file                       | ',COMPLIANCE_MODE_SCRIPT_NAME,sep='')
  pathrow__ <- paste('<TR>   File (relative to calling function) | ',outputfilename,sep='')
  userrow__ <- paste('<TR>   Username                            | ',userrow__,sep='')
  timerow__ <- paste('<TR>   Date of creation                    | ',timerow__,sep='')
  loglength__ <- max(1,max(nchar(callr__)),nchar(timerow__),nchar(userrow__),nchar(pathrow__))
  logsep__ <- paste(c("       ",rep("=",loglength__-7),"\n"),collapse="",sep='')
  content__ <- c(logt__,logsep__,pathrow__,userrow__,timerow__,callr__)
  if (FLAGshort) content__ <- short__
  if (FLAGsession) return(content__)
  write(content__,logfilepath__,append=FALSE)
}
#'@export
IQRoutputCSV <- function(data,
                         filename,
                         na=".",
                         quote=FALSE,
                         row.names=FALSE,
                         FLAGattributes=TRUE,
                         replaceComma=NULL) {
  if (is.null(filename)){
    warningIQR("filename is NULL - no file written")
    return(data)
  }
  filename.csv__ <- paste0(aux_strrep(filename,".csv",""),".csv")
  IQRsaveCSVdata(data,
                 filename.csv__,
                 na=na,
                 quote=quote,
                 row.names=row.names,
                 FLAGattributes=FLAGattributes,
                 replaceComma=replaceComma)
  genComplianceLog(filename.csv__)
  if (FLAGattributes) {
    filenameATR <- gsub('\\.csv(.gz)?$','.atr', filename)
    if (file.exists(filenameATR)) {
      genComplianceLog(filenameATR)
    }
  }
}
#'@export
IQRoutputFile <- function(text,filename) {
  if (is.null(filename)) return()
  aux_mkdir(aux_fileparts(filename)$pathname)
  aux_filewrite(text,filename)
  genComplianceLog(filename)
}
#'@export
IQRoutputRDS <- function(object,filename) {
  if (is.null(filename)) return()
  filename <- paste0(aux_strrep(filename,".rds",""),".rds")
  aux_mkdir(aux_fileparts(filename)$pathname)
  saveRDS(object,filename)
  genComplianceLog(filename)
}
#'@export
IQRoutputPNG <- function(gr, filename=NULL, res = 300, width = 21/2.54, height = 21/2.54*3/4, scale=1, scaleWidth=1, scaleHeight=1, ...) {
  on.exit({if (!is.null(filename)) aux_closePNGs()})
  if (!is.null(filename)) {
    aux_closePNGs()
    filename <- paste0(aux_strrep(filename,".png",""),".png")
    aux_mkdir(aux_fileparts(filename)$pathname)
    grDevices::png(filename, height = height*scale*scaleHeight, width = width*scale*scaleWidth, bg = "transparent", res = res, units = "in")
    if ("gtable" %in% class(gr))
    {
      print(graphics::plot(gr))
    } else {
      print(gr)
    }
    genComplianceLog(filename)
    aux_closePNGs()
    if (is_enabled_rdsMode()) {
      saveRDS(gr,file=paste0(filename,".rds"))
    }
  }
}
#'@export
IQRoutputPDF <- function(gr,
                         filename=NULL,
                         width = 21/2.54,
                         height = 21/2.54*3/4,
                         scale=1,
                         scaleWidth=1,
                         scaleHeight=1,
                         nrow = 1, ncol = 1,
                         ...) {
  on.exit({if (!is.null(filename)) aux_closePDFs()})
  if (!is.null(filename)) {
    aux_closePDFs()
    filename <- paste0(aux_strrep(filename,".pdf",""),".pdf")
    aux_mkdir(aux_fileparts(filename)$pathname)
    dummy__ <- grDevices::pdf(file = filename,
                              onefile=TRUE,
                              width=width*scale*scaleWidth,
                              height=height*scale*scaleHeight,
                              ...)
    if ("gtable" %in% class(gr)) {
      print(graphics::plot(gr))
    } else {
      if ("ggplot" %in% class(gr)) {
        print(gr)
      } else {
        if ("list" %in% class(gr)& "arrangelist" %in% class(gr[[1]])) {
          plyr::l_ply(gr, print)
        } else {
          if ("list" %in% class(gr)) {
            printGrid(gr, nrow = nrow, ncol = ncol)
          } else {
            if ("IQRslideplot" %in% class(gr)) {
              print(gr)
            } else {
              stopIQR("Unhandled graphics object")
            }
          }
        }
      }
    }
    aux_closePDFs()
    genComplianceLog(filename)
    if (is_enabled_rdsMode()) {
      saveRDS(gr,file=paste0(filename,".rds"))
    }
  }
}
#'@export
IQRoutputPDFstart <- function(filename, width = 21/2.54, height = 21/2.54*3/4, scale=1, scaleWidth=1, scaleHeight=1, ...) {
  aux_closePDFs()
  if (!is.null(filename)) {
    aux_mkdir(aux_fileparts(filename)$pathname)
    if (file.exists(filename)) {
      unlink(filename)
    }
    dummy__ <- grDevices::pdf(file = paste0(aux_strrep(filename,".pdf",""),".pdf"), onefile=TRUE,
                              width=width*scale*scaleWidth,
                              height=height*scale*scaleHeight, ...)
  }
}
#'@export
IQRoutputPDFend <- function(filename) {
  aux_closePDFs()
  if (!is.null(filename)) {
    genComplianceLog(paste0(aux_strrep(filename,".pdf",""),".pdf"))
  }
}
#'@export
IQRoutputTable <- function(xtable=NULL,
                           xfooter=NULL,
                           xtitle=NULL,
                           object=NULL,
                           filename=NULL,
                           report=NULL,
                           na.string=NULL,
                           FLAGreplaceRoundBracketsHeader=TRUE,
                           verbose=NULL) {
  if (!is.null(filename)) {
    filename <- paste0(aux_strrep(filename,".txt",""),".txt")
    aux_mkdir(aux_fileparts(filename)$pathname)
  }
  if (is.null(verbose)) verbose <- TRUE
  if (is.null(xtable) & is.null(object)) stopIQR("Neither xtable nor object defined")
  if (!is.null(xtable) & !is.null(object)) stopIQR("Both xtable and object defined")
  if (!is.null(xtable) & is.null(report)) report <- TRUE
  if (!is.null(xfooter)) {
    xfooter <- paste(xfooter, collapse = "\n")
  }
  if (!is.null(object) & (!"IQRoutputTable" %in% class(object))) stopIQR("Input argument object is not an IQRoutputTable object")
  if (is.null(object)) {
    out__ <- list(
      xtable = xtable,
      xtitle = xtitle,
      xfooter = xfooter,
      report = report,
      filename = filename
    )
  } else {
    out__ <- list(
      xtable = object$xtable,
      xtitle = {
        if (is.null(xtitle)) {
          x__ <- object$xtitle
        } else {
          x__ <- xtitle
        }
        x__
      },
      xfooter =  {
        if (is.null(xfooter)) {
          x__ <- object$xfooter
        } else {
          x__ <- xfooter
        }
        x__
      },
      report =  {
        if (is.null(report)) {
          x__ <- object$report
        } else {
          x__ <- report
        }
        x__
      },
      filename =  {
        if (is.null(filename)) {
          x__ <- object$filename
        } else {
          x__ <- filename
        }
        x__
      }
    )
  }
  class(out__) <- c("IQRoutputTable",class(out__))
  if (!is.null(filename)) {
    aux_filewrite(text=text_IQRoutputTable(out__,
                                           report=report,
                                           na.string=na.string,
                                           FLAGreplaceRoundBracketsHeader=FLAGreplaceRoundBracketsHeader),
                  filename=paste0(aux_strrep(filename,".txt",""),".txt"))
    genComplianceLog(filename)
    if (is_enabled_rdsMode()) {
      saveRDS(out__,file=paste0(filename,".rds"))
    }
  }
  if (is.null(filename) | verbose) {
    return(out__)
  }
}
#'@export
print.IQRoutputTable <- function (x, ...) {
  cat(text_IQRoutputTable(x,report = FALSE))
  cat("\n\nIQRoutputTable object")
}
#'@export
text_IQRoutputTable <- function (object,report=NULL, na.string=NULL,FLAGreplaceRoundBracketsHeader=TRUE) {
  if (!"IQRoutputTable" %in% class(object)) stopIQR("Input argument not an IQRoutputTable object")
  xtable <- object$xtable
  xfooter <- object$xfooter
  xtitle <- object$xtitle
  if (is.null(report)) report <- object$report
  if (FLAGreplaceRoundBracketsHeader) {
    n__ <- names(xtable)
    n__ <- gsub("(","[",n__,fixed = TRUE)
    n__ <- gsub(")","]",n__,fixed = TRUE)
    names(xtable) <- n__
  }
  if (!is.null(xfooter)) {
    if (report) {
      xfooter <- gsub("\n","<br>",xfooter,fixed = TRUE)
      xfooter <- gsub("^\\* ","\\\\* ",xfooter)
      xfooter <- gsub("<br>\\* ","<br>\\\\* ",xfooter)
    } else {
      xfooter <- gsub("<br>","\n",xfooter,fixed = TRUE)
    }
  }
  if (report) {
    trid__ <- "<TR>"
    tfid__ <- "<TF>"
    ttid__ <- "<TT>"
    thid__ <- "<TH>"
  } else {
    trid__ <- ""
    tfid__ <- ""
    ttid__ <- ""
    thid__ <- ""
  }
  tr__ <- format(data.frame(lapply(xtable,function (x) as.character(x)),stringsAsFactors = FALSE),justify="left")
  if (!is.null(na.string))
    tr__ <- data.frame(lapply(tr__, function(x) {x[grepl("^NA$", trimws(x))] <- na.string; x} ))
  if ("matrix" %in% class(xtable)){
    th__ <- paste0("X",c(1:ncol(xtable)))
  }  else{ 
    th__ <- colnames(xtable)
  }
  widths <- rep(1,ncol(xtable))
  for (coli__ in c(1:length(widths))) {
    tr_nchar <- nchar(tr__[,coli__])
    tr_nchar <- ifelse(length(tr_nchar) == 0, 0, tr_nchar)
    th_nchar <- nchar(th__[coli__])
    th_nchar <- ifelse(length(th_nchar) == 0, 0, th_nchar)
    widths[coli__] <- max(1, max(tr_nchar, th_nchar))
  }
  for (coli__ in c(1:length(th__))){
    th__[coli__] <- format(th__[coli__], width = widths[coli__])
  }
  th__ <- paste(th__,collapse= " | ")
  th__ <- paste(thid__," ",th__, collapse= "")
  for (coli__ in c(1:length(widths))){
    tr__[,coli__] <- sprintf(paste('%-',widths[coli__], 's',sep=''),tr__[,coli__])
  }
  tr__ <- utils::capture.output(utils::write.table(tr__,quote=FALSE,sep=" | ",row.names = FALSE,col.names=FALSE))
  tr__ <- paste(tr__,collapse = paste0("\n",trid__,"   "))
  tr__ <- paste(paste0(trid__,"  "),tr__,collapse="")
  if (!is.null(xfooter)) {
    if (report) {
      tf__ <- paste(tfid__,"  ",xfooter, collapse= "")
    } else {
      tf__ <- paste0(tfid__,xfooter, collapse= "")
    }
    tf__ <- format(tf__, width = nchar(th__))
  } else {
    tf__ <- ""
  }
  if (!is.null(xtitle)) {
    tt__ <- paste(ttid__," ",xtitle, collapse="")
    tt__ <- format(tt__, width = nchar(th__))
  } else {
    tt__ <- ""
  }
  tablength__ <- max(nchar(th__),nchar(tt__))  
  nminus <- 7
  if (!report) nminus <- 3
  xxx <- "       "
  if (!report) xxx <- "   "
  thsep__ <- paste0(c(xxx,rep("-",tablength__-nminus),"\n"),collapse="")
  tfsep__ <- paste0(c(xxx,rep("-",tablength__-nminus)),collapse="")
  ttsep__ <- paste0(c(xxx,rep("=",tablength__-nminus),"\n"),collapse="")
  if (is.null(xtitle)) {
    IQRtableHead__ <- paste(th__,thsep__, sep = "\n")
  } else {
    IQRtableHead__ <- paste(tt__,ttsep__,th__,thsep__, sep = "\n")
  }
  if (is.null(xfooter)) {
    IQRtableFoot__ <- NULL
  } else {
    IQRtableFoot__ <- paste(tfsep__,tf__, sep = "\n")
  }
  allTable__ <- paste0(IQRtableHead__,tr__,"\n",IQRtableFoot__)
  allTable__
}
#'@export
IQRoutputFigure <- function(x = NULL,
                            title = NULL,
                            subtitle = NULL,
                            footer = NULL,
                            filename=NULL,
                            FLAGreport = FALSE,
                            opt.pagesize = list(width = 21/2.54, height = 21/2.54*3/4,
                                                scale = 1, scaleWidth=1, scaleHeight=1,
                                                res = 300),
                            opt.layout   = list(nrow = NULL, ncol = NULL, npage = NULL,
                                                legend.option = c("as.is", "remove", "first.on.page"),
                                                legend.object = NULL,
                                                legend.position = "right", legend.relsize = 0.2,
                                                title.relheight = 0.05, subtitle.relheight = 0.05, footer.relheight = 0.05),
                            FLAGdraft = FALSE,
                            ...) {
  on.exit({if (!is.null(filename)) aux_closeDevice(aux_fileparts(filename)[["fileext"]])})
  if (inherits(x, "IQRoutputFigure")) {
    object <- x
    gr <- NULL
  } else {
    object <- NULL
    gr <- x
  }
  names.opt.layout   <- names(formals("opt.layout"))
  names.opt.pagesize <- names(formals("opt.pagesize"))
  if (!all(names(opt.layout) %in% names.opt.layout)) {
    stopIQR(paste0("No valid layout option(s):", paste0(setdiff(names(opt.layout), names.opt.layout), collapse = ", ")))
  }
  if (!all(names(opt.pagesize) %in% names.opt.pagesize)) {
    stopIQR(paste0("No valid page size option(s): ", paste0(setdiff(names(opt.pagesize), names.opt.pagesize), collapse = ", ")))
  }
  inputs__ <- as.list(match.call(expand.dots = TRUE))
  inputoptions__ <- inputs__[!names(inputs__) %in% c("", "x", "title", "subtitle", "footer", "filename", "FLAGreport", "FLAGdraft")]
  if ("opt.layout" %in% names(inputoptions__)) inputoptions__$opt.layout <- opt.layout 
  if ("opt.pagesize"   %in% names(inputoptions__)) inputoptions__$opt.pagesize   <- opt.pagesize 
  for (optk in intersect(names(inputoptions__), names.opt.layout)) {
    if (!"opt.layout" %in% names(inputoptions__)) inputoptions__$opt.layout <- list()
    inputoptions__$opt.layout[[optk]] <- eval(inputoptions__[[optk]])
    inputoptions__[[optk]] <- NULL
  }
  for (optk in intersect(names(inputoptions__), names.opt.pagesize)) {
    if (!"opt.pagesize" %in% names(inputoptions__)) inputoptions__$opt.pagesize <- list()
    inputoptions__$opt.pagesize[[optk]] <- eval(inputoptions__[[optk]])
    inputoptions__[[optk]] <- NULL
  }
  if ("legend.option" %in% names(inputoptions__$opt.layout)) {
    if (length(inputoptions__$opt.layout$legend.option) != 1) warningIQR("Only first element of legend.option is used.")
    if (is.numeric(inputoptions__$opt.layout$legend.option)) {
      if (!inputoptions__$opt.layout$legend.option[1] %in% 1:3) {
        stopIQR("legend.option needs to be numeric input of 1, 2, or 3, or character input of 'as.is', 'remove', or 'common'.")
      } else {
        inputoptions__$opt.layout$legend.option <- c("as.is", "remove", "common")[inputoptions__$opt.layout$legend.option]
      }
    } else {
      if (!inputoptions__$opt.layout$legend.option[1] %in% c("as.is", "remove", "common")) {
        stopIQR("legend.option needs to be numeric input of 1, 2, or 3, or character input of 'as.is', 'remove', or 'common'.")
      }
    }
  }
  argslist__ <- as.list(formals())
  argslist__ <- argslist__[!names(argslist__) %in% c("x", "title", "subtitle", "footer", "filename", "FLAGreport", "FLAGdraft", "...")]
  argslist__$opt.layout <- eval(argslist__$opt.layout)
  argslist__$opt.pagesize <- eval(argslist__$opt.pagesize)
  defoptions__ <- argslist__[setdiff(names(argslist__), intersect(names(inputoptions__), c(names.opt.layout, names.opt.pagesize)))]
  if ("opt.layout" %in% names(inputoptions__)) defoptions__$opt.layout <- defoptions__$opt.layout[setdiff(names(defoptions__$opt.layout), names(inputoptions__$opt.layout))]
  if ("opt.pagesize"   %in% names(inputoptions__)) defoptions__$opt.pagesize   <- defoptions__$opt.pagesize[setdiff(names(defoptions__$opt.pagesize), names(inputoptions__$opt.pagesize))]
  if (!is.null(object)) {
    defoptions__ <- defoptions__[setdiff(names(defoptions__), c(names(object$opt.layout), names(object$opt.pagesize)))]
    if ("opt.layout" %in% names(object)) defoptions__$opt.layout <- defoptions__$opt.layout[setdiff(names(defoptions__$opt.layout), names(object$opt.layout))]
    if ("opt.pagesize"   %in% names(object)) defoptions__$opt.pagesize   <- defoptions__$opt.pagesize[setdiff(names(defoptions__$opt.pagesize), names(object$opt.pagesize))]
  }
  if (!is.null(object)) {
    output__ <- object
    if ("opt.layout" %in% names(inputoptions__)) {
      new.opt.layout <- inputoptions__$opt.layout
    } else {
      new.opt.layout <- list()
    }
    for (layopt in names(new.opt.layout)) {
      if (is.null(output__$opt.layout)) output__$opt.layout <- list()
      output__$opt.layout[[layopt]] <- new.opt.layout[[layopt]]
    }
    if ("opt.pagesize" %in% names(inputoptions__)){
      new.opt.pagesize <- eval(inputoptions__$opt.pagesize)
    } else {
      new.opt.pagesize <- list()
    }
    for (pagopt in names(new.opt.pagesize)) {
      if (is.null(output__$opt.pagesize)) output__$opt.pagesize <- list()
      output__$opt.pagesize[[pagopt]] <- new.opt.pagesize[[pagopt]]
    }
    if ("title" %in% names(inputs__)) output__$title <- title
    if ("subtitle" %in% names(inputs__)) output__$subtitle <- subtitle
    if ("footer" %in% names(inputs__)) output__$footer <- footer
    if ("filename" %in% names(inputs__)) output__$filename <- filename
    if ("FLAGdraft" %in% names(inputs__)) output__$draft <- FLAGdraft
  }
  if (!is.null(gr)) {
    if (!(is_plot_object(gr) | all(sapply(gr, is_plot_object))))
      stopIQR("Input gr needs to be plot object or list of these")
    if (is_plot_object(gr)) gr <- list(gr)
    output__ <- list(
      content = gr,
      title = title,
      subtitle = subtitle,
      footer = footer,
      filename = filename
    )
    output__ <- purrr::discard(output__, is.null)
    if (!is.null(attr(gr, "plotdata"))) output__$plotdata <- attr(gr, "plotdata")
    if ("opt.layout" %in% names(inputoptions__)){
      opt.layout <- eval(inputoptions__$opt.layout)
    } else {
      opt.layout <- list()
    }
    if (length(opt.layout) > 0) output__$opt.layout <- opt.layout
    if ("opt.pagesize" %in% names(inputoptions__)){
      opt.pagesize <- eval(inputoptions__$opt.pagesize)
    } else {
      opt.pagesize <- list()
    }
    if (length(opt.pagesize) > 0) output__$opt.pagesize <- opt.pagesize
    output__$draft <- FLAGdraft
    class(output__) <- c("IQRoutputFigure", class(output__))
  }
  if (ifelse("legend.option" %in% names(output__$opt.layout), output__$opt.layout$legend.option != "common", TRUE)) {
    if (!is.null(output__$opt.layout$legend.object)) warningIQR("Legend object provided, but legend option not set to 'common'. Object will be ignored when plotting.")
    if (!is.null(output__$opt.layout$legend.position)) warningIQR("Legend position provided, but legend option not set to 'common'. Setting will be ignored when plotting.")
    if (!is.null(output__$opt.layout$legend.relsize)) warningIQR("Relative legend size provided, but legend option not set to 'common'. Setting will be ignored when plotting.")
  }
  if (!is.null(filename)) {
    objectPlot__ <- output__
    if (FLAGreport) {
      anntitle__  <- paste0("Title : ", ifelse("title" %in% names(objectPlot__),objectPlot__$title,""))
      annfooter__ <- paste0("Footer : ", ifelse("footer" %in% names(objectPlot__),objectPlot__$footer,""))
      annotation <- c(anntitle__,annfooter__)
      objectPlot__$title  <- NULL
      objectPlot__$footer <- NULL
    }
    layoutargs__ <- c(list(x=objectPlot__), defoptions__$opt.layout)
    layoutargs__$legend.option <- layoutargs__$legend.option[1]
    pages__     <- do.call(createPages_IQRoutputFigure, layoutargs__)
    devargs__ <- c(objectPlot__$opt.pagesize, defoptions__$opt.pagesize) 
    for (opt__ in names(devargs__)) assign(opt__, devargs__[[opt__]])
    fileType <- dplyr::case_when(
      grepl("[.]pdf$", filename) ~ "PDF",
      grepl("[.]png$", filename) ~ "PNG",
      TRUE ~ NA_character_
    )
    if (is.na(fileType)) stopIQR("File name needs to have .pdf or .png suffix. Only PDF or PNG output is handled.")
    if (fileType == "PDF") {
      argsDot <- list(...)
      namesDotKeep <- setdiff(names(argsDot), names.opt.pagesize) 
      namesDotKeep <- intersect(namesDotKeep, names(formals("pdf"))) 
      argsDot <- argsDot[namesDotKeep]
      do.call(IQRoutputPDF, c(list(gr=pages__, filename=filename,
                                   width = width, height = height,
                                   scale = scale, scaleWidth = scaleWidth, scaleHeight = scaleHeight,
                                   nrow = 1, ncol = 1), argsDot))
      if (FLAGreport) aux_filewrite(annotation, filename = paste0(filename,".ann"))
    }
    if (fileType == "PNG") {
      if (is_plot_object(pages__)) pages__ <- list(pages__)
      if (length(pages__) > 1) {
        nformat <- paste0("%.",1+floor(log10(length(pages__))),"d")
        .fname <- paste0(aux_strrep(filename,".png",""),"_", sprintf(nformat,seq_along(pages__)), ".png")
      } else {
        .fname <- filename
      }
      purrr::map2(.fname, pages__, function(.f,.p) {
        IQRoutputPNG(.p, filename=.f,
                     width = width, height = height, res = res,
                     scale = scale, scaleWidth = scaleWidth, scaleHeight = scaleHeight, ...)
        if (FLAGreport) aux_filewrite(annotation, filename = paste0(.f,".ann"))
      })
    }
    return(invisible(output__))
  } else {
    return(output__)
  }
}
#'@export
print.IQRoutputFigure <- function(
  x,
  nrow = NULL, ncol = NULL, npage = NULL,
  legend.option = "as.is", legend.object = NULL, legend.position = "right",
  legend.relsize = 0.2,
  title.relheight = 0.05, subtitle.relheight = 0.05, footer.relheight = 0.05,
  ...
) {
  inputoptions__ <- as.list(match.call(expand.dots = TRUE))
  inputoptions__ <- inputoptions__[!names(inputoptions__) %in% c("", "x")]
  plot_pages__ <- do.call(createPages_IQRoutputFigure, c(list(x=x), inputoptions__))
  if (is_plot_object(plot_pages__)) {
    print(plot_pages__)
  } else {
    lapply(plot_pages__, print)
    npages__ <- length(plot_pages__)
    if (npages__>1) {
      cat(paste0(length(plot_pages__), " pages were printed to the graphics device."))
    }
  }
  return(invisible(NULL))
}
#'@export
plot.IQRoutputFigure <- function(x, ...) {
  print(x, ...)
}
#'@export
summary.IQRoutputFigure <- function(object, ...) {
  x <- object
  dfmain__ <- tibble::tribble(
    ~a               , ~b,
    "Title"          , ifelse(is.null(object$title),crayon::silver("- none -"),object$title),
    "Number of plots", as.character(length(object$content)),
    "Subtitle"       , ifelse(is.null(object$subtitle),crayon::silver("- none -"),object$subtitle),
    "Footer"         , ifelse(is.null(object$footer),crayon::silver("- none -"),object$footer),
    "Filename"       , ifelse(is.null(object$filename),crayon::silver("- none -"),object$filename)
  )
  dfmain__$a <- format(dfmain__$a)
  dflayout__ <- NULL
  if ("opt.layout" %in% names(object)) {
    if (length(object$opt.layout)>0) {
      if ("legend.object" %in% names(object$opt.layout)) object$opt.layout$legend.object <- "Common legend provided"
      dflayout__ <- data.frame(a=names(object$opt.layout), b=sapply(object$opt.layout,c), stringsAsFactors = FALSE)
      dflayout__$a <- format(dflayout__$a)
    }
  }
  dfdev__ <- NULL
  if ("opt.pagesize" %in% names(object)) {
    if (length(object$opt.pagesize)>0) {
      dfdev__ <- data.frame(a=names(object$opt.pagesize), b=sapply(object$opt.pagesize,c), stringsAsFactors = FALSE)
      dfdev__$a <- format(dfdev__$a)
    }
  }
  cat("=== IQRoutputFigure object ===\n")
  for (k in 1:nrow(dfmain__)) cat(dfmain__$a[k], " : ", dfmain__$b[k],"\n", sep = "")
  if (!is.null(dflayout__)) {
    cat(crayon::blue("--- Defined layout settings:\n"))
    for (k in 1:nrow(dflayout__)) cat(crayon::blue(paste0(dflayout__$a[k], " : ", dflayout__$b[k],"\n")))
  } else {
    cat(crayon::silver("--- No layout settings\n"))
  }
  if (!is.null(dfdev__)) {
    cat(crayon::green("--- Defined page size settings for writing PDF or PNG:\n"))
    for (k in 1:nrow(dfdev__)) cat(crayon::green(paste0(dfdev__$a[k], " : ", dfdev__$b[k],"\n")))
  } else {
    cat(crayon::silver("--- No page size settings defined\n"))
  }
  return(invisible(NULL))
}
#'@export
print.IQRoutputFigureList <- function(x, ...) {
  lapply(x, function(x) summary.IQRoutputFigure(x))
}
#'@export
opt.pagesize <- function(width = NULL, height = NULL,
                         scale = NULL,
                         scaleWidth  = NULL, scaleHeight = NULL,
                         res         = NULL) {
  out <- list()
  out$width       <- width
  out$height      <- height
  out$scale       <- scale
  out$scaleWidth  <- scaleWidth
  out$scaleHeight <- scaleHeight
  out$res         <- res
  return(out)
}
#'@export
opt.layout <- function(nrow               = NULL,
                       ncol               = NULL,
                       npage              = NULL,
                       legend.option      = NULL,
                       legend.object      = NULL,
                       legend.position    = NULL,
                       legend.relsize     = NULL,
                       title.relheight    = NULL,
                       subtitle.relheight = NULL,
                       footer.relheight   = NULL) {
  out <- list()
  out$nrow               = nrow
  out$ncol               = ncol
  out$npage              = npage
  out$legend.option      = legend.option
  out$legend.object      = legend.object
  out$legend.position    = legend.position
  out$legend.relsize     = legend.relsize
  out$title.relheight    = title.relheight
  out$subtitle.relheight = subtitle.relheight
  out$footer.relheight   = footer.relheight
  return(out)
}
#'@export
import_IQRdataOriginal <- function(filename,
                                   description = "No description available",
                                   MD5 = NULL,
                                   target = basename(filename),
                                   interactive = TRUE) {
  path__ <- NULL
  logfile__ <- "datasources.txt"
  stopifnot(length(filename) == 1,
            length(description) == 1,
            length(target) == 1,
            !is.null(logfile__))
  if(!is.character(filename)) {
    stopIQR("The argument filename should be a character string denoting a file.")
  }
  if(!file.exists(filename)) {
    stopIQR("The specified filename ", as.character(filename), " does not exist.")
  }
  if (is.null(MD5)) MD5 <- "not provided"
  if (is.null(path__)) path__ <- "./"
  target.path__ <- dirname(as.character(target[1]))
  target <- basename(as.character(target[1]))
  if (target.path__ != ".") path__ <- target.path__
  logfile__ <- as.character(logfile__[1])
  fromScratch__ <- FALSE
  aux_mkdir(path__)
  if (!file.exists(file.path(path__, logfile__))) {
    file.create(file.path(path__, logfile__))
    message("A logfile called ", logfile__, " was created.")
  }
  con__ <- try(file(file.path(path__, logfile__), "r", blocking = FALSE), silent = TRUE)
  mysources__ <- readLines(con__)
  close(con__)
  files.index__ <- grep("@File:", mysources__)
  if (length(files.index__) == 0) fromScratch__ <- TRUE
  if (!fromScratch__) {
    files.index__ <- c(files.index__, length(mysources__) + 1)
    files__ <- lapply(seq_along(files.index__[-1]), function(i) {
      substream__ <- mysources__[files.index__[i]:(files.index__[i+1]-1)]
      do.call(rbind, lapply(strsplit(substream__, split = ": "), function(v) {
        if (length(v) < 2) return()
        v <- trimws(v)
        data.frame(Tag = v[1], Value = paste(v[-1], collapse = ": "), stringsAsFactors = FALSE)
      }))
    })
    MD5.contained__ <- all(sapply(files__, function(d) any(d[["Tag"]] %in% "@MD5 File")))
    if (!MD5.contained__)
      stopIQR("The specified logfile already existed but is not a valid logfile because MD5 sums are missing.")
  }
  if (file.exists(file.path(path__, target))) {
    MD5.source__ <- tools::md5sum(filename)[[1]]
    MD5.target__ <- tools::md5sum(file.path(path__, target))[[1]]
    if (MD5.target__ != MD5.source__) {
      message__ <- paste0("The target already exists. The MD5 sum between original and new file is different. ",
                          "Would you like to overwrite the file? (Y/n) ")
      if (interactive) {
        answer__ <- readline(message__)
      } else {
        answer__ <- "y"
      }
      if (tolower(substr(answer__, 1, 1)) == "n")
        return(message())
    } else {
      message("The source file was copied to the target location.")
    }
  } else {
    message("The source file was copied to the target location.")
  }
  copied <- file.copy(filename, file.path(path__, target), overwrite = TRUE)
  entry__ <- character()
  entry__["@File"] <- target
  entry__["@Description"] <- description
  entry__["@Source"] <- filename
  entry__["@Date"] <- date()
  entry__["@MD5 Source"] <- tools::md5sum(filename)[[1]]
  entry__["@MD5 File"] <- tools::md5sum(file.path(path__, entry__["@File"]))[[1]]
  entry__["@MD5 Customer"] <- tolower(MD5)
  entry__["@MD5 Check"] <- ifelse(length(setdiff(entry__[c("@MD5 Source", "@MD5 File", "@MD5 Customer")], "not provided")) == 1,
                                  yes = "All available MD5 sums match.",
                                  no = "!!! MD5 MISMATCH !!!")
  newfile__ <- data.frame(Tag = names(entry__), Value = as.character(entry__), stringsAsFactors = FALSE)
  if (grepl("MISMATCH", entry__[["@MD5 Check"]]))
    warningIQR("Encountered MD5 MISMATCH during import. The file was copied and imported. Please check what happend.")
  if (!fromScratch__) {
    file.check__ <- sapply(files__, function(d) {
      md5.ref__ <- d[["Value"]][d[["Tag"]] %in% "@MD5 File"][1]
      file.ref__ <- d[["Value"]][d[["Tag"]] %in% "@File"][1]
      if (md5.ref__ != entry__["@MD5 File"] & file.ref__ == entry__["@File"])
        return("update")
      if (md5.ref__ != entry__["@MD5 File"] & file.ref__ != entry__["@File"])
        return("different")
      if (md5.ref__ == entry__["@MD5 File"] & file.ref__ == entry__["@File"])
        return("identical")
      if (md5.ref__ == entry__["@MD5 File"] & file.ref__ != entry__["@File"])
        return("same")
    })
    if (any(file.check__ == "identical")) {
      message("The identical file already existed in the logfile. ",
              "The date in the logfile was updated.")
      files__[[which(file.check__ == "identical")]] <- newfile__
    } else {
      if (any(file.check__ == "update")) {
        message("The logfile was updated with the new information.")
        files__[[which(file.check__ == "update")]] <- newfile__
      }
      if (any(file.check__ == "same")) {
        message("According to the logfile, a file with the same MD5 sum but different name exists.")
        files__ <- c(files__, list(newfile__))
      }
      if (all(file.check__ == "different")) {
        files__ <- c(files__, list(newfile__))
      }
    }
  } else {
    files__ <- list(newfile__)
  }
  output__ <- paste0(do.call(function(...) paste(..., sep = "\n\n"), lapply(files__, function(f) {
    paste(paste(format(paste0(f[["Tag"]], ":")),
                f[["Value"]]), collapse = "\n")
  })), "\n\n")
  con__ <- file(file.path(path__, logfile__))
  writeLines(output__, con__)
  close(con__)
}
#'@export
IQRoutputXPT <- function(data, filename = NULL, covInfoAdd = NULL, catInfoAdd = NULL, addColLabels = NULL) {
  if (is.null(filename)) {
    stopIQR("filename must be provided")
  }
  if (is_IQRdataGENERAL(data) || ("IQRdataNLME" %in% attr(data, "class"))) {
    stopIQR("Use exportXPT_IQRdataGENERAL for this object.")
  }
  x <- aux_fileparts(filename)
  filename <- x$filename
  pathname <- x$pathname
  if (nchar(filename) > 8) {
    stopIQR("please provide a filename with length of max 8 characters (w/o extension)")
  }
  if (!is.null(covInfoAdd)) {
    attr(data, "covInfo") <- data.frame(covInfoAdd, stringsAsFactors = FALSE)
  }
  if (!is.null(catInfoAdd)) {
    attr(data, "catInfo") <- data.frame(catInfoAdd, stringsAsFactors = FALSE)
  }
  dataX <- data.frame(lapply(names(data), function(x) {
    x <- data[[x]]
    if (!is.null(levels(x))) {
      x <- levels(x)[x]
    }
    if (is.logical(x)) x <- as.double(x)
    if (is.integer(x)) x <- as.double(x)
    x
  }), row.names = NULL, stringsAsFactors = FALSE)
  names(dataX) <- names(data)
  attr(dataX,"methodBLLOQ") <- attr(data,"methodBLLOQ")
  attr(dataX,"doseNAMES")   <- attr(data,"doseNAMES")
  attr(dataX,"obsNAMES")    <- attr(data,"obsNAMES")
  attr(dataX,"aeNAMES")     <- attr(data,"aeNAMES")
  attr(dataX,"covInfo")     <- attr(data,"covInfo")
  attr(dataX,"catInfo")     <- attr(data,"catInfo")
  attr(dataX,"class")       <- c("IQRdataNLME","data.frame")
  attr(dataX,"imputeInfo")  <- attr(data,"imputeInfo")
  data <- dataX
  data <- addLabel_IQRdataGENERAL(data, addColLabels)
  aux_mkdir(pathname)
  haven::write_xpt(
    data = data,
    path = file.path(pathname, paste0(filename, ".xpt")),
    name = filename,
    version = 5
  )
  genComplianceLog(file.path(pathname, paste0(filename, ".xpt")))
}
#'@export
IQRoutputDEFINE <- function(data,
                            datasetName=NULL,
                            datasetLocation=NULL,
                            datasetDescription="Analysis dataset",
                            covInfoAdd=NULL,
                            catInfoAdd=NULL,
                            addColLabels=NULL,
                            filename=NULL) {
  if (is_IQRdataGENERAL(data) || ("IQRdataNLME" %in% attr(data,"class")))
    stopIQR("Use exportDEFINE_IQRdataGeneral function")
  if (is.null(datasetName))
    stopIQR("Please provide a name for the dataset as it should appear in the define file")
  if (is.null(datasetLocation))
    warningIQR("Please provide a location (path) for the dataset as it should appear in the define file")
  attr(data,"covInfo")      <- data.frame(covInfoAdd,stringsAsFactors = FALSE)
  attr(data,"catInfo")      <- data.frame(catInfoAdd,stringsAsFactors = FALSE)
  if (nrow(attr(data,"covInfo"))==0) attr(data,"covInfo") <- NULL
  if (nrow(attr(data,"catInfo"))==0) attr(data,"catInfo") <- NULL
  dataFirst__ <- data.frame(NAME=datasetName,DESCRIPTION=datasetDescription,LOCATION=datasetLocation,stringsAsFactors=FALSE,row.names=NULL)
  dataDefine__ <- data.frame(NAME=names(data),stringsAsFactors=FALSE,row.names=NULL)
  dataDefine__$TYPE <-lapply(data, function (x) { if (is.numeric(x)) { out <- "Numeric" } else { out <- "String" }; out })
  data <- addLabel_IQRdataGENERAL(data,addColLabels)
  dataDefine__$LABEL <-lapply(data, function (x) {
    label__ <- attr(x,"label")
    if (is.null(label__)) label__ <- "UNKNOWN"
    label__
  })
  dataDefine__$VALUES <- getValueTxtDefine(dataDefine__$NAME,data)
  dataDefine__$COMMENTS <- " "
  datasetName__ <- toupper(datasetName)
  RMDTEXT__ <- rmdEMPTY()
  RMDTEXT__ <- RMDTEXT__ + rmdTITLE(title=paste0("Define file for the \"",datasetName__,"\" dataset"),subtitle=NULL,date=NULL)
  RMDTEXT__ <- RMDTEXT__ + rmdNOINTRO()
  RMDTEXT__ <- RMDTEXT__ + rmdSECTION("Dataset name, description, and location",numbered=FALSE)
  RMDTEXT__ <- RMDTEXT__ + rmdTABLEDF(dataFirst__,label="overview",fontsize=8,caption="Dataset information",ignoreCaption=TRUE)
  RMDTEXT__ <- RMDTEXT__ + rmdNEWPAGE()
  RMDTEXT__ <- RMDTEXT__ + rmdSECTION(paste0(datasetName__," specification"),numbered=FALSE)
  RMDTEXT__ <- RMDTEXT__ + "Missing values are coded in the dataset as '.' and referenced in this specification as 'NA'.\n\n"
  RMDTEXT__ <- RMDTEXT__ + rmdTABLEDF(dataDefine__,label="overview",fontsize=8,caption="Definition of dataset contents",ignoreCaption=TRUE)
  RMDTEXT__ <- paste0(RMDTEXT__,"\n")
  if (is.null(filename)) {
    filename__ <- paste0(datasetName__,"_define",".rmd")
  } else {
    x <- aux_fileparts(filename)
    filename__ <- paste0(x$pathname,"/",x$filename,".rmd")
  }
  export_IQRrmd(RMDTEXT__,filename__)
  if (has_IQReport_executable()) {
    IQReport(filename__)
  }
}
#'@export
printGrid <- function (plotList,nrow=4,ncol=4) {
  if (length(plotList)==0) return(invisible(NULL))
  x <- which(!sapply(plotList, is.null))
  plotList <- plotList[x]
  pieces__ <- aux_splitVectorEqualPieces(x = 1:length(plotList), nrow*ncol)
  for (k__ in seq_along(pieces__)) {
    pO__ <- cowplot::plot_grid(plotlist=plotList[pieces__[[k__]]],nrow=nrow,ncol=ncol)
    print(pO__)
  }
}
#'@export
read_IQRoutputTable <- function(file, convertNum = TRUE) {
  con <- file(file)
  text <- readLines(con)
  close.connection(con)
  is_header <- grepl("^<TH>", text)
  is_row <- grepl("^<TR>", text)
  is_title <- grepl("^<TT>", text)
  is_footer <- grepl("^<TF>", text)
  tags <- c("<TH>", "<TR>")
  for (mytag in tags) text <- trimws(sub(mytag, "", text))
  data <- utils::read.table(textConnection(text[is_header|is_row]), sep = "|", header = any(is_header), stringsAsFactors = FALSE, check.names = FALSE)
  if(!convertNum)
    data <- mutate_if(data, is.numeric, function(x) {
      out <- as.character(x)
      out[is.na(out)] <- ""
      out
    })
  if (ncol(data) == 0) {
    warning("Nothing to read.")
    return()
  }
  colnames(data) <- trimws(colnames(data))
  for (i in 1:ncol(data)) {
    if (is.character(data[[i]])) data[[i]] <- trimws(data[[i]])
  }
  title <- footer <- NULL
  if (any(is_title)) {
    text[is_title] <- sub("<TT>", "", text[is_title])
    text[is_title] <- trimws(text[is_title])
    title <- paste(text[is_title], collapse = "\n")
  }
  if (any(is_footer)) {
    text[is_footer] <- sub("<TF>", "", text[is_footer])
    text[is_footer] <- trimws(text[is_footer])
    footer <- paste(text[is_footer], collapse = "\n")
  }
  out <- IQRoutputTable(
    xtable = data,
    xfooter = footer,
    xtitle = title
  )
  out$filename <- file
  return(out)
}
#'@export
IQRcalcTAD <- function (data)
{
  if ("ID" %in% names(data)) {
    data$IDUSESPLIT <- data$ID
  }
  else {
    if ("USUBJID" %in% names(data)) {
      data$IDUSESPLIT <- data$USUBJID
    }
    else {
      stopIQR("ID and/or USUBJID need to be present in data argument")
    }
  }
  if (!all(c("EVID", "TIME") %in% names(data))) {
    stopIQR("EVID and TIME need to be present in data argument")
  }
  data <- do.call(rbind, lapply(split(data, data$IDUSESPLIT),
                                function(x) {
                                  ixDOSE <- rep(NA, nrow(x))
                                  ixEVID <- which(x$EVID == 1)
                                  if (length(ixEVID) == 0) {
                                    xx <- x
                                    xx$TAD <- NA
                                  }
                                  else {
                                    ixDOSE[ixEVID] <- ixEVID
                                    ixDOSE <- aux_na_locf(ixDOSE)
                                    ixDOSE[is.na(ixDOSE)] <- 0
                                    x$ixDOSE <- ixDOSE
                                    xx <- do.call(rbind, lapply(split(x, x$ixDOSE),
                                                                function(y) {
                                                                  if (y$ixDOSE[1] > 0) {
                                                                    y$TAD <- y$TIME - y$TIME[1]
                                                                  }
                                                                  else {
                                                                    y$TAD <- y$TIME
                                                                  }
                                                                  y
                                                                }))
                                    xx$ixDOSE <- NULL
                                  }
                                  xx
                                }))
  data$IDUSESPLIT <- NULL
  data
}
#'@export
IQRexpandADDLII <- function(data) {
  data__ <- data
  data__$II[is.na(data__$II)] <- 0
  data__$ADDL[is.na(data__$ADDL)] <- 0
  dataIIADDL__ <- data__[data__$II>0 & data__$ADDL>0,]
  if (nrow(dataIIADDL__)==0) {
    return(data__)
  }
  expandedDoseRecords__ <- do.call(rbind,lapply(1:nrow(dataIIADDL__), function (krow) {
    II <- dataIIADDL__[krow,]$II
    NRDOSES__ <- dataIIADDL__[krow,]$ADDL + 1
    doseRecords__ <- dataIIADDL__[krow*rep(1,NRDOSES__),]
    doseRecords__$TIME <- dataIIADDL__[krow,]$TIME + seq(0,by=II,length.out=nrow(doseRecords__))
    if (!is.null(doseRecords__$TIMEPOS)) doseRecords__$TIMEPOS <- dataIIADDL__[krow,]$TIMEPOS + seq(0,by=II,length.out=nrow(doseRecords__))
    if (!is.null(doseRecords__$NT)) doseRecords__$NT <- dataIIADDL__[krow,]$NT + seq(0,by=II,length.out=nrow(doseRecords__))
    doseRecords__$ADDL <- 0
    doseRecords__$II <- 0
    doseRecords__
  }))
  data__ <- data__[!(data__$II>0 & data__$ADDL>0),]
  data__ <- rbind(data__,expandedDoseRecords__)
  data__ <- dplyr::arrange(data__,USUBJID,TIME,NAME)
  return(data__)
}
#'@export
is_IQRaedataER <- function(input) {
  methods::is(input,"IQRaedataER")
}
#'@export
info_IQRaedataER <- function (data) {
  if (!is_IQRaedataER(data)) stopIQR("data is not an IQRaedataER object")
  x <- unique(data[,c("USUBJID","PLACEBO")])
  NPlacebo = sum(x$PLACEBO==1)
  NActive = sum(x$PLACEBO==0)
  x <- data[,c("USUBJID","NAME")]
  ONE_AE_NAME_PER_INDIVIDUAL <- TRUE
  if (nrow(x) != nrow(unique(x))) ONE_AE_NAME_PER_INDIVIDUAL <- FALSE
  list(
    AEnames = sort(unique(data$NAME)),
    NPlacebo = NPlacebo,
    NActive = NActive,
    ONE_AE_NAME_PER_INDIVIDUAL = ONE_AE_NAME_PER_INDIVIDUAL,
    covInfo = attributes(data)$covInfo,
    catInfo = attributes(data)$catInfo,
    data_dose = attributes(data)$data_dose,
    modelinfo = attributes(data)$modelinfo,
    INTERVAL_EXPOSURE = attributes(data)$INTERVAL_EXPOSURE,
    DELTA_EXPOSURE = attributes(data)$DELTA_EXPOSURE,
    FLAGduplicateDoses = attributes(data)$FLAGduplicateDoses
  )
}
#'@export
print.IQRaedataER<- function(x, ...) {
  print.data.frame(x, ...)
  cat("\n")
  cat("\nIQRaedataER object\n")
  cat("\n")
  info <- info_IQRaedataER(x)
  cat("The following AEs are present in the data:\n")
  cat(paste0(info$AEnames,collapse = ", "))
  cat("\n\nNumber of placebo treated individuals: ",info$NPlacebo)
  cat("\nNumber of active treated individuals: ",info$NActive)
  if (!info$ONE_AE_NAME_PER_INDIVIDUAL) {
    cat("\n\nMore than one of same AE NAME per individual possible!")
  } else {
    cat("\n\nOnly one of same AE NAME per individual")
  }
  if (is.null(info$modelinfo)) {
    cat("\n\nNO exposure information present. Use function addExposure_IQRdataER() to add it!")
  } else {
    cat("\n\nExposure information:\n")
    cat("  * Models used to calculate exposure:\n")
    dummy <- sapply(seq_along(info$modelinfo), function (k) {
      m <- info$modelinfo[[k]]$NLMEPROJECT
      o <- info$modelinfo[[k]]$OUTPUT
      w <- info$modelinfo[[k]]$WEIGHT
      cat(paste0("    * MODEL ",k, ": ",m," (Output: ",o,", Weight: ",w,")\n"))
    })
    cat("  * Sum of weighted outputs was used to determine exposure metrics.\n")
    if (info$FLAGduplicateDoses) {
      cat("  * Original doses in dataset were duplicated to allow for parallel absorption.\n")
    }
    cat(paste0("  * Exposure metrics were calculated over ",info$INTERVAL_EXPOSURE," ",data$TIMEUNIT[1],".\n"))
    cat(paste0("  * Time step of ",info$DELTA_EXPOSURE," ",data$TIMEUNIT[1]," was used to derive Cavg, Cmin, Cmax, and Cavgacc.\n"))
  }
  cat("\n")
}
#'@export
summary.IQRaedataER <- function(object, ...) {
  print.IQRaedataER(object, ...)
}
#'@export
createAEdata_IQRdataGENERAL <- function (data,minGrade=1,FLAGkeepHighestGradeEarliestTime=FALSE,addCols=NULL) {
  if (!is_IQRdataGENERAL(data)) stopIQR("data is no an IQRdataGENERAL object")
  if (length(attr(data,"aeNAMES"))==0) stopIQR("data does not contain any adverse event information")
  if (!is.null(addCols)) {
    if (!all(addCols %in% names(data))) stopIQR("Contents of addCols are not all in the data")
  }
  data <- data[!(data$AEGRADE < minGrade & !is.na(data$AEGRADE) & data$AE==1),]
  data2 <- IQRexpandADDLII(data = data)
  attr <- attributes(data)
  aeNAMES <- attr$aeNAMES
  nonaeOBSnames <- setdiff(attr$obsNAMES,aeNAMES)
  covNAMES <- attr$covInfo$COLNAME
  catNAMES <- attr$catInfo$COLNAME
  lastEventTimeIndiv <- do.call(rbind,lapply(split(data2,data2$USUBJID), function (x) {
    maxTime <- max(x$TIME,na.rm = TRUE)
    data.frame(
      USUBJID = x$USUBJID[1],
      LASTTIME = maxTime,
      LASTTAD = x$TAD[x$TIME==maxTime][1],
      stringsAsFactors = FALSE
    )
  }))
  data3 <- dplyr::left_join(data2,lastEventTimeIndiv,by="USUBJID")
  data4 <- data3[!data3$NAME %in% nonaeOBSnames,]
  idsplaceboadding <- setdiff(data3$USUBJID,data4$USUBJID)
  if (length(idsplaceboadding) > 0) {
    dataadd <- data3[data3$USUBJID %in% idsplaceboadding,]
    dataadd <- dataadd[!duplicated(dataadd$USUBJID),]
    dataadd$TIME <- 0
    dataadd$TAD <- 0
    dataadd$TRTNAME <- "Placebo"
    dataadd$DURATION <- 0
    dataadd$NAME <- "Placebo Dose"
    dataadd$VALUE <- 0
    dataadd$AE <- 0
    dataadd$AEGRADE <- 0
    dataadd$AMT <- 0
    dataadd$EVID <- 1
    data4X <- dplyr::arrange(rbind(data4,dataadd),USUBJID,TIME)
  } else {
    data4X <- data4
  }
  keepColumns <- c("IXGDF","USUBJID","STUDY","STUDYN","TRTNAME","TRT",
                   "TIMEUNIT","TIME","TAD","DURATION","NAME","VALUE","UNIT",
                   "AE","AEGRADE","AESER","AEDRGREL","AMT","EVID","TINF","ADM",
                   "DOSE","LASTTIME","LASTTAD")
  addCovCols <- setdiff(c(covNAMES,catNAMES,addCols),keepColumns)
  checknames <- setdiff(keepColumns,names(data4X))
  if (length(checknames)!=0) {
    stopIQR(paste0("Missing columns: ",paste(checknames,collapse = ", ")))
  }
  data5 <- data4X[,c(keepColumns,addCovCols)]
  data5$COMMENT <- NA
  if ("PLACEBO" %in% names(data5))
    warningIQR("PLACEBO column in original data is overwritten (1: non-zero dose amounts present in individual)")
  data6 <- do.call(rbind,lapply(split(data5,data5$USUBJID), function (d) {
    PLACEBO <- 1
    if (sum(d$AMT>0,na.rm = TRUE)) PLACEBO <- 0
    PLACEBO
    d$PLACEBO <- PLACEBO
    d
  }))
  dS <- split(data6,data6$USUBJID)
  data7 <- do.call(rbind,lapply(seq_along(dS), function (k) {
    d <- dS[[k]]
    addAEnames <- setdiff(aeNAMES,d$NAME)
    if (length(addAEnames) > 0) {
      r <- d[rep(1,length(addAEnames)),]
      r$IXGDF <- NA 
      r$TIME <- r$LASTTIME
      r$TAD <- r$LASTTAD
      r$DURATION <- NA 
      r$NAME <- addAEnames
      r$VALUE <- 0
      r$UNIT <- NA
      r$EVID <- 0
      r$AMT <- 0
      r$TINF <- 0
      r$ADM <- 0
      r$AE <- 0 
      r$AEGRADE <- 0 
      r$AESER <- 0 
      r$AEDRGREL <- 0 
      r$AECENS <- 1
      d$AECENS <- 0
      r$COMMENT <- "Added (no)AE with AE=AEGRADE=AEDRGREL=AESER=0 and ACENS=1 (censored event)"
    } else {
      r <- NULL
      d$AECENS <- 0 
    }
    rbind(d,r)
  }))
  if (!all(data7$EVID[data7$AE %in% 1] %in% 0)) stopIQR("EVID should be set on 0 for all AE=1 events!")
  data_dose <- data7[data7$EVID==1,]
  data_ae <- data7[data7$EVID==0,]
  rownames(data_ae) <- NULL
  rownames(data_dose) <- NULL
  data_ae$VALUE <- NULL
  data_ae$UNIT <- NULL
  data_ae$EVID <- NULL
  data_ae$TINF <- NULL
  data_ae$ADM <- NULL
  data_ae$AMT <- NULL
  data_ae$LASTTAD <- NULL
  if (FLAGkeepHighestGradeEarliestTime) {
    dS <- split(data_ae,data_ae$USUBJID)
    data_ae <- do.call(rbind,lapply(seq_along(dS), function (k) {
      d <- dS[[k]]
      dS2 <- split(d,d$NAME)
      do.call(rbind,lapply(seq_along(dS2), function (k2) {
        d2 <- dS2[[k2]]
        if (nrow(d2) == 1) return(d2)
        d2 <- dplyr::arrange(d2,desc(AEGRADE),TIME) 
        d2[1,]
      }))
    }))
  }
  class(data_ae) <- c("IQRaedataER","IQRdataER","data.frame")
  attributes(data_ae)$covInfo <- attr$covInfo
  attributes(data_ae)$catInfo <- attr$catInfo
  attributes(data_ae)$data_dose <- data_dose
  data_ae
}
#'@export
exportXPT_IQRaedataER <- function(data,filename=NULL,addColLabels=NULL) {
  if (is.null(filename))
    stopIQR("filename must be provided")
  if (!is_IQRaedataER(data) & !("IQRaedataER" %in% attr(data,"class")))
    stopIQR("data is not an IQRaedataER object")
  x <- aux_fileparts(filename)
  filename <- x$filename
  pathname <- x$pathname
  if (nchar(filename) > 8)
    stopIQR("Please provide a filename with length of max 8 characters (w/o extension)")
  dataX <- data.frame(lapply(names(data), function (x) {
    x <- data[[x]]
    if (!is.null(levels(x))) {
      x <- levels(x)[x]
    }
    if (is.logical(x)) x <- as.double(x)
    if (is.integer(x)) x <- as.double(x)
    x
  }),row.names=NULL,stringsAsFactors=FALSE)
  names(dataX) <- names(data)
  attr(dataX,"covInfo") <- attr(data,"covInfo")
  attr(dataX,"catInfo") <- attr(data,"catInfo")
  attr(dataX,"data_dose") <- attr(data,"data_dose")
  attr(dataX,"modelinfo") <- attr(data,"modelinfo")
  attr(dataX,"INTERVAL_EXPOSURE") <- attr(data,"INTERVAL_EXPOSURE")
  attr(dataX,"DELTA_EXPOSURE")     <- attr(data,"DELTA_EXPOSURE")
  attr(dataX,"FLAGduplicateDoses") <- attr(data,"FLAGduplicateDoses")
  attr(dataX,"class") <- c("IQRaedataER","IQRdataER","data.frame")
  data <- dataX
  data <- addLabel_IQRaedataER(data,addColLabels)
  aux_mkdir(pathname)
  haven::write_xpt(data = data,path = paste0(pathname,'/',filename,'.xpt'),name = filename,version = 5)
  genComplianceLog(paste0(pathname,'/',filename,'.xpt'))
}
#'@export
addLabel_IQRaedataER <- function(data,addColLabels=NULL) {
  addLabel__ <- function (data,colName__,label) {
    if (colName__ %in% names(data)) {
      attr(data[[colName__]],"label") <- label
      attr(data[[colName__]],"class") <- unique(c("labelled",class(data[[colName__]])))
    }
    return(data)
  }
  data <- addLabel__(data,"IXGDF","Index of record in master dataset")
  data <- addLabel__(data,"IGNORE","Exclusion reason")
  data <- addLabel__(data,"USUBJID","Unique subject identifier")
  data <- addLabel__(data,"ID","Numeric subject ID for modeling software")
  data <- addLabel__(data,"STUDY","Short study name/number")
  data <- addLabel__(data,"STUDYN","Numeric study flag")
  data <- addLabel__(data,"TRTNAME","Name actual treatment given to subject")
  data <- addLabel__(data,"TRT","Numeric treatment flag")
  data <- addLabel__(data,"TIME","Actual time relative to first dose")
  data <- addLabel__(data,"TIMEPOS","Time since first record in subject")
  data <- addLabel__(data,"NT","Nominal event time")
  data <- addLabel__(data,"TAD","Time after last dose")
  data <- addLabel__(data,"TIMEUNIT","Unit of all numeric time definitions")
  data <- addLabel__(data,"YTYPE","Observation output number")
  data <- addLabel__(data,"NAME","Short name of event")
  data <- addLabel__(data,"UNIT","Unit of the value")
  data <- addLabel__(data,"DOSE","DOSE of last dose (carry-forward)")
  data <- addLabel__(data,"INDNAME","Indication name")
  data <- addLabel__(data,"IND","Numeric indication flag")
  data <- addLabel__(data,"DURATION","Duration of event")
  data <- addLabel__(data,"TYPENAME","Type of event")
  data <- addLabel__(data,"VALUE","Value of event defined by NAME")
  data <- addLabel__(data,"AE","Adverse event record flag")
  data <- addLabel__(data,"AEGRADE","Adverse event grade")
  data <- addLabel__(data,"AESER","Adverse event seriousness")
  data <- addLabel__(data,"AEDRGREL","Adverse event drug related")
  data <- addLabel__(data,"AECENS","Adverse event censoring flag")
  data <- addLabel__(data,"LASTTIME","Censoring time (last info)")
  data <- addLabel__(data,"COMMENT","Comment")
  data <- addLabel__(data,"PLACEBO","Placebo flag (no dose >0 identified)")
  data <- addLabel__(data,"Cmax","Cmax over defined interval at AE")
  data <- addLabel__(data,"Cavg","Cavg over defined interval at AE")
  data <- addLabel__(data,"Cmin","Cmin over defined interval at AE")
  data <- addLabel__(data,"Cavgacc","Accumulated Cavg from 0 to AE")
  data <- addLabel__(data,"Cae","Concentration at time of AE (NA if no AE)")
  covInfo <- attr(data,"covInfo")
  if (!is.null(covInfo)) {
    if (nrow(covInfo)>0) {
      for (k__ in 1:nrow(covInfo)) {
        if (covInfo$TIME.VARYING[k__]) {
          text <- paste0(covInfo$NAME[k__]," (",covInfo$UNIT[k__],")")
        } else {
          text <- paste0("Baseline ",covInfo$NAME[k__]," (",covInfo$UNIT[k__],")")
        }
        data <- addLabel__(data,covInfo$COLNAME[k__],text)
      }
    }
  }
  catInfo <- attr(data,"catInfo")
  if (!is.null(catInfo)) {
    if (nrow(catInfo)>0) {
      for (k__ in 1:nrow(catInfo)) {
        if (catInfo$TIME.VARYING[k__]) {
          text <- paste0(catInfo$NAME[k__]," (time varying)")
        } else {
          text <- catInfo$NAME[k__]
        }
        data <- addLabel__(data,catInfo$COLNAME[k__],text)
      }
    }
  }
  for (k__ in seq_along(addColLabels)) {
    colname <- names(addColLabels)[k__]
    data <- addLabel__(data,colname,addColLabels[[k__]])
  }
  return(data)
}
#'@export
exportDEFINE_IQRaedataER <- function(data,
                                     datasetName=NULL,
                                     datasetLocation=NULL,
                                     datasetDescription="AE Analysis dataset",
                                     addColLabels=NULL,
                                     filename=NULL) {
  exportDEFINEdocx_IQRaedataER(data,
                               datasetName,
                               datasetLocation,
                               datasetDescription,
                               addColLabels,
                               filename)
}
exportDEFINEdocx_IQRaedataER <- function(data,
                                         datasetName=NULL,
                                         datasetLocation=NULL,
                                         datasetDescription="AE Analysis dataset",
                                         addColLabels=NULL,
                                         filename=NULL) {
  if (!is_IQRaedataER(data) & !("IQRaedataER" %in% attr(data,"class")))
    stopIQR("Data is not an IQRaedataER object")
  if (is.null(datasetName))
    stopIQR("Please provide a name for the dataset as it should appear in the define file")
  if (is.null(datasetLocation))
    warningIQR("Please provide a location (path) for the dataset as it should appear in the define file")
  dataFirst__ <- data.frame(NAME=datasetName,DESCRIPTION=datasetDescription,LOCATION=datasetLocation,stringsAsFactors=FALSE,row.names=NULL)
  dataDefine__ <- data.frame(NAME=names(data),stringsAsFactors=FALSE,row.names=NULL)
  dataDefine__$TYPE <-lapply(data, function (x) { if (is.numeric(x)) { out <- "Numeric" } else { out <- "String" }; out })
  data <- addLabel_IQRaedataER(data,addColLabels)
  dataDefine__$LABEL <-lapply(data, function (x) {
    label__ <- attr(x,"label")
    if (is.null(label__)) label__ <- "UNKNOWN"
    label__
  })
  dataDefine__$VALUES <- getValueTxtDefineAEER(dataDefine__$NAME,unlabel_dataframe(data))
  dataDefine__$COMMENTS <- " "
  datasetName__ <- toupper(datasetName)
  RMDTEXT__ <- rmdEMPTY()
  RMDTEXT__ <- RMDTEXT__ + rmdTITLE(title=paste0("Define file for the \"",datasetName__,"\" dataset"),subtitle=NULL,date=NULL)
  RMDTEXT__ <- RMDTEXT__ + rmdNOINTRO()
  RMDTEXT__ <- RMDTEXT__ + "!BLOCKSTART[keepNext](block_kwnext)\n"
  RMDTEXT__ <- RMDTEXT__ + rmdSECTION("Dataset name, description, and location",numbered=FALSE)
  RMDTEXT__ <- RMDTEXT__ + rmdTABLEDF(dataFirst__,label="overview",fontsize=8,caption="Dataset information",ignoreCaption=TRUE)
  RMDTEXT__ <- RMDTEXT__ + rmdNEWPAGE()
  RMDTEXT__ <- RMDTEXT__ + rmdSECTION(paste0(datasetName__," specification"),numbered=FALSE)
  RMDTEXT__ <- RMDTEXT__ + "Missing values are coded in the dataset as '.' and referenced in this specification as 'NA'.\n\n"
  RMDTEXT__ <- RMDTEXT__ + rmdTABLEDF(dataDefine__,label="overview",fontsize=8,caption="Definition of dataset contents",ignoreCaption=TRUE)
  RMDTEXT__ <- RMDTEXT__ + "\n"
  RMDTEXT__ <- RMDTEXT__ + "!BLOCKEND(block_kwnext)\n"
  if (is.null(filename)) {
    filename__ <- paste0(datasetName__,"_define",".rmd")
  } else {
    x <- aux_fileparts(filename)
    filename__ <- paste0(x$pathname,"/",x$filename,".rmd")
  }
  export_IQRrmd(RMDTEXT__,filename__)
  if (has_IQReport_executable()) {
    IQReport(filename__)
  }
}
getValueTxtDefineAEER <- function(NAMES,data) {
  data <- unlabel_dataframe(data)
  imputationInformation <- attr(data,"imputeInfo")
  covInfo <- attr(data,"covInfo")
  catInfo <- attr(data,"catInfo")
  doseNAMES <- attr(data,"doseNAMES")
  obsNAMES <- attr(data,"obsNAMES")
  aeNAMES  <- attr(data,"aeNAMES")
  methodBLLOQ <- attr(data,"methodBLLOQ")
  if (length(which(grepl(":::",unique(data$NAME)))) > 0) {
    doseNAMES <- gsub(" ",":::",doseNAMES)
    obsNAMES <- gsub(" ",":::",obsNAMES)
  }
  output__ <- rep(" ",length(NAMES))
  for (k__ in seq_along(NAMES)) {
    NAME <- NAMES[k__]
    if (NAME=="IXGDF")
      output__[k__] <- "1...N"
    if (NAME=="USUBJID")
      output__[k__] <- "Unique subject ID or a derivative of it, allowing to identify the subject"
    if (NAME=="ID")
      output__[k__] <- "Numeric subject ID for modeling software"
    if (NAME=="STUDY")
      output__[k__] <- paste0(sort(unique(data$STUDY)),collapse=", \n")
    if (NAME=="STUDYN") {
      if ("STUDY" %in% names(data)) {
        x <- dplyr::arrange(unique(data[,c("STUDYN","STUDY")]),STUDYN)
        output__[k__] <- paste0(paste0(x$STUDYN," (STUDY=",x$STUDY,")"),collapse=", \n")
      } else {
        output__[k__] <- paste0(unique(data$STUDYN),collapse=", ")
      }
    }
    if (NAME=="STUDYDES")
      output__[k__] <- "See 'LABEL' column"
    if (NAME=="TRTNAME")
      output__[k__] <- paste0(sort(unique(data$TRTNAME)),collapse=", \n")
    if (NAME=="TRT") {
      if ("TRTNAME" %in% names(data)) {
        x <- dplyr::arrange(unique(data[,c("TRT","TRTNAME")]),TRT)
        output__[k__] <- paste0(paste0(x$TRT," (TRTNAME=",x$TRTNAME,")"),collapse=", \n")
      } else {
        output__[k__] <- paste0(unique(data$TRT),collapse=", ")
      }
    }
    if (NAME=="INDNAME")
      output__[k__] <- paste0(sort(unique(data$INDNAME)),collapse=", \n")
    if (NAME=="IND") {
      if ("INDNAME" %in% names(data)) {
        x <- dplyr::arrange(unique(data[,c("IND","INDNAME")]),IND)
        output__[k__] <- paste0(paste0(x$IND," (INDNAME=",x$INDNAME,")"),collapse=", \n")
      } else {
        output__[k__] <- paste0(unique(data$IND),collapse=", ")
      }
    }
    if (NAME=="COMPOUND")
      output__[k__] <- paste0(sort(unique(data$COMPOUND)),collapse=", \n")
    if (NAME=="TIME")
      output__[k__] <- "'TIME' values in the unit defined in the 'TIMEUNIT' column"
    if (NAME=="TAD")
      output__[k__] <- "'TAD' values in the unit defined in the 'TIMEUNIT' column"
    if (NAME=="TIMEUNIT")
      output__[k__] <- paste0("'",unique(data$TIMEUNIT),"'")
    if (NAME=="DURATION")
      output__[k__] <- "'DURATION' values in the unit defined in the 'TIMEUNIT' column. -1 if event ongoing post end of observation period"
    if (NAME=="TYPENAME")
      output__[k__] <- paste0(sort(unique(data$TYPENAME)),collapse=", \n")
    if (NAME=="NAME")
      output__[k__] <- paste0(sort(unique(data$NAME)),collapse=", \n")
    if (NAME=="AE")
      output__[k__] <- "1 if record codes an adverse event, 0 if not"
    if (NAME=="AEGRADE")
      output__[k__] <- "Can be 1,2,3,4,5. NA for "
    if (NAME=="AESER")
      output__[k__] <- "1: seriuous adverse event, 0: not serious"
    if (NAME=="AEDRGREL")
      output__[k__] <- "1: drug related AE, 0: not drug related"
    if (NAME=="COMMENT")
      output__[k__] <- "Various content - might be 'NA'"
    if (!is.null(covInfo)) {
      for (kk in 1:nrow(covInfo)) {
        if (NAME==covInfo$COLNAME[kk]) {
          output__[k__] <- "See 'LABEL' column"
        }
      }
    }
    if (!is.null(catInfo)) {
      for (kk__ in 1:nrow(catInfo)) {
        if (NAME==catInfo$COLNAME[kk__]) {
          output__[k__] <- paste0(aux_explodePC(catInfo$VALUES[kk__])," (",aux_explodePC(catInfo$VALUETXT[kk__]),")",collapse=", \n")
        }
      }
    }
  }
  return(output__)
}
#'@export
export_IQRaedataER <- function(data,
                               filename        = NULL,
                               FLAGxpt         = FALSE,
                               FLAGdefine      = TRUE,
                               addColLabels    = NULL) {
  if (!is_IQRaedataER(data))
    stopIQR("input argument is not an IQRaedataER object")
  if (is.null(filename))
    stopIQR("please provide a filename for the NLME CSV file")
  x__ <- aux_fileparts(filename)
  filename__ <- x__$filename
  pathname__ <- x__$pathname
  if (nchar(filename__) > 8 & FLAGxpt)
    stopIQR("please provide a filename with length of max 8 characters (w/o extension)")
  IQRoutputCSV(data,filename=paste0(pathname__,"/",filename__),na=".",quote=FALSE)
  if (FLAGxpt) exportXPT_IQRaedataER(data,paste0(pathname__,"/",filename__),addColLabels=addColLabels)
  if (FLAGdefine) {
    datasetName__     <- filename__
    datasetLocation__ <- paste0(pathname__,"/",datasetName__)
    if (FLAGxpt) {
      datasetLocation__ <- paste0(datasetLocation__,".xpt")
    } else {
      datasetLocation__ <- paste0(datasetLocation__,".csv")
    }
    filenameRMD__        <- paste0(pathname__,"/",datasetName__,"_define.rmd")
    exportDEFINE_IQRaedataER(data               = data,
                             datasetName        = datasetName__,
                             datasetLocation    = datasetLocation__,
                             datasetDescription = "AE analysis dataset",
                             addColLabels       = addColLabels,
                             filename           = filenameRMD__)
  }
}
#'@export
load_IQRaedataER <- function(filename) {
  filenameCSV__ <- paste0(aux_strrep(filename,".csv",""),".csv")
  filenameATR__ <- paste0(aux_strrep(filename,".csv",""),".atr")
  if (!file.exists(filenameCSV__))
    stopIQR(sprintf("File '%s' does not exist",filenameCSV__))
  if (!file.exists(filenameATR__))
    stopIQR(sprintf("Attribute file '%s' does not exist. Please consider importing the datafile with the function 'IQRdataGENERAL'",filenameATR__))
  data__ <- IQRloadCSVdata(filenameCSV__)
  atrcontents <- loadAttributeFile(filenameATR__)
  if (any(grepl("_", names(data__)))) {
    warningIQR("There are underscores in column names which are removed.")
    names(data__) <- gsub("_", "", names(data__))
    atrcontents$catInfo$COLNAME <- gsub("_", "", atrcontents$catInfo$COLNAME)
    atrcontents$covInfo$COLNAME <- gsub("_", "", atrcontents$covInfo$COLNAME)
    atrcontents$imputeInfo$COVNAME <- gsub("_", "", atrcontents$imputeInfo$COVNAME)
  }
  numericColumns__ <- c(
    "IXGDF","IND","STUDYN","TRT","TIME","TAD","DURATION","AE",
    "AEGRADE","AESER","AEDRGREL","DOSE","LASTTIME","PLACEBO","AECENS",
    "Cmax","Cavg","Cmin","Cavgacc","Cae"
  )
  numericColumnsPresent__ <- numericColumns__[numericColumns__ %in% names(data__)]
  for (k__ in seq_along(numericColumnsPresent__)) {
    suppressWarnings(data__[[numericColumnsPresent__[k__]]] <- as.numeric(data__[[numericColumnsPresent__[k__]]]))
  }
  data__$TIMEUNIT <- toupper(data__$TIMEUNIT)
  data__ <- data.frame(lapply(data__, function(x__) {
    if (!is.numeric(x__)) x__ <- gsub(x=x__,pattern=":::",replacement=" ")
    x__
  }),row.names=NULL,stringsAsFactors=FALSE)
  attributes(data__) <- c(attributes(data__),atrcontents)
  class(data__) <- c("IQRaedataER","IQRdataER","data.frame")
  return(data__)
}
#'@export
plotIndivAE_IQRdataGENERAL <- function (data,filename=NULL,AENAMES=NULL,nrow=4,shapesize=3) {
  req_columns <- c("USUBJID","AE","NAME","EVID","TIME","TIMEUNIT")
  for (k in 1:length(req_columns)) {
    if (!req_columns[k] %in% names(data)) stop(paste0("Column ",req_columns[k]," is missing in the data"))
  }
  if (!is.null(AENAMES)) {
    data <- data[data$EVID==1 | data$NAME %in% AENAMES,]
  }
  if (sum(data$AE)==0) stop("No AE=1 records in the dataset (for defined AENAMES - if defined)")
  IDae <- unique(data$USUBJID[data$AE==1])
  dataae <- data[data$USUBJID %in% IDae,]
  dataae <- dataae[dataae$EVID==1 | dataae$AE==1,]
  x <- sort(unique(dataae$NAME))
  dataae$NAMETYPE <- factor(dataae$NAME ,levels=x,labels=x)
  colors <- IQRtoolsColors[2:(length(x)+1)]
  names(colors) <- x
  shapes <- seq(1:length(x))
  names(shapes) <- x
  dS <- split(dataae,dataae$USUBJID)
  p <- lapply(seq_along(dS), function (k) {
    d <- dS[[k]]
    IQRggplot() +
      geom_vline(data=d[d$EVID==1,],aes(xintercept = TIME),color="red",linetype="dashed") +
      ggtitle(NULL,subtitle = paste0(d$USUBJID[1]," (ID=",d$ID[1],")")) +
      geom_point(data=d[d$AE==1,],aes(x=TIME,y=NAME,color=NAME,shape=NAME),size=shapesize) +
      scale_color_manual("",values=colors)+
      scale_shape_manual("",values=shapes) +
      xlab(paste0("Time (",d$TIMEUNIT[1],")")) +
      ylab(NULL) +
      theme(axis.title.y=element_blank(),
            axis.text.y=element_blank(),
            axis.ticks.y=element_blank(),
            legend.position = "bottom")
  })
  if (is.null(filename)) return(p)
  filename <- paste0(gsub(".pdf","",filename,fixed = TRUE),".pdf")
  IQRoutputFigure(x=p,filename = filename,opt.layout = opt.layout(nrow = nrow,ncol = 1),opt.pagesize = opt.pagesize(scaleHeight = 1.5))
  return(invisible(NULL))
}
#'@export
summaryN_IQRaedataER <- function (data,SIGNIF=3,filename=NULL,title="Summary of AE in data") {
  data <- data[data$AE==1 & data$AEDRGREL==1 | data$AE==0,]
  allAENAMEs <- unique(data$NAME)
  tab <- dplyr::arrange(do.call(rbind,lapply(seq_along(allAENAMEs), function (k) {
    AE <- allAENAMEs[k]
    Ntotal <- length(unique(data$USUBJID))
    Nae <-  length(unique(data$USUBJID[data$AE==1 & data$NAME==AE]))
    ci <- stats::binom.test(x = Nae,n = Ntotal,conf.level = 0.95)
    minGrade <- suppressWarnings(min(data$AEGRADE[data$NAME==AE & data$AE==1],na.rm = TRUE))
    maxGrade <- suppressWarnings(max(data$AEGRADE[data$NAME==AE & data$AE==1],na.rm = TRUE))
    data.frame(
      AENAME = AE,
      Ntotal = Ntotal,
      Nae = Nae,
      FREQ = paste0(signif(100*Nae/Ntotal,SIGNIF),"%"),
      FREQ_CI95 = paste0("[",signif(100*ci$conf.int[1],SIGNIF),",",signif(100*ci$conf.int[2],SIGNIF),"] %"),
      GRADE = ifelse(is.infinite(minGrade),"-",paste0(minGrade,"-", maxGrade)),
      stringsAsFactors = FALSE
    )
  })),desc(Nae))
  names(tab) <- c("Adverse Event (AE)","Number of all subjects","Number of subjects with AE","AE Frequency [%]", "AE Frequency 95% CI [%]*","Range of AE grades")
  IQRoutputTable(
    xtable = tab,
    xtitle = title,
    xfooter = "Occurrence of same AE in subject only counted once\nOnly drug related AEs considered (AEDRGREL=1)\n\\* Based on Clopper-Pearson test",
    filename = filename
  )
}
#'@export
summary_IQRaedataER <- function (
  data = data,
  stratifyTable = NULL,
  stratifyPlot = NULL,
  plotX = NULL,
  xlabel = NULL,
  stratName = NULL,
  breaksX = NULL,
  title = "Summary of drug related adverse events",
  addTitleFigure = "",
  filename = NULL,
  xtickangle = 0,
  SIGNIF = 3
) {
  if (!is.null(stratifyTable)) {
    if (!stratifyTable %in% names(data)) stopIQR(paste0(stratifyTable," is not a column of data"))
  }
  allAENAMEs <- unique(data$NAME[data$AE==1]) 
  allSTRAT <- sort(unique(data[[stratifyTable]]))
  order <- names(sort(table(data[data$AE==1,"NAME"]),decreasing = TRUE))
  res <- do.call(rbind, lapply(seq_along(allSTRAT), function (ks) {
    ds <- data[data[[stratifyTable]]==allSTRAT[ks],]
    PLOTX <- NA
    PLOTSTRAT <- NA
    if (!is.null(plotX)) PLOTX <- ds[[plotX]][1]
    if (!is.null(stratifyPlot)) PLOTSTRAT <- ds[[stratifyPlot]][1]
    do.call(rbind,lapply(seq_along(allAENAMEs), function (k) {
      AE <- allAENAMEs[k]
      d <- ds[ds$NAME==AE & ds$AE==1 & ds$AEDRGREL==1,]
      Nsubjects <- length(unique(ds$USUBJID))
      Naesubjects <- length(unique(d$USUBJID))
      minGrade <- suppressWarnings(min(d$AEGRADE))
      maxGrade <- suppressWarnings(max(d$AEGRADE))
      ci <- stats::binom.test(x = Naesubjects,n = Nsubjects,conf.level = 0.95)
      data.frame(
        AENAME = AE,
        STRAT = allSTRAT[ks],
        Nsubjects = Nsubjects,
        Naesubjects = Naesubjects,
        FREQ = paste0(signif(Naesubjects/Nsubjects*100,SIGNIF)," [",signif(100*ci$conf.int[1],SIGNIF),",",signif(100*ci$conf.int[2],SIGNIF),"] %"),
        GRADE = paste0(minGrade,"-", maxGrade),
        ORDERTAB = match(AE,order),
        PLOTX = PLOTX,
        PLOTSTRAT = PLOTSTRAT,
        FREQPLOT = Naesubjects/Nsubjects*100,
        FREQPLOTCI025 = 100*ci$conf.int[1],
        FREQPLOTCI975 = 100*ci$conf.int[2],
        stringsAsFactors = FALSE
      )
    }))
  }))
  tab <- res[,c("AENAME","STRAT","Nsubjects","Naesubjects","FREQ","GRADE","ORDERTAB")]
  tab$GRADE <- gsub("Inf--Inf","-",tab$GRADE)
  tab <- dplyr::arrange(tab,ORDERTAB)
  tab$AENAME[duplicated(tab$AENAME)] <- ""
  tab$ORDERTAB <- NULL
  names(tab) <- c("Adverse Event (AE)", paste0("Stratification (",stratifyTable,")"), "Number overall subjects", "Number subjects with AE", "AE Frequency [95% CI]*", "Range of AE grades")
  tabout <- IQRoutputTable(xtable = tab,xtitle = title,
                           xfooter = "Occurrence of same AE in subject only counted once\nOnly drug related AEs considered (AEDRGREL=1)\n\\* Based on Clopper-Pearson test",
                           filename = filename)
  if (is.null(xlabel)) xlabel <- plotX
  if (is.null(stratName)) stratName <- stratifyPlot
  if (!is.null(plotX)) {
    plotout <- lapply(split(res,res$AENAME), function (dp) {
      if (is.null(stratifyPlot)) {
        dp$PLOTSTRAT <- as.factor(1)
      } else {
        dp$PLOTSTRAT <- factor(dp$PLOTSTRAT,levels=sort(unique(dp$PLOTSTRAT)))
      }
      subtitle = "x indicate the 95% confidence interval (Clopper-Pearson)\nNumbers in labels indicate number of occurred adverse events"
      p <- IQRggplot(dp)
      if (length(unique(dp$PLOTSTRAT))>1) {
        p <- p +
          geom_point(aes(x=PLOTX,y=FREQPLOT,color=PLOTSTRAT,shape=PLOTSTRAT),size=3) +
          geom_label(aes(x=PLOTX,y=FREQPLOT,label=Naesubjects,color=PLOTSTRAT))
        p <- p +  scale_color_IQRtools(stratName) +
          scale_shape_discrete(stratName) +
          scale_linetype_discrete(stratName)
        p <- p +
          geom_point(aes(x=PLOTX,y=FREQPLOTCI025,color=PLOTSTRAT),shape="x") +
          geom_point(aes(x=PLOTX,y=FREQPLOTCI975,color=PLOTSTRAT),shape="x",size=2)
      } else {
        p <- p +
          geom_point(aes(x=PLOTX,y=FREQPLOT),size=3) +
          geom_label(aes(x=PLOTX,y=FREQPLOT,label=Naesubjects))
        p <- p +
          geom_point(aes(x=PLOTX,y=FREQPLOTCI025),shape="x") +
          geom_point(aes(x=PLOTX,y=FREQPLOTCI975),shape="x",size=2)
      }
      p <- p +
        ggtitle(paste0(dp$AENAME[1],addTitleFigure),subtitle = subtitle) +
        xlab(xlabel) +
        ylab("Frequency of AE (%)") +
        theme(axis.text.x = element_text(angle = xtickangle, hjust=1))
      if (!is.null(breaksX)) {
        p <- p + scale_x_continuous(breaks=breaksX)
      }
      p
    })
  } else {
    plotout <- NULL
  }
  list(tab=tabout,plot=plotout)
}
#'@export
summaryCat_IQRdataER <- function(data,
                                 catInfoAdd = NULL,
                                 catNames = NULL,
                                 stratifyColumns = "STUDY",
                                 stratifyOrder = NULL,
                                 FLAGtotal = NULL,
                                 SIGNIF = 3,
                                 tableTitle = NULL,
                                 footerAddText = NULL,
                                 filename = NULL,
                                 FLAGpatients = FALSE) {
  if(is_IQRdataGENERAL(data)){
    stopIQR("Use summaryCat_IQRdataGENERAL instead")
  }
  catInfo__ <- attributes(data)$catInfo
  if (!is.null(levels(catInfo__$COLNAME))) {
    stopIQR("Covariate information in attributes contains levels. This is not allowed.")
  }
  catInfo__ <- rbind(catInfo__,data.frame(catInfoAdd,stringsAsFactors = FALSE))
  catNamesData__ <- catInfo__$COLNAME
  if (is.null(catNames)) {
    catNames <- catNamesData__
  }
  if (is.null(catNames)) {
    message("No categorical covariates defined or present")
    return(invisible(NULL))
  }
  if (!all(catNames %in% catNamesData__)) {
    stopIQR(paste0("The following catNames are not available in the provided data:\n  ",paste0(catNames[!(catNames %in% catNamesData__)],collapse=", ")))
  }
  if (is.null(FLAGtotal)) {
    FLAGtotal <- rep(FALSE,length(stratifyColumns))
  }
  if (length(FLAGtotal)==1) {
    FLAGtotal <- rep(FLAGtotal,length(stratifyColumns))
  }
  if (length(FLAGtotal) != length(stratifyColumns)) {
    stopIQR("Missmatch between length of stratifyColumns and FLAGtotal input arguments")
  }
  if (!is.list(stratifyOrder)) {
    stratifyOrder <- list(stratifyOrder)
  }
  for (k__ in seq_along(stratifyColumns)) {
    entries__ <- unique(data[[stratifyColumns[k__]]])
    order__ <- unlist(stratifyOrder[k__])
    if (!is.null(order)) {
      if (!all(order__ %in% entries__)) {
        stopIQR(paste0("Not all entries in stratifyColumns are present for stratification column ",stratifyColumns[k__]))
      }
    }
  }
  if (is.null(tableTitle)) {
    tableTitle <- "Summary of demographic and baseline characteristics for categorical information"
  }
  datafirst__ <- as.data.frame(data[!duplicated(data$USUBJID),])
  catInfo__ <- catInfo__[catInfo__$COLNAME %in% catNames,]
  catInfo0__ <- catInfo__
  FLAGmissingVal <- FALSE
  for (icat__ in catNames) {
    if (any(is.na(datafirst__[[icat__]]))) {
      tmp__ <- catInfo__[catInfo__$COLNAME == icat__,]
      tmpValImpute__ <- max(as.numeric(aux_explode(tmp__$VALUES)))+1
      tmp__$VALUES <- paste0(tmp__$VALUES, ",", tmpValImpute__)
      tmp__$VALUETXT <- paste0(tmp__$VALUETXT, ",n.a.**")
      catInfo__[catInfo__$COLNAME == icat__,] <- tmp__
      datafirst__[[icat__]][is.na(datafirst__[[icat__]])] <- as.character(tmpValImpute__)
      FLAGmissingVal <- TRUE
    }
  }
  baseTable__ <- do.call(rbind,lapply(1:nrow(catInfo__), function (kRowCatInfo__) {
    row__ <- catInfo__[kRowCatInfo__,]
    characteristic__ <- row__$NAME
    colname__ <- row__$COLNAME
    categories__ <- aux_explodePC(as.character(row__$VALUETXT))
    values__ <- as.numeric(aux_explodePC(as.character(row__$VALUES)))
    subtable__ <- data.frame(
      Characteristic = characteristic__,
      Category = categories__,
      COLNAME = colname__,
      VALUE = values__,
      stringsAsFactors=FALSE
    )
  }))
  table__ <- baseTable__
  table__$COLNAME <- NULL
  table__$VALUE <- NULL
  FLAGmissingCat <- FALSE
  for (kstratcolumn__ in seq_along(stratifyColumns)) {
    stratifyColumn__ <- stratifyColumns[kstratcolumn__]
    FLAGtotal__ <- FLAGtotal[kstratcolumn__]
    stratifyOrder__ <- unlist(stratifyOrder[kstratcolumn__])
    datafirst__$stratifyColumn__ <- datafirst__[[stratifyColumn__]]
    if (stratifyColumn__ %in% catInfo0__$COLNAME) {
      tmpVal__ <- aux_explode(catInfo0__$VALUES[catInfo0__$COLNAME == stratifyColumn__])
      tmpTxt__ <- aux_explode(catInfo0__$VALUETXT[catInfo0__$COLNAME == stratifyColumn__])
      if (!is.null(stratifyOrder__)) stratifyOrder__ <- as.character(factor(stratifyOrder__, levels = tmpVal__, labels = tmpTxt__))
      datafirst__$stratifyColumn__ <- as.character(factor(datafirst__$stratifyColumn__, levels = tmpVal__, labels = tmpTxt__))
    }
    if (is.null(stratifyOrder__))
      stratifyOrder__ <- unique(datafirst__$stratifyColumn__[!is.na(datafirst__$stratifyColumn__)])
    if (any(is.na(datafirst__$stratifyColumn__)))
      stratifyOrder__ <- c(stratifyOrder__, NA)
    stratifyOrder__[is.na(stratifyOrder__)] <- "missing*"
    datafirst__$stratifyColumn__[is.na(datafirst__$stratifyColumn__)] <- "missing*"
    if ("missing*" %in% stratifyOrder__) FLAGmissingCat <- TRUE
    dummy__ <- sapply(stratifyOrder__, function (strata__) {
      stratData__ <- datafirst__[datafirst__$stratifyColumn__ == strata__,]
      NTOTALstrat__ <- nrow(stratData__)
      STRATCOLname__ <- paste0(stratData__$stratifyColumn__[1]," (N=",NTOTALstrat__,")")
      stratValueCol__ <- sapply(1:nrow(baseTable__), function (kRowTable__) {
        row__ <- baseTable__[kRowTable__,]
        COLNAME__ <- row__$COLNAME
        VALUE__ <- row__$VALUE
        NCATstraty__ <- sum(stratData__[COLNAME__] == VALUE__,na.rm=TRUE)
        PERCCATstraty__ <- signif(NCATstraty__/NTOTALstrat__*100,SIGNIF)
        paste0(NCATstraty__, " (",PERCCATstraty__,"%)")
      })
      table__ <<- cbind(table__, stratValueCol__)
      names(table__)[ncol(table__)] <<- STRATCOLname__
    })
    if (FLAGtotal__) {
      dataTOTAL__ <- datafirst__
      NTOTAL__ <- nrow(dataTOTAL__)
      totalValueCol__ <- sapply(1:nrow(baseTable__), function (kRowTable__) {
        row__ <- baseTable__[kRowTable__,]
        COLNAME__ <- row__$COLNAME
        VALUE__ <- row__$VALUE
        NCAT__ <- sum(dataTOTAL__[COLNAME__] == VALUE__,na.rm=TRUE)
        PERCCAT__ <- signif(NCAT__/NTOTAL__*100,SIGNIF)
        paste0(NCAT__, " (",PERCCAT__,"%)")
      })
      table__ <- cbind(table__, totalValueCol__)
      names(table__)[ncol(table__)] <- paste0("TOTAL (N=",NTOTAL__,")")
    }
  } 
  table__$Characteristic <- as.character(table__$Characteristic)
  table__$Characteristic[duplicated(table__$Characteristic)] = " "
  if (!is.null(filename)) {
    report__ <- TRUE
  } else {
    report__ <- FALSE
  }
  if (FLAGpatients) {
    footer__ <- "N: Number of patients<br>Number of patients in each category and percentage within this category"
  } else {
    footer__ <- "N: Number of subjects<br>Number of subjects in each category and percentage within this category"
  }
  if (FLAGmissingCat)
    footer__ <- paste0(footer__, "<br>","* stratification value missing in dataset")
  if (FLAGmissingVal)
    footer__ <- paste0(footer__, "<br>","** missing values in dataset")
  if (!is.null(footerAddText)) {
    footer__ <- paste0(footer__,"<br>",footerAddText)
  }
  if (!is.null(filename)) {
    filename <- paste0(aux_strrep(filename,".txt",""),".txt")
    IQRoutputTable(xtable=table__,xfooter=footer__,xtitle=tableTitle,report=report__,filename=filename)
    return(invisible(NULL))
  }
  output__ <- IQRoutputTable(xtable=table__,xfooter=footer__,xtitle=tableTitle,report=report__)
  output__
}
#'@export
summaryCov_IQRdataER <- function(data,
                                 covInfoAdd = NULL,
                                 covNames = NULL,
                                 stratifyColumns = "STUDY",
                                 stratifyOrder = NULL,
                                 FLAGtotal = NULL,
                                 SIGNIF = 3,
                                 tableTitle = NULL,
                                 footerAddText = NULL,
                                 filename = NULL,
                                 FLAGpatients = FALSE) {
  if(is_IQRdataGENERAL(data)){
    stopIQR("Use summaryCov_IQRdataGENERAL instead")
  }
  covInfo__ <- attributes(data)$covInfo
  if (!is.null(levels(covInfo__$COLNAME))) {
    stopIQR("Covariate information in attributes contains levels. This is not allowed.")
  }
  covInfo__ <- rbind(covInfo__,data.frame(covInfoAdd,stringsAsFactors = FALSE))
  covNamesData__ <- covInfo__$COLNAME
  if (is.null(covNames)) {
    covNames <- covNamesData__
  }
  if (is.null(covNames)) {
    message("No continuous covariates defined or present")
    return(invisible(NULL))
  }
  if (!all(covNames %in% covNamesData__)) {
    stopIQR(paste0("The following covNames are not available in the provided data:\n  ",paste0(covNames[!(covNames %in% covNamesData__)],collapse=", ")))
  }
  if (is.null(FLAGtotal)) {
    FLAGtotal <- rep(FALSE,length(stratifyColumns))
  }
  if (length(FLAGtotal)==1) {
    FLAGtotal <- rep(FLAGtotal,length(stratifyColumns))
  }
  if (length(FLAGtotal) != length(stratifyColumns)) {
    stopIQR("Missmatch between length of stratifyColumns and FLAGtotal input arguments")
  }
  if (!is.list(stratifyOrder)) {
    stratifyOrder <- list(stratifyOrder)
  }
  for (k__ in seq_along(stratifyColumns)) {
    entries__ <- unique(data[[stratifyColumns[k__]]])
    order__ <- unlist(stratifyOrder[k__])
    if (!is.null(order)) {
      if (!all(order__ %in% entries__)) {
        stopIQR(paste0("Not all entries in stratifyColumns are present for stratification column ",stratifyColumns[k__]))
      }
    }
  }
  if (is.null(tableTitle)) {
    tableTitle <- "Summary of demographic and baseline characteristics for continuous information"
  }
  datafirst__ <- as.data.frame(data[!duplicated(data$USUBJID),])
  covInfo__ <- covInfo__[covInfo__$COLNAME %in% covNames,]
  covInfo0__ <- covInfo__
  catInfo__ <- attr(data, "catInfo")
  baseTable__ <- do.call(rbind,lapply(1:nrow(covInfo__), function (kRowcovInfo__) {
    row__ <- covInfo__[kRowcovInfo__,]
    characteristic__ <- paste0(row__$NAME," (",row__$UNIT,")")
    colname__ <- row__$COLNAME
    subtable__ <- data.frame(
      Characteristic = characteristic__,
      COLNAME = colname__,
      stringsAsFactors=FALSE
    )
  }))
  table__ <- baseTable__
  table__$COLNAME <- NULL
  FLAGmissingVal <- FALSE
  FLAGmissingCat <- FALSE
  for (kstratcolumn__ in seq_along(stratifyColumns)) {
    stratifyColumn__ <- stratifyColumns[kstratcolumn__]
    FLAGtotal__ <- FLAGtotal[kstratcolumn__]
    stratifyOrder__ <- unlist(stratifyOrder[kstratcolumn__])
    if (is.null(stratifyOrder__))
      stratifyOrder__ <- unique(datafirst__[[stratifyColumn__]][!is.na(datafirst__[[stratifyColumn__]])])
    if (any(is.na(datafirst__[[stratifyColumn__]])))
      stratifyOrder__ <- c(stratifyOrder__, NA)
    if (stratifyColumn__ %in% catInfo__$COLNAME) {
      tmpVal__ <- aux_explode(catInfo__$VALUES[catInfo__$COLNAME == stratifyColumn__])
      tmpTxt__ <- aux_explode(catInfo__$VALUETXT[catInfo__$COLNAME == stratifyColumn__])
      stratifyOrder__ <- as.character(factor(stratifyOrder__, levels = tmpVal__, labels = tmpTxt__))
      datafirst__[[stratifyColumn__]] <- as.character(factor(datafirst__[[stratifyColumn__]], levels = tmpVal__, labels = tmpTxt__))
    }
    stratifyOrder__[is.na(stratifyOrder__)] <- "missing*"
    datafirst__[[stratifyColumn__]][is.na(datafirst__[[stratifyColumn__]])] <- "missing*"
    if ("missing*" %in% stratifyOrder__) FLAGmissingCat <- TRUE
    dummy__ <- sapply(stratifyOrder__, function (strata__) {
      stratData__ <- datafirst__[datafirst__[stratifyColumn__] == strata__,]
      stratData__ <- stratData__[!is.na(stratData__[stratifyColumn__]),]
      NTOTALstrat__ <- nrow(stratData__)
      STRATCOLname__ <- paste0(stratData__[[stratifyColumn__]][1]," (N=",NTOTALstrat__,")")
      stratValueCol__ <- sapply(1:nrow(baseTable__), function (kRowTable__) {
        row__ <- baseTable__[kRowTable__,]
        COLNAME__ <- row__$COLNAME
        if (!all(is.na(stratData__[[COLNAME__]]))) {
          MEAN <- signif(mean(stratData__[[COLNAME__]],na.rm=TRUE),SIGNIF)
          STD <- signif(stats::sd(stratData__[[COLNAME__]],na.rm=TRUE),SIGNIF)
          MAX <- signif(max(stratData__[[COLNAME__]],na.rm=TRUE),SIGNIF)
          MIN <- signif(min(stratData__[[COLNAME__]],na.rm=TRUE),SIGNIF)
          nNA <- sum(is.na(stratData__[[COLNAME__]]))
          out__ <- paste0(MEAN, " (",STD,") [",MIN,"-",MAX,"]")
          if (nNA > 0) {out__ <- paste0(out__, " (",nNA," n.a.**)"); FLAGmissingVal <<- TRUE}
        } else {
          out__ <- "-"
        }
        out__
      })
      table__ <<- cbind(table__, stratValueCol__)
      names(table__)[ncol(table__)] <<- STRATCOLname__
    })
    if (FLAGtotal__) {
      dataTOTAL__ <- datafirst__[!is.na(datafirst__[stratifyColumn__]),]
      NTOTAL__ <- nrow(dataTOTAL__)
      totalValueCol__ <- sapply(1:nrow(baseTable__), function (kRowTable__) {
        row__ <- baseTable__[kRowTable__,]
        COLNAME__ <- row__$COLNAME
        MEAN <- signif(mean(dataTOTAL__[[COLNAME__]],na.rm=TRUE),SIGNIF)
        STD <- signif(stats::sd(dataTOTAL__[[COLNAME__]],na.rm=TRUE),SIGNIF)
        MAX <- signif(max(dataTOTAL__[[COLNAME__]],na.rm=TRUE),SIGNIF)
        MIN <- signif(min(dataTOTAL__[[COLNAME__]],na.rm=TRUE),SIGNIF)
        nNA <- sum(is.na(dataTOTAL__[[COLNAME__]]))
        out__ <- paste0(MEAN, " (",STD,") [",MIN,"-",MAX,"]")
        if (nNA > 0) out__ <- paste0(out__, " (",nNA," n.a.**)")
        out__
      })
      table__ <- cbind(table__, totalValueCol__)
      names(table__)[ncol(table__)] <- paste0("TOTAL (N=",NTOTAL__,")")
    }
  } 
  if (!is.null(filename)) {
    report__ <- TRUE
  } else {
    report__ <- FALSE
  }
  if (FLAGpatients) {
    footer__ <- "N: Number of patients<br>Entries represent: Mean (Standard deviation) [Minimum-Maximum]"
  } else {
    footer__ <- "N: Number of subjects<br>Entries represent: Mean (Standard deviation) [Minimum-Maximum]"
  }
  if (FLAGmissingCat)
    footer__ <- paste0(footer__, "<br>","* stratification value missing in dataset")
  if (FLAGmissingVal)
    footer__ <- paste0(footer__, "<br>","** missing values in dataset")
  if (!is.null(footerAddText)) {
    footer__ <- paste0(footer__,"<br>",footerAddText)
  }
  if (!is.null(filename)) {
    filename <- paste0(aux_strrep(filename,".txt",""),".txt")
    IQRoutputTable(xtable=table__,xfooter=footer__,xtitle=tableTitle,report=report__,filename=filename)
    return(invisible(NULL))
  }
  output__ <- IQRoutputTable(xtable=table__,xfooter=footer__,xtitle=tableTitle,report=report__)
  output__
}
#'@export
mapContinuousCovariate_csvData <- function(csvfile,covName) {
  ATRinfo__ <- loadATRinfo_csvData(csvfile)
  if (is.null(ATRinfo__)) return(NULL)
  name__ <- ATRinfo__$covInfo[ATRinfo__$covInfo$COLNAME==covName]$NAME
  unit__ <- ATRinfo__$covInfo[ATRinfo__$covInfo$COLNAME==covName]$UNIT
  tv__ <- ATRinfo__$covInfo[ATRinfo__$covInfo$COLNAME==covName]$TIME.VARYING
  out__ <- list(
    NAME = name__,
    UNIT = unit__,
    TIME.VARYING = tv__
  )
  return(out__)
}
#'@export
mapCategoricalCovariate_csvData <- function(csvfile,catName,catValue) {
  ATRinfo__ <- loadATRinfo_csvData(csvfile)
  if (is.null(ATRinfo__)) return(NULL)
  name__ <- ATRinfo__$catInfo[ATRinfo__$catInfo$COLNAME==catName]$NAME
  values__ <- aux_explode(ATRinfo__$catInfo[ATRinfo__$catInfo$COLNAME==catName]$VALUES)
  valuetext__ <- aux_explode(ATRinfo__$catInfo[ATRinfo__$catInfo$COLNAME==catName]$VALUETXT)
  valuetext__ <- valuetext__[which(catValue==values__)]
  tv__ <- ATRinfo__$covInfo[ATRinfo__$catInfo$COLNAME==catName]$TIME.VARYING
  out__ <- list(
    NAME = name__,
    VALUETXT = valuetext__,
    TIME.VARYING = tv__
  )
  return(out__)
}
#'@export
mapContinuousCovariate_IQRnlmeProject <- function(projectPath,covName) {
  header__ <- parseNLMEprojectHeader(projectPath)
  oldpath__ <- getwd()
  setwd(projectPath)
  ATRinfo__ <- loadATRinfo_csvData(header__$DATA)
  setwd(oldpath__)
  if (is.null(ATRinfo__)) return(NULL)
  name__ <- ATRinfo__$covInfo$NAME[ATRinfo__$covInfo$COLNAME==covName]
  unit__ <- ATRinfo__$covInfo$UNIT[ATRinfo__$covInfo$COLNAME==covName]
  tv__ <- ATRinfo__$covInfo$TIME.VARYING[ATRinfo__$covInfo$COLNAME==covName]
  out__ <- list(
    NAME = name__,
    UNIT = unit__,
    TIME.VARYING = tv__
  )
  return(out__)
}
#'@export
mapCategoricalCovariate_IQRnlmeProject <- function(projectPath,catName,catValue=NULL) {
  header__ <- parseNLMEprojectHeader(projectPath)
  oldpath__ <- getwd()
  setwd(projectPath)
  ATRinfo__ <- loadATRinfo_csvData(header__$DATA)
  setwd(oldpath__)
  if (is.null(ATRinfo__)) return(NULL)
  name__ <- ATRinfo__$catInfo[ATRinfo__$catInfo$COLNAME==catName,]$NAME
  if (!is.null(catValue)) {
    if (!is.null(name__)) {
      values__ <- aux_explode(ATRinfo__$catInfo[ATRinfo__$catInfo$COLNAME==catName,]$VALUES)
      valuetext__ <- aux_explode(ATRinfo__$catInfo[ATRinfo__$catInfo$COLNAME==catName,]$VALUETXT)
      valuetext__ <- valuetext__[which(catValue==values__)]
      tv__ <- ATRinfo__$covInfo[ATRinfo__$catInfo$COLNAME==catName,]$TIME.VARYING
    } else {
      valuetext__ <- NULL
      tv__ <- NULL
    }
  } else {
    valuetext__ <- NULL
    tv__ <- NULL
  }
  out__ <- list(
    NAME = name__,
    VALUETXT = valuetext__,
    TIME.VARYING = tv__
  )
  return(out__)
}
#'@export
loadATRinfo_csvData <- function(filename) {
  filenameATR__ <- paste0(aux_strrep(filename,".csv",""),".atr")
  atrcontents <- loadAttributeFile(filenameATR__)
  out__ <- atrcontents
  return(out__)
}
loadAttributeFile <- function(filenameATR) {
  if (!file.exists(filenameATR)) return(NULL)
  atrContent__ <- aux_fileread(filenameATR)
  var0 <- ls() 
  eval(parse(text=atrContent__))
  var1 <- ls()
  if (!exists("atrcontents")) {
    atrcontents <- list()
    attrnames__ <- setdiff(var1, c(var0, "var0"))
    atrcontents <- plyr::alply(attrnames__, 1, function(x__) get(x__))
    names(atrcontents) <- attrnames__
    attr(atrcontents, "split_type") <- NULL
    attr(atrcontents, "split_labels") <- NULL
  }
  out__ <- atrcontents
  return(out__)
}
mapCovValues_Categories_ATR <- function(projectPath,data) {
  tryCatch(
    {
      proj <- as_IQRnlmeProject(projectPath)
    },
    error=function(e) {
      return(data)
    }
  )
  dataPath__ <- attr(proj,"absDataPath")
  atrPath__  <- aux_strrep(dataPath__,".csv",".atr")
  if (!file.exists(atrPath__)) return(data)
  atrContent__ <- aux_fileread(atrPath__)
  eval(parse(text=atrContent__))
  if (!is.null(atrcontents$catInfo)) {
    for (k in 1:nrow(atrcontents$catInfo)) {
      covCol__ <- atrcontents$catInfo$COLNAME[k]
      values__ <- aux_explodePC(atrcontents$catInfo$VALUES[k])
      valuetext__ <- aux_explodePC(atrcontents$catInfo$VALUETXT[k])
      if (covCol__ %in% names(data)) {
        sapply(1:length(values__), function (x) {
          data[[covCol__]][data[[covCol__]]==values__[x]] <<- paste0(values__[x]," (",valuetext__[x],")")
        })
      }
    }
  }
  return(data)
}
#'@export
#'@import dplyr
transformObs_IQRdataGENERAL<- function(data, transformation = "log(x)", x, y = sapply(x, function(i) sub("x", i, transformation)), unit, adjust = NULL) {
  contains.x <- x %in% data[["NAME"]]
  if (!all(contains.x)) {
    warningIQR(paste0("Did not find ", x[!contains.x], " in the data. Element is ignored."))
    x <- x[contains.x]
    if (length(x) == 0) return(data)
  }
  contains.adjust <- adjust %in% colnames(data)
  if (!all(contains.adjust)) {
    warningIQR(paste0("Did not find column(s) ", adjust[!contains.adjust], " in the data. Element is ignored."))
    adjust <- adjust[contains.adjust]
  }
  expr <- parse(text = transformation)
  name <- structure(y, names = x)
  if (length(unit) == 1) unit <- rep(unit, length(x))
  if (is.null(names(unit))) unit <- structure(rep_len(unit, length(x)), names = y)
  ytypeInfo <- unique(as.data.frame(data)[data$YTYPE != 0,c("NAME", "YTYPE")])
  ynew   <- setdiff(y, ytypeInfo$NAME)
  yexist <- setdiff(y, ynew)
  YTYPE <- c(
    structure(seq_along(ynew) + ifelse("YTYPE" %in% names(data), max(data[["YTYPE"]]), 0), names = ynew),
    structure(ytypeInfo$YTYPE[ytypeInfo$NAME %in% yexist], names=ytypeInfo$NAME[ytypeInfo$NAME %in% yexist])
  )
  subdata <-  dplyr::group_by(dplyr::filter(data, NAME %in% get('x')), NAME)
  for (n in intersect(adjust, names(subdata))) {
    subdata[[n]] <- with(list(x = subdata[[n]]), eval(expr))
  }
  subdata[["VALUE"]] <- with(list(x = subdata[["VALUE"]]), eval(expr))
  subdata[["NAME"]] <- name[subdata[["NAME"]]]
  subdata[["UNIT"]] <- unit[subdata[["NAME"]]]
  if ("DV" %in% names(subdata)) subdata[["DV"]] <- subdata[["VALUE"]]
  if ("VALUETXT" %in% names(subdata)) subdata[["VALUETXT"]] <- ifelse(is.na(subdata[["VALUE"]]), NA, format(subdata[["VALUE"]]))
  if ("YTYPE" %in% names(subdata)) subdata[["YTYPE"]] <- YTYPE[subdata[["NAME"]]]
  data <- rbind.data.frame(data, subdata)
  data <- data[order(data$USUBJID, data$TIME),]
  attr(data, "obsNAMES") <- union(attr(data, "obsNAMES"), y)
  mysummary <- data.frame(obsNAME = y,
                          transformation = sapply(x, function(i) sub("x", i, transformation)),
                          UNIT = unit,
                          YTYPE = YTYPE,
                          adjust = paste(adjust, collapse = ", "))
  cat ("The following observables have been added to the data:\n\n")
  print(IQRoutputTable(mysummary))
  return(data)
}
#'@import dplyr
#'@export
mutateCov_IQRdataGENERAL <- function(data, ..., unit, name) {
  equations <- unlist(list(...))
  unit <- rep_len(unit, length(equations))
  if (is.null(names(unit)))
    names(unit) <- names(equations)
  if (length(name) != length(equations))
    stopIQR("Each covariate must have a NAME. Check argument 'name'!")
  abbr <- names(equations)
  catInfo <- catInfo(data)
  catInfoNew <- NULL
  covInfo <- covInfo(data)
  covInfoNew <- NULL
  additionalCov <- lapply(seq_along(covInfo[["NAME"]]), function(i) data[[covInfo$COLNAME[i]]])
  additionalCat <- lapply(seq_along(catInfo[["NAME"]]), function(i) {
    values <- strsplit(catInfo[i, "VALUES"], split = ",")[[1]]
    valuetxt <- strsplit(catInfo[i, "VALUETXT"], split = ",")[[1]]
    names(valuetxt) <- values
    valuetxt[as.character(data[[catInfo$COLNAME[i]]])]
  })
  additional <- c(additionalCov, additionalCat)
  names(additional) <- gsub(" ", ".", c(covInfo$NAME, catInfo$NAME))
  for (i in 1:length(equations)) {
    symbols <- getSymbols(equations[i])
    missing <- !symbols %in% names(data) & !symbols %in% gsub(" ", ".", covInfo$NAME) & !symbols %in% gsub(" ", ".", catInfo$NAME)
    if (any(missing))
      stopIQR("Required column(s) for ", paste(symbols[missing], collapse = ", "), " are missing. Check dots argument!")
    data[[abbr[i]]] <- with(c(additional, data), {
      eval(parse(text = equations[i]))
    })
    is.categorical <- any(sapply(symbols, function(s) inherits(data[[s]], "character"))) | is.character(data[[abbr[i]]])
    nvalue <- sapply(split(data, data$USUBJID), function(d__) {
      abbr__ <- d__[[abbr[i]]]
      length(unique(abbr__[!is.na(abbr__)]))
    })
    if (max(nvalue, na.rm = TRUE) <= 1) time.varying <- FALSE else time.varying <- TRUE
    if (is.categorical) {
      valuetxt <- unique(data[[abbr[i]]])
      values <- 1:length(valuetxt) - 1
      names(values) <- valuetxt
      data[[abbr[i]]] <- values[data[[abbr[i]]]]
      catInfoNew <- rbind(catInfoNew,
                          data.frame(COLNAME = abbr[i], NAME = name[i], UNIT = unit[i],
                                     VALUETXT = paste(valuetxt, collapse = ","), VALUES = paste(values, collapse = ","),
                                     TIME.VARYING = time.varying,
                                     row.names = ifelse(is.null(catInfo), 0, nrow(catInfo)) + 1, stringsAsFactors = FALSE))
    } else {
      covInfoNew <- rbind(covInfoNew,
                          data.frame(COLNAME = abbr[i], NAME = name[i], UNIT = unit[i],
                                     TIME.VARYING = time.varying,
                                     row.names = ifelse(is.null(covInfo), 0, nrow(covInfo)) + 1, stringsAsFactors = FALSE))
    }
  }
  catInfo <- rbind(catInfo, catInfoNew)
  covInfo <- rbind(covInfo, covInfoNew)
  catInfo <- catInfo[rev(!duplicated(rev(catInfo[[1]]))),]
  covInfo <- covInfo[rev(!duplicated(rev(covInfo[[1]]))),]
  attr(data, "catInfo") <- catInfo
  attr(data, "covInfo") <- covInfo
  if (!is.null(covInfoNew)) {
    cat("The following continuous covariates have been added to the data:\n\n")
    print(IQRoutputTable(covInfoNew))
    cat("\n")
  }
  if (!is.null(catInfoNew)) {
    cat("The following categorical covariates have been added to the data:\n\n")
    print(IQRoutputTable(catInfoNew))
    cat("\n")
  }
  if (is.null(covInfoNew) & is.null(catInfoNew))
    cat("No covariates could be added.\n")
  return(data)
}
#'@export
convertCat2Text <- function(x, catValues, textValues) {
  if (length(catValues) != length(textValues)) stopIQR("Vectors with numerical ('catValues') and text ('textValues') values do not have same length.")
  if (!is.numeric(catValues)) {
    catValues <- tryCatch(as.numeric(catValues),
                          warning = function(w) w)
    if ("warning" %in% class(catValues)) {
      stopIQR("'catValue' needs to be numeric or convertable to numeric without issues.")
    }
  }
  if (!is.character(textValues)) stopIQR("'textValue' needs to be character.")
  if (!is.numeric(x)) stopIQR("'x' needs to be numeric.")
  if (!all(x %in% catValues)) {
    missing__ <- unique(setdiff(x, catValues))
    stopIQR(paste0("The following numerical values are missing in 'catValues': ", paste0(missing__, collapse = ", ")))
  }
  out__ <- factor(
    x,
    levels = catValues,
    labels = textValues
  )
  out__ <- as.character(out__)
  return(out__)
}
#'@export
getCatValues_catInfo <- function(catName, catInfo) {
  if (!catName %in% catInfo$COLNAME) stopIQR(catName, "is no categorical covariate in given categorical information table.")
  as.numeric(aux_explode(catInfo$VALUES[catInfo$COLNAME == catName]))
}
#'@export
getTextValues_catInfo <- function(catName, catInfo) {
  if (!catName %in% catInfo$COLNAME) stopIQR(catName, "is no categorical covariate in given categorical information table.")
  aux_explode(catInfo$VALUETXT[catInfo$COLNAME == catName])
}
#'@export
addCatColumnAsText_IQRdataGENERAL <- function(x, catColumn, newName = paste0(catColumn,"C")) {
  if (!is_IQRdataGENERAL(x)) {
    stopIQR("Input x needs to be IQRdataGENERAL.")
  }
  if (!catColumn %in% names(x)) stopIQR(paste0(catColumn, " does not exist in given IQRdataGENERAL object."))
  if (!is.character(newName)) stopIQR("newName input needs to be a character.")
  catInfo__ <- catInfo(x)
  if (!catColumn %in% catInfo__$COLNAME) stopIQR(paste0(catColumn, " is not a covariate column for the given IQRdataGENERAL object."))
  levels__  = aux_explode(catInfo__$VALUES[catInfo__$COLNAME == catColumn])
  labels__  = aux_explode(catInfo__$VALUETXT[catInfo__$COLNAME == catColumn])
  if(length(levels__) != length(labels__)) {
    stopIQR("The number of comma-separated elements in VALUES is different from those in VALUETXT.")
  }
  x[[newName]] <- convertCat2Text(x[[catColumn]],
                                  catValues = levels__,
                                  textValues = labels__)
  return(x)
}
obfuscate_numeric <- function(x, abs = 0, rel = 0.1) {
  stopifnot(is.numeric(x))
  amplitude__ <- max(abs(x[is.finite(x)]))
  matching__ <- match(x, unique(x))
  x__ <- unique(x)/amplitude__
  x__[is.finite(x__)] <- stats::rnorm(length(x__[is.finite(x__)]), mean = x__[is.finite(x__)], sd = abs + rel*abs(x__[is.finite(x__)]))
  x__ <- x__[matching__]
  x__
}
obfuscate_categoric <- function(x, basechar = "L") {
  stopifnot(is.character(x) | is.factor(x) | is.numeric(x))
  myclass__ <- case_when(
    is.factor(x) ~ "factor",
    is.numeric(x) ~ "numeric",
    TRUE ~ "character"
  )
  if (length(x) > 0 & any(!is.na(x))) {
    x <- as.character(x)
    x__ <- as.character(x[!is.na(x)])
    levels__ <- sample(unique(x__))
    if (myclass__ == "numeric") basechar <- ""
    substitute__ <- structure(
      .Data = paste0(basechar, formatC(1:length(levels__), flag = "0", width = ceiling(log10(length(levels__))))),
      names = levels__
    )
    x__ <- as.character(substitute__[x__])
    x[!is.na(x)] <- x__
    if (myclass__ == "numeric") x <- as.numeric(x)
    if (myclass__ == "factor") x <- factor(x, levels = substitute__)
  }
  x
}
obfuscate_NAME_VALUE <- function(data, names, basechar, method = "numeric") {
  if (length(names) > 0) {
    substitute__ <- structure(paste0(basechar, seq_along(names)), names = names)
    data$NAME[data$NAME %in% names] <- substitute__[data$NAME[data$NAME %in% names]]
    for (s__ in substitute__) {
      observations__ <- data$NAME %in% s__
      if (method == "numeric")
        data$VALUE[observations__] <- obfuscate_numeric(data$VALUE[observations__])
      if (method == "categoric")
        data$VALUE[observations__] <- obfuscate_categoric(data$VALUE[observations__])
    }
    attr(data, "ObfuscatedNames") <- as.character(substitute__)
  }
  data
}
obfuscate_IQRdataGENERAL <- function(data, additional = NULL, nSubjects = 10, abs = 0, rel = 0.1) {
  required__ <- c("USUBJID","TIME", "TIMEUNIT", "NAME", "VALUE", "UNIT", "ROUTE")
  stopifnot(all(required__ %in% colnames(data)),
            is.null(additional) | all(additional %in% colnames(data)))
  obsNAMES__ <- obsNAMES(data)
  doseNAMES__ <- doseNAMES(data)
  covNAMES__ <- covInfo(data)[["NAME"]]
  covCOLS__ <- covInfo(data)[["COLNAME"]]
  covTIME__ <- covInfo(data)[["TIME.VARYING"]]
  catNAMES__ <- catInfo(data)[["NAME"]]
  catCOLS__ <- catInfo(data)[["COLNAME"]]
  catTIME__ <- catInfo(data)[["TIME.VARYING"]]
  data__ <- as.data.frame(data)
  data__ <- data__[, unique(c(required__, additional, covCOLS__, catCOLS__))]
  data__ <- split(data__, data__$USUBJID, drop = TRUE)
  data__ <- data__[sample(seq_along(data__), nSubjects, replace = ifelse(length(data__) > nSubjects, FALSE, TRUE))]
  data__ <- lapply(seq_along(data__), function(i) {
    d__ <- data__[[i]]
    d__$USUBJID <- paste0("UID", formatC(i, flag = "0", width = ceiling(log10(nSubjects))))
    d__
  })
  data__ <- do.call(rbind, data__)
  data__ <- data__[data__$NAME %in% c(obsNAMES__, doseNAMES__),]
  data__ <- obfuscate_NAME_VALUE(data__, names = obsNAMES__, basechar = "Obs", method = "numeric")
  obsNAMES__ <- attr(data__, "ObfuscatedNames")
  data__ <- obfuscate_NAME_VALUE(data__, names = doseNAMES__, basechar = "Drug", method = "numeric")
  doseNAMES__ <- attr(data__, "ObfuscatedNames")
  for (s__ in covCOLS__) {
    data__[[s__]] <- obfuscate_numeric(data__[[s__]], abs = abs, rel = rel)
  }
  covNAMES__ <- obfuscate_categoric(covNAMES__, basechar = "Cov")
  names(data__)[match(covCOLS__, names(data__))] <- covNAMES__
  for (s__ in catCOLS__) {
    data__[[s__]] <- obfuscate_categoric(data__[[s__]])
  }
  catNAMES__ <- obfuscate_categoric(catNAMES__, basechar = "Cat")
  names(data__)[match(catCOLS__, names(data__))] <- catNAMES__
  for (s__ in additional) {
    if (is.numeric(data__[[s__]]))
      data__[[s__]] <- obfuscate_numeric(data__[[s__]], abs = abs, rel = rel)
    else
      data__[[s__]] <- obfuscate_categoric(data__[[s__]])
  }
  data__$TIME <- obfuscate_numeric(data__$TIME, abs = abs, rel = rel)
  data__$TIMEUNIT <- "Hours"
  data__$UNIT <- obfuscate_categoric(data__$UNIT, basechar = "Unit")
  data__$ROUTE[!is.na(data__$ROUTE)] <- "ORAL"
  covInfo__ <- catInfo__ <- NULL
  if (length(covNAMES__) > 0) {
    covInfo__ <- list(
      COLNAME = covNAMES__,
      NAME = covNAMES__,
      UNIT = rep("--", length(covNAMES__)),
      TIME.VARYING = covTIME__
    )
  }
  if (length(catNAMES__) > 0) {
    catInfo__ <- list(
      COLNAME = catNAMES__,
      NAME = catNAMES__,
      UNIT = rep("--", length(catNAMES__)),
      VALUETXT = sapply(catNAMES__, function(x) paste(unique(data__[[x]][!is.na(data__[[x]])]), collapse = ", ")),
      VALUES = sapply(catNAMES__, function(x) paste(unique(data__[[x]][!is.na(data__[[x]])]), collapse = ", ")),
      TIME.VARYING = catTIME__
    )
  }
  IQRdataGENERAL(data__, doseNAMES__, obsNAMES__,
                 covInfoAdd = covInfo__, catInfoAdd = catInfo__)
}
#'@export
checkForDuplicatedTimeSeries_IQRdataGENERAL <- function(dataGeneral, name, verbose = FALSE) {
  dtGeneral <- as.data.table(dataGeneral)
  setkey(dtGeneral, USUBJID, NAME, TIME)
  USUBJIDs <- dtGeneral[, unique(USUBJID)]
  duplicatedUSUBJIDs <- list()
  for(i in seq(1, length(USUBJIDs)-1)) {
    Ui <- USUBJIDs[i]
    tsi <- dtGeneral[list(USUBJID = Ui, NAME = name), list(USUBJID, NAME, TIME, VALUE, DV), nomatch = 0]
    for(j in seq(i+1, length(USUBJIDs))) {
      Uj <- USUBJIDs[j]
      tsj <- dtGeneral[list(USUBJID = Uj, NAME = name), list(USUBJID, NAME, TIME, VALUE, DV), nomatch = 0]
      if(nrow(tsi) > 0 && nrow(tsj) > 0 &&
         (identical(tsi[, list(TIME, VALUE)], tsj[, list(TIME, VALUE)]) ||
          identical(tsi[, list(TIME, DV)], tsj[, list(TIME, DV)])) ) {
        if(verbose) {
          cat("======================================================\n")
          cat("tsi:\n")
          print(tsi)
          cat("tsj:\n")
          print(tsj)
          cat("======================================================\n")
        }
        duplicatedUSUBJIDs[[Ui]] <- c(duplicatedUSUBJIDs[[Ui]], Uj)
      }
    }
  }
  duplicatedUSUBJIDs
}
#'@export
plot.IQRdataGENERAL <- function(
  x,
  pathname = "DataExploration",
  stratify = NULL,
  scaleOBS = "log",
  scaleCOV = "linear",
  covNames  = NULL,
  catNames   = NULL,
  ...)
{
  data__ <- x
  if (!is_IQRdataGENERAL(data__))
    stopIQR("Input data is not an IQRdataGENERAL object.")
  aux_mkdir(pathname)
  cat("Plotting individual lines per treatment group ...\n")
  tryCatch({
    plotSpaghetti_IQRdataGENERAL(data__,
                                 scale = scaleOBS,
                                 stratify = NULL,
                                 filename = file.path(pathname,"01_OBSvsTIME_Spaghetti"))
  }, error = function(err) {
    warningIQR(paste0("Spaghetti plots could not be generated: ", err))
  })
  cat("Plotting individual data per panel (may take a while) ...\n")
  tryCatch({
    suppressWarnings(plotIndiv_IQRdataGENERAL(data__,
                                              scale = scaleOBS,
                                              filename = file.path(pathname, "02_OBSvsTIME_Individual")))
  }, error = function(err) {
    warningIQR(paste0("Individual plots could not be generated: ", err))
  })
  cat("Plotting summary timecourses per treatment group ...\n")
  tryCatch({
    plotRange_IQRdataGENERAL(data__,
                             scale = scaleOBS,
                             stratify = NULL,
                             filename = file.path(pathname,"03_OBSvsTIME_Range"))
  }, error = function(err) {
    warningIQR(paste0("Range plots could not be generated: ", err))
  })
  cat("Plotting continuous covariate distributions ...\n")
  tryCatch({
    plotCovDistribution_IQRdataGENERAL(data__,
                                       scale = scaleCOV,
                                       covNames = c(covNames, catNames),
                                       filename = file.path(pathname,"04_ContCovDistributions"))
  }, error = function(err) {
    warningIQR(paste0("\nContinuous covariate distributions could not be plotted: ", err))
  })
  cat("Plotting continuous covariate correlations ...\n")
  tryCatch({
    plotCorCov_IQRdataGENERAL(data__,
                              covNames = covNames,
                              scale = scaleCOV,
                              filename = file.path(pathname, "05_ContCovCorrelation"))
  }, error = function(err) {
    warningIQR(paste0("\nContinuous covariate correlations could not be plotted: ", err))
  })
  cat("Plotting categorical covariate correlations ...\n")
  tryCatch({
    plotCorCat_IQRdataGENERAL(data__,
                              catNames = catNames,
                              filename = file.path(pathname, "06_CatCovCorrelation"))
  }, error = function(err) {
    warningIQR(paste0("\nCategorical covariate correlations could not be plotted: ", err))
  })
  cat("Plotting continuous/categorical covariate correlations ...\n")
  tryCatch({
    plotCorCovCat_IQRdataGENERAL(data__,
                                 covNames = covNames,
                                 catNames = catNames,
                                 filename = file.path(pathname, "07_ContCatCovCorrelation"))
  }, error = function(err) {
    warningIQR(paste0("\nCategorical/continuous covariate correlations could not be plotted: ", err))
  })
}
#'@export
plotSpaghetti_IQRdataGENERAL <- function(data, scale = "log", stratify = NULL, linetype=NULL,
                                         filename = NULL,
                                         FLAGreturnObject = FALSE)
{
  data__ <- data
  if (!is_IQRdataGENERAL(data__))
    stopIQR("Input argument is not an IQRdataGENERAL object.")
  if (!"TRTNAME" %in% names(data__)) {
    data__$TRTNAME <- ""
    data__$TRT <- 0
  }
  if (!class(stratify) %in% c("NULL","character"))
    stopIQR("Invalid input argument for 'stratify'. Must be either NULL or character vector.")
  if (!(is.null(filename) | (is.character(filename)) & length(filename) == 1))
    stopIQR("Filename for PDF needs to be character string (no vector).")
  if (!is.null(linetype)) {
    if (!linetype %in% names(data)) stopIQR("linetype argument is not a column in the dataset")
    if (length(unique(data[[linetype]]))>5) warningIQR("More than 5 distinct elements in linetype column")
  }
  if (!is.null(attr(data__,"covInfo")))
    covInfo0__ <- attr(data__,"covInfo")[!attr(data__,"covInfo")$TIME.VARYING,]
  if (!is.null(attr(data__,"catInfo")))
    catInfo0__ <- attr(data__,"catInfo")[!attr(data__,"catInfo")$TIME.VARYING,]
  obsNAMES__ <- attr(data__, "obsNAMES")
  timelabel__ <- get_timelabelIQR(data__)
  data__ <- handle_MDVBLQplot(data__)
  obsSCALES__ <- handle_obsScalesIQR(scale, obsNAMES__)
  if (is.factor(data__$TRTNAME)) {
    data__$TRTNAMElabel <- factor(data__$TRTNAME, labels = paste0(levels(data__$TRTNAME)))
  } else {
    data__$TRTNAMElabel <- data__$TRTNAME
  }
  trtlabels <- unique(data__$TRTNAMElabel)
  ntrt <- length(trtlabels)
  ltrt <- max(nchar(as.character(trtlabels)), na.rm=TRUE)
  basefs <- max(14 - floor(ltrt/9),6)
  data_out <- list()
  env.data_out <- environment()
  gr__ <- plyr::dlply(
    data__[data__$NAME %in% obsNAMES__,],    
    ~ NAME,                                  
    function(x) {
      name.x <- x$NAME[1]
      title__ <- paste0("Individual ", unique(x$NAME), " over time")
      subtitle__ <- "Stratified by treatment group"
      if (trtlabels[1]=="") subtitle__ <- NULL
      ssInfo <- plyr::ddply(unique(x[,c("USUBJID","TRTNAME","TRTNAMElabel")]), ~TRTNAME+TRTNAMElabel,
                            function(xx__) data.frame(N = sum(!is.na(xx__$TRTNAME))))
      ssInfo$valueMax__ <- max(x$VALUE, na.rm=TRUE)
      ssInfo$timeMin__ <- min(x$TIME, na.rm=TRUE)
      env.data_out$data_out[["unstratified"]][[name.x]] <- x
      if (!is.null(linetype)) {
        x[[linetype]] <- as.factor(x[[linetype]])
      }
      p__ <- IQRggplot(data=x, aes_string("TIME", "VALUE"))
      if (is.null(linetype)) {
        p__ <- p__ + geom_line(aes_string(group="USUBJID"),alpha=0.3)
      } else {
        p__ <- p__ + geom_line(aes_string(group="USUBJID",linetype=linetype),alpha=1)
      }
      p__ +
        geom_point(aes_string(
          shape="BLOQ",
          color="BLOQ"
        ), alpha=0.6) +
        geom_text(data = ssInfo, aes_string(x="timeMin__", y="valueMax__", label="paste0('N=',N)"), hjust = 0, vjust = 1) +
        scale_color_IQRblloq +
        scale_shape_IQRblloq +
        labs(
          x = timelabel__,
          y = get_obslabelIQR(x[1,]),
          title = title__,
          subtitle = subtitle__,
          caption = "Missing values (MDV=1) have been removed, records below LLOQ plotted at value in dataset."
        ) +
        facet_wrap(~TRTNAMElabel) +
        scale_y_apply(obsSCALES__$scale[obsSCALES__$NAME == unique(x$NAME)]) +
        theme(legend.position="bottom",
              strip.text = element_text(size = max(5,basefs-ceiling(sqrt(ntrt)))),
              plot.caption = element_text(size = 7, hjust=0))
    }
  )
  tmp__ <- handle_stratificationIQR(data__, stratify)
  data__ <- tmp__[[1]]
  strat__ <- tmp__[[2]]
  catInfo0__ <- tmp__[[3]]
  grstrat__ <- list()
  attr(grstrat__, "strat_info") <- data.frame()
  for (strk__ in strat__) {
    grstratk__ <- plyr::dlply(
      data__[data__$NAME %in% obsNAMES__,],    
      c("NAME", strk__),                       
      function(x) {
        condition.x <- paste(x$NAME[1], x[[strk__]][1], sep = "_")
        strval__  <- unique(x[[strk__]])
        strname__ <- catInfo0__$NAME[catInfo0__$COLNAME == strk__]
        posval__  <- aux_explode(catInfo0__$VALUES[catInfo0__$COLNAME == strk__])
        postxt__  <- aux_explode(catInfo0__$VALUETXT[catInfo0__$COLNAME == strk__])
        strtxt__  <- postxt__[posval__ == strval__]
        title__   <- paste0("Individual ", unique(x$NAME), " over time")
        subtitle__<- paste0("Stratified by treatment group and ", strname__,": ",strtxt__)
        ssInfo <- plyr::ddply(unique(x[,c("USUBJID","TRTNAME","TRTNAMElabel")]), ~TRTNAME+TRTNAMElabel,
                              function(xx__) data.frame(N = sum(!is.na(xx__$TRTNAME))))
        ssInfo$valueMax__ <- max(x$VALUE, na.rm=TRUE)
        ssInfo$timeMin__ <- min(x$TIME, na.rm=TRUE)
        env.data_out$data_out[["stratified"]][[condition.x]] <- x
        IQRggplot(data=x, aes_string("TIME", "VALUE")) +
          geom_line(aes_string(group = "USUBJID"), alpha=0.3) +
          geom_point(aes_string(
            shape="BLOQ",
            color="BLOQ"
          ), alpha=0.6) +
          geom_text(data = ssInfo, aes_string(x="timeMin__",y="valueMax__", label='paste0("N=",N)'), hjust = 0, vjust = 1) +
          scale_color_IQRblloq +
          scale_shape_IQRblloq +
          labs(
            x = timelabel__,
            y = get_obslabelIQR(x[1,]),
            title = title__,
            subtitle = subtitle__,
            caption = "Missing values (MDV=1) have been removed, records below LLOQ plotted at value in dataset."
          ) +
          facet_wrap(~TRTNAMElabel) +
          scale_y_apply(obsSCALES__$scale[obsSCALES__$NAME == unique(x$NAME)]) +
          theme(legend.position="bottom",
                strip.text = element_text(size = max(5,basefs-ceiling(sqrt(ntrt)))),
                plot.caption = element_text(size = 7, hjust=0))
      }
    )
    si__ <- attr(grstratk__,"split_labels")
    si__$STRAT <- names(si__)[2]
    names(si__)[2] <- "VALUE"
    names(grstratk__) <- with(si__, {paste0(NAME,".",STRAT,"::",VALUE)} )
    grstrat__ <- c(grstrat__,grstratk__)
    attr(grstrat__, "strat_info") <- rbind(attr(grstrat__, "strat_info"), si__)
  }
  if (!is.null(filename)) {
    if (exists("grstrat__")) {
      plotList <- c(gr__,grstrat__)
    }
    IQRoutputPDF(plotList,filename=filename)
  } else {
    plyr::l_ply(gr__, print)
    if (exists("grstrat__")) plyr::l_ply(grstrat__, print)
  }
  if (FLAGreturnObject) {
    out <- list(unstratified=gr__,stratified=grstrat__)
    attr(out, "data") <- data_out
    return(out)
  }
}
#'@export
plotIndiv_IQRdataGENERAL <- function(
  data,
  obsNames = NULL,
  scale = "log",
  filename = "OBSvsTIME_IndivPanels",
  FLAGplotDosesSeparate = TRUE,
  FLAGreturnObject = FALSE)
{
  if (!is_IQRdataGENERAL(data))
    stopIQR("Input argument is not an IQRdataGENERAL object.")
  if (!class(obsNames) %in% c("NULL","character"))
    stopIQR("Invalid input argument for 'obsNames'. Must be either NULL or character vector.")
  if (!(is.null(filename) | (is.character(filename)) & length(filename) == 1))
    stopIQR("Filename for PDF needs to be character string (no vector).")
  data__ <- data
  if (!"TRTNAME" %in% names(data__)) {
    data__$TRTNAME <- ""
    data__$TRT <- 0
  }
  if (is.null(obsNames)) {
    obsNAMES__ <- attr(data__, "obsNAMES")
  } else {
    missingobs__ <- setdiff(obsNames, attr(data__, "obsNAMES"))
    if (length(missingobs__) != 0){
      warningIQR('Following observation(s) are not contained in the dataset: ',paste0(missingobs__, collapse = ", "))
    }
    obsNAMES__ = intersect(obsNames,attr(data__, "obsNAMES"))
    if (length(obsNAMES__) == 0){
      stopIQR('No existing observations chosen for plotting.')
    }
  }
  doseNAMES__ <- attr(data__, "doseNAMES")
  obsSCALES__ <- handle_obsScalesIQR(scale, obsNAMES__)
  timelabel__ <- get_timelabelIQR(data__)
  data__ <- handle_MDVBLQplot(data__, FLAGremoveMDV = FALSE)
  data_out <- list()
  env.data_out <- environment()
  dP__ <- data__[data__$NAME %in% c(obsNAMES__,doseNAMES__),]
  dPs__ <- split(dP__,dP__$ID)
  gr__ <- lapply(seq_along(dPs__), function (kP__) {
    xx <- dPs__[[kP__]]
    usubjid.xx <- xx$USUBJID[1]
    tmin <- min(xx$TIME, na.rm = TRUE)
    tmax <- max(xx$TIME, na.rm = TRUE)
    xx1__ <- xx[xx$NAME %in% obsNAMES__,]
    xx2__ <- xx[xx$NAME %in% doseNAMES__,]
    if (dim(xx1__)[1] == 0) {
      if (FLAGplotDosesSeparate) {
        pl__ <- add_LayerDosingSingle(IQRggplot(xx2__),xx2__, 0, max(xx2__$VALUE, na.rm=TRUE), tmin, tmax, "linear")
      } else {
        if (length(unique(xx2__$NAME)) > 1) {
          warningIQR("Summarized plotting of dosing for different dosing of more than one compound not implemented yet.\n Plot separately.")
          pl__ <- add_LayerDosingSingle(IQRggplot(xx2__),xx2__, 0, max(xx2__$VALUE, na.rm=TRUE), tmin, tmax, "linear")
        } else {
          pl__ <- add_LayerDosingMulti(IQRggplot(xx2__),xx2__, 0, max(xx2__$VALUE, na.rm=TRUE), tmin, tmax, "linear")
        }
      }
      plotList__ <- list(
        pl__ +
          coord_cartesian(ylim = c(-0.5, max(xx2__$VALUE, na.rm = TRUE)+0.5)) +
          labs(
            x=timelabel__,
            y= "Dose amount",
            title = "Dosing (no observations present)"
          )
      )
    } else {
      nOBS__ <- length(unique(xx1__$NAME))
      fs.axistitle__ <- 14-nOBS__*1.5
      plotList__ <- plyr::dlply(
        xx1__, ~NAME, doseInfo = xx2__, tmin = tmin, tmax = tmax,
        function(xxx, doseInfo, tmin, tmax) {
          name.xxx <- xxx$NAME[1]
          sc__ <- obsSCALES__$scale[obsSCALES__$NAME == name.xxx]
          if (!any(xxx$VALUE > 0)) sc__ <- "linear"
          ymin <- switch(sc__,
                         linear = min(xxx$VALUE, na.rm = TRUE),
                         log    = 10^(floor(log10(min(xxx$VALUE[xxx$VALUE>0], na.rm=TRUE))))
          )
          ymax <- max(xxx$VALUE, na.rm = TRUE)
          caption <- "Non-NA values set as missing (MDV=1) marked with orange diamond, records below LLOQ plotted at value in dataset."
          pl__ <- IQRggplot(data=xxx, aes_string("TIME", "VALUE"))
          if (dim(doseInfo)[1] > 0) {
            if (FLAGplotDosesSeparate) {
              pl__ <- add_LayerDosingSingle(pl__, doseInfo, ymin, ymax, tmin, tmax, sc__)
            } else {
              if (length(unique(doseInfo$NAME)) > 1) {
                warningIQR("Summarized plotting of dosing for different dosing of more than one compound not implemented yet.\n Plot separately.")
                pl__ <- add_LayerDosingSingle(pl__, doseInfo, ymin, ymax, tmin, tmax, sc__)
              } else {
                pl__ <- add_LayerDosingMulti(pl__, doseInfo, ymin, ymax, tmin, tmax, sc__)
                caption <- paste0(caption,"\nMerged single dose records to multiple records indicated by dotted box.")
              }
            }
          }
          pl__ <- pl__ +
            geom_line(alpha=0.3) +
            geom_point(aes_string(
              shape="BLOQ"
            ), alpha=0.6) +
            geom_point(data=xxx[xxx$MDV == 1,], color = "darkorange", shape = 5) +
            geom_text(
              aes_string(label='paste0(IXGDF,"@(",format(TAD, digits = 2),",",format(VALUE, digits=2),")")'),
              color = '#008C48', hjust=-0.1,vjust=0.1, size = 2) +
            scale_shape_IQRblloq +
            labs(
              x=timelabel__,
              y= paste0(name.xxx, " (", xxx$UNIT[1], ")"),
              title = name.xxx,
              caption = caption
            ) +
            scale_y_apply(sc__) +
            coord_cartesian(
              xlim=c(tmin-0.05*(tmax-tmin),tmax+0.2*(tmax-tmin))
            ) +
            theme(legend.position="right", legend.text = element_text(size = 8), legend.title = element_text(size = 9),
                  plot.caption = element_text(size = 7, hjust=0), axis.title = element_text(size = fs.axistitle__))
          return(pl__)
        }
      )
    }
    if (any(xx$TRTNAME=="")) {
      text__ <- paste0(xx$USUBJID[1], " (ID=",xx$ID[1],")")
    } else {
      text__ <- paste0(xx$USUBJID[1], " (ID=",xx$ID[1],") in TRTNAME group ", xx$TRTNAME[1])
    }
    suppressWarnings(
      plot__ <- gridExtra::marrangeGrob(
        plotList__, ncol = 1, nrow = length(plotList__),
        top = grid::textGrob(text__,
                             x = unit(0.08, "npc"), just = "left",
                             gp=grid::gpar(fontsize = 12, font =2) ))
    )
    return(plot__)
  })
  if (!is.null(filename)) {
    IQRoutputPDF(gr__,filename=filename)
  } else {
    plyr::l_ply(gr__, print)
  }
  if (FLAGreturnObject) {
    attr(gr__, "data") <- data_out
    return(gr__)
  }
}
#'@export
plotRange_IQRdataGENERAL <- function(data,
                                     scale = "log",
                                     stratify = NULL,
                                     filename = NULL,
                                     FLAGreturnObject = FALSE)
{
  if (!is_IQRdataGENERAL(data))
    stopIQR("Input argument is not an IQRdataGENERAL object.")
  if (!class(stratify) %in% c("NULL","character"))
    stopIQR("Invalid input argument for 'stratify'. Must be either NULL or character vector.")
  if (!(is.null(filename) | (is.character(filename)) & length(filename) == 1))
    stopIQR("Filename for PDF needs to be character string (no vector).")
  if (all(is.na(data$NT))) {
    message("No nominal time available - Range plots not done!")
    return(invisible(NULL))
  }
  data__ <- data
  if (!"TRTNAME" %in% names(data__)) {
    data__$TRTNAME <- ""
    data__$TRT <- 0
  }
  if (!is.null(attr(data__,"covInfo")))
    covInfo0__ <- attr(data__,"covInfo")[!attr(data__,"covInfo")$TIME.VARYING,]
  if (!is.null(attr(data__,"catInfo")))
    catInfo0__ <- attr(data__,"catInfo")[!attr(data__,"catInfo")$TIME.VARYING,]
  obsNAMES__ <- attr(data__, "obsNAMES")
  timelabel__ <- get_timelabelIQR(data__)
  obsSCALES__ <- handle_obsScalesIQR(scale, obsNAMES__)
  data__ <- handle_MDVBLQplot(data__)
  data__ <- data__[!is.na(data__$NT),]
  if (is.factor(data__$TRTNAME)) {
    data__$TRTNAMElabel <- factor(data__$TRTNAME, labels = paste0(levels(data__$TRTNAME)))
  } else {
    data__$TRTNAMElabel <- data__$TRTNAME
  }
  trtlabels <- unique(data__$TRTNAMElabel)
  ntrt <- length(trtlabels)
  ltrt <- max(nchar(as.character(trtlabels)), na.rm=TRUE)
  basefs <- max(14 - floor(ltrt/9),6)
  data_out <- list()
  env.data_out <- environment()
  gr__ <- plyr::dlply(
    data__[data__$NAME %in% obsNAMES__,],    
    ~ NAME,                                  
    function(x) {
      name.x <- x$NAME[[1]]
      title__ <- paste0("Individual ", unique(x$NAME), " over time")
      if (x$TRTNAME[1]!="") {
        subtitle__ <- "Stratified by treatment group"
      } else {
        subtitle__ <- NULL
      }
      ssInfo <- plyr::ddply(unique(x[,c("USUBJID","TRTNAME","TRTNAMElabel")]), ~TRTNAME+TRTNAMElabel,
                            function(xx__) data.frame(N = sum(!is.na(xx__$TRTNAME))))
      ssInfo$valueMax__ <- max(x$VALUE, na.rm=TRUE)
      ssInfo$timeMin__ <- min(x$NT, na.rm=TRUE)
      env.data_out$data_out[["unstratified"]][[name.x]] <- x
      IQRggplot(data=x, aes_string("NT", "VALUE")) +
        stat_summary(fun.data=median90range, geom="line") +
        stat_summary(fun.data=median90range, geom="ribbon", color = NA, fill = '#185AA9', alpha = 0.3) +
        geom_text(data = ssInfo, aes_string(x="timeMin__",y="valueMax__", label='paste0("N=",N)'), hjust = 0, vjust = 1) +
        scale_color_IQRblloq +
        labs(
          x = timelabel__,
          y = get_obslabelIQR(x[1,]),
          title = title__,
          subtitle = subtitle__,
          caption = "Missing values (MDV=1) and records with missing nominal time have been removed, records below LLOQ plotted at value in dataset."
        ) +
        facet_wrap(~TRTNAMElabel) +
        scale_y_apply(obsSCALES__$scale[obsSCALES__$NAME == unique(x$NAME)]) +
        theme(legend.position="bottom",
              strip.text = element_text(size = max(5,basefs-ceiling(sqrt(ntrt)))),
              plot.caption = element_text(size = 7,hjust=0))
    }
  )
  tmp__ <- handle_stratificationIQR(data__, stratify)
  data__ <- tmp__[[1]]
  strat__ <- tmp__[[2]]
  catInfo0__ <- tmp__[[3]]
  grstrat__ <- list()
  attr(grstrat__, "strat_info") <- data.frame()
  for (strk__ in strat__) {
    grstratk__ <- plyr::dlply(
      data__[data__$NAME %in% obsNAMES__,],    
      c("NAME", strk__),                       
      function(x) {
        condition.x <- paste(x$NAME[1], x[[strk__]][1], sep = "_")
        strval__  <- unique(x[[strk__]])
        strname__ <- catInfo0__$NAME[catInfo0__$COLNAME == strk__]
        posval__  <- aux_explode(catInfo0__$VALUES[catInfo0__$COLNAME == strk__])
        postxt__  <- aux_explode(catInfo0__$VALUETXT[catInfo0__$COLNAME == strk__])
        strtxt__  <- postxt__[posval__ == strval__]
        title__   <- paste0("Individual ", unique(x$NAME), " over time")
        subtitle__<- paste0("Stratified by treatment group and ", strname__,": ",strtxt__)
        ssInfo <- plyr::ddply(unique(x[,c("USUBJID","TRTNAME","TRTNAMElabel")]), ~TRTNAME+TRTNAMElabel,
                              function(xx__) data.frame(N = sum(!is.na(xx__$TRTNAME))))
        ssInfo$valueMax__ <- max(x$VALUE, na.rm=TRUE)
        ssInfo$timeMin__ <- min(x$TIME, na.rm=TRUE)
        env.data_out$data_out[["stratified"]][[condition.x]] <- x
        IQRggplot(data=x, aes_string("NT", "VALUE")) +
          stat_summary(fun.data=median90range, geom="line") +
          stat_summary(fun.data=median90range, geom="ribbon", color = NA, fill = '#185AA9', alpha = 0.3) +
          geom_text(data = ssInfo, aes_string(x="timeMin__",y="valueMax__", label='paste0("N=",N)'), hjust = 0, vjust = 1) +
          labs(
            x = timelabel__,
            y = get_obslabelIQR(x[1,]),
            title = title__,
            subtitle = subtitle__,
            caption = "Missing values (MDV=1) have been removed, records below LLOQ plotted at value in dataset."
          ) +
          facet_wrap(~TRTNAMElabel) +
          scale_y_apply(obsSCALES__$scale[obsSCALES__$NAME == unique(x$NAME)]) +
          theme(legend.position="bottom",
                strip.text = element_text(size = max(5,basefs-ceiling(sqrt(ntrt)))),
                plot.caption = element_text(size = 7, hjust=0))
      }
    )
    si__ <- attr(grstratk__,"split_labels")
    si__$STRAT <- names(si__)[2]
    names(si__)[2] <- "VALUE"
    names(grstratk__) <- with(si__, {paste0(NAME,".",STRAT,"::",VALUE)} )
    grstrat__ <- c(grstrat__,grstratk__)
    attr(grstrat__, "strat_info") <- rbind(attr(grstrat__, "strat_info"), si__)
  }
  if (!is.null(filename)) {
    if (exists("grstrat__")) {
      plotList <- c(gr__,grstrat__)
    }
    IQRoutputPDF(plotList,filename=filename)
  } else {
    plyr::l_ply(gr__, print)
    if (exists("grstrat__")) plyr::l_ply(grstrat__, print)
  }
  if (FLAGreturnObject) {
    out <- list(unstratified=gr__,stratified=grstrat__)
    attr(out, "data") <- data_out
    return(out)
  }
}
#'@export
plotCovDistribution_IQRdataGENERAL <- function(data,
                                               covNames = NULL,
                                               scale = "linear",
                                               filename = NULL,
                                               FLAGreturnObject=FALSE)
{
  data__ <- data
  contInfo0__  <- attr(data__,"covInfo") 
  catInfo0__ <- attr(data__,"catInfo") 
  if (!is_IQRdataGENERAL(data__))
    stopIQR("Input argument is not an IQRdataGENERAL object.")
  if (!class(covNames) %in% c("NULL","character"))
    stopIQR("Invalid input argument for 'covNames'. Must be either NULL or character vector of covariate names.")
  if (!(is.null(filename) | (is.character(filename)) & length(filename) == 1))
    stopIQR("Filename for PDF needs to be character string (no vector).")
  if (is.null(covNames)) {
    covNames__ <- c(contInfo0__$COLNAME, catInfo0__$COLNAME)
  } else {
    covNames__ <- covNames
    missingCovNames__ <- setdiff(covNames, c(contInfo0__$COLNAME, catInfo0__$COLNAME))
    if (length(missingCovNames__) != 0){
      warningIQR('Following covariate(s) are no covariates in the dataset: ',paste0(missingCovNames__, collapse = ", "))
      covNames__ <- intersect(covNames__,c(contInfo0__$COLNAME, catInfo0__$COLNAME))
    }
  }
  data_out <- list()
  env.data_out <- environment()
  contNames__ <- intersect(covNames__, contInfo0__$COLNAME)
  if (length(contNames__) > 0) {
    obsSCALES__ <- handle_obsScalesIQR(scale, contNames__, default = "linear")
    logCOV__    <- obsSCALES__[obsSCALES__$scale == "log", "NAME"]
    for (k in seq_along(logCOV__)) {
      if (any(data__[[logCOV__[k]]]<=0, na.rm = TRUE)){
        warningIQR("Trying to transform covariate that contains negative values. Left on linear scale.")
      } else {
        data__[[logCOV__[k]]] <- log(data__[[logCOV__[k]]])
        contInfo0__$UNIT[contInfo0__$COLNAME == logCOV__[k]] <- paste0("log(",contInfo0__$UNIT[contInfo0__$COLNAME == logCOV__[k]],")")
      }
    }
    idCols__ <- c("USUBJID")
    data__ <- data__[order(data__$USUBJID,data__$TIME),]
    contdata__ <- as.data.frame(data__[!duplicated(data__$USUBJID),c(idCols__,contNames__)])
    contdata.long__ <- tidyr::gather(contdata__,COLNAME,VALUE,-USUBJID)
    contdata.long__ <- merge(contdata.long__, contInfo0__, all.x=TRUE, all.y = FALSE)
    contdata.long__$COVlabel <- with(contdata.long__, paste0(COLNAME, "\n", NAME, " (",UNIT, ")"))
    contdata.long__ <- contdata.long__[!is.na(contdata.long__$VALUE),]
    nBins__ <- ceiling(min(nrow(contdata__)/5,20))
    data_out[["cont"]] <- contdata.long__
    grCont__ <- IQRggplot(data=contdata.long__) +
      geom_histogram(aes_string(x="VALUE"),bins=nBins__) +
      facet_wrap(~COVlabel,scales="free") +
      ylab("") + xlab("") +
      ggtitle(label="Histograms of continuous covariates")
  } else {
    grCont__ <- NULL
  }
  catNames__ <- intersect(covNames__, catInfo0__$COLNAME)
  if (length(catNames__) > 0) {
    idCols__ <- c("USUBJID")
    data__ <- data__[order(data__$USUBJID,data__$TIME),]
    catdata__ <- as.data.frame(data__[!duplicated(data__$USUBJID),c(idCols__,catNames__)])
    catInfo0__ <- handle_duplicatedLevels(catInfo0__)
    for (covk__ in catNames__) {
      catdata__[[covk__]] <- as.character(factor(
        catdata__[[covk__]],
        levels = aux_explode(catInfo0__$VALUES[catInfo0__$COLNAME == covk__]),
        labels = aux_explode(catInfo0__$VALUETXT[catInfo0__$COLNAME == covk__])
      ))
    }
    catdata.long__ <- tidyr::gather(catdata__,COLNAME,VALUE,-USUBJID)
    catdata.long__ <- merge(catdata.long__, catInfo0__[,c("COLNAME","NAME","UNIT")], all.x=TRUE, all.y = FALSE)
    catdata.long__$COVlabel <- with(catdata.long__, paste0(COLNAME, "\n", NAME, " (",UNIT, ")"))
    data_out[["cat"]] <- catdata.long__
    grCat__ <- IQRggplot(data=catdata.long__) +
      geom_bar(aes_string(x="VALUE"), stat = "count",
               orientation = "x", width = 0.8) +
      facet_wrap(~COVlabel,scales="free") +
      ylab("") + xlab("") +
      ggtitle(label="Level counts of categorical covariates") +
      coord_flip()
  } else {
    grCat__ <- NULL
  }
  if (!is.null(filename)) {
    plotList <- list(grCont__,grCat__)
    IQRoutputPDF(plotList,filename=filename)
  } else {
    if (!is.null("grCont__")) print(grCont__)
    if (!is.null("grCat__")) print(grCat__)
  }
  if (FLAGreturnObject) {
    out <- list(continuous = grCont__, categorical = grCat__)
    attr(out, "data") <- data_out
    return(out)
  }
}
#'@export
plotCorCov_IQRdataGENERAL <- function(data,
                                      covNames = NULL,
                                      scale = "linear",
                                      filename = NULL,
                                      CORR_THRESHOLD=0.3,
                                      fontSize = NULL,
                                      FLAGreturnObject=FALSE)
{
  data__ <- data
  contInfo0__ <- attr(data__,"covInfo")
  if (!is_IQRdataGENERAL(data__))
    stopIQR("Input argument is not an IQRdataGENERAL object.")
  if (!class(covNames) %in% c("NULL","character"))
    stopIQR("Invalid input argument for 'covNames'. Must be either NULL or character vector of covariate names.")
  if (!(is.null(filename) | (is.character(filename)) & length(filename) == 1))
    stopIQR("Filename for PDF needs to be character string (no vector).")
  if (is.null(covNames)) {
    covNames__ <- contInfo0__$COLNAME
  } else {
    covNames__ <- covNames
    missingCovNames__ <- setdiff(covNames, contInfo0__$COLNAME)
    if (length(missingCovNames__) != 0){
      warningIQR('Following covariate(s) are no continuous covariates in the dataset: ',paste0(missingCovNames__, collapse = ", "))
      covNames__ <- intersect(covNames__,contInfo0__$COLNAME)
    }
  }
  if (length(covNames__) < 2) {
    warningIQR("Less than 2 covariates available or selected for plotting.");
    return(NULL)
  }
  obsSCALES__ <- handle_obsScalesIQR(scale, covNames__, default = "linear")
  logCOV__    <- obsSCALES__[obsSCALES__$scale == "log", "NAME"]
  for (k in seq_along(logCOV__)) {
    if (any(data__[[logCOV__[k]]]<=0, na.rm = TRUE)){
      warningIQR("Trying to transform covariate that contains negative values. Left on linear scale.")
    } else {
      data__[[logCOV__[k]]] <- log(data__[[logCOV__[k]]])
      contInfo0__$UNIT[contInfo0__$COLNAME == logCOV__[k]] <- paste0("log(",contInfo0__$UNIT[contInfo0__$COLNAME == logCOV__[k]],")")
    }
  }
  idCols__ <- c("USUBJID")
  data__ <- data__[order(data__$USUBJID,data__$TIME),]
  covdata__ <- as.data.frame(data__[!duplicated(data__$USUBJID),c(idCols__,covNames__)])
  y__ <- tidyr::gather(covdata__,CNAME,CVALUE,-USUBJID)
  yy__ <- dplyr::full_join(y__,y__,by="USUBJID")
  yy__ <- within(yy__, {
    CNo.x <- as.numeric(factor(CNAME.x))
    CNo.y <- as.numeric(factor(CNAME.y))
    upper <- CNo.x > CNo.y
    lower <- CNo.x < CNo.y
    diag  <- CNo.x == CNo.y
  })
  cc__ <- plyr::ddply(yy__[yy__$diag|yy__$lower,], ~CNAME.x+CNAME.y, function(xxx) {
    out <- with(xxx, {
      res <- stats::cor.test(CVALUE.x,CVALUE.y,method="pearson")
      pos.x <- mean(range(CVALUE.x, na.rm=TRUE))
      pos.y <- mean(range(CVALUE.y, na.rm=TRUE))
      data.frame(corr=res$estimate, p.value=res$p.value, pos.x=pos.x, pos.y=pos.y)
    })
    return(out)
  })
  cc__$diag <- cc__$CNAME.x == cc__$CNAME.y
  cc__ <- dplyr::left_join(cc__, contInfo0__, by = c("CNAME.x"="COLNAME"))
  cc__ <- dplyr::left_join(cc__, contInfo0__, by = c("CNAME.y"="COLNAME"), suffix = c(".x",".y"))
  cc__$CORR_THRESHOLD <- CORR_THRESHOLD
  if (is.null(fontSize)) {
    if (length(covNames__) <=3) {
      fontSize__ <- 4
    } else {
      if (length(covNames__) <= 5) {
        fontSize__ <- 3
      } else {
        fontSize__ <- 2
      }
    }
  } else {
    fontSize__ <- fontSize
  }
  yy__ <- yy__[!is.na(yy__$CVALUE.x) & !is.na(yy__$CVALUE.y),]
  data_out <- yy__[yy__$upper,]
  gr__ <- IQRggplot(data=yy__[yy__$upper,], aes_string("CVALUE.x","CVALUE.y")) +
    geom_point(alpha=0.3) +
    geom_smooth(method = "lm", color = "forestgreen") +
    geom_label(data=cc__[!cc__$diag,],
               aes_string("pos.x", "pos.y",
                          label = "round(corr,2)",
                          color = 'factor(as.character(p.value < 0.05), levels = c("FALSE", "TRUE"))',
                          fill = 'factor(as.character(abs(corr) > CORR_THRESHOLD), levels = c("FALSE", "TRUE"))'),
               size=fontSize__+1) +
    scale_color_manual("p-value<0.05",values = c("FALSE" = 'grey', "TRUE" = 'firebrick'), drop = FALSE) +
    scale_fill_manual(paste0("|corr|>",CORR_THRESHOLD),values = c("FALSE" = "white", "TRUE" = "#ffaaaa"), drop = FALSE) +
    facet_grid(CNAME.y~CNAME.x, scales = "free") +
    theme(strip.text = element_blank(), axis.title = element_blank()) +
    ggtitle("Correlation of continuous covariates",subtitle="Numeric values correspond to Pearson's product moment correlation coefficient") +
    theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5)) +
    theme(legend.position="bottom")
  if (length(covNames__) <= 9) {
    gr__ <- gr__ + geom_label(data=cc__[cc__$diag,],
                              aes_string("pos.x","pos.y",label= 'paste0(CNAME.x,"\n",aux_strrep(NAME.x," ","\n"), "\n(",UNIT.x,")")'),
                              size = fontSize__, vjust = 0.5, hjust=0.5, label.size = NA)
  } else {
    gr__ <- gr__ + geom_label(data=cc__[cc__$diag,], aes_string("pos.x","pos.y", label= "CNAME.x"), size = fontSize__+0.5, vjust = 0.5)
  }
  if (!is.null(filename)) {
    IQRoutputPDF(gr__,filename=filename,scale = 1.2)
  } else {
    print(gr__)
  }
  if (FLAGreturnObject) {
    attr(gr__, "data") <- data_out
    return(gr__)
  }
}
#'@export
plotCorCat_IQRdataGENERAL <- function(data, catNames = NULL, filename = NULL, fontSize=NULL, FLAGreturnObject=FALSE)
{
  data__ <- data
  catInfo0__ <- attr(data__,"catInfo")
  if (is.null(catInfo0__)) return()
  if (all(c("TRT", "TRTNAME") %in% names(data__)) & !("TRT" %in% catInfo0__$COLNAME)) {
    trtInfo__ <- unique(data__[, c("TRT", "TRTNAME")])
    trtInfo__ <- trtInfo__[order(trtInfo__$TRT),]
    trtInfo__ <- trtInfo__[!is.na(trtInfo__$TRT),]
    addcatinfo__ <- data.frame(COLNAME = "TRT", NAME = "Treatment group", UNIT = "-",
                               VALUETXT = paste0(trtInfo__$TRTNAME, collapse = ","),
                               VALUES  = paste0(trtInfo__$TRT, collapse = ","),
                               TIME.VARYING = FALSE)
    catInfo0__ <- rbind(catInfo0__, addcatinfo__)
  }
  if (all(c("STUDYN", "STUDY") %in% names(data__)) & !("STUDYN" %in% catInfo0__$COLNAME)) {
    stdInfo__ <- unique(data__[, c("STUDYN", "STUDY")])
    stdInfo__ <- stdInfo__[order(stdInfo__$STUDYN),]
    stdInfo__ <- stdInfo__[!is.na(stdInfo__$STUDYN),]
    addcatinfo__ <- data.frame(COLNAME = "STUDYN", NAME = "Study", UNIT = "-",
                               VALUETXT = paste0(stdInfo__$STUDY, collapse = ","),
                               VALUES   = paste0(stdInfo__$STUDYN, collapse = ","),
                               TIME.VARYING = FALSE)
    catInfo0__ <- rbind(catInfo0__, addcatinfo__)
  }
  if (!is_IQRdataGENERAL(data__))
    stopIQR("Input argument is not an IQRdataGENERAL object.")
  if (!class(catNames) %in% c("NULL","character"))
    stopIQR("Invalid input argument for 'catNames'. Must be either NULL or character vector of covariate names.")
  if (!(is.null(filename) | (is.character(filename)) & length(filename) == 1))
    stopIQR("Filename for PDF needs to be character string (no vector).")
  if (is.null(catNames)) {
    catNames__ <- catInfo0__$COLNAME
  } else {
    catNames__ <- catNames
    missingcatNames__ <- setdiff(catNames, catInfo0__$COLNAME)
    if (length(missingcatNames__) != 0){
      warningIQR('Following covariate(s) are no categorical covariates in the dataset: ',paste0(missingcatNames__, collapse = ", "))
      catNames__ = intersect(catNames__,catInfo0__$COLNAME)
    }
  }
  if (length(catNames__) < 2) {
    warningIQR("Less than 2 covariates available or selected for plotting.");
    return(NULL)
  }
  data__ <- data__[order(data__$USUBJID,data__$TIME),]
  covdata__ <- as.data.frame(data__[!duplicated(data__$USUBJID),c("USUBJID",catNames__)])
  catInfo0__ <- handle_duplicatedLevels(catInfo0__)
  for (covk__ in catNames__) {
    x__ <- as.character(factor(
      covdata__[[covk__]],
      levels = aux_explode(catInfo0__$VALUES[catInfo0__$COLNAME == covk__]),
      labels = paste0(aux_explode(catInfo0__$VALUETXT[catInfo0__$COLNAME == covk__]))
    ))
    x__[!is.na(x__)] <- paste0(covk__,": ",x__[!is.na(x__)])
    covdata__[[covk__]] <- x__
  }
  y__ <- tidyr::gather(covdata__,CNAME,CVALUE,-USUBJID)
  y__ <- y__[!is.na(y__$CVALUE),]
  yy__ <- dplyr::full_join(y__,y__,by="USUBJID")
  alllev__ <- unique(yy__[,c("CNAME.x","CVALUE.x")])
  yy__$CNo.x <- as.numeric(factor(yy__$CNAME.x))
  yy__$CNo.y <- as.numeric(factor(yy__$CNAME.y))
  yy__$upper <- yy__$CNo.x > yy__$CNo.y
  yy__$lower <- yy__$CNo.x < yy__$CNo.y
  yy__$diag  <- yy__$CNo.x == yy__$CNo.y
  yy__$LNo.x <- as.numeric(factor(yy__$CVALUE.x, levels = alllev__$CVALUE.x))
  yy__$LNo.y <- as.numeric(factor(yy__$CVALUE.y, levels = alllev__$CVALUE.x))
  cc__ <- plyr::ddply(yy__[yy__$diag|yy__$lower,], ~CNAME.x+CNAME.y, function(xxx) {
    out <- with(xxx, {
      tbl <- table(CVALUE.x,CVALUE.y)
      if (nrow(tbl) >= 2) {
        res <- suppressWarnings(stats::chisq.test(tbl))
      } else {
        res <- list(p.value = 1)
      }
      pos.x <- mean(range(LNo.x, na.rm=TRUE))
      pos.y <- mean(range(LNo.y, na.rm=TRUE))
      data.frame(p.value=res$p.value, pos.x=pos.x, pos.y=pos.y)
    })
    return(out)
  })
  cc__$diag <- cc__$CNAME.x == cc__$CNAME.y
  cc__$upper <- cc__$CNAME.x > cc__$CNAME.y
  cc__$lower <- cc__$CNAME.x < cc__$CNAME.y
  cc__ <- dplyr::left_join(cc__, catInfo0__, by = c("CNAME.x"="COLNAME"))
  cc__ <- dplyr::left_join(cc__, catInfo0__, by = c("CNAME.y"="COLNAME"), suffix = c(".x",".y"))
  ixPsmall__ <- cc__$p.value<0.05
  cc__$p.value[!ixPsmall__] <- paste0("p=",round(cc__$p.value[!ixPsmall__],2))
  cc__$p.value[ixPsmall__] <- "p<0.05"
  cc__$p.value.small <- ixPsmall__
  FirLa__ <- levels(factor(yy__$CNAME.x))
  FirLa__ <- FirLa__[c(1,length(FirLa__))]
  cc__[cc__$CNAME.x == FirLa__[1] ,"pos.x"] <- -1
  cc__[cc__$CNAME.y == FirLa__[2],"pos.y"] <- -1
  yyy__ <- plyr::ddply(
    yy__[yy__$upper,],
    ~CNAME.x+CVALUE.x+CNAME.y+CVALUE.y+diag+lower+upper+CNo.y+CNo.x+LNo.y+LNo.x,
    function(x) c(N = nrow(x))
  )
  pVal__ <- unique(cc__[,c("CNAME.x","CNAME.y", "p.value.small")])
  names(pVal__) <- c("CNAME.y","CNAME.x", "p.value.small")
  yyy__ <- merge(yyy__, pVal__)
  if (is.null(fontSize)) {
    if (length(catNames__) <=3) {
      fontSize__ <- 4
    } else {
      if (length(catNames__) <= 5) {
        fontSize__ <- 3
      } else {
        fontSize__ <- 2
      }
    }
  } else {
    fontSize__ <- fontSize
  }
  adjax__ <- plyr::ddply(yyy__, ~CNAME.y+CNAME.x, function(x) {
    data.frame(
      LNo.x = c(min(x$LNo.x)-0.5, max(x$LNo.x)+0.5),
      LNo.y = c(min(x$LNo.y)-0.5, max(x$LNo.y)+0.5)
    )
  })
  adjax__ <- adjax__[adjax__$CNAME.x != FirLa__[1] | adjax__$CNAME.y != FirLa__[2],]
  data_out <- yyy__
  gr__ <- IQRggplot(data=yyy__, aes_string("LNo.x","LNo.y")) +
    geom_point(data=yyy__[yyy__$upper,],aes_string(size="N"),alpha=0.3) +
    geom_text(data=yyy__, aes_string(label = "N"), color = "darkred", hjust=0.5, size=fontSize__) +
    geom_text(data=yyy__, aes_string(label = "N"), hjust=0.5, size=fontSize__) +
    geom_label(data=cc__[cc__$lower,], aes_string("pos.x", "pos.y", label="p.value", color = "p.value.small"), size = fontSize__, vjust = 0.5) +
    geom_point(data=adjax__, color = "transparent" ) +
    scale_color_manual(values = c('grey', 'darkred')) +
    scale_size_area(max_size=6) +
    scale_x_continuous(breaks = seq_along(alllev__$CVALUE.x), labels = alllev__$CVALUE.x) +
    scale_y_continuous(breaks = seq_along(alllev__$CVALUE.x), labels = alllev__$CVALUE.x) +
    facet_grid(CNAME.y~CNAME.x, scales = "free") +
    theme(strip.text = element_blank(), axis.title = element_blank(),
          axis.text.x = element_text(angle = 90,hjust=1,vjust=0.5, size=fontSize__+4),
          axis.text.y = element_text(size=fontSize__+4)) +
    theme(legend.position="none") +
    ggtitle("Correlation of categorical covariates",
            subtitle="Numeric values correspond to Pearson's Chi-squared Test for Count Data\nNon-available data (NA) is ignored")
  if (length(catNames__) <= 9) {
    gr__ <- gr__ + geom_label(data=cc__[cc__$diag,],
                              aes_string("pos.x","pos.y", label= 'paste0(CNAME.x,"\n",aux_strrep(NAME.x," ","\n"), ifelse((is.na(UNIT.x)),paste0(" (",UNIT.x,")"),""))'),
                              size = fontSize__, vjust = 0.5, hjust=0.5, label.size = NA)
  } else {
    gr__ <- gr__ + geom_label(data=cc__[cc__$diag,], aes_string("pos.x","pos.y", label= "CNAME.x"), size = fontSize__, vjust = 0.5)
  }
  if (!is.null(filename)) {
    IQRoutputPDF(gr__,filename=filename,scale = 1.2)
  } else {
    print(gr__)
  }
  if (FLAGreturnObject) {
    attr(gr__, "data") <- data_out
    return(gr__)
  }
}
#'@export
plotCorCovCat_IQRdataGENERAL <- function(data,
                                         covNames = NULL,
                                         catNames = NULL,
                                         scale = "linear",
                                         filename = NULL,
                                         fontSize = NULL,
                                         FLAGreturnObject = FALSE) {
  data__ <- data
  contInfo0__ <- attr(data__,"covInfo")
  catInfo0__ <- attr(data__,"catInfo")
  if (is.null(contInfo0__)) return()
  if (is.null(catInfo0__)) return()
  if (all(c("TRT", "TRTNAME") %in% names(data__)) & !("TRT" %in% catInfo0__$COLNAME)) {
    trtInfo__ <- unique(data__[, c("TRT", "TRTNAME")])
    trtInfo__ <- trtInfo__[order(trtInfo__$TRT),]
    trtInfo__ <- trtInfo__[!is.na(trtInfo__$TRT),]
    addcatinfo__ <- data.frame(COLNAME = "TRT", NAME = "Treatment group", UNIT = "-",
                               VALUETXT = paste0(trtInfo__$TRTNAME, collapse = ","),
                               VALUES  = paste0(trtInfo__$TRT, collapse = ","),
                               TIME.VARYING = FALSE)
    catInfo0__ <- rbind(catInfo0__, addcatinfo__)
  }
  if (all(c("STUDYN", "STUDY") %in% names(data__)) & !("STUDYN" %in% catInfo0__$COLNAME)) {
    stdInfo__ <- unique(data__[, c("STUDYN", "STUDY")])
    stdInfo__ <- stdInfo__[order(stdInfo__$STUDYN),]
    stdInfo__ <- stdInfo__[!is.na(stdInfo__$STUDYN),]
    addcatinfo__ <- data.frame(COLNAME = "STUDYN", NAME = "Study", UNIT = "-",
                               VALUETXT = paste0(stdInfo__$STUDY, collapse = ","),
                               VALUES   = paste0(stdInfo__$STUDYN, collapse = ","),
                               TIME.VARYING = FALSE)
    catInfo0__ <- rbind(catInfo0__, addcatinfo__)
  }
  if (!is_IQRdataGENERAL(data__))
    stopIQR("Input argument is not an IQRdataGENERAL object.")
  if (!class(covNames) %in% c("NULL","character"))
    stopIQR("Invalid input argument for 'covNames'. Must be either NULL or character vector of covariate names.")
  if (!class(catNames) %in% c("NULL","character"))
    stopIQR("Invalid input argument for 'catNames'. Must be either NULL or character vector of covariate names.")
  if (!(is.null(filename) | (is.character(filename)) & length(filename) == 1))
    stopIQR("Filename for PDF needs to be character string (no vector).")
  if (is.null(covNames)) {
    covNames__ <- contInfo0__$COLNAME
  } else {
    covNames__ <- covNames
    missingcovNames__ <- setdiff(covNames, contInfo0__$COLNAME)
    if (length(missingcovNames__) != 0){
      warningIQR('Following covariate(s) are no continuous covariates in the dataset: ',paste0(missingcovNames__, collapse = ", "))
      covNames__ = intersect(covNames__,contInfo0__$COLNAME)
    }
  }
  if (length(covNames__) < 1) {
    stopIQR("No continuous covariates available or selected for plotting.");
  }
  if (is.null(catNames)) {
    catNames__ <- catInfo0__$COLNAME
  } else {
    catNames__ <- catNames
    missingCatNames__ <- setdiff(catNames, catInfo0__$COLNAME)
    if (length(missingCatNames__) != 0){
      warningIQR('Following covariate(s) are no categorical covariates in the dataset: ',paste0(missingCatNames__, collapse = ", "))
      catNames__ = intersect(catNames__,catInfo0__$COLNAME)
    }
  }
  if (length(catNames__) < 1) {
    stopIQR("No categorical covariates available or selected for plotting.");
  }
  obsSCALES__ <- handle_obsScalesIQR(scale, covNames__, default = "linear")
  logCOV__    <- obsSCALES__[obsSCALES__$scale == "log","NAME"]
  for (k in seq_along(logCOV__)) {
    if (any(data__[[logCOV__[k]]]<=0, na.rm = TRUE)){
      warningIQR("Trying to transform covariate that contains negative values. Left on linear scale.")
    } else {
      data__[[logCOV__[k]]] <- log(data__[[logCOV__[k]]])
      contInfo0__$UNIT[contInfo0__$COLNAME == logCOV__[k]] <- paste0("log(",contInfo0__$UNIT[contInfo0__$COLNAME == logCOV__[k]],")")
    }
  }
  if (is.null(fontSize)) {
    if (length(catNames__) <=3) {
      fontSize__ <- 4
    } else {
      if (length(catNames__) <= 5) {
        fontSize__ <- 3
      } else {
        fontSize__ <- 2
      }
    }
  } else {
    fontSize__ <- fontSize
  }
  idCols__ <- c("USUBJID")
  data__ <- data__[order(data__$USUBJID,data__$TIME),]
  contdata__ <- as.data.frame(data__[!duplicated(data__$USUBJID),c(idCols__,covNames__)])
  catdata__ <- as.data.frame(data__[!duplicated(data__$USUBJID),c(idCols__,catNames__)])
  catInfo0__ <- handle_duplicatedLevels(catInfo0__)
  for (covk__ in catNames__) {
    catdata__[[covk__]] <- as.character(factor(
      catdata__[[covk__]],
      levels = aux_explode(catInfo0__$VALUES[catInfo0__$COLNAME == covk__]),
      labels = aux_explode(catInfo0__$VALUETXT[catInfo0__$COLNAME == covk__])
    ))
  }
  y1__ <- tidyr::gather(contdata__,CNAME,CVALUE,-USUBJID)
  y1__ <- y1__[!is.na(y1__$CVALUE),]
  y1__ <- dplyr::left_join(y1__,contInfo0__[,c("COLNAME","NAME","UNIT")], by=c("CNAME"="COLNAME"))
  y1__$CNAME <- with(y1__, paste0(CNAME, "\n", NAME, " (", UNIT,")"))
  y1__$NAME <- y1__$UNIT <- NULL
  y2__ <- tidyr::gather(catdata__,CNAME,CVALUE,-USUBJID)
  y2__ <- dplyr::left_join(y2__,catInfo0__[,c("COLNAME","NAME","UNIT")], by=c("CNAME"="COLNAME"))
  y2__$NAME <- y2__$UNIT <- NULL
  catN__ <- plyr::ddply(y2__, ~CNAME+CVALUE, function(xxx) c(N=length(xxx$CVALUE)))
  catN__$N <- paste0("(N = ",(catN__$N),")")
  y2__ <- dplyr::left_join(y2__, catN__,by = c("CNAME", "CVALUE"))
  y2__$CVALUE <- with(y2__, paste(CVALUE, N))
  y2__$N <- NULL
  yy__ <- dplyr::full_join(y1__,y2__,by="USUBJID")
  yy__$CNAME.x <- gsub(" ","\n",yy__$CNAME.x)
  data_out <- yy__
  gr__ <- IQRggplot(yy__, aes_string("CVALUE.y","CVALUE.x")) +
    geom_boxplot(size=0.5) +
    facet_grid(CNAME.y~CNAME.x, scales = "free") +
    coord_flip() +
    theme(strip.text.y=element_text(angle = 0,size=fontSize__+4),
          strip.text.x=element_text(angle = 0,size=fontSize__+4),
          axis.title = element_blank(),
          axis.text.x = element_text(angle = 90,hjust=1, size=fontSize__+4),
          axis.text.y = element_text(size=fontSize__+4)) +
    ggtitle("Correlation of continuous and categorical covariates")
  if (!is.null(filename)) {
    IQRoutputPDF(gr__,filename=filename,scale = 1.2)
  } else {
    print(gr__)
  }
  if (FLAGreturnObject) {
    attr(gr__, "data") <- data_out
    return(gr__)
  }
}
#'@export
plotDoseSchedule_IQRdataGENERAL <- function(data,
                                            doseNames = NULL,
                                            filename  = NULL,
                                            NperPage  = 10,
                                            FLAGreturnObject = FALSE) {
  data__ <- data
  if (!is_IQRdataGENERAL(data__))
    stopIQR("Input argument is not an IQRdataGENERAL object.")
  if (!(is.null(filename) | (is.character(filename)) & length(filename) == 1))
    stopIQR("Filename for PDF needs to be character string (no vector).")
  if (is.null(doseNames)) {
    doseNAMES__ <- attr(data__, "doseNAMES")
  } else {
    missingdos__ <- setdiff(doseNames, attr(data__, "doseNAMES"))
    if (length(missingdos__) != 0){
      warningIQR('Following dosing(s) are not contained in the dataset: ',paste0(missingdos__, collapse = ", "))
    }
    doseNAMES__ = intersect(doseNames,attr(data__, "doseNAMES"))
    if (length(doseNAMES__) == 0){
      stopIQR('No existing observations chosen for plotting.')
    }
  }
  data_out <- list()
  env.data_out <- environment()
  dos__ <- data__[data__$NAME %in% doseNAMES__,]
  dos__$ADDL <- ifelse(is.na(dos__$ADDL), 0, dos__$ADDL)
  dos__$II <- ifelse(is.na(dos__$II), 0, dos__$II)
  subj__   <- unique(dos__$USUBJID)
  nSubj__  <- length(subj__)
  pageNo__ <- ceiling(1:nSubj__ / NperPage)
  pages__  <- data.frame(USUBJID = subj__, Page = pageNo__)
  dos__    <- plyr::join(dos__, pages__, by = "USUBJID")
  gr__ <- plyr::dlply(dos__, ~Page, function(xx__) {
    env.data_out$data_out[[xx__$Page[1]]] <- xx__
    IQRggplot(xx__, aes_string(x="TIME", xend="TIME+(ADDL+1)*II+1", y = "USUBJID", yend = "USUBJID")) +
      geom_segment(data=dplyr::filter(xx__, ADDL > 0), aes_string(color = "NAME"), alpha = 0.7)+
      geom_point(data=dplyr::filter(xx__, ADDL == 0), aes_string(color = "NAME"), alpha = 1, shape = "|")+
      scale_color_manual(values = IQRtoolsColors[2:10]) +
      labs(
        x=paste0("Time ", xx__$TIMEUNIT[1]),
        y = "",
        title = paste0("Dosing schedule (page",xx__$Page[1]," of ",max(pageNo__)," )"),
        caption = "Missing ADDL and II set to 0"
      ) +
      theme(legend.position = "bottom")
  })
  if (!is.null(filename)) {
    IQRoutputPDF(gr__,filename=filename)
  } else {
    plyr::l_ply(gr__, print)
  }
  if (FLAGreturnObject) {
    attr(gr__, "data") <- data_out
    return(gr__)
  }
}
#'@export
plotSampleSchedule_IQRdataGENERAL <- function(data,
                                              obsNames = NULL,
                                              filename  = NULL,
                                              NperPage  = 10,
                                              FLAGreturnObject = FALSE) {
  data__ <- data
  if (!is_IQRdataGENERAL(data__))
    stopIQR("Input argument is not an IQRdataGENERAL object.")
  if (!(is.null(filename) | (is.character(filename)) & length(filename) == 1))
    stopIQR("Filename for PDF needs to be character string (no vector).")
  if (!"TRTNAME" %in% names(data__)) {
    data__$TRTNAME <- ""
    data__$TRT <- 0
  }
  doseNAMES__ <- attr(data__, "doseNAMES")
  if (is.null(obsNames)) {
    obsNAMES__ <- attr(data__, "obsNAMES")
  } else {
    missingobs__ <- setdiff(obsNames, attr(data__, "obsNAMES"))
    if (length(missingobs__) != 0){
      warningIQR('Following observation(s) are not contained in the dataset: ',paste0(missingobs__, collapse = ", "))
    }
    obsNAMES__ = intersect(obsNames,attr(data__, "obsNAMES"))
    if (length(obsNAMES__) == 0){
      stopIQR('No existing observations chosen for plotting.')
    }
  }
  data__ <- data__[data__$NAME %in% c(doseNAMES__, obsNAMES__),]
  data_out <- list()
  env.data_out <- environment()
  data__$TRTNAME <- ifelse(is.na(data__$TRTNAME), "UNKNOWN", data__$TRTNAME)
  subj__   <- unique(as.data.frame(data__)[,c("TRTNAME","USUBJID")])
  if (any(duplicated(subj__$USUBJID)))  {
    warningIQR("Different treatments annotated for subject(s).\n  Please check!!! Only first annotated in plots.")
    subj__ <- subj__[!duplicated(subj__$USUBJID),]
  }
  subj__ <- subj__[order(subj__$TRTNAME),]
  nSubj__  <- dim(subj__)[1]
  pageNo__ <- ceiling(1:nSubj__ / NperPage)
  subj__$Page <- pageNo__
  data__    <- plyr::join(data__, subj__, by = c("TRTNAME","USUBJID"))
  data__$USUBJID <- factor(data__$USUBJID, levels = subj__$USUBJID)
  gr__ <- plyr::dlply(data__, ~Page, function(xx__) {
    obs__ <- xx__[xx__$NAME %in% obsNAMES__,]
    dos__ <- xx__[xx__$NAME %in% doseNAMES__,]
    dos__$ADDL <- ifelse(is.na(dos__$ADDL), 0, dos__$ADDL)
    dos__$II  <- ifelse(is.na(dos__$II), 0, dos__$II)
    if (dim(obs__)[1] > 0) {
      gr__ <- IQRggplot(obs__, aes_string(y="TIME", x = 1)) +
        geom_point(aes_string(color = "NAME"), position = position_dodge(width=0.8), shape = 124)
      if (dim(dos__)[1] > 0) {
        gr__ <- gr__ +
          geom_segment(data = dos__, aes_string(y="TIME", yend="TIME+(ADDL+1)*II+1", x = 0, xend = 0,color = "NAME"), show.legend = FALSE, size = 2)
      }
    } else {
      gr__ <- IQRggplot(data = dos__, aes_string(y="TIME", x = 0)) +
        geom_segment(aes_string(yend="TIME+(ADDL+1)*II+1", xend = 0,color = "NAME"), size = 2)
    }
    gr__ <- gr__ +
      geom_text(data=unique(rbind(obs__[,c("USUBJID", "TRTNAME")], dos__[,c("USUBJID", "TRTNAME")])),
                aes_string(y=0, x= 1.5, label = "TRTNAME"),
                size = 2.5, hjust=0, vjust=0) +
      scale_color_manual("Observation/Dose",values = IQRtoolsColors[2:20]) +
      scale_x_continuous(breaks = c(0,1), labels = c("Dosing","Observation")) +
      labs(
        y=paste0("Time (", xx__$TIMEUNIT[1],")"),
        x = "",
        title = paste0("Sampling schedule (page ",xx__$Page[1]," of ",max(pageNo__)," )"),
        caption = "Missing ADDL and II set to 0"
      ) +
      facet_grid(USUBJID~.) + coord_flip(xlim = c(-0.5, 2)) +
      theme(legend.position = "bottom", legend.direction = "vertical",
            strip.text.y = element_text(angle=0),
            axis.text.y = element_text(angle = 0))
  })
  if (!is.null(filename)) {
    suppressWarnings(IQRoutputPDF(gr__,filename=filename,scale = 1.2))
  } else {
    plyr::l_ply(gr__, print)
  }
  if (FLAGreturnObject) {
    attr(gr__, "data") <- data_out
    return(gr__)
  }
}
#'@export
summaryObservations_IQRdataGENERAL <- function(data,
                                               obsNames = NULL,
                                               stratifyColumn = "STUDY",
                                               SIGNIF = 3,
                                               tableTitle = NULL,
                                               footerAddText = NULL,
                                               filename = NULL,
                                               FLAGpk = TRUE,
                                               FLAGpatients = FALSE,
                                               FLAGsimple = FALSE) {
  if(!is_IQRdataGENERAL(data)) {
    stopIQR("Input argument 'data' is not an IQRdataGENERAL object")
  }
  if (!"STUDY" %in% names(data)) {
    data$STUDY <- "Undefined Study"
    data$STUDYN <- 0
  }
  obsNamesData__ <- attributes(data)$obsNAMES
  if (is.null(obsNames)) {
    obsNames <- obsNamesData__
  }
  if (!all(obsNames %in% obsNamesData__)) {
    stopIQR(paste0("The following obsNames are not available in the provided data:\n  ",paste0(obsNames[!(obsNames %in% obsNamesData__)],collapse=", ")))
  }
  if (is.null(tableTitle)) {
    tableTitle <- "Summary of available observations"
  }
  data__ <- data[!is.na(data[[stratifyColumn]]),]
  data__ <- data__[data__$NAME %in% obsNames | data__$NAME %in% attributes(data__)$doseNAMES,]
  dataSplit__ <- split(data__,data__[[stratifyColumn]])
  dataSplit__[["TOTAL"]] <- data__
  table__ <- do.call(rbind,lapply(seq_along(dataSplit__), function (k__) {
    datak__ <- dataSplit__[[k__]]
    TIMEfirstDose__ <- datak__$TIME[datak__$EVID==1][1]
    datak__ <- datak__[datak__$NAME %in% obsNames,]
    Name__ <- names(dataSplit__)[k__]
    Nindiv__ <- length(unique(datak__$USUBJID))
    Nsamples__ <- nrow(datak__)
    NsamplesBLOQ__ <- nrow(datak__[(datak__$DV<datak__$LLOQ | datak__$CENS==1) & !is.na(datak__$DV) & !is.na(datak__$LLOQ) & !is.na(datak__$TIME),])
    NsamplesBLOQpostFirstDose__ <- nrow(datak__[(datak__$DV<datak__$LLOQ | datak__$CENS==1) & !is.na(datak__$DV) & !is.na(datak__$LLOQ) & !is.na(datak__$TIME) & datak__$TIME > TIMEfirstDose__,])
    NmissingDV__ <- nrow(datak__[is.na(datak__$DV),])
    NmissingTIME__ <- nrow(datak__[is.na(datak__$TIME),])
    NNONZEROPFD__ <- nrow(datak__[datak__$VALUE>0 & !is.na(datak__$DV) & !is.na(datak__$TIME) & datak__$TIME < TIMEfirstDose__,])
    NMDV1outliers__ <- nrow(datak__[datak__$MDV==1 & datak__$EVID==0,])
    NsamplesMDV0__ <- nrow(datak__[datak__$MDV==0,])
    data.frame(
      DATA = Name__,
      SUBJECT_N = Nindiv__,
      NSAMPLES = Nsamples__,
      NSAMPLESBLOQ = paste0(NsamplesBLOQ__, " (", signif(100*NsamplesBLOQ__/Nsamples__,SIGNIF), "%)"),
      NSAMPLESBLOQPFD = paste0(NsamplesBLOQpostFirstDose__, " (", signif(100*NsamplesBLOQpostFirstDose__/Nsamples__,SIGNIF), "%)"),
      NSAMPLESMISSINGDV = paste0(NmissingDV__, " (", signif(100*NmissingDV__/Nsamples__,SIGNIF), "%)"),
      NSAMPLESMISSINGTIME = paste0(NmissingTIME__, " (", signif(100*NmissingTIME__/Nsamples__,SIGNIF), "%)"),
      NSAMPLESNONZEROPFD = paste0(NNONZEROPFD__, " (", signif(100*NNONZEROPFD__/Nsamples__,SIGNIF), "%)"),
      NSAMPLESOUTLIERS = paste0(NMDV1outliers__, " (", signif(100*NMDV1outliers__/Nsamples__,SIGNIF), "%)"),
      NSAMPLESANALYSIS = paste0(NsamplesMDV0__, " (", signif(100*NsamplesMDV0__/Nsamples__,SIGNIF), "%)"),
      stringsAsFactors=FALSE
    )
  }))
  if (FLAGpatients) {
    pattext__ <- "patients"
  } else {
    pattext__ <- "subjects"
  }
  names(table__) <- c(
    "Data",
    paste0("N ",pattext__),
    "N samples",
    "N BLOQ samples*",
    "N BLOQ samples post first dose*",
    "N missing observations",
    "N missing time information",
    "N non-zero pre-first dose samples",
    "N total ignored observations",
    "N samples included in analysis"
  )
  table__[["N non-zero pre-first dose samples"]] <- NULL
  if (!FLAGpk) {
    table__[["N BLOQ samples post first dose*"]] <- NULL
  }
  catInfo__ <- attributes(data)$catInfo
  if (stratifyColumn %in% catInfo__$COLNAME) {
    numValues__  <- aux_explode(catInfo__$VALUES[catInfo__$COLNAME == stratifyColumn])
    textValues__ <- aux_explode(catInfo__$VALUETXT[catInfo__$COLNAME == stratifyColumn])
    table__$Data <- as.character(factor(table__$Data,
                                        levels = c(numValues__, "TOTAL"),
                                        labels = c(textValues__, "TOTAL")))
  }
  footer__ <- "N: Number of<br>"
  if (attributes(data)$methodBLLOQ=="M1") footer__ <- paste0(footer__,"* These records are excluded from the analysis (M1 method).<br>")
  if (attributes(data)$methodBLLOQ=="M3") footer__ <- paste0(footer__,"* These records are not excluded from the analysis but censored (M3 method).<br>")
  if (attributes(data)$methodBLLOQ=="M4") footer__ <- paste0(footer__,"* These records are not excluded from the analysis but censored (M4 method).<br>")
  if (attributes(data)$methodBLLOQ=="M5") footer__ <- paste0(footer__,"* These records are not excluded from the analysis but set to LLOQ/2 (M5 method).<br>")
  if (attributes(data)$methodBLLOQ=="M6") footer__ <- paste0(footer__,"* Only the first BLOQ value in a sequence is kept in the analysis with LLOQ/2 (M6 method).<br>")
  if (attributes(data)$methodBLLOQ=="M7") footer__ <- paste0(footer__,"* These records are not excluded from the analysis but set to 0 (M7 method).<br>")
  footer__ <- paste0(footer__,footerAddText)
  if (!is.null(filename)) {
    report__ <- TRUE
  } else {
    report__ <- FALSE
  }
  if (FLAGsimple) {
    footer__ <- NULL
    table__$`N BLOQ samples*` <- NULL
    table__$`N BLOQ samples post first dose*` <- NULL
    table__$`N missing observations` <- NULL
    table__$`N missing time information` <- NULL
    table__$`N non-zero pre-first dose samples` <- NULL
    table__$`N total ignored observations` <- NULL
    table__$`N samples` <- NULL
  }
  if (!is.null(filename)) {
    filename <- paste0(aux_strrep(filename,".txt",""),".txt")
    IQRoutputTable(xtable=table__,xfooter=footer__,xtitle=tableTitle,report=report__,filename=filename)
    return(invisible(NULL))
  }
  output__ <- IQRoutputTable(xtable=table__,xfooter=footer__,xtitle=tableTitle,report=report__)
  output__
}
#'@export
summaryCat_IQRdataGENERAL <- function(data,
                                      catNames = NULL,
                                      stratifyColumns = "STUDY",
                                      stratifyOrder = NULL,
                                      FLAGtotal = NULL,
                                      SIGNIF = 3,
                                      tableTitle = NULL,
                                      footerAddText = NULL,
                                      filename = NULL,
                                      FLAGpatients = FALSE) {
  if(!is_IQRdataGENERAL(data)){
    stopIQR("Input argument 'data' is not an IQRdataGENERAL object")
  }
  if (!"STUDY" %in% names(data)) {
    data$STUDY <- "Undefined Study"
    data$STUDYN <- 0
  }
  catNamesData__ <- attributes(data)$catInfo$COLNAME
  if (is.null(catNames)) {
    catNames <- catNamesData__
  }
  if (is.null(catNames)) {
    message("No categorical covariates defined or present")
    return(invisible(NULL))
  }
  if (!all(catNames %in% catNamesData__)) {
    stopIQR(paste0("The following catNames are not available in the provided data:\n  ",paste0(catNames[!(catNames %in% catNamesData__)],collapse=", ")))
  }
  if (is.null(FLAGtotal)) {
    FLAGtotal <- rep(FALSE,length(stratifyColumns))
  }
  if (length(FLAGtotal)==1) {
    FLAGtotal <- rep(FLAGtotal,length(stratifyColumns))
  }
  if (length(FLAGtotal) != length(stratifyColumns)) {
    stopIQR("Missmatch between length of stratifyColumns and FLAGtotal input arguments")
  }
  if (!is.list(stratifyOrder)) {
    stratifyOrder <- list(stratifyOrder)
  }
  for (k__ in seq_along(stratifyColumns)) {
    entries__ <- unique(data[[stratifyColumns[k__]]])
    order__ <- unlist(stratifyOrder[k__])
    if (!is.null(order)) {
      if (!all(order__ %in% entries__)) {
        stopIQR(paste0("Not all entries in stratifyColumns are present for stratification column ",stratifyColumns[k__]))
      }
    }
  }
  if (is.null(tableTitle)) {
    tableTitle <- "Summary of demographic and baseline characteristics for categorical information"
  }
  datafirst__ <- as.data.frame(data[!duplicated(data$USUBJID),])
  catInfo0__ <- attributes(data)$catInfo
  catInfo__ <- catInfo0__
  catInfo__ <- catInfo__[catInfo__$COLNAME %in% catNames,]
  FLAGmissingVal <- FALSE
  for (icat__ in catNames) {
    if (any(is.na(datafirst__[[icat__]]))) {
      tmp__ <- catInfo__[catInfo__$COLNAME == icat__,]
      tmpValImpute__ <- max(as.numeric(aux_explode(tmp__$VALUES)))+1
      tmp__$VALUES <- paste0(tmp__$VALUES, ",", tmpValImpute__)
      tmp__$VALUETXT <- paste0(tmp__$VALUETXT, ",n.a.**")
      catInfo__[catInfo__$COLNAME == icat__,] <- tmp__
      datafirst__[[icat__]][is.na(datafirst__[[icat__]])] <- as.character(tmpValImpute__)
      FLAGmissingVal <- TRUE
    }
  }
  baseTable__ <- do.call(rbind,lapply(1:nrow(catInfo__), function (kRowCatInfo__) {
    row__ <- catInfo__[kRowCatInfo__,]
    characteristic__ <- row__$NAME
    colname__ <- row__$COLNAME
    categories__ <- aux_explodePC(row__$VALUETXT)
    values__ <- aux_explodePC(row__$VALUES)
    subtable__ <- data.frame(
      Characteristic = characteristic__,
      Category = categories__,
      COLNAME = colname__,
      VALUE = values__,
      stringsAsFactors=FALSE
    )
  }))
  table__ <- baseTable__
  table__$COLNAME <- NULL
  table__$VALUE <- NULL
  FLAGmissingCat <- FALSE
  for (kstratcolumn__ in seq_along(stratifyColumns)) {
    stratifyColumn__ <- stratifyColumns[kstratcolumn__]
    FLAGtotal__ <- FLAGtotal[kstratcolumn__]
    stratifyOrder__ <- unlist(stratifyOrder[kstratcolumn__])
    datafirst__$stratifyColumn__ <- datafirst__[[stratifyColumn__]]
    if (stratifyColumn__ %in% catInfo0__$COLNAME) {
      tmpVal__ <- aux_explode(catInfo0__$VALUES[catInfo0__$COLNAME == stratifyColumn__])
      tmpTxt__ <- aux_explode(catInfo0__$VALUETXT[catInfo0__$COLNAME == stratifyColumn__])
      if (!is.null(stratifyOrder__)) stratifyOrder__ <- as.character(factor(stratifyOrder__, levels = tmpVal__, labels = tmpTxt__))
      datafirst__$stratifyColumn__ <- as.character(factor(datafirst__$stratifyColumn__, levels = tmpVal__, labels = tmpTxt__))
    }
    if (is.null(stratifyOrder__))
      stratifyOrder__ <- unique(datafirst__$stratifyColumn__[!is.na(datafirst__$stratifyColumn__)])
    if (any(is.na(datafirst__$stratifyColumn__)))
      stratifyOrder__ <- c(stratifyOrder__, NA)
    stratifyOrder__[is.na(stratifyOrder__)] <- "missing*"
    datafirst__$stratifyColumn__[is.na(datafirst__$stratifyColumn__)] <- "missing*"
    if ("missing*" %in% stratifyOrder__) FLAGmissingCat <- TRUE
    dummy__ <- sapply(stratifyOrder__, function (strata__) {
      stratData__ <- datafirst__[datafirst__$stratifyColumn__ == strata__,]
      NTOTALstrat__ <- nrow(stratData__)
      STRATCOLname__ <- paste0(stratData__$stratifyColumn__[1]," [N=",NTOTALstrat__,"]")
      stratValueCol__ <- sapply(1:nrow(baseTable__), function (kRowTable__) {
        row__ <- baseTable__[kRowTable__,]
        COLNAME__ <- row__$COLNAME
        VALUE__ <- row__$VALUE
        NCATstraty__ <- sum(stratData__[COLNAME__] == VALUE__,na.rm=TRUE)
        PERCCATstraty__ <- signif(NCATstraty__/NTOTALstrat__*100,SIGNIF)
        paste0(NCATstraty__, " (",PERCCATstraty__,"%)")
      })
      table__ <<- cbind(table__, stratValueCol__)
      names(table__)[ncol(table__)] <<- STRATCOLname__
    })
    if (FLAGtotal__) {
      dataTOTAL__ <- datafirst__
      NTOTAL__ <- nrow(dataTOTAL__)
      totalValueCol__ <- sapply(1:nrow(baseTable__), function (kRowTable__) {
        row__ <- baseTable__[kRowTable__,]
        COLNAME__ <- row__$COLNAME
        VALUE__ <- row__$VALUE
        NCAT__ <- sum(dataTOTAL__[COLNAME__] == VALUE__,na.rm=TRUE)
        PERCCAT__ <- signif(NCAT__/NTOTAL__*100,SIGNIF)
        paste0(NCAT__, " (",PERCCAT__,"%)")
      })
      table__ <- cbind(table__, totalValueCol__)
      names(table__)[ncol(table__)] <- paste0("TOTAL [N=",NTOTAL__,"]")
    }
  } 
  table__$Characteristic[duplicated(table__$Characteristic)] = " "
  if (!is.null(filename)) {
    report__ <- TRUE
  } else {
    report__ <- FALSE
  }
  if (FLAGpatients) {
    footer__ <- "N: Number of patients<br>Number of patients in each category and percentage within this category"
  } else {
    footer__ <- "N: Number of subjects<br>Number of subjects in each category and percentage within this category"
  }
  if (FLAGmissingCat)
    footer__ <- paste0(footer__, "<br>","* stratification value missing in dataset")
  if (FLAGmissingVal)
    footer__ <- paste0(footer__, "<br>","** missing values in dataset")
  if (!is.null(footerAddText)) {
    footer__ <- paste0(footer__,"<br>",footerAddText)
  }
  if (!is.null(filename)) {
    filename <- paste0(aux_strrep(filename,".txt",""),".txt")
    IQRoutputTable(xtable=table__,xfooter=footer__,xtitle=tableTitle,report=report__,filename=filename)
    return(invisible(NULL))
  }
  output__ <- IQRoutputTable(xtable=table__,xfooter=footer__,xtitle=tableTitle,report=report__)
  output__
}
#'@export
summaryCov_IQRdataGENERAL <- function(data,
                                      covNames = NULL,
                                      stratifyColumns = "STUDY",
                                      stratifyOrder = NULL,
                                      FLAGtotal = NULL,
                                      SIGNIF = 3,
                                      tableTitle = NULL,
                                      footerAddText = NULL,
                                      filename = NULL,
                                      FLAGpatients = FALSE) {
  if(!is_IQRdataGENERAL(data)){
    stopIQR("Input argument 'data' is not an IQRdataGENERAL object")
  }
  if (!"STUDY" %in% names(data)) {
    data$STUDY <- "Undefined Study"
    data$STUDYN <- 0
  }
  covNamesData__ <- attributes(data)$covInfo$COLNAME
  if (is.null(covNames)) {
    covNames <- covNamesData__
  }
  if (is.null(covNames)) {
    message("No continuous covariates defined or present")
    return(invisible(NULL))
  }
  if (!all(covNames %in% covNamesData__)) {
    stopIQR(paste0("The following covNames are not available in the provided data:\n  ",paste0(covNames[!(covNames %in% covNamesData__)],collapse=", ")))
  }
  if (is.null(FLAGtotal)) {
    FLAGtotal <- rep(FALSE,length(stratifyColumns))
  }
  if (length(FLAGtotal)==1) {
    FLAGtotal <- rep(FLAGtotal,length(stratifyColumns))
  }
  if (length(FLAGtotal) != length(stratifyColumns)) {
    stopIQR("Missmatch between length of stratifyColumns and FLAGtotal input arguments")
  }
  if (!is.list(stratifyOrder)) {
    stratifyOrder <- list(stratifyOrder)
  }
  for (k__ in seq_along(stratifyColumns)) {
    entries__ <- unique(data[[stratifyColumns[k__]]])
    order__ <- unlist(stratifyOrder[k__])
    if (!is.null(order)) {
      if (!all(order__ %in% entries__)) {
        stopIQR(paste0("Not all entries in stratifyColumns are present for stratification column ",stratifyColumns[k__]))
      }
    }
  }
  if (is.null(tableTitle)) {
    tableTitle <- "Summary of demographic and baseline characteristics for continuous information"
  }
  datafirst__ <- as.data.frame(data[!duplicated(data$USUBJID),])
  covInfo__ <- attributes(data)$covInfo
  catInfo__ <- attributes(data)$catInfo
  covInfo__ <- covInfo__[covInfo__$COLNAME %in% covNames,]
  baseTable__ <- do.call(rbind,lapply(1:nrow(covInfo__), function (kRowcovInfo__) {
    row__ <- covInfo__[kRowcovInfo__,]
    characteristic__ <- paste0(row__$NAME," (",row__$UNIT,")")
    colname__ <- row__$COLNAME
    subtable__ <- data.frame(
      Characteristic = characteristic__,
      COLNAME = colname__,
      stringsAsFactors=FALSE
    )
  }))
  table__ <- baseTable__
  table__$COLNAME <- NULL
  FLAGmissingVal <- FALSE
  FLAGmissingCat <- FALSE
  for (kstratcolumn__ in seq_along(stratifyColumns)) {
    stratifyColumn__ <- stratifyColumns[kstratcolumn__]
    FLAGtotal__ <- FLAGtotal[kstratcolumn__]
    stratifyOrder__ <- unlist(stratifyOrder[kstratcolumn__])
    if (is.null(stratifyOrder__))
      stratifyOrder__ <- unique(datafirst__[[stratifyColumn__]][!is.na(datafirst__[[stratifyColumn__]])])
    if (any(is.na(datafirst__[[stratifyColumn__]])))
      stratifyOrder__ <- c(stratifyOrder__, NA)
    if (stratifyColumn__ %in% catInfo__$COLNAME) {
      tmpVal__ <- aux_explode(catInfo__$VALUES[catInfo__$COLNAME == stratifyColumn__])
      tmpTxt__ <- aux_explode(catInfo__$VALUETXT[catInfo__$COLNAME == stratifyColumn__])
      stratifyOrder__ <- as.character(factor(stratifyOrder__, levels = tmpVal__, labels = tmpTxt__))
      datafirst__[[stratifyColumn__]] <- as.character(factor(datafirst__[[stratifyColumn__]], levels = tmpVal__, labels = tmpTxt__))
    }
    stratifyOrder__[is.na(stratifyOrder__)] <- "missing*"
    datafirst__[[stratifyColumn__]][is.na(datafirst__[[stratifyColumn__]])] <- "missing*"
    if ("missing*" %in% stratifyOrder__) FLAGmissingCat <- TRUE
    dummy__ <- sapply(stratifyOrder__, function (strata__) {
      stratData__ <- datafirst__[datafirst__[stratifyColumn__] == strata__,]
      stratData__ <- stratData__[!is.na(stratData__[stratifyColumn__]),]
      NTOTALstrat__ <- nrow(stratData__)
      STRATCOLname__ <- paste0(stratData__[[stratifyColumn__]][1]," [N=",NTOTALstrat__,"]")
      stratValueCol__ <- sapply(1:nrow(baseTable__), function (kRowTable__) {
        row__ <- baseTable__[kRowTable__,]
        COLNAME__ <- row__$COLNAME
        if (!all(is.na(stratData__[[COLNAME__]]))) {
          MEAN <- signif(mean(stratData__[[COLNAME__]],na.rm=TRUE),SIGNIF)
          STD <- signif(stats::sd(stratData__[[COLNAME__]],na.rm=TRUE),SIGNIF)
          MAX <- signif(max(stratData__[[COLNAME__]],na.rm=TRUE),SIGNIF)
          MIN <- signif(min(stratData__[[COLNAME__]],na.rm=TRUE),SIGNIF)
          nNA <- sum(is.na(stratData__[[COLNAME__]]))
          out__ <- paste0(MEAN, " (",STD,") [",MIN,"-",MAX,"]")
          if (nNA > 0) {out__ <- paste0(out__, " (",nNA," n.a.**)"); FLAGmissingVal <<- TRUE}
        } else {
          out__ <- "-"
        }
        out__
      })
      table__ <<- cbind(table__, stratValueCol__)
      names(table__)[ncol(table__)] <<- STRATCOLname__
    })
    if (FLAGtotal__) {
      dataTOTAL__ <- datafirst__[!is.na(datafirst__[stratifyColumn__]),]
      NTOTAL__ <- nrow(dataTOTAL__)
      totalValueCol__ <- sapply(1:nrow(baseTable__), function (kRowTable__) {
        row__ <- baseTable__[kRowTable__,]
        COLNAME__ <- row__$COLNAME
        MEAN <- signif(mean(dataTOTAL__[[COLNAME__]],na.rm=TRUE),SIGNIF)
        STD <- signif(stats::sd(dataTOTAL__[[COLNAME__]],na.rm=TRUE),SIGNIF)
        MAX <- signif(max(dataTOTAL__[[COLNAME__]],na.rm=TRUE),SIGNIF)
        MIN <- signif(min(dataTOTAL__[[COLNAME__]],na.rm=TRUE),SIGNIF)
        nNA <- sum(is.na(dataTOTAL__[[COLNAME__]]))
        out__ <- paste0(MEAN, " (",STD,") [",MIN,"-",MAX,"]")
        if (nNA > 0) out__ <- paste0(out__, " (",nNA," n.a.**)")
        out__
      })
      table__ <- cbind(table__, totalValueCol__)
      names(table__)[ncol(table__)] <- paste0("TOTAL [N=",NTOTAL__,"]")
    }
  } 
  if (!is.null(filename)) {
    report__ <- TRUE
  } else {
    report__ <- FALSE
  }
  if (FLAGpatients) {
    footer__ <- "N: Number of patients<br>Entries represent: Mean (Standard deviation) [Minimum-Maximum]"
  } else {
    footer__ <- "N: Number of subjects<br>Entries represent: Mean (Standard deviation) [Minimum-Maximum]"
  }
  if (FLAGmissingCat)
    footer__ <- paste0(footer__, "<br>","* stratification value missing in dataset")
  if (FLAGmissingVal)
    footer__ <- paste0(footer__, "<br>","** missing values in dataset")
  if (!is.null(footerAddText)) {
    footer__ <- paste0(footer__,"<br>",footerAddText)
  }
  if (!is.null(filename)) {
    filename <- paste0(aux_strrep(filename,".txt",""),".txt")
    IQRoutputTable(xtable=table__,xfooter=footer__,xtitle=tableTitle,report=report__,filename=filename)
    return(invisible(NULL))
  }
  output__ <- IQRoutputTable(xtable=table__,xfooter=footer__,xtitle=tableTitle,report=report__)
  output__
}
#'@export
is_IQRdataGENERAL <- function(input) {
  methods::is(input,"IQRdataGENERAL")
}
#'@export
print.IQRdataGENERAL <- function(x, ...) {
  print.data.frame(x, ...)
  cat("\n")
  cat("\nIQRdataGENERAL object\n")
  cat("\n")
  checkResults__ <- check_IQRdataGENERAL(x,FLAGreturnText=TRUE)
  if (nchar(checkResults__$checkInfoText_ERROR) > 0) {
    message(
      "\nERRORS in the dataset that need to be addressed\n===============================================\n",
      checkResults__$checkInfoText_ERROR
    )
  }
  if (nchar(checkResults__$checkInfoText_WARNING) > 0) {
    message(
      "\nWARNINGS in the dataset that should be addressed\n================================================\n",
      checkResults__$checkInfoText_WARNING
    )
  }
  if (nchar(checkResults__$checkInfoText_MINOR) > 0) {
    message(
      "\nMINOR issues in the dataset that might be addressed\n===================================================\n",
      checkResults__$checkInfoText_MINOR
    )
  }
  if (nchar(checkResults__$checkInfoText_WARNING) > 0)
    warningIQR("Issues in the dataset detected that should be addressed (see above)")
  if (nchar(checkResults__$checkInfoText_ERROR) > 0)
    warningIQR("Issues in the dataset detected that need to be addressed (see above)")
}
#'@export
summary.IQRdataGENERAL <- function(object, extended = FALSE, ...) {
  if(!"AE" %in% names(object)) object$AE <- 0
  x__ <- object
  xrow__ <- NULL
  dI__ <- doseInfo_IQRdataGENERAL(x__)
  if (nrow(dI__) > 0) {
    VALUE <- paste0("Ntotal: ",dI__$TOTAL.DOSES, ",  Nindiv (min/median/max): ",dI__$MIN.INDIV.DOSES,"/",dI__$MEDIAN.INDIV.DOSES,"/",dI__$MAX.INDIV.DOSES,")")
    xtable__ <- data.frame(INFO="Dose events",
                           NAME=dI__$DOSE.NAME,
                           VALUE=VALUE)
    xtable__ <- rbind(xtable__,xrow__)
  }
  oI__ <- obsInfo_IQRdataGENERAL(x__[x__$AE==0,])
  if (nrow(oI__) > 0) {
    VALUE <- paste0("Ntotal: ",oI__$TOTAL.OBSERVATIONS, ",  Nindiv (min/median/max): ",oI__$MIN.INDIV.OBSERVATIONS,"/",oI__$MEDIAN.INDIV.OBSERVATIONS,"/",oI__$MAX.INDIV.OBSERVATIONS,")")
    xtableadd__ <- data.frame(INFO="Observation events (all)",
                              NAME=oI__$OBSERVATION.NAME,
                              VALUE=VALUE)
    xtable__ <- rbind(xtable__,xtableadd__,xrow__)
  }
  oI__ <- obsInfo_IQRdataGENERAL(x__[x__$MDV==0 & x__$AE==0,])
  if (nrow(oI__) > 0) {
    VALUE <- paste0("Ntotal: ",oI__$TOTAL.OBSERVATIONS, ",  Nindiv (min/median/max): ",oI__$MIN.INDIV.OBSERVATIONS,"/",oI__$MEDIAN.INDIV.OBSERVATIONS,"/",oI__$MAX.INDIV.OBSERVATIONS,")")
    xtableadd__ <- data.frame(INFO="Observation events (MDV=0)",
                              NAME=oI__$OBSERVATION.NAME,
                              VALUE=VALUE)
    xtable__ <- rbind(xtable__,xtableadd__,xrow__)
  }
  oI__ <- dplyr::arrange(obsInfo_IQRdataGENERAL(x__[x__$AE==1,]),desc(as.numeric(TOTAL.OBSERVATIONS)),OBSERVATION.NAME)
  if (nrow(oI__) > 0) {
    VALUE <- paste0("Ntotal: ",oI__$TOTAL.OBSERVATIONS, ",  Nindiv (min/median/max): ",oI__$MIN.INDIV.OBSERVATIONS,"/",oI__$MEDIAN.INDIV.OBSERVATIONS,"/",oI__$MAX.INDIV.OBSERVATIONS,")")
    xtableadd__ <- data.frame(INFO="Adverse events (AE=1)",
                              NAME=oI__$OBSERVATION.NAME,
                              VALUE=VALUE)
    xtable__ <- rbind(xtable__,xtableadd__,xrow__)
  }
  zI__ <- zeroDoses_IQRdataGENERAL(x__)
  if (sum(zI__$N.ZERO.DOSES)>0) {
    xtableadd__ <- data.frame(INFO="Doses AMT=0 present",
                              NAME="ALL dose events",
                              VALUE=paste0(as.character(sum(zI__$N.ZERO.DOSES)>0), " (N=",sum(zI__$N.ZERO.DOSES),")"))
    xtable__ <- rbind(xtable__,xtableadd__,xrow__)
  }
  pI__ <- placeboIndiv_IQRdataGENERAL(x__)
  if (length(pI__) > 0) {
    xtableadd__ <- data.frame(INFO="Placebo subjects present (AMT=0 or no doses)",
                              NAME="ALL dose events",
                              VALUE=paste0(as.character(length(pI__)>0), " (N=",length(pI__),")"))
    xtable__ <- rbind(xtable__,xtableadd__,xrow__)
  }
  N_IGNORED_OBS <- sum(x__$EVID==0 & x__$YTYPE>0 & x__$MDV==1)
  if (N_IGNORED_OBS > 0) {
    xtableadd__ <- data.frame(INFO="IGNORED (MDV=1) observation records present",
                              NAME="ALL observation events",
                              VALUE=paste0(as.character(N_IGNORED_OBS>0), " (N=",N_IGNORED_OBS,")"))
    xtable__ <- rbind(xtable__,xtableadd__,xrow__)
  }
  pI__ <- noObsIndiv_IQRdataGENERAL(x__)
  if (length(pI__) > 0) {
    xtableadd__ <- data.frame(INFO="Subjects without observations (MDV=0) present",
                              NAME="ALL observation events",
                              VALUE=paste0(as.character(length(pI__)>0), " (N=",length(pI__),")"))
    xtable__ <- rbind(xtable__,xtableadd__,xrow__)
  }
  bI__ <- blloqInfo_IQRdataGENERAL(x__[x__$AE==0,])
  xtableadd__ <- data.frame(INFO="Total BLLOQ information",
                            NAME=bI__$blloqInfoTotal$OBSERVATION,
                            VALUE=paste0("N=",bI__$blloqInfoTotal$BLLOQ.OBSERVATIONS," / ",bI__$blloqInfoTotal$PERCENT.BLLOQ,"%"))
  xtable__ <- rbind(xtable__,xtableadd__,xrow__)
  VALUE <- unname(unlist(lapply(bI__$blloqInfoIndividual, function (x__) max(x__$PERCENT.BLLOQ))))
  xtableadd__ <- data.frame(INFO="Max % BLLOQ values in a subject",
                            NAME=bI__$blloqInfoTotal$OBSERVATION,
                            VALUE=paste0(VALUE, "%"))
  xtable__ <- rbind(xtable__,xtableadd__,xrow__)
  VALUE <- attr(x__,"methodBLLOQ")
  if (is.null(VALUE)) VALUE <- "UNDEFINED"
  xtableadd__ <- data.frame(INFO="BLLOQ handling method",
                            NAME="All observation events",
                            VALUE=VALUE)
  xtable__ <- rbind(xtable__,xtableadd__,xrow__)
  allCovInfo     <- c(attr(x__,"cov0"),attr(x__,"covT"),attr(x__,"cat0"),attr(x__,"catT"))
  covColumnNAMES <- names(allCovInfo)
  covColumnValues <- data.frame(do.call(rbind,lapply(split(x__,x__$USUBJID), function (y) {
    y[1,covColumnNAMES]
  })),stringsAsFactors=FALSE)
  missingPercent <- signif(100*apply(is.na(covColumnValues),2,sum) / nrow(covColumnValues),3)
  missingPercent <- missingPercent[missingPercent>0]
  if (length(missingPercent) > 0) {
    xtableadd__ <- data.frame(INFO="Missing covariates",
                              NAME=names(missingPercent),
                              VALUE=paste0(missingPercent,"%"))
    xtable__ <- rbind(xtable__,xtableadd__,xrow__)
  }
  colContainingNA__ <- getNAcolNLME_IQRdataGENERAL(x__)
  if (length(colContainingNA__) > 0) {
    xtableadd__ <- data.frame(INFO="NLME columns containing NA",
                              NAME="All events",
                              VALUE=paste0(colContainingNA__,collapse=", "))
    xtable__ <- rbind(xtable__,xtableadd__,xrow__)
  }
  if (as.character(sum(x__$AE) > 0)) {
    xtableadd__ <- data.frame(INFO="Adverse event information present",
                              NAME="All events",
                              VALUE=as.character(sum(x__$AE) > 0))
    xtable__ <- rbind(xtable__,xtableadd__,xrow__)
    if (sum(x__$AE) > 0) {
      xtableadd__ <- data.frame(INFO="Drug unrelated adverse events present",
                                NAME="All events",
                                VALUE=as.character(sum(x__$AEDRGREL[x__$AE==1]==0) > 0))
      xtable__ <- rbind(xtable__,xtableadd__,xrow__)
    }
  }
  dosObsNames <- unique(x__$NAME[x__$EVID==1 | x__$EVID==0 & x__$YTYPE>0])
  if (as.character(length(setdiff(unique(x__$NAME),dosObsNames)) > 0)) {
    xtableadd__ <- data.frame(INFO="Non dose/observation events present",
                              NAME="All events",
                              VALUE=as.character(length(setdiff(unique(x__$NAME),dosObsNames)) > 0))
    xtable__ <- rbind(xtable__,xtableadd__,xrow__)
  }
  checkResults <- check_IQRdataGENERAL(x__,FLAGreturnText=TRUE)
  VALUE <- sapply(checkResults,function (x__) {
    out <- "NONE"
    if (nchar(x__)>0) out <- "YES (see text below the table for more information)"
    out
  })
  xtableadd__ <- data.frame(INFO="Issues present in the data",
                            NAME=c("Minor","Warnings","Errors"),
                            VALUE=VALUE)
  xtable__ <- rbind(xtable__,xtableadd__,xrow__)
  print(IQRoutputTable(xtable__,report=FALSE))
  if (extended) {
    covInfo__ <- IQRoutputTable(attr(x__, "covInfo"))
    catInfo__ <- IQRoutputTable(attr(x__, "catInfo"))
    regressorNames__ <- attr(x__, "regressorNames")
    cat("\nAdditional Information:\n")
    cat("\nContinuous covariates:\n")
    cat(covInfo__)
    cat("\nCategorical covariates:\n")
    cat(catInfo__)
    cat("\nRegressor names:\n")
    cat(regressorNames__)
    cat("\n\n")
  }
  if (nchar(checkResults$checkInfoText_ERROR) > 0) {
    message(
      "\nERRORS in the dataset that need to be addressed\n===============================================\n",
      checkResults$checkInfoText_ERROR
    )
  }
  if (nchar(checkResults$checkInfoText_WARNING) > 0) {
    message(
      "\nWARNINGS in the dataset that should be addressed\n================================================\n",
      checkResults$checkInfoText_WARNING
    )
  }
  if (nchar(checkResults$checkInfoText_MINOR) > 0) {
    message(
      "\nMINOR issues in the dataset that might be addressed\n===================================================\n",
      checkResults$checkInfoText_MINOR
    )
  }
  if (nchar(checkResults$checkInfoText_WARNING) > 0)
    warningIQR("Issues in the dataset detected that should be addressed (see above)")
  if (nchar(checkResults$checkInfoText_ERROR) > 0)
    warningIQR("Issues in the dataset detected that need to be addressed (see above)")
}
#'@export
exportNLME_IQRdataGENERAL <- function(data,
                                      regressorNames = NULL,
                                      doseNAMES      = NULL,
                                      obsNAMES       = NULL,
                                      filename       = NULL,
                                      FLAGxpt        = FALSE,
                                      FLAGdefine     = TRUE,
                                      FLAGzip        = FALSE,
                                      addColLabels   = NULL) {
  FLAGrmUnusedOBSdose <- TRUE
  if (!is_IQRdataGENERAL(data))
    stopIQR("input argument is not an IQRdataGENERAL object")
  if (is.null(filename))
    stopIQR("please provide a filename for the NLME CSV file")
  if (!is.null(obsNAMES)) {
    if (!all(obsNAMES %in% attr(data,"obsNAMES")))
      stopIQR("not all obsNAMES available in the dataset")
  }
  x <- aux_fileparts(filename)
  filename <- x$filename
  pathname <- x$pathname
  if (nchar(filename) > 8 & FLAGxpt)
    stopIQR("please provide a filename with length of max 8 characters (w/o extension)")
  if (length(setdiff(regressorNames,names(data))) > 0)
    stopIQR("not all regressorNames available in the dataset")
  newColOrder__ <- c("IXGDF",  "IGNORE", "USUBJID","ID",     "STUDY",    "STUDYN",  "TRTNAME", "TRT",
                     "TIME",   "TIMEPOS","NT",     "TAD",    "TIMEUNIT", "YTYPE",   "NAME",    "VALUE",   "DV",
                     "UNIT",   "LLOQ",   "CENS",   "MDV",    "EVID",     "AMT",     "ADM",     "II",      "ADDL",
                     "ROUTE",  "TINF",   "RATE",   "DOSE",   "PROFNR",   "PROFTIME")
  newColOrderPresent__ <- newColOrder__[newColOrder__ %in% names(data)]
  if ("CONDITION" %in% names(data))
    newColOrder__ <- c(newColOrderPresent__[1:4], "CONDITION", newColOrderPresent__[5:length(newColOrderPresent__)])
  newColOrderPresent__ <- setdiff(newColOrderPresent__,regressorNames)
  newColOrderPresent__ <- c(newColOrderPresent__, names(data)[!(names(data) %in% newColOrderPresent__ | names(data) %in% regressorNames)])
  newColOrderPresent__ <- c(newColOrderPresent__, regressorNames)
  newColOrderPresent__ <- setdiff(newColOrderPresent__,c("AE","AEGRADE","AESER","AEDRGREL","VALUETXT","BASE","SCREEN"))
  dataNLME__ <- data[,newColOrderPresent__]
  if (!is.null(doseNAMES)) {
    if (length(setdiff(doseNAMES,attr(data,"doseNAMES"))) > 0) {
      stopIQR("Povided input argument doseNAMES contains element(s) that are not defined as doses")
    }
    dataNLME__$ADM[dataNLME__$EVID==1] <- 999
    dataNLME__$YTYPE[dataNLME__$EVID==1] <- 0 
    for (k in seq_along(doseNAMES)) {
      dataNLME__$ADM[dataNLME__$NAME == doseNAMES[k]] <- k
    }
  } else {
    doseNAMES <- attr(data,"doseNAMES")
  }
  if (FLAGrmUnusedOBSdose) {
    dataNLME__ <- dataNLME__[is.na(dataNLME__$ADM) | dataNLME__$ADM != 999,]
  }
  if (!is.null(obsNAMES)) {
    dataNLME__$YTYPE[dataNLME__$EVID==0] <- 999
    dataNLME__$ADM[dataNLME__$EVID==0] <- 0
    for (k in seq_along(obsNAMES)) {
      dataNLME__$YTYPE[dataNLME__$NAME == obsNAMES[k]] <- k
    }
  } else {
    obsNAMES <- attr(data,"obsNAMES")
  }
  if (FLAGrmUnusedOBSdose) {
    dataNLME__ <- dataNLME__[is.na(dataNLME__$YTYPE) | dataNLME__$YTYPE != 999,]
  }
  dataNLME__ <- data.frame(lapply(dataNLME__, function(x) {
    if (!is.numeric(x)) x <- gsub(x=x,pattern=" ",replacement=":::")
    x
  }),stringsAsFactors = FALSE)
  dataNLME__$ADM[dataNLME__$EVID==0] <- NA
  dataNLME__$YTYPE[dataNLME__$EVID==1] <- NA
  attr(dataNLME__,"methodBLLOQ") <- attr(data,"methodBLLOQ")
  attr(dataNLME__,"doseNAMES") <- doseNAMES
  attr(dataNLME__,"obsNAMES") <- obsNAMES
  attr(dataNLME__,"aeNAMES")     <- attr(data,"aeNAMES")
  attr(dataNLME__,"covInfo") <- attr(data,"covInfo")
  attr(dataNLME__,"catInfo") <- attr(data,"catInfo")
  attr(dataNLME__,"imputeInfo") <- attr(data,"imputeInfo")
  attr(dataNLME__,"regressorNames") <- regressorNames
  attr(dataNLME__,"class") <- c("IQRdataGENERAL","data.frame")
  if (is.null(addColLabels)) addColLabels <- list()
  for (k__ in seq_along(regressorNames)) {
    addColLabels[[regressorNames[k__]]] <- paste0("Regression parameter ",regressorNames[k__])
  }
  export_IQRdataGENERAL(dataNLME__,filename=paste0(pathname,"/",filename),
                        FLAGxpt=FLAGxpt,
                        FLAGdefine=FLAGdefine,
                        addColLabels=addColLabels,
                        FLAGzip=FLAGzip)
}
#'@export
#'@importFrom data.table fread
load_IQRdataGENERAL <- function(filename) {
  if (substr(filename,nchar(filename)-7,nchar(filename)) == ".dat.zip") {
    if (!file.exists(filename))
      stopIQR(sprintf("file '%s' does not exist",filename))
    oldpath__ <- getwd()
    pfe__ <- aux_fileparts(filename);
    setwd(pfe__$pathname)
    datzippath__ <- paste0(getwd(),"/",pfe__$filename,pfe__$fileext)
    tempdir <- paste0(tempdirIQR(),"_data")
    aux_mkdir(tempdir)
    setwd(tempdir)
    unlink("*",recursive=TRUE)
    file.copy(from=datzippath__,to=".")
    utils::unzip(paste0(pfe__$filename,pfe__$fileext))
    filename <- paste0(getwd(),"/",aux_strrep(pfe__$filename,".dat",""),".csv")
    FLAG_zip_loaded__ <- TRUE
  } else {
    FLAG_zip_loaded__ <- FALSE
  }
  filenameCSV__ <- paste0(aux_strrep(filename,".csv",""),".csv")
  filenameATR__ <- paste0(aux_strrep(filename,".csv",""),".atr")
  if (!file.exists(filenameCSV__))
    stopIQR(sprintf("File '%s' does not exist",filenameCSV__))
  if (!file.exists(filenameATR__))
    stopIQR(sprintf("Attribute file '%s' does not exist. Please consider importing the datafile with the function 'IQRdataGENERAL'",filenameATR__))
  data__ <- as.data.frame(data.table::fread(input = filenameCSV__, header=TRUE,sep=",",stringsAsFactors=FALSE,na.strings="."))
  atrcontents <- loadAttributeFile(filenameATR__)
  if (any(grepl("_", names(data__)))) {
    warningIQR("There are underscores in column names which are removed.")
    names(data__) <- gsub("_", "", names(data__))
    atrcontents$catInfo$COLNAME <- gsub("_", "", atrcontents$catInfo$COLNAME)
    atrcontents$covInfo$COLNAME <- gsub("_", "", atrcontents$covInfo$COLNAME)
    atrcontents$imputeInfo$COVNAME <- gsub("_", "", atrcontents$imputeInfo$COVNAME)
  }
  data__ <- generalDataHandleMissingColums(data__)
  numericColumns__ <- getColumnsInfo_IQRdataGENERAL()$numericColumns
  numericColumnsPresent__ <- numericColumns__[numericColumns__ %in% names(data__)]
  for (k__ in seq_along(numericColumnsPresent__)) {
    suppressWarnings(data__[[numericColumnsPresent__[k__]]] <- as.numeric(data__[[numericColumnsPresent__[k__]]]))
  }
  data__$TIMEUNIT <- toupper(data__$TIMEUNIT)
  data__$ROUTE <- toupper(data__$ROUTE)
  data__ <- generalData_IDcolumn(data__,FLAGforceOverwriteNLMEcols=FALSE)
  data__ <- generalData_TIMEPOScolumn(data__,FLAGforceOverwriteNLMEcols=FALSE)
  data__ <- generalData_EVIDcolumn(data__,doseNAMES,FLAGforceOverwriteNLMEcols=FALSE)
  data__ <- generalData_MDVcolumn(data__,doseNAMES,FLAGforceOverwriteNLMEcols=FALSE)
  data__ <- generalData_CENScolumn(data__,FLAGforceOverwriteNLMEcols=FALSE)
  data__ <- generalData_AMTcolumn(data__,doseNAMES,FLAGforceOverwriteNLMEcols=FALSE)
  data__ <- generalData_DVcolumn(data__,doseNAMES,FLAGforceOverwriteNLMEcols=FALSE)
  data__ <- generalData_TINFcolumn(data__,doseNAMES,FLAGforceOverwriteNLMEcols=FALSE)
  data__ <- generalData_RATEcolumn(data__,doseNAMES,FLAGforceOverwriteNLMEcols=FALSE)
  data__ <- generalData_ADMcolumn(data__,doseNAMES,FLAGforceOverwriteNLMEcols=FALSE)
  data__ <- generalData_TADcolumns(data__,doseNAMES,FLAGforceOverwriteNLMEcols=FALSE)
  data__ <- generalData_DOSEcolumns(data__,doseNAMES,FLAGforceOverwriteNLMEcols=FALSE)
  data__ <- generalData_YTYPEcolumn(data__,obsNAMES,FLAGforceOverwriteNLMEcols=FALSE)
  namesOrder__ <- getColumnsInfo_IQRdataGENERAL()$namesOrder
  numericOrderPresent__ <- namesOrder__[namesOrder__ %in% names(data__)]
  dataOrdered__ <- data__[,numericOrderPresent__]
  data__ <- cbind(dataOrdered__, data__[,setdiff(names(data__),numericOrderPresent__)])
  data__ <- data.frame(lapply(data__, function(x__) {
    if (!is.numeric(x__)) x__ <- gsub(x=x__,pattern=":::",replacement=" ")
    x__
  }),row.names=NULL,stringsAsFactors=FALSE)
  attributes(data__) <- c(attributes(data__),atrcontents)
  attr(data__,"class") <- c("IQRdataGENERAL", attr(data__,"class"))
  if (FLAG_zip_loaded__) {
    unlink("*",recursive=TRUE)
    setwd(oldpath__)
    unlink(tempdir)
  }
  data__$ADM[is.na(data__$ADM)] <- 0
  data__$YTYPE[is.na(data__$YTYPE)] <- 0
  return(data__)
}
#'@export
#'@importFrom data.table fwrite
export_IQRdataGENERAL <- function(data,
                                  filename        = NULL,
                                  FLAGxpt         = FALSE,
                                  FLAGdefine      = TRUE,
                                  addColLabels    = NULL,
                                  FLAGzip         = FALSE) {
  if (!is_IQRdataGENERAL(data))
    stopIQR("input argument is not an IQRdataGENERAL object")
  if (is.null(filename))
    stopIQR("please provide a filename for the NLME CSV file")
  x__ <- aux_fileparts(filename)
  filename__ <- x__$filename
  pathname__ <- x__$pathname
  if (nchar(filename__) > 8 & FLAGxpt)
    stopIQR("please provide a filename with length of max 8 characters (w/o extension)")
  IQRoutputCSV(data,filename=paste0(pathname__,"/",filename__),na=".",quote=FALSE)
  if (FLAGxpt) exportXPT_IQRdataGENERAL(data,paste0(pathname__,"/",filename__),addColLabels=addColLabels)
  if (FLAGdefine) {
    datasetName__     <- filename__
    datasetLocation__ <- paste0(pathname__,"/",datasetName__)
    if (FLAGxpt) {
      datasetLocation__ <- paste0(datasetLocation__,".xpt")
    } else {
      datasetLocation__ <- paste0(datasetLocation__,".csv")
    }
    filenameRMD__        <- paste0(pathname__,"/",datasetName__,"_define.rmd")
    exportDEFINE_IQRdataGENERAL(data               = data,
                                datasetName        = datasetName__,
                                datasetLocation    = datasetLocation__,
                                datasetDescription = "General analysis dataset",
                                addColLabels       = addColLabels,
                                filename           = filenameRMD__)
  }
  methodBLLOQ__     <- paste0(deparse(attr(data,"methodBLLOQ")),collapse="\n")
  doseNAMES__       <- paste0(deparse(attr(data,"doseNAMES")),collapse="\n")
  obsNAMES__        <- paste0(deparse(attr(data,"obsNAMES")),collapse="\n")
  aeNAMES__         <- paste0(deparse(attr(data,"aeNAMES")),collapse="\n")
  covInfo__         <- paste0(deparse(attr(data,"covInfo")),collapse="\n")
  catInfo__         <- paste0(deparse(attr(data,"catInfo")),collapse="\n")
  imputeInfo__      <- paste0(deparse(attr(data,"imputeInfo")),collapse="\n")
  regressionNames__ <- paste0(deparse(attr(data,"regressorNames")),collapse="\n")
  ATTRTEXT__ <- paste0("# Attributes file for dataset ",filename__,"\n\n")
  ATTRTEXT__ <- paste0(ATTRTEXT__,"atrcontents <- list()\n\n")
  ATTRTEXT__ <- paste0(ATTRTEXT__,"atrcontents$methodBLLOQ <- ",methodBLLOQ__,"\n\n")
  ATTRTEXT__ <- paste0(ATTRTEXT__,"atrcontents$doseNAMES <- ",doseNAMES__,"\n\n")
  ATTRTEXT__ <- paste0(ATTRTEXT__,"atrcontents$obsNAMES <- ",obsNAMES__,"\n\n")
  ATTRTEXT__ <- paste0(ATTRTEXT__,"atrcontents$aeNAMES <- ",aeNAMES__,"\n\n")
  ATTRTEXT__ <- paste0(ATTRTEXT__,"atrcontents$covInfo <- ",covInfo__,"\n\n")
  ATTRTEXT__ <- paste0(ATTRTEXT__,"atrcontents$catInfo <- ",catInfo__,"\n\n")
  ATTRTEXT__ <- paste0(ATTRTEXT__,"atrcontents$imputeInfo <- ",imputeInfo__,"\n\n")
  ATTRTEXT__ <- paste0(ATTRTEXT__,"atrcontents$regressorNames <- ",regressionNames__,"\n\n")
  IQRoutputFile(ATTRTEXT__,paste0(pathname__,"/",filename__,".atr"))
  if (FLAGzip) {
    oldpath__ <- getwd()
    setwd(pathname__)
    files__ <- dir(pattern=paste0(filename__,".csv*"))
    files__ <- c(files__,dir(pattern=paste0(filename__,".atr*")))
    if (FLAGdefine)
      files__ <- c(files__,dir(pattern=paste0(filename__,"_define.*")))
    if (FLAGxpt)
      files__ <- c(files__,dir(pattern=paste0(filename__,".xpt*")))
    utils::zip(paste0(filename__,".dat.zip"),files__)
    unlink(files__)
    setwd(oldpath__)
  }
}
#'@export
exportDEFINE_IQRdataGENERAL <- function(data,
                                        datasetName=NULL,
                                        datasetLocation=NULL,
                                        datasetDescription="Analysis dataset",
                                        addColLabels=NULL,
                                        filename=NULL) {
  exportDEFINEdocx_IQRdataGENERAL(data,
                                  datasetName,
                                  datasetLocation,
                                  datasetDescription,
                                  addColLabels,
                                  filename)
}
exportDEFINEdocx_IQRdataGENERAL <- function(data,
                                            datasetName=NULL,
                                            datasetLocation=NULL,
                                            datasetDescription="Analysis dataset",
                                            addColLabels=NULL,
                                            filename=NULL) {
  if (!is_IQRdataGENERAL(data) & !("IQRdataNLME" %in% attr(data,"class")))
    stopIQR("input data is not an IQRdataGENERAL object")
  if (is.null(datasetName))
    stopIQR("Please provide a name for the dataset as it should appear in the define file")
  if (is.null(datasetLocation))
    warningIQR("Please provide a location (path) for the dataset as it should appear in the define file")
  dataFirst__ <- data.frame(NAME=datasetName,DESCRIPTION=datasetDescription,LOCATION=datasetLocation,stringsAsFactors=FALSE,row.names=NULL)
  dataDefine__ <- data.frame(NAME=names(data),stringsAsFactors=FALSE,row.names=NULL)
  dataDefine__$TYPE <-lapply(data, function (x) { if (is.numeric(x)) { out <- "Numeric" } else { out <- "String" }; out })
  data <- addLabel_IQRdataGENERAL(data,addColLabels)
  dataDefine__$LABEL <-lapply(data, function (x) {
    label__ <- attr(x,"label")
    if (is.null(label__)) label__ <- "UNKNOWN"
    label__
  })
  dataDefine__$VALUES <- getValueTxtDefine(dataDefine__$NAME,unlabel_dataframe(data))
  dataDefine__$COMMENTS <- " "
  datasetName__ <- toupper(datasetName)
  RMDTEXT__ <- rmdEMPTY()
  RMDTEXT__ <- RMDTEXT__ + rmdTITLE(title=paste0("Define file for the \"",datasetName__,"\" dataset"),subtitle=NULL,date=NULL)
  RMDTEXT__ <- RMDTEXT__ + rmdNOINTRO()
  RMDTEXT__ <- RMDTEXT__ + "!BLOCKSTART[keepNext](block_kwnext)\n"
  RMDTEXT__ <- RMDTEXT__ + rmdSECTION("Dataset name, description, and location",numbered=FALSE)
  RMDTEXT__ <- RMDTEXT__ + rmdTABLEDF(dataFirst__,label="overview",fontsize=8,caption="Dataset information",ignoreCaption=TRUE)
  RMDTEXT__ <- RMDTEXT__ + rmdNEWPAGE()
  RMDTEXT__ <- RMDTEXT__ + rmdSECTION(paste0(datasetName__," specification"),numbered=FALSE)
  RMDTEXT__ <- RMDTEXT__ + "Missing values are coded in the dataset as '.' and referenced in this specification as 'NA'.\n\n"
  RMDTEXT__ <- RMDTEXT__ + rmdTABLEDF(dataDefine__,label="overview",fontsize=8,caption="Definition of dataset contents",ignoreCaption=TRUE)
  RMDTEXT__ <- RMDTEXT__ + "\n"
  RMDTEXT__ <- RMDTEXT__ + "!BLOCKEND(block_kwnext)\n"
  if (is.null(filename)) {
    filename__ <- paste0(datasetName__,"_define",".rmd")
  } else {
    x <- aux_fileparts(filename)
    filename__ <- paste0(x$pathname,"/",x$filename,".rmd")
  }
  export_IQRrmd(RMDTEXT__,filename__)
  if (has_IQReport_executable()) {
    IQReport(filename__)
  }
}
#'@export
exportDEFINEpdf_IQRdataGENERAL <- function(data,
                                           datasetName=NULL,
                                           datasetLocation=NULL,
                                           datasetDescription="Analysis dataset",
                                           addColLabels=NULL,
                                           filename=NULL) {
  if (!is_IQRdataGENERAL(data) & !("IQRdataNLME" %in% attr(data,"class")))
    stopIQR("input data is not an IQRdataGENERAL object")
  if (is.null(datasetName))
    stopIQR("Please provide a name for the dataset as it should appear in the define file")
  if (is.null(datasetLocation))
    warningIQR("Please provide a location (path) for the dataset as it should appear in the define file")
  splitRows <- function(data, skip = 5) {
    data <- split(data, seq_along(data[[1]]))
    data <- do.call(rbind, lapply(data, function(d) {
      nr <- max(unlist(lapply(d, function(x) length(strsplit(as.character(x), "\n")[[1]]))))
      if (nr > skip) {
        d <- as.data.frame(lapply(d, function(x) {
          x <- strsplit(as.character(x), "\n")[[1]][1:nr]
          x[is.na(x)] <- ""
          x <- c(paste(x[1:skip], collapse = "\n"), x[-(1:skip)])
          return(x)
        }), stringsAsFactors = FALSE)
      }
      return(d)
    }))
    rownames(data) <- NULL
    return(data)
  }
  defineFile_makeTable_Description <- function(NAME, DESCRIPTION, LOCATION, width = 16) {
    table <- kableExtra::kable(data.frame(Name = NAME, Description = DESCRIPTION, Location = LOCATION), format = "latex",
                               longtable = TRUE, booktabs = TRUE)
    table <- kableExtra::kable_styling(table, latex_options = c("repeat_header"), font_size = 8)
    table <- kableExtra::column_spec(table, 1, width = paste0(width*3/17, "cm"))
    table <- kableExtra::column_spec(table, 2, width = paste0(width*4/17, "cm"))
    table <- kableExtra::column_spec(table, 3, width = paste0(width*9/17, "cm"))
    table <- kableExtra::row_spec(table, 0, bold = TRUE)
    return(table)
  }
  defineFile_makeTable_Dataspec <- function(NAME, TYPE, LABEL, VALUES, COMMENTS, width = 16) {
    mydata <- data.frame(Name = unlist(NAME), Type = unlist(TYPE), Label = unlist(LABEL),
                         Values = gsub(":::", " ", unlist(VALUES)),
                         Comments = unlist(COMMENTS),
                         row.names = NULL)
    mydata <- splitRows(mydata)
    table <- kableExtra::kable(mydata, format = "latex",
                               longtable = TRUE, booktabs = TRUE)
    table <- kableExtra::kable_styling(table, latex_options = c("repeat_header"), font_size = 8)
    table <- kableExtra::column_spec(table, 1, width = paste0(width*2/18, "cm"))
    table <- kableExtra::column_spec(table, 2, width = paste0(width*2/18, "cm"))
    table <- kableExtra::column_spec(table, 3, width = paste0(width*2/18, "cm"))
    table <- kableExtra::column_spec(table, 4, width = paste0(width*8/18, "cm"))
    table <- kableExtra::column_spec(table, 5, width = paste0(width*2/18, "cm"))
    table <- kableExtra::row_spec(table, 0, bold = TRUE)
    return(table)
  }
  dataFirst__ <- data.frame(NAME=datasetName,DESCRIPTION=datasetDescription,LOCATION=datasetLocation,stringsAsFactors=FALSE,row.names=NULL)
  dataDefine__ <- data.frame(NAME=names(data),stringsAsFactors=FALSE,row.names=NULL)
  dataDefine__$TYPE <-lapply(data, function (x) { if (is.numeric(x)) { out <- "Numeric" } else { out <- "String" }; out })
  data <- addLabel_IQRdataGENERAL(data,addColLabels)
  dataDefine__$LABEL <-lapply(data, function (x) {
    label__ <- attr(x,"label")
    if (is.null(label__)) label__ <- "UNKNOWN"
    label__
  })
  dataDefine__$VALUES <- getValueTxtDefine(dataDefine__$NAME,unlabel_dataframe(data))
  dataDefine__$COMMENTS <- " "
  table1__ <- defineFile_makeTable_Description(datasetName, datasetDescription, datasetLocation)
  table2__ <- with(dataDefine__, defineFile_makeTable_Dataspec(NAME, TYPE, LABEL, VALUES, COMMENTS))
  datasetName__ <- toupper(datasetName)
  templatefile__ <- template <- system.file(package="IQRtools", file.path("templates", "definefile.tex"))
  con__ <- file(templatefile__)
  txt__ <- readLines(con__)
  close.connection(con__)
  txt__ <- lapply(txt__, function(mytxt__) {
    mytxt__ <- sub("<dataname>", datasetName, mytxt__)   
    if (mytxt__ == "<table1>") return(table1__)          
    if (mytxt__ == "<table2>") return(table2__)          
    return(mytxt__)
  })
  if (is.null(filename)) {
    filename.tex__ <- paste0(datasetName__,"_define",".tex")
  } else {
    x <- aux_fileparts(filename)
    filename.tex__ <- paste0(x$pathname,"/", x$filename,".tex")
  }
  con__ <- file(filename.tex__)
  writeLines(text = unlist(txt__), con = con__)
  close.connection(con__)
  msg__ <- try(tinytex::pdflatex(filename.tex__), silent = TRUE)
  return(invisible(NULL))
}
exportXPT_IQRdataGENERAL <- function(data,filename=NULL,addColLabels=NULL) {
  if (is.null(filename))
    stopIQR("filename must be provided")
  if (!is_IQRdataGENERAL(data) & !("IQRdataNLME" %in% attr(data,"class")))
    stopIQR("input data is not an IQRdataGENERAL object")
  x <- aux_fileparts(filename)
  filename <- x$filename
  pathname <- x$pathname
  if (nchar(filename) > 8)
    stopIQR("please provide a filename with length of max 8 characters (w/o extension)")
  dataX <- data.frame(lapply(names(data), function (x) {
    x <- data[[x]]
    if (!is.null(levels(x))) {
      x <- levels(x)[x]
    }
    if (is.logical(x)) x <- as.double(x)
    if (is.integer(x)) x <- as.double(x)
    x
  }),row.names=NULL,stringsAsFactors=FALSE)
  names(dataX) <- names(data)
  attr(dataX,"methodBLLOQ") <- attr(data,"methodBLLOQ")
  attr(dataX,"doseNAMES") <- attr(data,"doseNAMES")
  attr(dataX,"obsNAMES") <- attr(data,"obsNAMES")
  attr(dataX,"aeNAMES")     <- attr(data,"aeNAMES")
  attr(dataX,"covInfo") <- attr(data,"covInfo")
  attr(dataX,"catInfo") <- attr(data,"catInfo")
  attr(dataX,"class") <- c("IQRdataNLME","data.frame")
  attr(dataX,"imputeInfo") <- attr(data,"imputeInfo")
  data <- dataX
  data <- addLabel_IQRdataGENERAL(data,addColLabels)
  aux_mkdir(pathname)
  haven::write_xpt(data = data,path = paste0(pathname,'/',filename,'.xpt'),name = filename,version = 5)
  genComplianceLog(paste0(pathname,'/',filename,'.xpt'))
}
#'@export
clean_IQRdataGENERAL <- function(data,
                                 methodBLLOQ="M1",
                                 records=NULL,
                                 subjects=NULL,
                                 FLAGrmPlacebo=FALSE,
                                 FLAGrmIGNOREDrecords=FALSE,
                                 FLAGrmDosePostLastObs=FALSE,
                                 continuousCovs=NULL,
                                 categoricalCovs=NULL,
                                 pathname=NULL) {
  if (!is_IQRdataGENERAL(data))
    stopIQR("input argument is not an IQRdataGENERAL object")
  filename <- NULL
  dataNew <- handleSameTimeObs_IQRdataGENERAL(data)
  if (!is.null(methodBLLOQ)) dataNew <- blloq_IQRdataGENERAL(dataNew,methodBLLOQ=methodBLLOQ)
  if (!is.null(pathname)) filename <- paste0(pathname,"/01_Manually_Selected_Records.txt")
  dataNew <- setIGNORErecords_IQRdataGENERAL(dataNew,records=records,filename=filename)
  if (!is.null(pathname)) filename <- paste0(pathname,"/02_Missing_TIME_Observation_Records.txt")
  dataNew <- rmMissingTIMEobsRecords_IQRdataGENERAL(dataNew,filename=filename)
  if (!is.null(pathname)) filename <- paste0(pathname,"/03_Missing_DV_Observation_Records.txt")
  dataNew <- setMissingDVobsRecordsIGNORE_IQRdataGENERAL(dataNew,filename=filename)
  if (!is.null(pathname)) filename <- paste0(pathname,"/04_Manually_Selected_Subjects.txt")
  dataNew <- rmSubjects_IQRdataGENERAL(dataNew,subjects=subjects,filename=filename)
  if (!is.null(pathname)) filename <- paste0(pathname,"/05_Non_Dose_Observation_Records.txt")
  dataNew <- rmNonTask_IQRdataGENERAL(dataNew,filename=filename)
  if (FLAGrmPlacebo) {
    if (!is.null(pathname)) filename <- paste0(pathname,"/06_Placebo_Subjects.txt")
    dataNew <- rmPLACEBO_IQRdataGENERAL(dataNew,filename=filename)
  }
  if (!is.null(pathname)) filename <- paste0(pathname,"/07_No_Observations_Subjects.txt")
  dataNew <- rmNOobsSUB_IQRdataGENERAL(dataNew,filename=filename)
  if (!is.null(pathname)) filename <- paste0(pathname,"/08_Zero_Amount_Dose_Records.txt")
  dataNew <- rmAMT0_IQRdataGENERAL(dataNew,filename=filename)
  if (FLAGrmIGNOREDrecords) {
    if (!is.null(pathname)) filename <- paste0(pathname,"/09_IGNORED_records.txt")
    dataNew <- rmIGNOREd_IQRdataGENERAL(dataNew,filename=filename)
  }
  if (!is.null(pathname)) filename <- paste0(pathname,"/10_Covariate_Imputations.txt")
  dataNew <- covImpute_IQRdataGENERAL(dataNew,continuousCovs=continuousCovs,categoricalCovs=categoricalCovs,filename=filename)
  if (FLAGrmDosePostLastObs) {
    if (!is.null(pathname)) filename <- paste0(pathname,"/11_Doses_Post_Last_Observation.txt")
    dataNew <- rmDosePostLastObs_IQRdataGENERAL(dataNew,filename=filename)
  }
  return(dataNew)
}
#'@export
covImpute_IQRdataGENERAL <- function(data,continuousCovs=NULL,categoricalCovs=NULL, filename=NULL) {
  if (!is_IQRdataGENERAL(data))
    stopIQR("input argument is not an IQRdataGENERAL object")
  covColNames <- c()
  covColImputationValues <- c()
  if (length(continuousCovs)>0) {
    if (!is.null(names(continuousCovs))) {
      covColNames <- c(covColNames, names(continuousCovs))
      covColImputationValues <- c(covColImputationValues, unname(continuousCovs))
    } else {
      covColNames <- c(covColNames, continuousCovs)
      covColImputationValues <- c(covColImputationValues, rep("median",length(continuousCovs)))
    }
  }
  if (length(categoricalCovs)>0) {
    if (is.null(names(categoricalCovs))) {
      stopIQR("categoricalCovs needs to be a named vector")
    } else {
      covColNames <- c(covColNames, names(categoricalCovs))
      covColImputationValues <- c(covColImputationValues, unname(categoricalCovs))
    }
  }
  imputeInfo <- data.frame(COVNAME=covColNames, IMPUTATION=covColImputationValues,stringsAsFactors=FALSE)
  if (length(unique(imputeInfo$COVNAME)) != length(imputeInfo$COVNAME))
    stopIQR("Imputation rule defined more than once for same covariate")
  notInData <- imputeInfo$COVNAME[which(!(imputeInfo$COVNAME %in% names(data)))]
  if (length(notInData)>0)
    stopIQR(paste0("The following covariate column is not in the data:\n    ",paste0(notInData,collapse=", ")))
  nonNumericDefCols <- imputeInfo$COVNAME[is.na(suppressWarnings(as.numeric(imputeInfo$IMPUTATION)))]
  indivValues <- data.frame(do.call(rbind,lapply(split(data,data$USUBJID), function (x) {
    sapply(nonNumericDefCols, function (y) {
      x[[y]][1]
    })
  })),stringsAsFactors=FALSE,row.names=NULL)
  imputationValuesNN <- sapply(nonNumericDefCols, function (x) {
    fct   <- imputeInfo$IMPUTATION[imputeInfo$COVNAME==x]
    expr  <- paste0(fct,"(indivValues$",x,",na.rm=TRUE)")
    eval(parse(text=expr))
  })
  imputeInfo$VALUES <- suppressWarnings(as.numeric(imputeInfo$IMPUTATION))
  for (k__ in seq_along(imputationValuesNN)) {
    imputeInfo$VALUES[imputeInfo$COVNAME==names(imputationValuesNN)[k__]] <- signif(imputationValuesNN[k__],5)
  }
  xtable <- data.frame()
  for (k__ in seq_along(imputeInfo$COVNAME)) {
    ixNA <- which(is.na(data[[imputeInfo$COVNAME[k__]]]))
    data[[imputeInfo$COVNAME[k__]]][ixNA] <- imputeInfo$VALUES[k__]
    if (length(ixNA)>0) {
      N          <- length(unique(data$USUBJID[ixNA]))
      COVNAME    <- c(imputeInfo$COVNAME[k__], rep(" ",N))
      IMPUTATION <- c(imputeInfo$IMPUTATION[k__], rep(" ",N))
      VALUES     <- c(imputeInfo$VALUES[k__], rep(" ",N))
      N.IMPUTED  <- c(N, rep(" ",N))
      PERCENT.IMPUTED <- c(paste0(signif(100*N/length(unique(data$USUBJID)),4),"%"), rep(" ",N))
      USUBJID    <- c(unique(data$USUBJID[ixNA]), " ")
      xtableadd__  <- data.frame(COVNAME=COVNAME,
                                 IMPUTATION=IMPUTATION,
                                 VALUES=VALUES,
                                 N.IMPUTED=N.IMPUTED,
                                 PERCENT.IMPUTED=PERCENT.IMPUTED,
                                 USUBJID=USUBJID)
      xtable     <- rbind(xtable, xtableadd__)
    }
  }
  xtitle <- sprintf("Protocol of covariate imputations (N_Total_Subjects=%d)",length(unique(data$USUBJID)))
  if (nrow(xtable)==0) xtable <- data.frame(COVNAME="-",IMPUTATION="-",VALUES="-",N.IMPUTED=0,PERCENT.IMPUTED=0,USUBJID="-")
  if (!is.null(filename)) {
    IQRoutputTable(xtable=xtable,xtitle=xtitle,filename=filename,report=TRUE)
  } else {
    print(IQRoutputTable(xtable=xtable,xtitle=xtitle,report=FALSE))
  }
  attr(data,"imputeInfo") <- imputeInfo
  return(data)
}
#'@export
getNAcolNLME_IQRdataGENERAL <- function(data) {
  if (!is_IQRdataGENERAL(data))
    stopIQR("input argument is not an IQRdataGENERAL object")
  globalColNames <- getColumnsInfo_IQRdataGENERAL()$namesOrder
  nlmeColNames <- setdiff(names(data),globalColNames)
  colContainingNA__ <- unlist(lapply(nlmeColNames, function (x) {
    col <- data[,x]
    if (length(which(is.na(col))) > 0) {
      outx__ <- x
    } else {
      outx__ <- NULL
    }
    outx__
  }))
  colContainingNA__ <- colContainingNA__[!grepl("^TADD",colContainingNA__)]
  return(colContainingNA__)
}
#'@export
rmSubjects_IQRdataGENERAL <- function(data,subjects,filename=NULL) {
  if (!is_IQRdataGENERAL(data))
    stopIQR("input argument is not an IQRdataGENERAL object")
  removeTable <- do.call(rbind,lapply(seq_along(subjects), function (k) {
    data.frame(USUBJID=subjects[[k]],REMOVE.REASON=names(subjects)[k],stringsAsFactors=FALSE,row.names=NULL)
  }))
  if (!is.null(removeTable)) removeTable <- dplyr::arrange(removeTable,USUBJID)
  ixnotpresent__ <- removeTable$USUBJID[!(removeTable$USUBJID %in% data$USUBJID)]
  if (length(ixnotpresent__) > 0)
    stopIQR(paste0("The following USUBJIDs are not present in the dataset:\n    ",paste0(ixnotpresent__,collapse=" ")))
  output <- data[!(data$USUBJID %in% removeTable$USUBJID),]
  if (!is.null(removeTable)) {
    xtable <- dplyr::arrange(removeTable,USUBJID)
  } else {
    xtable <- data.frame(USUBJID="-",REMOVE.REASON="No subjects removed")
  }
  Nremoved__ <- nrow(removeTable)
  if (is.null(Nremoved__)) Nremoved__ = 0
  xtitle <- paste0("N=",Nremoved__," subjects removed from the data")
  xfooter <- paste0("Rule for removal: user defined input")
  if (!is.null(filename)) {
    IQRoutputTable(xtable=xtable,xfooter=xfooter,xtitle=xtitle,filename=filename,report=TRUE)
  } else {
    print(IQRoutputTable(xtable=xtable,xfooter=xfooter,xtitle=xtitle,report=FALSE))
  }
  return(output)
}
#'@export
setIGNORErecords_IQRdataGENERAL <- function(data,records,filename=NULL) {
  if (!is_IQRdataGENERAL(data))
    stopIQR("input argument is not an IQRdataGENERAL object")
  ignoreTable__ <- do.call(rbind,lapply(seq_along(records), function (k) {
    if (length(records[[k]])==0) {
      stopIQR(paste0("No entries in list entry ",names(records)[k]," of the ignored records list"))
    }
    data.frame(IXGDF=records[[k]],IGNORE.REASON=names(records)[k],stringsAsFactors=FALSE,row.names=NULL)
  }))
  ix__ <- ignoreTable__$IXGDF[duplicated(ignoreTable__$IXGDF)]
  if (length(ix__) > 0) {
    message("Concatenating multiple reasons for record(s): ", paste0(ix__, collapse = ","))
    ignoreTable__ <- plyr::ddply(ignoreTable__, ~IXGDF, function(y__) {
      out__ <- y__[1,]
      out__$IGNORE.REASON <- paste0(y__$IGNORE.REASON, collapse = ";")
      out__
    })
  }
  if (!is.null(ignoreTable__)) ignoreTable__ <- dplyr::arrange(ignoreTable__,IXGDF)
  ixnotpresent__ <- ignoreTable__$IXGDF[!(ignoreTable__$IXGDF %in% data$IXGDF)]
  if (length(ixnotpresent__) > 0)
    stopIQR(paste0("The following IXGDFs are not present in the dataset:\n    ",paste0(ixnotpresent__,collapse=" ")))
  ixdose__ <- unlist(sapply(ignoreTable__$IXGDF, function (x__) {
    if (data$EVID[data$IXGDF==x__] == 1) return(x__)
    return(NULL)
  }))
  if (length(ixdose__) > 0)
    stopIQR(paste0("The following defined IXGDF values contain dose records:\n    ",paste0(ixdose__,collapse=" ")))
  ixNonObs__ <- ignoreTable__$IXGDF[data$YTYPE[data$IXGDF %in% ignoreTable__$IXGDF] == 0]
  if (length(which(data$YTYPE[data$IXGDF %in% ignoreTable__$IXGDF] == 0)) > 0)
    warningIQR(paste0("setIGNORErecords_IQRdataGENERAL: The following defined IXGDF values contain non-observation records (EVID=0 and YTYPE=0):\n    ",paste0(ixNonObs__,collapse=" ")))
  data$MDV[data$IXGDF %in% ignoreTable__$IXGDF] <- 1
  dummy__ <- sapply(ignoreTable__$IXGDF, function(x__) {
    data$IGNORE[data$IXGDF==x__] <<- ignoreTable__$IGNORE.REASON[ignoreTable__$IXGDF==x__]
  })
  xtable <- data.frame(data[data$IXGDF %in% ignoreTable__$IXGDF,c("IXGDF","USUBJID","NAME","TIME","TAD","EVID","DV","MDV","IGNORE")],stringsAsFactors=FALSE)
  if (nrow(xtable)==0) xtable <- data.frame(IXGDF="-",USUBJID="-",NAME="-",TIME="-",TAD="-",EVID="-",DV="-",MDV="-",IGNORE="-")
  xtable <- dplyr::arrange(xtable,IXGDF)
  Nremoved__ <- nrow(ignoreTable__)
  if (is.null(Nremoved__)) Nremoved__ = 0
  xtitle <- paste0("N=",Nremoved__," observation records have been set to MDV=1 and an IGNORE reason was set")
  xfooter <- paste0("Rule for IGNORE: user defined input")
  if (!is.null(filename)) {
    IQRoutputTable(xtable=xtable,xfooter=xfooter,xtitle=xtitle,filename=filename,report=TRUE)
  } else {
    print(IQRoutputTable(xtable=xtable,xfooter=xfooter,xtitle=xtitle,report=FALSE))
  }
  return(data)
}
#'@export
setMissingDVobsRecordsIGNORE_IQRdataGENERAL <- function(data,filename=NULL) {
  if (!is_IQRdataGENERAL(data))
    stopIQR("input argument is not an IQRdataGENERAL object")
  output__ <- data
  ix_ignore__ <- output__$EVID==0 & is.na(output__$DV)
  output__$MDV[ix_ignore__] <- 1
  output__$IGNORE[ix_ignore__ & is.na(output__$IGNORE)] <- "Missing value"
  dataIGNORE__ <- as.data.frame(output__[ix_ignore__,])
  xtable__ <- dataIGNORE__[,c("IXGDF","USUBJID","NAME","TIME","DV","MDV","IGNORE")]
  if (nrow(xtable__)==0) xtable__ <- data.frame(IXGDF="-",USUBJID="-",NAME="-",TIME="-",DV="-",MDV="-",IGNORE="-")
  xtable__ <- dplyr::arrange(xtable__,IXGDF)
  xtitle__ <- paste0("N=",nrow(dataIGNORE__),' observation records with missing DV have been set to ignore (MDV=1, IGNORE="Missing value")')
  xfooter__ <- paste0("Rule for ignoring: EVID==0 & is.na(DV)")
  if (!is.null(filename)) {
    IQRoutputTable(xtable=xtable__,xfooter=xfooter__,xtitle=xtitle__,filename=filename,report=TRUE)
  } else {
    print(IQRoutputTable(xtable=xtable__,xfooter=xfooter__,xtitle=xtitle__,report=FALSE))
  }
  return(output__)
}
#'@export
rmMissingTIMEobsRecords_IQRdataGENERAL <- function(data,filename=NULL) {
  if (!is_IQRdataGENERAL(data))
    stopIQR("input argument is not an IQRdataGENERAL object")
  output__ <- data
  ix_ignore__ <- output__$EVID==0 & is.na(output__$TIME)
  dataIGNORE__ <- as.data.frame(output__[ix_ignore__,])
  output__ <- output__[!ix_ignore__,]
  xtable__ <- dataIGNORE__[,c("IXGDF","USUBJID","NAME","TIME","DV")]
  if (nrow(xtable__)==0) xtable__ <- data.frame(IXGDF="-",USUBJID="-",NAME="-",TIME="-",DV="-")
  xtable__ <- dplyr::arrange(xtable__,IXGDF)
  xtitle__ <- paste0("N=",nrow(dataIGNORE__),' observation records with missing TIME have been removed from the dataset.')
  xfooter__ <- paste0("Rule for removal: EVID==0 & is.na(TIME)")
  if (!is.null(filename)) {
    IQRoutputTable(xtable=xtable__,xfooter=xfooter__,xtitle=xtitle__,filename=filename,report=TRUE)
  } else {
    print(IQRoutputTable(xtable=xtable__,xfooter=xfooter__,xtitle=xtitle__,report=FALSE))
  }
  return(output__)
}
#'@export
handleSameTimeObs_IQRdataGENERAL <- function(data, timestep = 0.0001) {
  if (!is_IQRdataGENERAL(data))
    stopIQR("input argument is not an IQRdataGENERAL object")
  out <- do.call(rbind,lapply(split(data,data$USUBJID), function (x) {
    outx__ <- do.call(rbind,lapply(split(x,x$NAME), function (y) {
      if (y$EVID[1]==0) {
        yTIMEna__ <- y[is.na(y$TIME),]
        yTIME__ <- y[!is.na(y$TIME),]
        if (length(unique(yTIME__$TIME)) != length(yTIME__$TIME)) {
          outy__ <- do.call(rbind,lapply(split(yTIME__,yTIME__$TIME), function (z) {
            if (length(z$TIME)>1) {
              delta     <- seq(0,by=timestep,length.out=length(z$TIME))
              z$TIME    <- z$TIME+delta
              z$TIMEPOS <- z$TIMEPOS+delta
              z$TAD     <- z$TAD+delta
            }
            z
          }))
          outy__ <- rbind(outy__,yTIMEna__)
        } else {
          outy__ <- y
        }
      } else {
        outy__ <- y
      }
      outy__
    }))
    outx__
  }))
  if ("STUDY" %in% names(out)) {
    if ("TYPENAME" %in% names(out)) {
      output <- dplyr::arrange(out,STUDY,USUBJID,TIME,TYPENAME,NAME)
    } else {
      output <- dplyr::arrange(out,STUDY,USUBJID,TIME,NAME)
    }
  } else {
    if ("TYPENAME" %in% names(out)) {
      output <- dplyr::arrange(out,USUBJID,TIME,TYPENAME,NAME)
    } else {
      output <- dplyr::arrange(out,USUBJID,TIME,NAME)
    }
  }
  attributes(output) <- attributes(data)
  return(output)
}
#'@export
rmAMT0_IQRdataGENERAL <- function(data, filename=NULL) {
  if (!is_IQRdataGENERAL(data))
    stopIQR("input argument is not an IQRdataGENERAL object")
  dataREMOVE__ <- as.data.frame(data[data$EVID==1 & data$AMT==0,])
  xtable <- dataREMOVE__[,c("IXGDF","USUBJID","NAME","TIME","EVID","AMT")]
  if (nrow(xtable)==0) xtable <- data.frame(IXGDF="-",USUBJID="-",NAME="-",TIME="-",EVID="-",AMT="-")
  xtable <- dplyr::arrange(xtable,IXGDF)
  xtitle <- paste0("N=",nrow(dataREMOVE__)," dose records with AMT=0 have been removed")
  xfooter <- paste0("Rule for removal: EVID==1 & AMT=0")
  if (!is.null(filename)) {
    IQRoutputTable(xtable=xtable,xfooter=xfooter,xtitle=xtitle,filename=filename,report=TRUE)
  } else {
    print(IQRoutputTable(xtable=xtable,xfooter=xfooter,xtitle=xtitle,report=FALSE))
  }
  output <- data[!(data$EVID==1 & data$AMT==0),]
  return(output)
}
#'@export
rmNOobsSUB_IQRdataGENERAL <- function(data, filename=NULL) {
  if (!is_IQRdataGENERAL(data))
    stopIQR("input argument is not an IQRdataGENERAL object")
  noObsSubject__ <- noObsIndiv_IQRdataGENERAL(data)
  if (length(noObsSubject__)>0) {
    xtable <- data.frame(USUBJID=noObsSubject__,REMOVAL.REASON="No or no MDV=0 observations")
  } else {
    xtable <- data.frame(USUBJID="-",REMOVAL.REASON="-")
  }
  xtable <- dplyr::arrange(xtable,USUBJID)
  xtitle <- paste0("N=",length(noObsSubject__)," subjects without MDV=0 observations have been removed")
  xfooter <- paste0("Rule for removal: No observations in subject. Observations defined by EVID=0 & MDV=0 & YTYYPE>0")
  if (!is.null(filename)) {
    IQRoutputTable(xtable=xtable,xfooter=xfooter,xtitle=xtitle,filename=filename,report=TRUE)
  } else {
    print(IQRoutputTable(xtable=xtable,xfooter=xfooter,xtitle=xtitle,report=FALSE))
  }
  output <- data[!(data$USUBJID %in% noObsSubject__),]
  return(output)
}
#'@export
rmPLACEBO_IQRdataGENERAL <- function(data, filename=NULL) {
  if (!is_IQRdataGENERAL(data))
    stopIQR("input argument is not an IQRdataGENERAL object")
  placeboSubject__ <- placeboIndiv_IQRdataGENERAL(data)
  if (length(placeboSubject__)>0) {
    xtable <- data.frame(USUBJID=placeboSubject__,REMOVAL.REASON="Placebo Subject")
  } else {
    xtable <- data.frame(USUBJID="-",REMOVAL.REASON="-")
  }
  xtable <- dplyr::arrange(xtable,USUBJID)
  xtitle <- paste0("N=",length(placeboSubject__)," placebo subjects have been removed")
  xfooter <- paste0("Rule for removal: subject has no dose events or all dose events have AMT=0")
  if (!is.null(filename)) {
    IQRoutputTable(xtable=xtable,xfooter=xfooter,xtitle=xtitle,filename=filename,report=TRUE)
  } else {
    print(IQRoutputTable(xtable=xtable,xfooter=xfooter,xtitle=xtitle,report=FALSE))
  }
  output <- data[!(data$USUBJID %in% placeboSubject__),]
  return(output)
}
#'@export
rmNonTask_IQRdataGENERAL <- function(data, filename=NULL) {
  if (!is_IQRdataGENERAL(data))
    stopIQR("Input argument is not an IQRdataGENERAL object")
  validRecordNAMEs__ <- unique(data$NAME[data$EVID==1 | data$EVID==0 & data$YTYPE>0])
  dataREMOVE__ <- as.data.frame(data[!(data$NAME %in% validRecordNAMEs__),])
  xtable <- dataREMOVE__[,c("IXGDF","USUBJID","NAME","TIME","VALUE","EVID","YTYPE")]
  if (nrow(xtable)==0) xtable <- data.frame(IXGDF="-",USUBJID="-",NAME="-",TIME="-",VALUE="-",EVID="-",YTYPE="-")
  xtable <- dplyr::arrange(xtable,IXGDF)
  xtitle <- paste0("N=",nrow(dataREMOVE__)," non-dose and non-observation records have been removed")
  xfooter <- paste0("Rule for removal: !(EVID==1 | EVID==0 & YTYPE>0)")
  if (!is.null(filename)) {
    IQRoutputTable(xtable=xtable,xfooter=xfooter,xtitle=xtitle,filename=filename,report=TRUE)
  } else {
    print(IQRoutputTable(xtable=xtable,xfooter=xfooter,xtitle=xtitle,report=FALSE))
  }
  output <- data[data$NAME %in% validRecordNAMEs__,]
  return(output)
}
#'@export
rmIGNOREd_IQRdataGENERAL <- function(data, filename=NULL) {
  if (!is_IQRdataGENERAL(data))
    stopIQR("Input argument is not an IQRdataGENERAL object")
  if (length(which(data$MDV[!is.na(data$IGNORE)]==0)) > 0)
    stopIQR("Not all records with a non empty IGNORE entry are set to MDV=1")
  dataIGNORE__ <- as.data.frame(data[!is.na(data$IGNORE),])
  xtable <- dataIGNORE__[,c("IXGDF","USUBJID","NAME","TIME","VALUE","IGNORE")]
  if (nrow(xtable)==0) xtable <- data.frame(IXGDF="-",USUBJID="-",NAME="-",TIME="-",IGNORE="-")
  xtable <- dplyr::arrange(xtable,IXGDF)
  xtitle <- paste0("N=",nrow(dataIGNORE__)," IGNOREd records have been removed")
  xfooter <- paste0("Rule for removal: entry in IGNORE column is NOT NA")
  if (!is.null(filename)) {
    IQRoutputTable(xtable=xtable,xfooter=xfooter,xtitle=xtitle,filename=filename,report=TRUE)
  } else {
    print(IQRoutputTable(xtable=xtable,xfooter=xfooter,xtitle=xtitle,report=FALSE))
  }
  output <- data[is.na(data$IGNORE),]
  return(output)
}
getColumnsInfo_IQRdataGENERAL <- function () {
  list(
    numericColumns  = c("IXGDF","IND","STUDYN","TRT","TRTR","NT","TIME","PROFTIME","DURATION","VALUE","ULOQ","LLOQ","II","ADDL","AESER","AEDRGREL","OCC"),
    requiredColumns = c("USUBJID", "TIMEUNIT", "TIME", "NAME", "VALUE", "UNIT", "ROUTE"),
    namesOrder      = c("IXGDF","IGNORE","USUBJID","CENTER","SUBJECT","INDNAME","IND","COMPOUND",
                        "STUDY","STUDYN","STUDYDES","PART","EXTENS","TRTNAME","TRT","TRTNAMER","TRTR",
                        "VISIT","VISNAME","BASE","SCREEN","STDTC","ENDTC","TIMEUNIT","DATEDAY","DATETIME","NT","TIME","PROFNR","PROFTIME","DURATION",
                        "TYPENAME","NAME","VALUE","VALUETXT","UNIT","ULOQ","LLOQ","ROUTE","II","ADDL","OCC",
                        "AE","AEGRADE","AESER","AEDRGREL","COMMENT"),
    requiredColumnsNLME = c("ID","TIMEPOS","EVID","MDV","CENS","AMT","DV",
                            "TINF","RATE","ADM","YTYPE","TAD","DOSE")
  )
}
#'@export
IQRdataGENERAL <- function(input,
                           doseNAMES=NULL,
                           obsNAMES=NULL,
                           cov0=NULL,
                           covT=NULL,
                           cat0=NULL,
                           catT=NULL,
                           covInfoAdd=NULL,
                           catInfoAdd=NULL,
                           methodBLLOQ="M1",
                           FLAGforceOverwriteNLMEcols=TRUE,
                           FLAGtaskEventsOnly=TRUE,
                           FLAGnoNAlocf=FALSE) {
  if (!is.null(covInfoAdd)) {
    required__ <- c("COLNAME","NAME","UNIT","TIME.VARYING")
    if (length(setdiff(required__,names(covInfoAdd))) > 0) {
      stopIQR("Names in covInfoAdd list do not match the requird ones: COLNAME,NAME,UNIT,TIME.VARYING")
    }
  }
  if (!is.null(catInfoAdd)) {
    required__ <- c("COLNAME","NAME","UNIT","VALUETXT","VALUES","TIME.VARYING")
    if (length(setdiff(required__,names(catInfoAdd))) > 0) {
      stopIQR("Names in catInfoAdd list do not match the requird ones: COLNAME,NAME,UNIT,VALUETXT,VALUES,TIME.VARYING")
    }
    for (icol__ in catInfoAdd$COLNAME) {
      tmpVal__ <- aux_explode(catInfoAdd$VALUES[catInfoAdd$COLNAME == icol__])
      tmpValTxt__ <- aux_explode(catInfoAdd$VALUETXT[catInfoAdd$COLNAME == icol__])
      if (length(tmpVal__) != length(tmpValTxt__))
        stopIQR(paste0("Number of numerical values and text values given in catInfoAdd does not match for ", icol__))
    }
  }
  if (length(cov0)==0) cov0 <- NULL
  if (length(covT)==0) covT <- NULL
  if (length(cat0)==0) cat0 <- NULL
  if (length(catT)==0) catT <- NULL
  covNAMEScheck <- names(c(cov0,covT,cat0,catT))
  if (length(unique(covNAMEScheck)) != length(covNAMEScheck))
    stopIQR("Defined covariate column names contain same name more than once")
  if (is.character(input)) {
    if(!file.exists(input))
      stopIQR("Trouble loading the data file. Please check if provided datafile argument is correct")
    data <- data.table::fread(file = input,na.strings=c(".","","NA","NaN"), strip.white = TRUE)
  } else {
    if (is.data.frame(input)) {
      data <- input
    } else {
      stopIQR("datafile argument needs to be a path to a csv file or a data.frame object")
    }
  }
  data <- data.frame(
    lapply(data, function (col) {
      if (is.character(col) || is.factor(col)){
        if (any(grepl(",",col, fixed = TRUE))) {
          warningIQR("Some entries in the dataset contain commata ',', which are replaced by ' '.")
          col <- gsub(","," ",col)
        }
      }
      col
    }),stringsAsFactors = FALSE
  )
  requiredColumns__ <- getColumnsInfo_IQRdataGENERAL()$requiredColumns
  missingColumns__ <- setdiff(requiredColumns__,names(data))
  if (length(missingColumns__) > 0)
    stopIQR(paste0("Missing required columns in the dataset:\n    ",paste0(missingColumns__,collapse="\n    ")))
  if ("DURATION" %in% names(data)) {
    if (any(is.na(data$DURATION))) stopIQR("DURATION column not allowed to contain NA entries")
  }
  if ("TINF" %in% names(data)) {
    if (any(is.na(data$TINF))) stopIQR("TINF column not allowed to contain NA entries")
  }
  if ("YTYPE" %in% names(data)) {
    if (any(is.na(data$YTYPE))) stopIQR("YTYPE column not allowed to contain NA entries. Dosing records have YTYPE = 0.")
  }
  if (is.null(doseNAMES)) {
    doseNAMES <- unique(data$NAME[!is.na(data$ROUTE)])
  }
  if (is.null(obsNAMES)) {
    obsNAMES <- unique(data$NAME[is.na(data$ROUTE)])
  }
  for (k__ in seq_along(doseNAMES)) {
    if (!(doseNAMES[k__] %in% data$NAME))
      stopIQR("Not all provided doseNAMES are present in the NAME column of the dataset")
  }
  for (k__ in seq_along(obsNAMES)) {
    if (!(obsNAMES[k__] %in% data$NAME))
      stopIQR("Not all provided obsNAMES are present in the NAME column of the dataset")
  }
  is.factor <- sapply(data, function(x) inherits(x, "factor"))
  if (any(is.factor))
    stopIQR("Data contains factor variables. Please use IQRloadCSVdata() to read data from file.")
  if (!is.null(catInfoAdd)) {
    if (any(sapply(data[,catInfoAdd$COLNAME, drop = FALSE], is.character))) {
      charcol__ <- sapply(data[,catInfoAdd$COLNAME, drop = FALSE], is.character)
      charcol__ <- names(charcol__)[charcol__]
      for (icol__ in charcol__) {
        tmpVal__ <- aux_explode(catInfoAdd$VALUES[catInfoAdd$COLNAME == icol__])
        tmpValTxt__ <- aux_explode(catInfoAdd$VALUETXT[catInfoAdd$COLNAME == icol__])
        if (!all(unique(stats::na.omit(data[[icol__]])) %in% tmpValTxt__))
          stopIQR("Given categorical covariate column contains text values for which no numerical value is defined.")
        data[[icol__]] <- as.numeric(as.character(factor(data[[icol__]], levels = tmpValTxt__, labels = tmpVal__)))
      }
    }
  }
  data <- generalDataHandleMissingColums(data)
  numericColumns__ <- getColumnsInfo_IQRdataGENERAL()$numericColumns
  for (k__ in seq_along(numericColumns__)) {
    if (numericColumns__[k__] %in% names(data))
      suppressWarnings(data[[numericColumns__[k__]]] <- as.numeric(data[[numericColumns__[k__]]]))
  }
  data$TIMEUNIT <- toupper(data$TIMEUNIT)
  data$ROUTE <- toupper(data$ROUTE)
  if ("STUDY" %in% names(data)) {
    if ("TYPENAME" %in% names(data)) {
      data <- dplyr::arrange(data,STUDY,USUBJID,TIME,TYPENAME,NAME)
    } else {
      data <- dplyr::arrange(data,STUDY,USUBJID,TIME,NAME)
    }
  } else {
    if ("TYPENAME" %in% names(data)) {
      data <- dplyr::arrange(data,USUBJID,TIME,TYPENAME,NAME)
    } else {
      data <- dplyr::arrange(data,USUBJID,TIME,NAME)
    }
  }
  data <- generalDataMapVALUETXT2VALUE(data)
  data <- generalData_IDcolumn(data,FLAGforceOverwriteNLMEcols)
  data <- generalData_TIMEPOScolumn(data,FLAGforceOverwriteNLMEcols)
  data <- generalData_EVIDcolumn(data,doseNAMES,FLAGforceOverwriteNLMEcols)
  data <- generalData_MDVcolumn(data,doseNAMES,FLAGforceOverwriteNLMEcols)
  data <- generalData_CENScolumn(data,FLAGforceOverwriteNLMEcols)
  data <- generalData_AMTcolumn(data,doseNAMES,FLAGforceOverwriteNLMEcols)
  data <- generalData_DVcolumn(data,doseNAMES,FLAGforceOverwriteNLMEcols)
  data <- generalData_TINFcolumn(data,doseNAMES,FLAGforceOverwriteNLMEcols)
  data <- generalData_RATEcolumn(data,doseNAMES,FLAGforceOverwriteNLMEcols)
  data <- generalData_ADMcolumn(data,doseNAMES,FLAGforceOverwriteNLMEcols)
  data <- generalData_TADcolumns(data,doseNAMES,FLAGforceOverwriteNLMEcols)
  data <- generalData_DOSEcolumns(data,doseNAMES,FLAGforceOverwriteNLMEcols)
  data <- generalData_YTYPEcolumn(data,obsNAMES,FLAGforceOverwriteNLMEcols)
  ixmissingDV__ <- which(data$EVID==0 & data$MDV==0 & is.na(data$DV))
  data$MDV[ixmissingDV__] <- 1
  data$IGNORE[ixmissingDV__] <- "Missing value"
  ixmissingTIME__ <- which(data$EVID==0 & data$MDV==0 & is.na(data$TIME))
  data$MDV[ixmissingTIME__] <- 1
  data$IGNORE[ixmissingTIME__] <- "Missing time"
  data <- generalDataTimeIndependentCovariates(data,cov0,cat0)
  data <- generalDataTimeDependentCovariates(data,covT,catT,FLAGnoNAlocf)
  namesOrderGeneral__ <- getColumnsInfo_IQRdataGENERAL()$namesOrder
  namesOrderGeneralPresent__ <- namesOrderGeneral__[namesOrderGeneral__ %in% names(data)]
  namesOrder__ <- c(namesOrderGeneralPresent__,getColumnsInfo_IQRdataGENERAL()$requiredColumnsNLME)
  dataOrdered__ <- data[,namesOrder__]
  if (!is.null(c(cov0,cat0))) dataOrdered__ <- cbind(dataOrdered__, data[,names(c(cov0,cat0)),drop=FALSE])
  if (!is.null(c(covT,catT))) dataOrdered__ <- cbind(dataOrdered__, data[,names(c(covT,catT)),drop=FALSE])
  addNames__ <- setdiff(names(data),names(dataOrdered__))
  dataOrdered__ <- cbind(dataOrdered__, data[,addNames__,drop=FALSE])
  output <- dataOrdered__
  rownames(output) <- NULL
  attr(output,"class")                 <- c("IQRdataGENERAL", attr(output,"class"))
  output <- blloq_IQRdataGENERAL(output,methodBLLOQ)
  covInfo <- data.frame(COLNAME=names(c(cov0,covT)),NAME=sapply(c(cov0,covT),function(y) y),stringsAsFactors=FALSE,row.names=NULL)
  catInfo <- data.frame(COLNAME=names(c(cat0,catT)),NAME=sapply(c(cat0,catT),function(y) y),stringsAsFactors=FALSE,row.names=NULL)
  if (nrow(covInfo) > 0) covInfo <- dplyr::left_join(covInfo,unique(output[,c("NAME","UNIT")]),by="NAME")
  if (nrow(catInfo) > 0) catInfo <- dplyr::left_join(catInfo,unique(output[,c("NAME","UNIT")]),by="NAME")
  value_text_Mapping <- mappingVALUETXT_IQRdataGENERAL(output)
  if (nrow(covInfo)==0) covInfo <- NULL
  if (nrow(catInfo)>0) {
    catMapInfo <- do.call(rbind,lapply(1:nrow(catInfo), function (k__) {
      name <- catInfo$NAME[k__]
      mapname <- value_text_Mapping[value_text_Mapping$NAME==name,c("VALUETXT","VALUE")]
      if (!is.null(mapname)) {
        if (nrow(mapname)>0) {
          valtext <- paste0(mapname$VALUETXT,collapse=",")
          values  <- paste0(mapname$VALUE,collapse=",")
        } else {
          values  <- paste0(sort(unique(data$VALUE[data$NAME==name])),collapse=",")
          valtext <- paste0(rep("UNKNOWN",length(unique(data$VALUE[data$NAME==name]))),collapse=",")
        }
      } else {
        values  <- paste0(sort(unique(data$VALUE[data$NAME==name])),collapse=",")
        valtext <- paste0(rep("UNKNOWN",length(unique(data$VALUE[data$NAME==name]))),collapse=",")
      }
      data.frame(NAME=name,VALUETXT=valtext,VALUES=values,row.names=NULL,stringsAsFactors=FALSE)
    }))
  } else {
    catMapInfo <- NULL
    catInfo <- NULL
  }
  if (!is.null(catInfo)) catInfo <- dplyr::left_join(catInfo,catMapInfo,by="NAME")
  if (!is.null(covInfo)) {
    covInfo$TIME.VARYING <- FALSE
    covInfo$TIME.VARYING[covInfo$COLNAME %in% names(covT)] <- TRUE
  }
  if (!is.null(catInfo)) {
    catInfo$TIME.VARYING <- FALSE
    catInfo$TIME.VARYING[catInfo$COLNAME %in% names(catT)] <- TRUE
  }
  if (is.null(catInfo)) catInfo <- list()
  if (all(c("STUDYN","STUDY") %in% names(output))) {
    if (length(unique(output$STUDY)) > 1) {
      if (!"STUDYN" %in% catInfoAdd$COLNAME) {
        catInfoAdd$COLNAME <- c(catInfoAdd$COLNAME, "STUDYN")
        catInfoAdd$NAME <- c(catInfoAdd$NAME, "Study")
        catInfoAdd$UNIT <- c(catInfoAdd$UNIT, "-")
        catInfoAdd$VALUETXT <- c(catInfoAdd$VALUETXT, paste0(unique(output$STUDY),collapse = ","))
        catInfoAdd$VALUES <- c(catInfoAdd$VALUES, paste0(unique(output$STUDYN),collapse = ","))
        catInfoAdd$TIME.VARYING <- c(catInfoAdd$TIME.VARYING, FALSE)
      }
    }
  }
  if (all(c("TRT","TRTNAME") %in% names(output))) {
    if (length(unique(output$TRTNAME)) > 1) {
      if (!"TRT" %in% catInfoAdd$COLNAME) {
        catInfoAdd$COLNAME <- c(catInfoAdd$COLNAME, "TRT")
        catInfoAdd$NAME <- c(catInfoAdd$NAME, "TRTNAME")
        catInfoAdd$UNIT <- c(catInfoAdd$UNIT, "-")
        catInfoAdd$VALUETXT <- c(catInfoAdd$VALUETXT, paste0(unique(output$TRTNAME),collapse = ","))
        catInfoAdd$VALUES <- c(catInfoAdd$VALUES, paste0(unique(output$TRT),collapse = ","))
        catInfoAdd$TIME.VARYING <- c(catInfoAdd$TIME.VARYING, FALSE)
      }
    }
  }
  covInfo <- rbind(covInfo, data.frame(covInfoAdd,stringsAsFactors=FALSE,row.names=NULL))
  catInfo <- rbind(catInfo, data.frame(catInfoAdd,stringsAsFactors=FALSE,row.names=NULL))
  if (nrow(covInfo)==0) covInfo <- NULL
  if (nrow(catInfo)==0) catInfo <- NULL
  if (length(unique(covInfo$COLNAME)) != length(covInfo$COLNAME))
    stopIQR("Same covariates defined within cov0, covT, or covInfoAdd. Other possible reason: a covariate is listed with different units.")
  if (length(unique(catInfo$COLNAME)) != length(catInfo$COLNAME))
    stopIQR("Same covariates defined within cat0, catT, or catInfoAdd. Other possible reason: a covariate is listed with different units.")
  if ("STUDY" %in% names(data)) {
    if ("TYPENAME" %in% names(data)) {
      data <- dplyr::arrange(data,STUDY,USUBJID,TIME,TYPENAME,NAME)
      message("Sorting by STUDY, USUBJID, TIME, TYPENAME, NAME")
    } else {
      data <- dplyr::arrange(data,STUDY,USUBJID,TIME,NAME)
      message("Sorting by STUDY, USUBJID, TIME, NAME")
    }
  } else {
    if ("TYPENAME" %in% names(data)) {
      data <- dplyr::arrange(data,USUBJID,TIME,TYPENAME,NAME)
      message("Sorting by USUBJID, TIME, TYPENAME, NAME")
    } else {
      data <- dplyr::arrange(data,USUBJID,TIME,NAME)
      message("Sorting by USUBJID, TIME, NAME")
    }
  }
  AEnames__ <- unique(data$NAME[data$AE==1])
  attr(output,"doseNAMES")    <- doseNAMES
  attr(output,"obsNAMES")     <- obsNAMES
  attr(output,"aeNAMES")      <- AEnames__ 
  attr(output,"covInfo")      <- covInfo
  attr(output,"catInfo")      <- catInfo
  if (FLAGtaskEventsOnly) {
    output <- output[output$NAME %in% c(doseNAMES,obsNAMES),]
  }
  check_IQRdataGENERAL(output)
  return(output)
}
#'@export
check_IQRdataGENERAL <- function(data,FLAGreturnText=FALSE) {
  if (!is_IQRdataGENERAL(data))
    stopIQR("Provided input argument is not an IQRdataGENERAL object")
  checkInfoText_ERROR   <- ""
  checkInfoText_WARNING <- ""
  checkInfoText_MINOR   <- ""
  AEGRADE <- data$AEGRADE[data$AE==1]
  if (!all(AEGRADE %in% c(1,2,3,4,5)))
    checkInfoText_ERROR <- paste0(checkInfoText_ERROR,sprintf('GLOBAL LEVEL: AEs present. Not all entries in AEGRADE (for AE=1) lie between 1 and 5\n'))
  if (any(!is.na(data$PROFNR[is.na(data$PROFTIME)])))
    checkInfoText_ERROR <- paste0(checkInfoText_ERROR,sprintf('GLOBAL LEVEL: There are PROFNR entries that have PROFTIME set to NA\n'))
  if (any(!is.na(data$PROFNR[is.na(data$PROFTIME)])))
    checkInfoText_ERROR <- paste0(checkInfoText_ERROR,sprintf('GLOBAL LEVEL: There are PROFNR entries that have PROFTIME set to NA\n'))
  timeunit <- unique(data$TIMEUNIT)
  if (length(timeunit) > 1)
    checkInfoText_ERROR <- paste0(checkInfoText_ERROR,sprintf('GLOBAL LEVEL: Different time units are present in the TIMEUNIT column\n'))
  ix <- which(!(timeunit %in% c("HOURS", "MINUTES", "DAYS", "SECONDS", "WEEKS", "MONTHS", "YEARS")))
  if (length(ix)>0)
    checkInfoText_ERROR <- paste0(checkInfoText_ERROR,sprintf('GLOBAL LEVEL: TIMEUNIT column contains not acceptable entries\n              (allowed are: "HOURS", "MINUTES", "DAYS", "SECONDS", "WEEKS", "MONTHS", "YEARS")\n'))
  if (length(setdiff(sort(unique(data$MDV)),c(0,1)))>0)
    checkInfoText_ERROR <- paste0(checkInfoText_WARNING,sprintf('GLOBAL LEVEL: MDV column contains wrong contents (only 0 and 1 allowed)\n'))
  if (length(setdiff(sort(unique(data$EVID)),c(0,1)))>0)
    checkInfoText_ERROR <- paste0(checkInfoText_WARNING,sprintf('GLOBAL LEVEL: EVID column contains wrong contents (only 0 and 1 allowed)\n'))
  if (length(which(is.na(unique(data$IGNORE[data$MDV==1 & data$EVID==0])))) > 0)
    checkInfoText_ERROR <- paste0(checkInfoText_WARNING,sprintf('GLOBAL LEVEL: MDV==1 & EVID==0 entries do not have an entry in IGNORE\n'))
  if (length(which(!is.na(unique(data$IGNORE[data$MDV==0 & data$EVID==0])))) > 0)
    checkInfoText_ERROR <- paste0(checkInfoText_WARNING,sprintf('GLOBAL LEVEL: IGNORE value for MDV=0 and EVID=0 entries must be undefined (NA)\n'))
  if (sum(is.na(data$TIME)) > 0)
    checkInfoText_WARNING <- paste0(checkInfoText_WARNING,sprintf('GLOBAL LEVEL: TIME column contains undefined (NA) entries\n'))
  if (sum(is.na(data$NT[data$AE==0])) > 0)
    checkInfoText_MINOR <- paste0(checkInfoText_MINOR,sprintf('GLOBAL LEVEL: NT column contains undefined (NA) entries\n'))
  if (sum(is.na(data$EXTENS)) > 0)
    checkInfoText_MINOR <- paste0(checkInfoText_MINOR,sprintf('GLOBAL LEVEL: EXTENS column contains undefined (NA) entries\n'))
  if (sum(is.na(data$CENTER)) > 0)
    checkInfoText_MINOR <- paste0(checkInfoText_MINOR,sprintf('GLOBAL LEVEL: CENTER column contains undefined (NA) entries\n'))
  if (sum(is.na(data$VISIT[data$AE==0])) > 0)
    checkInfoText_MINOR <- paste0(checkInfoText_MINOR,sprintf('GLOBAL LEVEL: VISIT column contains undefined (NA) entries\n'))
  if (sum(is.na(data$BASE)) > 0)
    checkInfoText_WARNING <- paste0(checkInfoText_WARNING,sprintf('GLOBAL LEVEL: BASE column contains undefined (NA) entries\n'))
  if (sum(is.na(data$SCREEN)) > 0)
    checkInfoText_WARNING <- paste0(checkInfoText_WARNING,sprintf('GLOBAL LEVEL: SCREEN column contains undefined (NA) entries\n'))
  route <- unique(data$ROUTE[!is.na(data$ROUTE)])
  test <- setdiff(route,c("IV","SUBCUT","ORAL","INHALED","INTRAMUSCULAR","INTRAARTICULAR","RECTAL","TOPICAL","GENERAL_IV","GENERAL_ABS1","GENERAL_ABS0"))
  if (length(test)>0)
    checkInfoText_ERROR <- paste0(checkInfoText_ERROR,sprintf('GLOBAL LEVEL: ROUTE column contains not acceptable entries\n              (allowed are: "IV","SUBCUT","ORAL","INHALED","INTRAMUSCULAR","INTRAARTICULAR","RECTAL",\n              "TOPICAL","GENERAL_IV","GENERAL_ABS1","GENERAL_ABS0")\n'))
  if (length(which(is.na(data$VALUE[data$AE==0]) & is.na(data$VALUETXT[data$AE==0]))) > 0)
    checkInfoText_WARNING <- paste0(checkInfoText_WARNING,sprintf('GLOBAL LEVEL: Records are present that have neither VALUE nor VALUETXT defined\n'))
  colname.is.alphanumeric <- grepl("^[[:alnum:]]+$", names(data))
  if (any(!colname.is.alphanumeric))
    checkInfoText_WARNING <- paste0(checkInfoText_WARNING,sprintf('GLOBAL LEVEL: Some column names contain non-alphanumeric values.\n'))
  if ("OCC" %in% names(data)) {
    if (!is.numeric(data$OCC)) {
      checkInfoText_ERROR <- paste0(checkInfoText_ERROR,sprintf('GLOBAL LEVEL: OCC column is not numeric\n'))
    } else {
      if (!all(round(data$OCC)-data$OCC==0)) checkInfoText_ERROR <- paste0(checkInfoText_ERROR,sprintf('GLOBAL LEVEL: OCC column does not contain only integer values\n'))
      if (length(unique(data$OCC))<2) checkInfoText_WARNING <- paste0(checkInfoText_ERROR,sprintf('GLOBAL LEVEL: OCC column contains only one occasion\n'))
      if (NA %in% data$OCC) checkInfoText_ERROR <- paste0(checkInfoText_ERROR,sprintf('GLOBAL LEVEL: OCC column contains NA values\n'))
    }
  }
  if ("INDNAME" %in% names(data)) {
    dummy <- lapply(split(data,data$INDNAME), function (x) {
      if (length(unique(x$IND)) > 1)
        checkInfoText_ERROR <<- paste0(checkInfoText_ERROR,sprintf('INDICATION LEVEL (%s): IND column entries are not unique\n',x$INDNAME[1]))
    })
  }
  if (all(c("STUDY","STUDYN") %in% names(data))) {
    dummy <- lapply(split(data,data$STUDY), function (x) {
      if (length(unique(x$STUDYN)) > 1)
        checkInfoText_ERROR <<- paste0(checkInfoText_ERROR,sprintf('STUDY LEVEL (%s): STUDYN column entries are not unique\n',x$STUDY[1]))
      if (length(unique(x$STUDYDES)) > 1)
        checkInfoText_ERROR <<- paste0(checkInfoText_ERROR,sprintf('STUDY LEVEL (%s): STUDYDES column entries are not unique\n',x$STUDY[1]))
    })
  }
  if (all(c("TRTNAME","TRT") %in% names(data))) {
    dummy <- lapply(split(data,data$TRTNAME), function (x) {
      if (length(unique(x$TRT)) > 1)
        checkInfoText_ERROR <<- paste0(checkInfoText_ERROR,sprintf('TREATMENT LEVEL (%s): TRT column entries are not unique for TRTNAME\n',x$TRTNAME[1]))
    })
  }
  if (all(c("TRTNAMER","TRTR") %in% names(data))) {
    dummy <- lapply(split(data,data$TRTNAMER), function (x) {
      if (length(unique(x$TRTR)) > 1)
        checkInfoText_ERROR <<- paste0(checkInfoText_ERROR,sprintf('TREATMENT LEVEL (%s): TRTR column entries are not unique for TRTNAMER\n',x$TRTNAME[1]))
    })
  }
  dummy <- lapply(split(data,data$NAME), function (x) {
    if (length(unique(x$UNIT)) > 1)
      checkInfoText_ERROR <<- paste0(checkInfoText_ERROR,sprintf('NAME LEVEL (%s): UNIT column entries are not unique\n',x$NAME[1]))
  })
  dummy <- lapply(split(data,data$NAME), function (x) {
    ixNotNAvalue <- which(!is.na(x$VALUE))
    ixNotNAvaluetxt <- which(!is.na(x$VALUETXT))
    if (length(ixNotNAvalue)>0 & length(ixNotNAvaluetxt)>0) {
      if (length(c(setdiff(ixNotNAvalue,ixNotNAvaluetxt), setdiff(ixNotNAvaluetxt,ixNotNAvalue)))>0)
        checkInfoText_ERROR <<- paste0(checkInfoText_ERROR,sprintf('NAME LEVEL (%s): Sometimes VALUE and sometimes VALUETXT defined. Define either one for each NAME or both\n',x$NAME[1]))
    }
  })
  dataTemp <- data[!is.na(data$VALUE) & !is.na(data$VALUETXT),]
  dummy <- lapply(split(dataTemp,dataTemp$NAME), function (x) {
    values_txt <- unique(x$VALUETXT)
    lapply(values_txt, function (y) {
      datak <- x[x$VALUETXT==y,]
      if (length(unique(datak$VALUE))>1)
        checkInfoText_ERROR <<- paste0(checkInfoText_ERROR,sprintf('NAME LEVEL (%s): Used values for VALUE and VALUETXT do not match\n',x$NAME[1]))
    })
  })
  dummy <- lapply(split(data,data$USUBJID),function (x) {
    lapply(split(x, x$ADM), function (y) {
      y$ADM[is.na(y$ADM)] <- 0
      if (y$ADM[1] > 0) {
        if (length(y$TIME) != length(unique(y$TIME)))
          checkInfoText_ERROR <<- paste0(checkInfoText_ERROR,sprintf('SUBJECT LEVEL (%s): Subject has DOSE record of ADM "%d" at same TIME points\n',y$USUBJID[1],y$ADM[1]))
      }
    })
    lapply(split(x, x$NAME), function (y) {
      if (length(y$TIME) != length(unique(y$TIME)))
        checkInfoText_MINOR <<- paste0(checkInfoText_MINOR,sprintf('SUBJECT LEVEL (%s): Subject has records of NAME "%s" at same TIME points\n',y$USUBJID[1],y$NAME[1]))
      if (length(unique(y$LLOQ))>1)
        checkInfoText_MINOR <<- paste0(checkInfoText_MINOR,sprintf('SUBJECT LEVEL (%s): Subject has different LLOQ for NAME "%s"\n',y$USUBJID[1],y$NAME[1]))
      if (length(unique(y$ULOQ))>1) {
        checkInfoText_MINOR <<- paste0(checkInfoText_MINOR,sprintf('SUBJECT LEVEL (%s): Subject has different ULOQ for NAME "%s"\n',y$USUBJID[1],y$NAME[1]))
      }
    })
    if (sum(diff(x$TIME)<0,na.rm=TRUE))
      checkInfoText_ERROR <<- paste0(checkInfoText_ERROR,sprintf('SUBJECT LEVEL (%s): TIME not monotonously non-decreasing\n',x$USUBJID[1]))
    if (length(unique(x$CENTER))>1)
      checkInfoText_ERROR <<- paste0(checkInfoText_ERROR,sprintf('SUBJECT LEVEL (%s): Multiple different entries for CENTER present\n',x$USUBJID[1]))
    if (length(unique(x$SUBJECT))>1)
      checkInfoText_ERROR <<- paste0(checkInfoText_ERROR,sprintf('SUBJECT LEVEL (%s): Multiple different entries for SUBJECT present\n',x$USUBJID[1]))
    if (length(unique(x$INDNAME))>1)
      checkInfoText_ERROR <<- paste0(checkInfoText_ERROR,sprintf('SUBJECT LEVEL (%s): Multiple different entries for INDNAME present\n',x$USUBJID[1]))
    if (length(unique(x$IND))>1)
      checkInfoText_ERROR <<- paste0(checkInfoText_ERROR,sprintf('SUBJECT LEVEL (%s): Multiple different entries for IND present\n',x$USUBJID[1]))
    if (length(unique(x$COMPOUND))>1)
      checkInfoText_ERROR <<- paste0(checkInfoText_ERROR,sprintf('SUBJECT LEVEL (%s): Multiple different entries for COMPOUND present\n',x$USUBJID[1]))
    if (length(unique(x$STUDY))>1)
      checkInfoText_ERROR <<- paste0(checkInfoText_ERROR,sprintf('SUBJECT LEVEL (%s): Multiple different entries for STUDY present\n',x$USUBJID[1]))
    if (length(unique(x$STUDYN))>1)
      checkInfoText_ERROR <<- paste0(checkInfoText_ERROR,sprintf('SUBJECT LEVEL (%s): Multiple different entries for STUDYN present\n',x$USUBJID[1]))
    if (length(unique(x$STUDYDES))>1)
      checkInfoText_ERROR <<- paste0(checkInfoText_ERROR,sprintf('SUBJECT LEVEL (%s): Multiple different entries for STUDYDES present\n',x$USUBJID[1]))
    if (length(unique(x$PART))>1)
      checkInfoText_ERROR <<- paste0(checkInfoText_ERROR,sprintf('SUBJECT LEVEL (%s): Multiple different entries for PART present\n',x$USUBJID[1]))
    if (length(unique(x$EXTENS))>1)
      checkInfoText_ERROR <<- paste0(checkInfoText_ERROR,sprintf('SUBJECT LEVEL (%s): Multiple different entries for EXTENS present\n',x$USUBJID[1]))
    if (length(unique(x$TRTNAME))>1)
      checkInfoText_ERROR <<- paste0(checkInfoText_ERROR,sprintf('SUBJECT LEVEL (%s): Multiple different entries for TRTNAME present\n',x$USUBJID[1]))
    if (length(unique(x$TRT))>1)
      checkInfoText_ERROR <<- paste0(checkInfoText_ERROR,sprintf('SUBJECT LEVEL (%s): Multiple different entries for TRT present\n',x$USUBJID[1]))
    if (length(unique(x$TRTNAMER))>1)
      checkInfoText_ERROR <<- paste0(checkInfoText_ERROR,sprintf('SUBJECT LEVEL (%s): Multiple different entries for TRTNAMER present\n',x$USUBJID[1]))
    if (length(unique(x$TRTR))>1)
      checkInfoText_ERROR <<- paste0(checkInfoText_ERROR,sprintf('SUBJECT LEVEL (%s): Multiple different entries for TRTR present\n',x$USUBJID[1]))
  })
  if (FLAGreturnText) {
    output <- list(
      checkInfoText_MINOR = checkInfoText_MINOR,
      checkInfoText_WARNING = checkInfoText_WARNING,
      checkInfoText_ERROR = checkInfoText_ERROR
    )
    return(output)
  }
  if (nchar(checkInfoText_ERROR) > 0) {
    message(
      "\ncheck_IQRdataGENERAL: ERROR messages that need to be addressed\n==============================================================\n",
      checkInfoText_ERROR
    )
  }
  if (nchar(checkInfoText_WARNING) > 0) {
    message(
      "\ncheck_IQRdataGENERAL: WARNING messages that should be addressed\n===============================================================\n",
      checkInfoText_WARNING
    )
  }
  if (nchar(checkInfoText_MINOR) > 0) {
    message(
      "\ncheck_IQRdataGENERAL: MINOR messages that might be addressed\n============================================================\n",
      checkInfoText_MINOR
    )
  }
  if (nchar(checkInfoText_WARNING)) warningIQR("check_IQRdataGENERAL: Warnings present in general dataset - please check messages above")
  if (nchar(checkInfoText_ERROR)) warningIQR("check_IQRdataGENERAL: Errors present in general dataset - please check messages above")
  cat("\n\n")
}
generalDataHandleMissingColums <- function(data) {
  if (!("IXGDF" %in% names(data))) {
    data$IXGDF <- as.numeric(1:nrow(data))
    message("Adding default IXGDF column")
  }
  if (!("IGNORE" %in% names(data))) {
    data$IGNORE <- NA
    message("Adding default IGNORE column")
  }
  if ("INDNAME" %in% names(data)) {
    if (!("IND" %in% names(data))) {
      data$IND <- as.numeric(factor(data$INDNAME,levels=sort(unique(data$INDNAME))))
      message("Adding default IND column")
    }
  }
  if ("STUDY" %in% names(data)) {
    if (!("STUDYN" %in% names(data))) {
      data$STUDYN <- as.numeric(factor(data$STUDY,levels=sort(unique(data$STUDY))))
      message("Adding default STUDYN column")
    }
  }
  if ("TRTNAME" %in% names(data)) {
    if (!("TRT" %in% names(data))) {
      data$TRT <- as.numeric(factor(data$TRTNAME,levels=sort(unique(data$TRTNAME))))
      message("Adding default TRT column")
    }
  }
  if ("TRTNAMER" %in% names(data)) {
    if (!("TRTR" %in% names(data))) {
      data$TRTR <- as.numeric(factor(data$TRTNAMER,levels=sort(unique(data$TRTNAMER))))
      message("Adding default TRTR column")
    }
  }
  if (!("BASE" %in% names(data))) {
    data$BASE <- as.numeric(0)
    message("Adding default BASE column")
  }
  if (!("SCREEN" %in% names(data))) {
    data$SCREEN <- as.numeric(0)
    message("Adding default SCREEN column")
  }
  if (!("DURATION" %in% names(data))) {
    data$DURATION <- as.numeric(0)
    message("Adding default DURATION column")
  }
  if (!("VALUETXT" %in% names(data))) {
    data$VALUETXT <- NA
    message("Adding default VALUETXT column")
  }
  if (!("LLOQ" %in% names(data))) {
    data$LLOQ <- as.numeric(NA)
    message("Adding default LLOQ column")
  }
  if (!("II" %in% names(data))) {
    data$II <- as.numeric(0)
    message("Adding default II column")
  }
  if (!("ADDL" %in% names(data))) {
    data$ADDL <- as.numeric(0)
    message("Adding default ADDL column")
  }
  if ("AE" %in% names(data)) {
    if (!("AEGRADE" %in% names(data))) {
      data$AEGRADE <- as.numeric(NA)
      message("Adding default AEGRADE column")
    }
    if (!("AESER" %in% names(data))) {
      data$AESER <- as.numeric(NA)
      message("Adding default AESER column")
    }
    if (!("AEDRGREL" %in% names(data))) {
      data$AEDRGREL <- as.numeric(NA)
      message("Adding default AEDRGREL column")
    }
  }
  namesOrder__ <- c(getColumnsInfo_IQRdataGENERAL()$namesOrder)
  namesOrderPresent__ <- names(data)[names(data) %in% namesOrder__]
  dataOrdered__ <- data[,namesOrderPresent__]
  addcols <- setdiff(names(data),names(dataOrdered__))
  data <- cbind(dataOrdered__, data[,addcols,drop=FALSE])
  rownames(data) <- NULL
  return(data)
}
generalDataMapVALUETXT2VALUE <- function(data) {
  ix_VALUE_undefined      <- which(is.na(data$VALUE))
  ix_VALUE_TEXT_defined   <- which(!is.na(data$VALUETXT))
  ix_handle               <- intersect(ix_VALUE_undefined,ix_VALUE_TEXT_defined)
  dataHandle              <- unique(data[ix_handle,c('NAME','VALUETXT')])
  if (length(ix_handle) > 0) {
    dummy__ <- lapply(split(dataHandle,dataHandle$NAME), function (x) {
      x <- dplyr::arrange(x,VALUETXT)
      x$VALUE <- 1:nrow(x)
      lapply(x$VALUETXT, function (y) {
        data$VALUE[data$VALUETXT==y & data$NAME == x$NAME[1]] <<- x$VALUE[x$VALUETXT==y]
      })
      x
    })
  }
  dataX <- data[!is.na(data$VALUETXT),c("NAME","VALUETXT","VALUE")]
  mappingVALUETXTinfo <- lapply(split(dataX,dataX$NAME), function (x) {
    x <- dplyr::arrange(x,VALUE)
    x <- unique(x,drop=FALSE)
    lapply(split(x,x$VALUETXT), function (y) {
      if (length(unique(y$VALUETXT)) != length(y$VALUETXT)) {
        stopIQR(paste0(y$NAME[1],": Wrong definition of VALUE and VALUETXT columns.\nEnsure assignment of unique VALUE for each VALUETXT"))
      }
    })
    names(x) <- c("NAME",x$NAME[1],"VALUE")
    x[,2:ncol(x)]
    x
  })
  if (length(mappingVALUETXTinfo)==0) mappingVALUETXTinfo <- NULL
  rownames(data) <- NULL
  return(data)
}
generalData_IDcolumn <- function(data,FLAGforceOverwriteNLMEcols) {
  if (!("ID" %in% names(data)) | FLAGforceOverwriteNLMEcols) {
    count <- 1
    data <- do.call(rbind,lapply(split(data,data$USUBJID), function (x) { x$ID <- count; count<<-count+1; x}))
    rownames(data) <- NULL
    message("Adding default ID column")
  }
  return(data)
}
generalData_TIMEPOScolumn <- function(data,FLAGforceOverwriteNLMEcols) {
  if (!("TIMEPOS" %in% names(data)) | FLAGforceOverwriteNLMEcols) {
    data <- do.call(rbind,lapply(split(data,data$USUBJID), function (x) { x$TIMEPOS <- x$TIME-x$TIME[1]; x}))
    rownames(data) <- NULL
    message("Adding default TIMEPOS column")
  }
  return(data)
}
generalData_EVIDcolumn <- function(data,doseNAMES,FLAGforceOverwriteNLMEcols) {
  if (!("EVID" %in% names(data)) | FLAGforceOverwriteNLMEcols) {
    data$EVID <- 0
    for (k__ in seq_along(doseNAMES)) {
      data$EVID[data$NAME==doseNAMES[k__]] <- 1
    }
    rownames(data) <- NULL
    message("Adding default EVID column")
  }
  return(data)
}
generalData_MDVcolumn <- function(data,doseNAMES,FLAGforceOverwriteNLMEcols) {
  if (!("MDV" %in% names(data)) | FLAGforceOverwriteNLMEcols) {
    data$MDV <- 0
    for (k__ in seq_along(doseNAMES)) {
      data$MDV[data$NAME==doseNAMES[k__]] <- 1
    }
    data$MDV[!is.na(data$IGNORE)] <- 1
    rownames(data) <- NULL
    message("Adding default MDV column")
  }
  return(data)
}
generalData_DVcolumn <- function(data,doseNAMES,FLAGforceOverwriteNLMEcols) {
  if (!("DV" %in% names(data)) | FLAGforceOverwriteNLMEcols) {
    data$DV <- 0
    if ("AE" %in% names(data)) {
      data$DV[!(data$NAME %in% doseNAMES) & data$AE==0] <- data$VALUE[!(data$NAME %in% doseNAMES) & data$AE==0]
    } else {
      data$DV[!(data$NAME %in% doseNAMES)] <- data$VALUE[!(data$NAME %in% doseNAMES)]
    }
    rownames(data) <- NULL
    message("Adding default DV column")
  }
  return(data)
}
generalData_AMTcolumn <- function(data,doseNAMES,FLAGforceOverwriteNLMEcols) {
  if (!("AMT" %in% names(data)) | FLAGforceOverwriteNLMEcols) {
    data$AMT <- 0
    data$AMT[data$NAME %in% doseNAMES] <- data$VALUE[data$NAME %in% doseNAMES]
    rownames(data) <- NULL
    message("Adding default AMT column")
  }
  return(data)
}
generalData_CENScolumn <- function(data,FLAGforceOverwriteNLMEcols) {
  if (!("CENS" %in% names(data)) | FLAGforceOverwriteNLMEcols) {
    data$CENS <- 0
    rownames(data) <- NULL
    message("Adding default CENS column")
  }
  return(data)
}
generalData_TINFcolumn <- function(data,doseNAMES,FLAGforceOverwriteNLMEcols) {
  if (!("TINF" %in% names(data)) | FLAGforceOverwriteNLMEcols) {
    data$TINF <- 0
    data$TINF[data$NAME %in% doseNAMES] <- data$DURATION[data$NAME %in% doseNAMES]
    rownames(data) <- NULL
    message("Adding default TINF column")
  }
  return(data)
}
generalData_RATEcolumn <- function(data,doseNAMES,FLAGforceOverwriteNLMEcols) {
  if (!("RATE" %in% names(data)) | FLAGforceOverwriteNLMEcols) {
    data$RATE <- 0
    data$RATE[data$TINF>0] <- data$AMT[data$TINF>0] / data$TINF[data$TINF>0]
    rownames(data) <- NULL
    message("Adding default RATE column")
  }
  return(data)
}
generalData_ADMcolumn <- function(data,doseNAMES,FLAGforceOverwriteNLMEcols) {
  if (!("ADM" %in% names(data)) | FLAGforceOverwriteNLMEcols) {
    data$ADM <- 0
    if (length(doseNAMES) > 1) {
      for (k__ in seq_along(doseNAMES)) {
        data$ADM[data$NAME==doseNAMES[k__]] <- k__
      }
    } else {
      ROUTES__ <- unique(data$ROUTE)
      ROUTES__ <- ROUTES__[!is.na(ROUTES__)]
      if (length(ROUTES__) > 1) {
        data$ADM[data$ROUTE %in% c("SUBCUT", "ORAL", "INTRAMUSCULAR", "INTRAARTICULAR", "RECTAL", "INHALED", "GENERAL_ABS1")] <- 1
        data$ADM[data$ROUTE %in% c("IV", "GENERAL_IV")] <- 2
        data$ADM[data$ROUTE %in% c("TOPICAL", "GENERAL_ABS0")] <- 3
      } else {
        data$ADM[data$ROUTE %in% c("SUBCUT", "ORAL", "INTRAMUSCULAR", "INTRAARTICULAR", "RECTAL", "INHALED", "GENERAL_ABS1", "IV", "GENERAL_IV","TOPICAL", "GENERAL_ABS0")] <- 1
      }
    }
    rownames(data) <- NULL
    message("Adding default ADM column")
  }
  return(data)
}
generalData_TADcolumns <- function(data,doseNAMES,FLAGforceOverwriteNLMEcols) {
  if (!("TAD" %in% names(data)) | FLAGforceOverwriteNLMEcols) {
    data <- do.call(rbind,lapply(split(data,data$USUBJID), function (x) {
      ixDOSE__                    <- rep(NA,nrow(x))
      ixEVID__                    <- which(x$EVID==1)
      if (length(ixEVID__)==0) {
        xx__ <- x
        xx__$TAD <- NA
      } else {
        ixDOSE__[ixEVID__]          <- ixEVID__
        ixDOSE__                  <- aux_na_locf(ixDOSE__)
        ixDOSE__[is.na(ixDOSE__)]     <- 0
        x$ixDOSE__                  <- ixDOSE__
        xx__ <- do.call(rbind,lapply(split(x,x$ixDOSE__), function (y) {
          if (y$ixDOSE__[1]>0) {
            y$TAD <- y$TIME-y$TIME[1]
          } else {
            y$TAD <- y$TIME
          }
          y
        }))
        xx__$ixDOSE__ <- NULL
      }
      xx__
    }))
    message("Adding default TAD column")
  }
  if (length(doseNAMES) > 1) {
    FLAG_add_TAD_cols__ <- c()
    for (k__ in seq_along(doseNAMES)) {
      TAD_name__             <- paste0("TADD",k__)
      if (!(TAD_name__ %in% names(data)) | FLAGforceOverwriteNLMEcols) {
        data[[TAD_name__]] <- NA
        FLAG_add_TAD_cols__[k__] <- TRUE
      } else {
        FLAG_add_TAD_cols__[k__] <- FALSE
      }
    }
    for (k__ in seq_along(doseNAMES)) {
      if (FLAG_add_TAD_cols__[k__]) {
        data <- do.call(rbind,lapply(split(data,data$USUBJID), function (x) {
          TAD_name__                  <- paste0("TADD",k__)
          ixDOSE__                    <- rep(NA,nrow(x))
          ixDOSE_name               <- which(x$EVID==1 & x$NAME==doseNAMES[k__])
          if (length(ixDOSE_name)==0) {
            xx__ <- x
            xx__[[TAD_name__]] <- NA
          } else {
            ixDOSE__[ixDOSE_name]       <- ixDOSE_name
            ixDOSE__                    <- aux_na_locf(ixDOSE__)
            ixDOSE__[is.na(ixDOSE__)]     <- 0
            x$ixDOSE__                  <- ixDOSE__
            x[[TAD_name__]]             <- x$TIMEPOS-x$TIMEPOS[min(ixDOSE_name)]
            xx__ <- do.call(rbind,lapply(split(x,x$ixDOSE__), function (y) {
              if (y$ixDOSE__[1]>0) {
                y[[TAD_name__]] <- y$TIMEPOS-y$TIMEPOS[1]
              }
              y
            }))
            xx__$ixDOSE__ <- NULL
          }
          xx__
        }))
      }
    }
  }
  rownames(data) <- NULL
  return(data)
}
generalData_DOSEcolumns <- function(data,doseNAMES,FLAGforceOverwriteNLMEcols) {
  if (!("DOSE" %in% names(data)) | FLAGforceOverwriteNLMEcols) {
    data <- do.call(rbind,lapply(split(data,data$USUBJID), function (x) {
      x$DOSE <- NA
      x$DOSE[x$EVID==1] <- x$AMT[x$EVID==1]
      x$DOSE <- aux_na_locf(x$DOSE,x$TIME)
      x$DOSE[is.na(x$DOSE)] <- 0
      x
    }))
    message("Adding default DOSE column")
  }
  if (length(doseNAMES) > 1) {
    FLAG_add_DOSE_cols__ <- c()
    for (k__ in seq_along(doseNAMES)) {
      DOSE_name__             <- paste0("DOSED",k__)
      if (!(DOSE_name__ %in% names(data)) | FLAGforceOverwriteNLMEcols) {
        data[[DOSE_name__]] <- NA
        FLAG_add_DOSE_cols__[k__] <- TRUE
      } else {
        FLAG_add_DOSE_cols__[k__] <- FALSE
      }
    }
    for (k__ in seq_along(doseNAMES)) {
      if (FLAG_add_DOSE_cols__[k__]) {
        DOSE_name__ <- paste0("DOSED",k__)
        data <- do.call(rbind,lapply(split(data,data$USUBJID), function (x) {
          ixDOSEn <- which(x$NAME==doseNAMES[k__])
          x[[DOSE_name__]][ixDOSEn] <- x$AMT[ixDOSEn]
          x[[DOSE_name__]] <- aux_na_locf(x[[DOSE_name__]],x$TIME)
          x[[DOSE_name__]][is.na(x[[DOSE_name__]])] <- 0
          x
        }))
      }
    }
  }
  rownames(data) <- NULL
  return(data)
}
generalData_YTYPEcolumn <- function(data,obsNAMES,FLAGforceOverwriteNLMEcols) {
  if (!("YTYPE" %in% names(data))) {
    AEobsNames <- sort(obsNAMES[which(obsNAMES %in% data$NAME[data$AE==1])])
    NonAEobsNames <- sort(setdiff(obsNAMES,AEobsNames))
    obsNamesYTYPEorder <- c(NonAEobsNames,AEobsNames)
    data$YTYPE <- 0
    for (k__ in seq_along(obsNAMES)) {
      data$YTYPE[data$NAME==obsNAMES[k__]] <- k__
    }
    rownames(data) <- NULL
    message("Adding default YTYPE column")
  }
  return(data)
}
generalDataTimeIndependentCovariates <- function (data,cov0,cat0) {
  x__ <- setdiff(unlist(cov0),unique(data$NAME))
  if (length(x__) > 0) {
    stopIQR(paste0("Input argument 'cov0' selected covariates that are not present in the datasat (NAME):\n  ",
                   paste0(x__,collapse=",")))
  }
  x__ <- setdiff(unlist(cat0),unique(data$NAME))
  if (length(x__) > 0) {
    stopIQR(paste0("Input argument 'cat0' selected covariates that are not present in the datasat (NAME):\n  ",
                   paste0(x__,collapse=",")))
  }
  x__ <- intersect(cov0, unique(data$NAME[data$AE==1]))
  if (length(x__)>0) {
    stopIQR(paste0("Input argument 'cov0' selected covariates that are adverse events:\n  ",
                   paste0(x__,collapse=",")))
  }
  x__ <- intersect(cat0, unique(data$NAME[data$AE==1]))
  if (length(x__)>0) {
    stopIQR(paste0("Input argument 'cat0' selected covariates that are adverse events:\n  ",
                   paste0(x__,collapse=",")))
  }
  x__ <- intersect(names(cov0),names(data))
  if (length(x__) > 0) {
    stopIQR(paste0("Input argument 'cov0' defines covariate columns that are already present in the dataset:\n  ",
                   paste0(x__,collapse=",")))
  }
  x__ <- intersect(names(cat0),names(data))
  if (length(x__) > 0) {
    stopIQR(paste0("Input argument 'cat0' defines covariate columns that are already present in the dataset:\n  ",
                   paste0(x__,collapse=",")))
  }
  covariateInfo0 <- c(cov0,cat0)
  for (k__ in seq_along(covariateInfo0)) {
    colName__ <- names(covariateInfo0)[k__]
    covNAME__ <- covariateInfo0[[k__]]
    data[[colName__]] <- NA
    data <- do.call(rbind,lapply(split(data,data$USUBJID), function(x) {
      y <- subset(x,x$NAME==covNAME__ & x$BASE!=0)
      if (nrow(y)==0) {
        z <- NA
      } else {
        z <- mean(y$VALUE)
      }
      x[[colName__]] <- z
      x
    }))
    data <- do.call(rbind,lapply(split(data,data$USUBJID), function(x) {
      if (is.na(x[[colName__]][1])) {
        y <- subset(x,x$NAME==covNAME__ & x$SCREEN!=0)
        if (nrow(y)==0) {
          z <- NA
        } else {
          z <- mean(y$VALUE)
        }
        x[[colName__]] <- z
      }
      x
    }))
    data <- do.call(rbind,lapply(split(data,data$USUBJID), function(x) {
      if (is.na(x[[colName__]][1])) {
        y <- subset(x,x$NAME==covNAME__ & x$TIME<=0)
        if (nrow(y)==0) {
          z <- NA
        } else {
          z <- mean(y$VALUE)
        }
        x[[colName__]] <- z
      }
      x
    }))
  }
  rownames(data) <- NULL
  return(data)
}
generalDataTimeDependentCovariates <- function (data,covT,catT,FLAGnoNAlocf) {
  if (length(setdiff(unlist(covT),unique(data$NAME))) > 0)
    stopIQR("Input argument 'covT' selects covariates that are not present in the datasat (NAME)")
  if (length(setdiff(unlist(catT),unique(data$NAME))) > 0)
    stopIQR("Input argument 'catT' selectes covariates that are not present in the datasat (NAME)")
  if (length(intersect(covT, unique(data$NAME[data$AE==1])))>0)
    stopIQR("Input argument 'covT' selectes covariates that are adverse events")
  if (length(intersect(catT, unique(data$NAME[data$AE==1])))>0)
    stopIQR("Input argument 'catT' selectes covariates that are adverse events")
  if (length(intersect(names(covT),names(data))) > 0)
    stopIQR("Input argument 'covT' defines covariate columns that are already present in the dataset")
  if (length(intersect(names(catT),names(data))) > 0)
    stopIQR("Input argument 'catT' defines covariate columns that are already present in the dataset")
  covariateInfoT__ <- c(covT,catT)
  for (k__ in seq_along(covariateInfoT__)) {
    colName__ <- names(covariateInfoT__)[k__]
    covNAME__ <- covariateInfoT__[[k__]]
    data[[colName__]] <- NA
    data[[colName__]][data$NAME==covNAME__] <- data$VALUE[data$NAME==covNAME__]
    if (!FLAGnoNAlocf) {
      data <- do.call(rbind,lapply(split(data,data$USUBJID), function (x) {
        x[[colName__]] <- aux_na_locf(x[[colName__]],x$TIME)
        ix_notNA__ <- which(!is.na(x[[colName__]]))
        if (length(ix_notNA__) > 0) x[[colName__]][is.na(x[[colName__]])] <- x[[colName__]][min(ix_notNA__)]
        x
      }))
    }
  }
  rownames(data) <- NULL
  return(data)
}
mappingVALUETXT_IQRdataGENERAL <- function(data) {
  if (!is_IQRdataGENERAL(data))
    stopIQR("input argument is not an IQRdataGENERAL object")
  dataX <- data[!is.na(data$VALUETXT),c("NAME","VALUETXT","VALUE")]
  mappingVALUETXT <- data.frame(do.call(rbind,mappingVALUETXT <- lapply(split(dataX,dataX$NAME), function (x) {
    x <- dplyr::arrange(x,VALUE)
    unique(x)
  })),stringsAsFactors=FALSE,row.names=NULL)
  if (length(mappingVALUETXT)==0) mappingVALUETXT <- NULL
  return(mappingVALUETXT)
}
doseInfo_IQRdataGENERAL <- function (data) {
  if (!is_IQRdataGENERAL(data))
    stopIQR("input argument is not an IQRdataGENERAL object")
  doseNAMES <- unique(data$NAME[data$EVID==1])
  output <- data.frame(do.call(rbind,lapply(doseNAMES, function (x) {
    dN__ <- data[data$NAME==x & data$EVID==1,]
    N_TOTAL__ <- nrow(dN__)
    N_INDIV__ <- sapply(split(dN__,dN__$USUBJID), function (y) {
      nrow(y)
    })
    c(DOSE.NAME=x,
      TOTAL.DOSES=N_TOTAL__,
      MIN.INDIV.DOSES=min(N_INDIV__),
      MEDIAN.INDIV.DOSES=stats::median(N_INDIV__),
      MAX.INDIV.DOSES=max(N_INDIV__))
  })),stringsAsFactors=FALSE)
  if (nrow(output)==0) {
    output <- data.frame(
      DOSE.NAME = "No Dose name present",
      TOTAL.DOSES = 0,
      MIN.INDIV.DOSES = 0,
      MEDIAN.INDIV.DOSES = 0,
      MAX.INDIV.DOSES = 0
    )
  }
  output$TOTAL.DOSES        <- as.numeric(output$TOTAL.DOSES)
  output$MIN.INDIV.DOSES    <- as.numeric(output$MIN.INDIV.DOSES)
  output$MEDIAN.INDIV.DOSES <- as.numeric(output$MEDIAN.INDIV.DOSES)
  output$MAX.INDIV.DOSES    <- as.numeric(output$MAX.INDIV.DOSES)
  rownames(output) <- NULL
  return(output)
}
obsInfo_IQRdataGENERAL <- function (data) {
  if (!is_IQRdataGENERAL(data))
    stopIQR("input argument is not an IQRdataGENERAL object")
  obsNAMES <- unique(data$NAME[data$EVID==0 & data$YTYPE>0])
  output <- data.frame(do.call(rbind,lapply(obsNAMES, function (x) {
    dN__ <- data[data$NAME==x & data$EVID==0,]
    N_TOTAL__ <- as.character(nrow(dN__))
    N_INDIV__ <- do.call(rbind,lapply(split(dN__,dN__$USUBJID), function (y) {
      c(nrow(y))
    }))
    c(OBSERVATION.NAME=x,
      TOTAL.OBSERVATIONS=N_TOTAL__,
      MIN.INDIV.OBSERVATIONS=as.character(min(N_INDIV__[,1])),
      MEDIAN.INDIV.OBSERVATIONS=as.character(stats::median(N_INDIV__[,1])),
      MAX.INDIV.OBSERVATIONS=as.character(max(N_INDIV__[,1])))
  })),stringsAsFactors=FALSE)
  rownames(output) <- NULL
  return(output)
}
#'@export
blloq_IQRdataGENERAL <- function(data,methodBLLOQ="M1") {
  if (!is_IQRdataGENERAL(data))
    stopIQR("data argument is not an IQRdataGENERAL object")
  if (!(methodBLLOQ %in% c("M1","M3","M4","M5","M6","M7")))
    stopIQR('methodBLLOQ argument is not correctly set (choose one from: "M1","M3","M4","M5","M6","M7")')
  dataBLLOQ <- data
  dataBLLOQ$DV[dataBLLOQ$CENS==1] <- dataBLLOQ$VALUE[dataBLLOQ$CENS==1]
  dataBLLOQ$CENS <- 0
  ix_BLLOQ_handled_MDV <- which(grepl("BLLOQ (M",dataBLLOQ$IGNORE,fixed=TRUE))
  dataBLLOQ$MDV[ix_BLLOQ_handled_MDV] <- 0
  dataBLLOQ$IGNORE[ix_BLLOQ_handled_MDV] <- NA
  if (methodBLLOQ=="M1") {
    ix_handle <- which(!is.na(dataBLLOQ$LLOQ) & dataBLLOQ$VALUE<dataBLLOQ$LLOQ & dataBLLOQ$MDV==0 & dataBLLOQ$EVID==0 & dataBLLOQ$YTYPE>0)
    dataBLLOQ$MDV[ix_handle] <- 1
    dataBLLOQ$IGNORE[ix_handle] <- "BLLOQ (M1)"
  }
  if (methodBLLOQ=="M3" | methodBLLOQ=="M4") {
    ix_handle <- which(!is.na(dataBLLOQ$LLOQ) & dataBLLOQ$VALUE<dataBLLOQ$LLOQ & dataBLLOQ$MDV==0 & dataBLLOQ$EVID==0 & dataBLLOQ$YTYPE>0)
    dataBLLOQ$CENS[ix_handle] <- 1
    dataBLLOQ$DV[ix_handle] <- dataBLLOQ$LLOQ[ix_handle]
  }
  if (methodBLLOQ=="M5") {
    ix_handle <- which(!is.na(dataBLLOQ$LLOQ) & dataBLLOQ$VALUE<dataBLLOQ$LLOQ & dataBLLOQ$MDV==0 & dataBLLOQ$EVID==0 & dataBLLOQ$YTYPE>0)
    dataBLLOQ$DV[ix_handle] <- dataBLLOQ$LLOQ[ix_handle] / 2
  }
  if (methodBLLOQ=="M7") {
    ix_handle <- which(!is.na(dataBLLOQ$LLOQ) & dataBLLOQ$VALUE<dataBLLOQ$LLOQ & dataBLLOQ$MDV==0 & dataBLLOQ$EVID==0 & dataBLLOQ$YTYPE>0)
    dataBLLOQ$DV[ix_handle] <- 0
  }
  if (methodBLLOQ=="M6") {
    ix_handle <- which(!is.na(dataBLLOQ$LLOQ) & dataBLLOQ$VALUE<dataBLLOQ$LLOQ & dataBLLOQ$MDV==0 & dataBLLOQ$EVID==0 & dataBLLOQ$YTYPE>0)
    NAMES_BLLOQ_present <- unique(data$NAME[ix_handle])
    for (k00 in seq_along(NAMES_BLLOQ_present)) {
      handleNAME <- NAMES_BLLOQ_present[k00]
      dataBLLOQ <- do.call(rbind,lapply(split(dataBLLOQ,dataBLLOQ$USUBJID), function (x) {
        x$BLOQ <- 0
        x$BLOQ[which(!is.na(x$LLOQ) & x$DV<x$LLOQ & x$MDV==0 & x$EVID==0 & x$YTYPE>0 & x$NAME==handleNAME)] <- 1
        x$seq_check <- NA
        x$seq_check[x$NAME==handleNAME] <- 1
        x$cumsum <- NA
        x$cumsum[!is.na(x$seq_check)] <- cumsum(x$seq_check[!is.na(x$seq_check)])
        x$cumsumLLOQ <- NA
        x$cumsumLLOQ[x$BLOQ==1] <- x$cumsum[x$BLOQ==1]
        x$delta <- NA
        x$delta[x$BLOQ==1] <- c(Inf, diff(x$cumsumLLOQ[x$BLOQ==1]))
        x$first <- FALSE
        x$first[x$delta>1] <- TRUE
        x$consecutive <- FALSE
        x$consecutive[x$delta==1] <- TRUE
        x$MDV[x$consecutive] <- 1
        x$IGNORE[x$consecutive] <- "BLLOQ (M6)"
        x$DV[x$BLOQ==1] <- x$LLOQ[x$BLOQ==1] / 2
        x$seq_check <- NULL
        x$cumsum <- NULL
        x$cumsumLLOQ <- NULL
        x$delta <- NULL
        x$first <- NULL
        x$consecutive <- NULL
        x$BLOQ <- NULL
        x
      }))
    }
  }
  output <- dataBLLOQ
  attr(output,"methodBLLOQ") <- methodBLLOQ
  rownames(output) <- NULL
  return(output)
}
#'@export
blloqInfo_IQRdataGENERAL <- function (data) {
  if (!is_IQRdataGENERAL(data))
    stopIQR("data argument is not an IQRdataGENERAL object")
  data <- data[data$YTYPE>0,]
  blloqInfoTotal <- data.frame(do.call(rbind,lapply(split(data,data$NAME), function (x) {
    x$BLOQ <- as.numeric(x$VALUE < x$LLOQ)
    NobsTotal <- nrow(x)
    NobsBLLOQ <- sum(x$BLOQ,na.rm=TRUE)
    PercBLLOQ <- signif(100*NobsBLLOQ/NobsTotal,3)
    out <- c(OBSERVATION=unique(x$NAME),TOTAL.OBSERVATIONS=NobsTotal,BLLOQ.OBSERVATIONS=NobsBLLOQ,PERCENT.BLLOQ=PercBLLOQ)
    rownames(out) <- NULL
    out
  })),stringsAsFactors=FALSE)
  blloqInfoIndividual <- lapply(split(data,data$NAME), function (x) {
    x$BLOQ <- as.numeric(x$VALUE < x$LLOQ)
    infoNAME <- data.frame(do.call(rbind,lapply(split(x,x$USUBJID), function (y) {
      NobsTotal <- nrow(y)
      NobsBLLOQ <- sum(y$BLOQ,na.rm=TRUE)
      PercBLLOQ <- signif(100*NobsBLLOQ/NobsTotal,3)
      out <- c(OBSERVATION=unique(y$USUBJID),TOTAL.OBSERVATIONS=NobsTotal,BLLOQ.OBSERVATIONS=NobsBLLOQ,PERCENT.BLLOQ=PercBLLOQ)
      rownames(out) <- NULL
      out
    })),stringsAsFactors=FALSE)
  })
  output <- list(blloqInfoTotal=blloqInfoTotal,blloqInfoIndividual=blloqInfoIndividual)
  return(output)
}
zeroDoses_IQRdataGENERAL <- function (data) {
  if (!is_IQRdataGENERAL(data))
    stopIQR("input argument is not an IQRdataGENERAL object")
  doseNAMES <- unique(data$NAME[data$EVID==1])
  output__ <- data.frame(do.call(rbind,lapply(doseNAMES, function (x) {
    dN__ <- data[data$NAME==x & data$EVID==1 & data$AMT==0,]
    N_TOTAL__ <- nrow(dN__)
    c(DOSE.NAME=x,
      N.ZERO.DOSES=N_TOTAL__)
  })),stringsAsFactors=FALSE)
  output__$N.ZERO.DOSES        <- as.numeric(output__$N.ZERO.DOSES)
  rownames(output__) <- NULL
  return(output__)
}
placeboIndiv_IQRdataGENERAL <- function (data) {
  if (!is_IQRdataGENERAL(data))
    stopIQR("input argument is not an IQRdataGENERAL object")
  output__ <- unname(unlist(sapply(split(data,data$USUBJID), function (x) {
    Ndoses <- nrow(x[x$EVID==1,])
    NdosesAMT0 <- nrow(x[x$EVID==1 & x$AMT==0,])
    NdosesAMTnot0 <- Ndoses-NdosesAMT0
    if (NdosesAMTnot0 > 0) {
      out <- NULL
    } else {
      out <- x$USUBJID[1]
    }
    out
  })))
  return(output__)
}
noObsIndiv_IQRdataGENERAL <- function (data) {
  if (!is_IQRdataGENERAL(data))
    stopIQR("input argument is not an IQRdataGENERAL object")
  output__ <- unname(unlist(sapply(split(data,data$USUBJID), function (x) {
    if (!any(x$EVID==0)) {
      out <- x$USUBJID[1]
    } else {
      NobsNotIgnored <- nrow(x[x$EVID==0 & x$MDV==0 & x$YTYPE>0,])
      if (NobsNotIgnored > 0) {
        out <- NULL
      } else {
        out <- x$USUBJID[1]
      }
    }
    out
  })))
  return(output__)
}
#'@export
addLabel_IQRdataGENERAL <- function(data,addColLabels=NULL) {
  addLabel__ <- function (data,colName__,label) {
    if (colName__ %in% names(data)) {
      attr(data[[colName__]],"label") <- label
      attr(data[[colName__]],"class") <- unique(c("labelled",class(data[[colName__]])))
    }
    return(data)
  }
  data <- addLabel__(data,"IXGDF","Index of record in master dataset")
  data <- addLabel__(data,"IGNORE","Exclusion reason")
  data <- addLabel__(data,"USUBJID","Unique subject identifier")
  data <- addLabel__(data,"ID","Numeric subject ID for modeling software")
  data <- addLabel__(data,"STUDY","Short study name/number")
  data <- addLabel__(data,"STUDYN","Numeric study flag")
  data <- addLabel__(data,"TRTNAME","Name actual treatment given to subject")
  data <- addLabel__(data,"TRT","Numeric treatment flag")
  data <- addLabel__(data,"TIME","Actual time relative to first dose")
  data <- addLabel__(data,"TIMEPOS","Time since first record in subject")
  data <- addLabel__(data,"NT","Nominal event time")
  data <- addLabel__(data,"TAD","Time after last dose")
  data <- addLabel__(data,"TIMEUNIT","Unit of all numeric time definitions")
  data <- addLabel__(data,"YTYPE","Observation output number")
  data <- addLabel__(data,"NAME","Short name of event")
  data <- addLabel__(data,"DV","Dependent variable")
  data <- addLabel__(data,"LNDV","Log dependent variable")
  data <- addLabel__(data,"UNIT","Unit of the value")
  data <- addLabel__(data,"CENS","Censoring flag")
  data <- addLabel__(data,"LIMIT","Lower limit censoring (for MONOLIX)")
  data <- addLabel__(data,"MDV","Missing dependent variable flag")
  data <- addLabel__(data,"EVID","Event ID")
  data <- addLabel__(data,"AMT",sprintf("Dose amount (%s)",unique(unclass(data$UNIT)[data$EVID==1])))
  data <- addLabel__(data,"ADM","Administration input number")
  data <- addLabel__(data,"II","Interval of dosing")
  data <- addLabel__(data,"ADDL","Number of addl doses with II interval")
  data <- addLabel__(data,"ROUTE","Route of administration")
  data <- addLabel__(data,"TINF","Infusion time")
  data <- addLabel__(data,"RATE","Rate of infusion")
  data <- addLabel__(data,"DOSE","DOSE of last dose (carry-forward)")
  data <- addLabel__(data,"CENTER","Center number")
  data <- addLabel__(data,"SUBJECT","Subject number")
  data <- addLabel__(data,"INDNAME","Indication name")
  data <- addLabel__(data,"IND","Numeric indication flag")
  data <- addLabel__(data,"COMPOUND","Name of the studied compound")
  data <- addLabel__(data,"STUDYDES","Study title, short description")
  data <- addLabel__(data,"PART","Part of study as defined per protocol")
  data <- addLabel__(data,"EXTENS","Extension of the core study")
  data <- addLabel__(data,"TRTNAMER","Name of randomized treatment")
  data <- addLabel__(data,"TRTR","Numeric randomized treatment flag")
  data <- addLabel__(data,"VISIT","Visit number")
  data <- addLabel__(data,"VISNAME","Visit name")
  data <- addLabel__(data,"BASE","Flag indicating assessments at baseline")
  data <- addLabel__(data,"SCREEN","Flag indicating assessments at screening")
  data <- addLabel__(data,"STDTC","Start date and time of event")
  data <- addLabel__(data,"ENDTC","End date and time of event")
  data <- addLabel__(data,"DATEDAY","Start date of event")
  data <- addLabel__(data,"DATETIME","Start time of event")
  data <- addLabel__(data,"DURATION","Duration of event")
  data <- addLabel__(data,"PROFNR","Profile number")
  data <- addLabel__(data,"PROFTIME","Profile time")
  data <- addLabel__(data,"TYPENAME","Type of event")
  data <- addLabel__(data,"VALUE","Value of event defined by NAME")
  data <- addLabel__(data,"VALUETXT","Text version of value")
  data <- addLabel__(data,"OCC","Index of different occasions for IOV")
  data <- addLabel__(data,"ULOQ","Upper limit of quantification")
  data <- addLabel__(data,"LLOQ","Lower limit of quantification")
  data <- addLabel__(data,"AE","Adverse event record flag")
  data <- addLabel__(data,"AEGRADE","Adverse event grade")
  data <- addLabel__(data,"AESER","Adverse event seriousness")
  data <- addLabel__(data,"AEDRGREL","Adverse event drug related")
  data <- addLabel__(data,"COMMENT","Comment")
  data <- addLabel__(data,"CONDITION","Condition name")
  covInfo <- attr(data,"covInfo")
  if (!is.null(covInfo)) {
    if (nrow(covInfo)>0) {
      for (k__ in 1:nrow(covInfo)) {
        if (covInfo$TIME.VARYING[k__]) {
          text <- paste0(covInfo$NAME[k__]," (",covInfo$UNIT[k__],")")
        } else {
          text <- paste0("Baseline ",covInfo$NAME[k__]," (",covInfo$UNIT[k__],")")
        }
        data <- addLabel__(data,covInfo$COLNAME[k__],text)
      }
    }
  }
  catInfo <- attr(data,"catInfo")
  if (!is.null(catInfo)) {
    if (nrow(catInfo)>0) {
      for (k__ in 1:nrow(catInfo)) {
        if (catInfo$TIME.VARYING[k__]) {
          text <- paste0(catInfo$NAME[k__]," (time varying)")
        } else {
          text <- catInfo$NAME[k__]
        }
        data <- addLabel__(data,catInfo$COLNAME[k__],text)
      }
    }
  }
  TAD_Dcols__ <- names(data)[grepl("TAD_D",names(data))]
  TAD_Dcols_label <- paste0("TAD for ", attr(data,"doseNAMES")[as.numeric(gsub("TAD_D","",TAD_Dcols__))])
  for (k__ in seq_along(TAD_Dcols__)) {
    data <- addLabel__(data,TAD_Dcols__[k__],TAD_Dcols_label[k__])
  }
  DOSE_Dcols__ <- names(data)[grepl("^DOSED",names(data))]
  DOSE_Dcols_label <- paste0("DOSE for ", attr(data,"doseNAMES")[as.numeric(gsub("DOSED","",DOSE_Dcols__))])
  for (k__ in seq_along(DOSE_Dcols__)) {
    data <- addLabel__(data,DOSE_Dcols__[k__],DOSE_Dcols_label[k__])
  }
  for (k__ in seq_along(addColLabels)) {
    colname <- names(addColLabels)[k__]
    data <- addLabel__(data,colname,addColLabels[[k__]])
  }
  return(data)
}
getValueTxtDefine <- function(NAMES,data) {
  data <- unlabel_dataframe(data)
  imputationInformation <- attr(data,"imputeInfo")
  covInfo <- attr(data,"covInfo")
  catInfo <- attr(data,"catInfo")
  doseNAMES <- attr(data,"doseNAMES")
  obsNAMES <- attr(data,"obsNAMES")
  aeNAMES  <- attr(data,"aeNAMES")
  methodBLLOQ <- attr(data,"methodBLLOQ")
  if (length(which(grepl(":::",unique(data$NAME)))) > 0) {
    doseNAMES <- gsub(" ",":::",doseNAMES)
    obsNAMES <- gsub(" ",":::",obsNAMES)
  }
  output__ <- rep(" ",length(NAMES))
  for (k__ in seq_along(NAMES)) {
    NAME <- NAMES[k__]
    if (NAME=="IXGDF")
      output__[k__] <- "1...N"
    if (NAME=="IGNORE")
      output__[k__] <- "Reason for ignoring an observation record in the analysis. If NA then the record is not ignored"
    if (NAME=="USUBJID")
      output__[k__] <- "Unique subject ID or a derivative of it, allowing to identify the subject"
    if (NAME=="ID")
      output__[k__] <- "Numeric subject ID for modeling software"
    if (NAME=="STUDY")
      output__[k__] <- paste0(sort(unique(data$STUDY)),collapse=", \n")
    if (NAME=="STUDYN") {
      if ("STUDY" %in% names(data)) {
        x <- dplyr::arrange(unique(data[,c("STUDYN","STUDY")]),STUDYN)
        output__[k__] <- paste0(paste0(x$STUDYN," (STUDY=",x$STUDY,")"),collapse=", \n")
      } else {
        output__[k__] <- paste0(unique(data$STUDYN),collapse=", ")
      }
    }
    if (NAME=="STUDYDES")
      output__[k__] <- "See 'LABEL' column"
    if (NAME=="TRTNAME")
      output__[k__] <- paste0(sort(unique(data$TRTNAME)),collapse=", \n")
    if (NAME=="TRT") {
      if ("TRTNAME" %in% names(data)) {
        x <- dplyr::arrange(unique(data[,c("TRT","TRTNAME")]),TRT)
        output__[k__] <- paste0(paste0(x$TRT," (TRTNAME=",x$TRTNAME,")"),collapse=", \n")
      } else {
        output__[k__] <- paste0(unique(data$TRT),collapse=", ")
      }
    }
    if (NAME=="TRTNAMER")
      output__[k__] <- paste0(sort(unique(data$TRTNAMER)),collapse=", \n")
    if (NAME=="TRTR") {
      if ("TRTNAMER" %in% names(data)) {
        x <- dplyr::arrange(unique(data[,c("TRTR","TRTNAMER")]),TRTR)
        output__[k__] <- paste0(paste0(x$TRTR," (TRTNAMER=",x$TRTNAMER,")"),collapse=", \n")
      } else {
        output__[k__] <- paste0(unique(data$TRTR),collapse=", ")
      }
    }
    if (NAME=="CENTER")
      output__[k__] <- "See 'LABEL' column"
    if (NAME=="SUBJECT")
      output__[k__] <- "See 'LABEL' column"
    if (NAME=="INDNAME")
      output__[k__] <- paste0(sort(unique(data$INDNAME)),collapse=", \n")
    if (NAME=="IND") {
      if ("INDNAME" %in% names(data)) {
        x <- dplyr::arrange(unique(data[,c("IND","INDNAME")]),IND)
        output__[k__] <- paste0(paste0(x$IND," (INDNAME=",x$INDNAME,")"),collapse=", \n")
      } else {
        output__[k__] <- paste0(unique(data$IND),collapse=", ")
      }
    }
    if (NAME=="COMPOUND")
      output__[k__] <- paste0(sort(unique(data$COMPOUND)),collapse=", \n")
    if (NAME=="PART")
      output__[k__] <- "1=part 1, A=part A, ...\n '0' codes for a study with a single part or an undefined value either because information was not available or not needed for the analysis"
    if (NAME=="EXTENS")
      output__[k__] <- "0=core, 1=extension 1, 2=extension 2, ...\n '0': codes for core and also for an undefined value either because information was not available or not needed for the analysis"
    if (NAME=="VISIT")
      output__[k__] <- "'NA' if undefined or information not available / not needed for analysis"
    if (NAME=="VISNAME")
      output__[k__] <- "'UNKNOWN': if undefined or information not available / not needed for analysis"
    if (NAME=="BASE")
      output__[k__] <- "0 for non-baseline, 1 for first, 2 for second, ..."
    if (NAME=="SCREEN")
      output__[k__] <- "0 for non-screening, 1 for first, 2 for second, ..."
    if (NAME=="TIME")
      output__[k__] <- "'TIME' values in the unit defined in the 'TIMEUNIT' column"
    if (NAME=="TIMEPOS")
      output__[k__] <- "'TIMEPOS' values in the unit defined in the 'TIMEUNIT' column"
    if (NAME=="NT")
      output__[k__] <- "'NT' values in the unit defined in the 'TIMEUNIT' column. Can be 'NA' if value is undefined"
    if (NAME=="TAD")
      output__[k__] <- "'TAD' values in the unit defined in the 'TIMEUNIT' column"
    if (NAME=="TIMEUNIT")
      output__[k__] <- paste0("'",unique(data$TIMEUNIT),"'")
    if (NAME=="DATEDAY")
      output__[k__] <- "'UNKNOWN': if undefined or information not available / not needed for analysis"
    if (NAME=="DATETIME")
      output__[k__] <- "'UNKNOWN': if undefined or information not available / not needed for analysis"
    if (NAME=="DURATION")
      output__[k__] <- "'DURATION' values in the unit defined in the 'TIMEUNIT' column. -1 if event ongoing post end of observation period"
    if (NAME=="TYPENAME")
      output__[k__] <- paste0(sort(unique(data$TYPENAME)),collapse=", \n")
    if (NAME=="NAME")
      output__[k__] <- paste0(sort(unique(data$NAME)),collapse=", \n")
    if (NAME=="VALUE")
      output__[k__] <- "'VALUE' values in the unit defined in the 'UNIT' column for the same record"
    if (NAME=="VALUETXT")
      output__[k__] <- "'NA': if undefined or information not available / not needed for analysis"
    if (NAME=="OCC")
      output__[k__] <- "Integer indices, each unique index coding for a distinct occasion to consider in IOV modeling"
    if (NAME=="ULOQ")
      output__[k__] <- "In units as defined in the 'UNIT' column of the same record. 'NA': if undefined or information not available / not needed for analysis"
    if (NAME=="LLOQ")
      output__[k__] <- "In units as defined in the 'UNIT' column of the same record. 'NA': if undefined or information not available / not needed for analysis"
    if (NAME=="AE")
      output__[k__] <- "1 if record codes an adverse event, 0 if not"
    if (NAME=="AEGRADE")
      output__[k__] <- "Can be 1,2,3,4,5. NA for "
    if (NAME=="AESER")
      output__[k__] <- "1: seriuous adverse event, 0: not serious"
    if (NAME=="AEDRGREL")
      output__[k__] <- "1: drug related AE, 0: not drug related"
    if (NAME=="COMMENT")
      output__[k__] <- "Various content - might be 'NA'"
    if (NAME=="UNIT")
      output__[k__] <- "'NA': if undefined or information not available / not needed for analysis"
    if (NAME=="ROUTE")
      output__[k__] <- paste0(paste0(sort(unique(data$ROUTE)),collapse=", \n"),". 'NA' for non-dosing records")
    if (NAME=="II")
      output__[k__] <- "In units as defined in the 'UNIT' column of the same record. '0': if undefined (non-dosing events) or information not available / not needed for analysis"
    if (NAME=="ADDL")
      output__[k__] <- "'0': if undefined (non-dosing events) or information not available / not needed for analysis"
    if (NAME=="EVID")
      output__[k__] <- "1 for dosing records, 0 for non-dosing records"
    if (NAME=="MDV")
      output__[k__] <- "1 for dosing records and ignored observation records, 0 otherwise"
    if (NAME=="CENS")
      output__[k__] <- "1 for observation records below 'LLOQ' if handling in the model via the M3 or M4 method. 0 otherwise"
    if (NAME=="LIMIT")
      output__[k__] <- "Lower censoring limit - only used for MONOLIX. Set to 0 if M4 used."
    if (NAME=="AMT")
      output__[k__] <- "Dose given in the unit of the 'UNIT' column of this record. 0 for non-dosing records"
    if (NAME=="ADM") {
      if ("ROUTE" %in% data$NAME) {
        x <- dplyr::arrange(unique(data[data$NAME %in% doseNAMES,c("NAME","ADM","ROUTE")]),ADM)
        output__[k__] <- paste0(paste0(paste0(x$ADM," (",x$NAME,", Route: ",x$ROUTE,")"),collapse=", \n"),",\n0 or NA (non-dose records)")
      } else {
        x <- dplyr::arrange(unique(data[data$NAME %in% doseNAMES,c("NAME","ADM")]),ADM)
        output__[k__] <- paste0(paste0(paste0(x$ADM," (",x$NAME,")"),collapse=", \n"),",\n0 or NA (non-dose records)")
      }
    }
    if (NAME=="TINF")
      output__[k__] <- "Duration of dose administration / infusion time for dosing records. 0 indicates a bolus admnistration or a non-dosing record"
    if (NAME=="RATE")
      output__[k__] <- "Rate of dose administration for dosing records. 0 indicates a bolus admnistration or a non-dosing record"
    if (NAME=="LNDV") {
      output__[k__] <- "Log transformed version of 'DV'"
    }
    if (NAME=="DOSE")
      output__[k__] <- "In units as defined in the 'UNIT' column of current dose record. 0 for pre-first dose records in a subject"
    if (NAME=="YTYPE") {
      x <- dplyr::arrange(unique(data[data$NAME %in% obsNAMES,c("NAME","YTYPE")]),YTYPE)
      output__[k__] <- paste0(paste0(paste0(x$YTYPE," (",x$NAME,")"),collapse=", \n"),",\n0 or NA (non-observation records)")
    }
    if (NAME=="DV") {
      output__[k__] <- "0 for dosing events.\nFor observation events the value of the observation in the units defined in the 'UNIT' column of this record.\nMissing observations are coded as 'NA'.\n\n"
      if (!is.null(methodBLLOQ)) {
        if (methodBLLOQ %in% c("M3","M4")) output__[k__] <- paste0(output__[k__],"For observations below the 'LLOQ' the value is set to the 'LLOQ' for handling the M3 or M4 method in the modeling.")
        if (methodBLLOQ %in% c("M5","M6")) output__[k__] <- paste0(output__[k__],"For observations below the 'LLOQ' the value is set to the 'LLOQ'/2 for handling the M5 or M6 method in the modeling.")
        if (methodBLLOQ %in% c("M7")) output__[k__] <- paste0(output__[k__],"For observations below the 'LLOQ' the value is set to the 0 for handling the M7 method in the modeling.")
      }
    }
    if (NAME=="CONDITION")
      output__[k__] <- paste0(sort(unique(data$CONDITION)),collapse=", \n")
    if (!is.null(covInfo)) {
      for (kk in 1:nrow(covInfo)) {
        if (NAME==covInfo$COLNAME[kk]) {
          output__[k__] <- "See 'LABEL' column"
        }
      }
    }
    if (!is.null(catInfo)) {
      for (kk__ in 1:nrow(catInfo)) {
        if (NAME==catInfo$COLNAME[kk__]) {
          output__[k__] <- paste0(aux_explodePC(catInfo$VALUES[kk__])," (",aux_explodePC(catInfo$VALUETXT[kk__]),")",collapse=", \n")
        }
      }
    }
    if (grepl("^TADD",NAME))
      output__[k__] <- "'NA' before first administration of the dose"
    if (grepl("^DOSED",NAME))
      output__[k__] <- "'0' before first administration of the dose"
  }
  return(output__)
}
#'@export
rmDosePostLastObs_IQRdataGENERAL <- function (data,filename=NULL) {
  doseRecPostLastObs__ <- do.call(rbind,lapply(split(data,data$USUBJID), function (datak__) {
    maxTimeObs__ <- max(datak__$TIME[datak__$EVID==0 & datak__$YTYPE>0],na.rm=TRUE)
    doseDataPostObs__ <- datak__[datak__$EVID==1 & datak__$TIME > maxTimeObs__,]
  }))
  if (nrow(doseRecPostLastObs__)==0) {
    xtable__ <- data.frame(IXGDF = "-",
                           USUBJID = "-",
                           TIME = "-",
                           NAME = "-",
                           AMT = "-",
                           II = "-",
                           ADDL = "-",
                           ROUTE = "-",
                           COMMENT = "-",stringsAsFactors = FALSE)
    if (!is.null(filename)) {
      IQRoutputTable(xtable__,"Rule for removal: Dose time larger than latest observation time in an individual",
                     sprintf("N=0 dose records post last individual observation have been removed"),
                     report=TRUE,filename=filename)
    } else {
      print(IQRoutputTable(xtable__,"Rule for removal: Dose time larger than latest observation time in an individual",
                           sprintf("N=0 dose records post last individual observation have been removed"),
                           report=FALSE,filename=filename)
      )
    }
    return(data)
  } else {
    cleanedDataWOdoseRecPostLastObs__ <- do.call(rbind,lapply(split(data,data$USUBJID), function (datak__) {
      maxTimeObs__ <- max(datak__$TIME[datak__$EVID==0 & datak__$YTYPE>0],na.rm=TRUE)
      datakDosesPostRemoved__ <- datak__[!(datak__$EVID==1 & datak__$TIME > maxTimeObs__),]
    }))
    xtable__ <- as.data.frame(doseRecPostLastObs__[,c("IXGDF","USUBJID","TIME","NAME","AMT","II","ADDL","ROUTE")])
    xtable__ <- cbind(xtable__,COMMENT = "Dose record post last observation")
    if (!is.null(filename)) {
      IQRoutputTable(xtable__,"Rule for removal: Dose time larger than latest observation time in an individual",
                     sprintf("N=%d dose records post last individual observation have been removed",nrow(xtable__)),
                     report=TRUE,filename=filename)
    } else {
      print(IQRoutputTable(xtable__,"Rule for removal: Dose time larger than latest observation time in an individual",
                           sprintf("N=%d dose records post last individual observation have been removed",nrow(xtable__)),
                           report=FALSE,filename=filename)
      )
    }
    return(cleanedDataWOdoseRecPostLastObs__)
  }
}
#'@export
combine_IQRdataGENERAL <- function(
  data1, data2,
  FLAGkeepAllCols = FALSE,
  FLAGforceOverwriteNLMEcols = TRUE,
  methodBLOQ = NULL,
  FLAGforceOverwriteNUMcols = TRUE
) {
  x1__ <- as.data.frame(data1)
  x2__ <- as.data.frame(data2)
  if (!is_IQRdataGENERAL(data1) | !(is_IQRdataGENERAL(data2)))
    stopIQR("Both inputs need to be IQRdataGENERAL objects.")
  covInfo1__ <- attr(data1, "covInfo")
  catInfo1__ <- attr(data1, "catInfo")
  covInfo2__ <- attr(data2, "covInfo")
  catInfo2__ <- attr(data2, "catInfo")
  doseNames1__ <- attr(data1, "doseNAMES")
  doseNames2__ <- attr(data2, "doseNAMES")
  obsNames1__ <- attr(data1, "obsNAMES")
  obsNames2__ <- attr(data2, "obsNAMES")
  covInfo__ <- unique(rbind(covInfo1__, covInfo2__))
  catInfo__ <- unique(rbind(catInfo1__, catInfo2__))
  if (any(duplicated(covInfo__$COLNAME))) {
    warningIQR("Continous covariate information not consistent.")
  }
  if (any(duplicated(catInfo__$COLNAME))) {
    warningIQR("Categorical covariate information not consistent.")
  }
  obsNames__ <- union(obsNames1__, obsNames2__)
  doseNames__ <- union(doseNames1__, doseNames2__)
  mBLOQcomm__ <- unique(c(attr(data1, "methodBLLOQ"),attr(data2, "methodBLLOQ")))
  if (FLAGforceOverwriteNLMEcols) {
    if (!is.null(methodBLOQ)) {
      mBLOQcomm__ <- "M1"
    } else {
      if (length(mBLOQcomm__) != 1) {
        warningIQR("BLLOQ methods different between datasets. Will be overwritten by default M1 method.")
        mBLOQcomm__ <- "M1"
      }
    }
  } else {
    if (length(mBLOQcomm__) != 1)
      warningIQR("BLLOQ methods different between datasets. Consider overwriting NLME columns.")
  }
  namesCommon__ <- intersect(names(x1__), names(x2__))
  namesCov1__   <- c(covInfo1__$COLNAME, catInfo1__$COLNAME)
  namesCov2__   <- c(covInfo2__$COLNAME, catInfo2__$COLNAME)
  namesU1__       <- setdiff(names(x1__), c(namesCommon__, namesCov1__))
  namesU2__       <- setdiff(names(x2__), c(namesCommon__, namesCov2__))
  if (FLAGkeepAllCols) {
    names1__ <- unique(c(namesCommon__, namesCov1__, namesU1__))
    names2__ <- unique(c(namesCommon__, namesCov2__, namesU2__))
  } else {
    names1__ <- unique(c(namesCommon__, namesCov1__))
    names2__ <- unique(c(namesCommon__, namesCov2__))
  }
  out__ <- plyr::rbind.fill(x1__[, names1__], x2__[, union(namesCommon__, names2__)])
  out__ <- dplyr::arrange(out__,STUDY,USUBJID,TIME,TYPENAME,NAME)
  attr(out__,"class")        <- c("IQRdataGENERAL", attr(out__,"class"))
  if (FLAGforceOverwriteNLMEcols) {
    out__ <- generalData_IDcolumn(out__,FLAGforceOverwriteNLMEcols)
    out__ <- generalData_TIMEPOScolumn(out__,FLAGforceOverwriteNLMEcols)
    out__ <- generalData_EVIDcolumn(out__,doseNames__,FLAGforceOverwriteNLMEcols)
    out__ <- generalData_MDVcolumn(out__,doseNames__,FLAGforceOverwriteNLMEcols)
    out__ <- generalData_CENScolumn(out__,FLAGforceOverwriteNLMEcols)
    out__ <- generalData_AMTcolumn(out__,doseNames__,FLAGforceOverwriteNLMEcols)
    out__ <- generalData_DVcolumn(out__,doseNames__,FLAGforceOverwriteNLMEcols)
    out__ <- generalData_TINFcolumn(out__,doseNames__,FLAGforceOverwriteNLMEcols)
    out__ <- generalData_RATEcolumn(out__,doseNames__,FLAGforceOverwriteNLMEcols)
    out__ <- generalData_ADMcolumn(out__,doseNames__,FLAGforceOverwriteNLMEcols)
    out__ <- generalData_TADcolumns(out__,doseNames__,FLAGforceOverwriteNLMEcols)
    out__ <- generalData_DOSEcolumns(out__,doseNames__,FLAGforceOverwriteNLMEcols)
    out__ <- generalData_YTYPEcolumn(out__,obsNames__,FLAGforceOverwriteNLMEcols)
    ixmissingDV__ <- which(out__$EVID==0 & out__$MDV==0 & is.na(out__$DV))
    out__$MDV[ixmissingDV__] <- 1
    out__$IGNORE[ixmissingDV__] <- "Missing value"
    ixmissingTIME__ <- which(out__$EVID==0 & out__$MDV==0 & is.na(out__$TIME))
    out__$MDV[ixmissingTIME__] <- 1
    out__$IGNORE[ixmissingTIME__] <- "Missing time"
    out__ <- blloq_IQRdataGENERAL(out__, mBLOQcomm__)
  }
  out__$IXGDF <- 1:dim(out__)[1]
  if (FLAGforceOverwriteNUMcols) {
    if ("INDNAME" %in% names(out__)) out__$IND <- as.numeric(factor(out__$INDNAME))
    if ("STUDY" %in% names(out__)) out__$STUDYN <- as.numeric(factor(out__$STUDY))
    if ("TRTNAME" %in% names(out__)) out__$TRT <- as.numeric(factor(out__$TRTNAME, levels = unique(out__$TRTNAME)))
    if ("TRTNAMER" %in% names(out__)) out__$TRTR <- as.numeric(factor(out__$TRTNAMER, levels = unique(out__$TRTNAMER)))
  }
  attr(out__,"doseNAMES")    <- doseNames__
  attr(out__,"obsNAMES")     <- obsNames__
  attr(out__,"covInfo")      <- covInfo__
  attr(out__,"catInfo")      <- catInfo__
  attr(out__,"methodBLLOQ")  <- mBLOQcomm__
  out__
}
#'@export
"+.IQRdataGENERAL" <- function (data1,data2) {
  out__ <- combine_IQRdataGENERAL(data1,data2)
  return(out__)
}
#'@export
subset.IQRdataGENERAL <- function(x, subset, select, ...) {
  x.attr <- attributes(x)
  x.attr0 <- attributes0(x)
  r <- if (missing(subset))
    rep_len(TRUE, nrow(x))
  else {
    e <- substitute(subset)
    r <- eval(e, x, parent.frame())
    if (!is.logical(r))
      stopIQR("'subset' must be logical")
    r & !is.na(r)
  }
  vars <- if (missing(select))
    TRUE
  else {
    nl <- as.list(seq_along(x))
    names(nl) <- names(x)
    eval(substitute(select), nl, parent.frame())
  }
  subx <- x[r, vars, drop = FALSE]
  info <- getColumnsInfo_IQRdataGENERAL()
  removed <- setdiff(names(x), names(subx))
  if (any(removed %in% info$requiredColumns))
    stopIQR("It is not allowed to remove columns that are required by IQRdataGENERAL")
  if (any(removed %in% info$requiredColumnsNLME)) {
    stopIQR("It is not allowed to remove existing columns required for NLME modeling.")
  }
  attr.expected <- c("doseNAMES", "obsNAMES", "covInfo", "catInfo", "regressorNames")
  for (a in intersect(attr.expected, names(x.attr))) {
    if (a == "doseNAMES")  {
      doseNAMES <- intersect(x.attr[["doseNAMES"]], unique(subx[["NAME"]]))
      Dx <- ifelse(length(x.attr[["doseNAMES"]]) > 1, "D", "")
      index <- match(doseNAMES, x.attr[["doseNAMES"]]) 
      TAD_Dx <- unclass(subx)[grepl(paste0("^TAD", Dx), colnames(subx))] 
      DOSE_Dx <- unclass(subx)[grepl(paste0("^DOSE", Dx), colnames(subx))] 
      subx <- subx[, !grepl("^TADD", colnames(subx)) & !grepl("^DOSED", colnames(subx))] 
      if (length(doseNAMES) == 0) { 
        subx[["TAD"]] <- NA
        subx[["DOSE"]] <- 0
      }
      if (length(doseNAMES) == 1) { 
        subx[["TAD"]] <- TAD_Dx[[index]]
        subx[["DOSE"]] <- DOSE_Dx[[index]]
      }
      if (length(doseNAMES) > 1) { 
        for (i in 1:length(index)) {
          subx[[paste0("TADD", i)]] <- TAD_Dx[[index[i]]]
          subx[[paste0("DOSED", i)]] <- DOSE_Dx[[index[i]]]
        }
        DOSE_matrix <- do.call(cbind, subx[grepl("^DOSED", names(subx))])
        TAD_matrix <- do.call(cbind, subx[grepl("^TADD", names(subx))])
        minIndex <- apply(TAD_matrix, 1, which.min)
        minIndex <- sapply(seq_along(minIndex), function(i) ifelse(length(minIndex[[i]])==0, 1, minIndex[[i]]))
        subx[["TAD"]] <- sapply(seq_along(minIndex), function(i) TAD_matrix[i, minIndex[i]])
        subx[["DOSE"]] <- sapply(seq_along(minIndex), function(i) DOSE_matrix[i, minIndex[i]])
      }
      adms.present <- sort(unique(c(0, subx[["ADM"]])))
      adms.replace <- seq_along(adms.present) - 1
      subx[["ADM"]] <- adms.replace[match(subx[["ADM"]], adms.present)]
      attr(subx, "doseNAMES") <- doseNAMES
    }
    if (a == "obsNAMES")  {
      obsNAMES <- intersect(x.attr[["obsNAMES"]], unique(subx[["NAME"]]))
      attr(subx, "obsNAMES") <- obsNAMES
    }
    if (a == "covInfo")  {
      covInfo <- x.attr[["covInfo"]]
      select <- (covInfo[["COLNAME"]] %in% colnames(subx))
      attr(subx, "covInfo") <- covInfo[select, ]
    }
    if (a == "catInfo") {
      catInfo <- x.attr[["catInfo"]]
      select <- (catInfo[["COLNAME"]] %in% colnames(subx))
      catInfo <- catInfo[select, ]
      if (any(select)) {
        valuetxt <- strsplit(catInfo[["VALUETXT"]], split = ","); names(valuetxt) <- catInfo[["COLNAME"]]
        values <- strsplit(catInfo[["VALUES"]], split = ","); names(values) <- catInfo[["COLNAME"]]
        new_values <- lapply(1:nrow(catInfo), function(i){
          with(catInfo[i, ], sort(unique(subx[[COLNAME]])))
        })
        VALUETXT <- sapply(1:length(new_values), function(i) {
          paste(valuetxt[[i]][match(new_values[[i]], values[[i]])], collapse = ",")
        })
        VALUES <- sapply(1:length(new_values), function(i) {
          paste(new_values[[i]], collapse = ",")
        })
        catInfo[["VALUETXT"]] <- VALUETXT
        catInfo[["VALUES"]] <- VALUES
        catInfo <- catInfo[catInfo[["VALUES"]] != "",]
      }
      attr(subx, "catInfo") <- catInfo
    }
    if (a == "regressorNames") {
      regressorNames <- intersect(x.attr[["regressorNames"]], colnames(subx))
      attr(subx, "regressorNames") <- regressorNames
    }
  }
  n <- setdiff(names(x.attr0), c("doseNAMES", "obsNAMES", "covInfo", "catInfo", "regressorNames"))
  if (length(n) > 0)
    attributes(subx) <- c(attributes(subx), x.attr0[n])
  return(subx)
}
#'@export
attributes0 <- function(x) UseMethod("attributes0", x)
#'@export
attributes0.IQRdataGENERAL <- function(x) {
  allAttributes <- attributes(x)
  exclude <- c("names", "row.names", "class")
  allAttributes[setdiff(names(allAttributes), exclude)]
}
#'@export
obsNAMES <- function(x) UseMethod("obsNAMES", x)
#'@export
obsNAMES.IQRdataGENERAL <- function(x) attr(x, "obsNAMES")
#'@export
doseNAMES <- function(x) UseMethod("doseNAMES", x)
#'@export
doseNAMES.IQRdataGENERAL <- function(x) attr(x, "doseNAMES")
#'@export
covInfo <- function(x) UseMethod("covInfo", x)
#'@export
covInfo.IQRdataGENERAL <- function(x) attr(x, "covInfo")
#'@export
catInfo <- function(x) UseMethod("catInfo", x)
#'@export
catInfo.IQRdataGENERAL <- function(x) attr(x, "catInfo")
#'@export
addIndivRegressors_IQRdataGENERAL <- function(
  projectPath,
  dataPath        = NULL,
  data            = NULL,
  filename        = NULL,
  model           = NULL,
  regressorNames  = NULL,
  doseNAMES       = NULL,
  obsNAMES        = NULL,
  FLAGrmNoInd     = FALSE,
  FLAGnoCovSample = FALSE,
  FLAGxpt         = FALSE,
  FLAGdefine      = TRUE,
  FLAGzip         = FALSE,
  addColLabels    = NULL) {
  if (!(is.null(regressorNames) | "character" %in% class(regressorNames)) ) {
    stopIQR("regressorNames need to be NULL or of class character.")
  }
  if (!(is.null(model) | is_IQRmodel(model)) ) {
    if (!file.exists(model)) {
      stopIQR("modelFile need to be NULL, IQR model or path to model file.")
    }
  }
  if (is.null(dataPath) & is.null(data)) {
    stopIQR("Please provide either dataPath or data input argument")
  }
  if (!is.null(dataPath) & !is.null(data)) {
    stopIQR("Please provide either dataPath or data input argument")
  }
  if (!is.null(dataPath)) {
    data__ <- load_IQRdataGENERAL(dataPath)
  } else {
    data__ <- data
  }
  if (!is_IQRdataGENERAL(data__)) {
    stopIQR("Data is not a saved IQRdataGENERAL object")
  }
  projInfo__ <- parseNLMEprojectHeader(projectPath)
  dataProj__ <- IQRloadCSVdata(file.path(projectPath, projInfo__$DATA))
  subjProj__ <- unique(dataProj__[,c("ID","USUBJID")])
  indivPars__ <- getIndivParameters_IQRnlmeProject(projectPath, FLAGcovariate = FALSE)
  indivPars__ <- merge(indivPars__, subjProj__)
  indivPars__$ID <- NULL
  subjNoIndPar    <- setdiff(unique(data__$USUBJID), indivPars__$USUBJID)
  if (length(subjNoIndPar) > 0) {
    if (FLAGrmNoInd) {
    } else {
      if (all(projInfo__$COVARIATESUSED != "") & !FLAGnoCovSample) {
        if ((!all(projInfo__$COVARIATESUSED %in% names(data__)))) {
          warningIQR("Data set does not contain all covariates in the model.\nParameters for subjects for which estimates are not available will not be adjusted by covariates.")
          popPars__  <- suppressWarnings(getPopParameters_IQRnlmeProject(projectPath,verbose=FALSE))
          popParsDF__  <- as.data.frame(t(replicate(length(subjNoIndPar),popPars__)))
          popParsDF__$USUBJID <- subjNoIndPar
        } else {
          IndCov__   <- unique(data__[data__$USUBJID %in% subjNoIndPar, c("USUBJID", projInfo__$COVARIATESUSED)])
          contCovNames__ <- intersect(projInfo__$COVNAMES, names(IndCov__))
          for (kccn in seq_along(contCovNames__)) {
            idxccn__ <- grep(contCovNames__[kccn], projInfo__$BETACOVNAMES)[1]
            refValue__ <- as.numeric(gsub(")","",gsub("log(cov/", "", projInfo__$BETACOVTRANS[idxccn__], fixed = TRUE), fixed= TRUE))
            idx0__ <- IndCov__[[contCovNames__[kccn]]] == 0 | is.na(IndCov__[[contCovNames__[kccn]]])
            if (any(idx0__)) {
              warningIQR("There are continuous covariate values that are zero or NA. Zero is not feasible since log-transformation is applied.\n   For all subjects with NA or zero reference covariate value will be used.")
              IndCov__[[contCovNames__[kccn]]][idx0__] <- refValue__
            }
          }
          popParsDF__  <- getPopParameters_IQRnlmeProject(projectPath, IndCovariates=IndCov__,verbose=FALSE)
          popParsDF__$USUBJID <- IndCov__$USUBJID
        }
      } else {
        popPars__  <- suppressWarnings(getPopParameters_IQRnlmeProject(projectPath,verbose=FALSE))
        popParsDF__  <- as.data.frame(t(replicate(length(subjNoIndPar),popPars__)))
        popParsDF__$USUBJID <- subjNoIndPar
      }
      indivPars__ <- rbind(indivPars__, popParsDF__)
    }
  }
  if (!is.null(model)) {
    if (!is_IQRmodel(model))
      model <- IQRmodel(model)
    modPars__ <- names(model$parameters)
    indivPars__ <- indivPars__[,c("USUBJID", intersect(names(indivPars__), modPars__) )]
  }
  if (!is.null(regressorNames)) {
    notAvail__ <- setdiff(regressorNames, names(indivPars__))
    if (length(notAvail__) > 0) {
      warningIQR("Some required regressorNames do not exist in NLME model.")
    }
    indivPars__ <- indivPars__[,c("USUBJID", intersect(names(indivPars__), regressorNames) )]
  }
  cat("The following parameters are added to the dataset as regression parameters:\n")
  AddRegrNames__ <- setdiff(names(indivPars__), "USUBJID")
  if (length(AddRegrNames__) == 0) {
    stopIQR("no regression variables to be added.")
  } else {
    print(paste0(AddRegrNames__, collapse = ", "))
  }
  colIndexist <- setdiff(intersect(names(data__), names(indivPars__)), "USUBJID")
  if (length(colIndexist) > 0) {
    cat("The following regression colums exist and will be substituted:\n")
    print(paste0(colIndexist, collapse = ", "))
    data__[,colIndexist] <- NULL
  }
  attrData__                <- attributes(data__)
  data__                    <- merge(data__, indivPars__, by = "USUBJID", all = FALSE, sort = FALSE)
  attrData__$names          <- names(data__)
  attrData__$row.names      <- row.names(data__)
  attrData__$regressorNames <- unique(c(attrData__$regressorNames, AddRegrNames__))
  class(data__)             <- c("IQRdataGENERAL", "data.frame")
  attributes(data__)        <- attrData__
  regressorNames__ <- NULL
  if (!is.null(regressorNames)) {
    regressorNames__ <- intersect(regressorNames, attrData__$regressorNames)
  }
  if (!is.null(model)) {
    regressorNames__ <- intersect(modPars__, attrData__$regressorNames)
  }
  if (!is.null(regressorNames__)) {
    colIndex__ <- seq_along(data__)
    colIndex.regressors__ <- match(regressorNames__, names(data__))
    colIndex__[colIndex__ %in% colIndex.regressors__] <- colIndex.regressors__
    data__ <- data__[colIndex__]
    attrData__$names          <- names(data__)
    attrData__$regressorNames <- regressorNames__
    class(data__)             <- c("IQRdataGENERAL", "data.frame")
    attributes(data__)        <- attrData__
  }
  attrX__ <- attributes(data__)
  data__ <- dplyr::arrange(data__,ID,TIME,YTYPE)
  attributes(data__) <- attrX__
  if (!is.null(filename)) {
    exportNLME_IQRdataGENERAL(data            = data__,
                              regressorNames  = attrData__$regressorNames,
                              doseNAMES       = doseNAMES,
                              obsNAMES        = obsNAMES,
                              filename        = filename,
                              FLAGxpt         = FLAGxpt,
                              FLAGdefine      = FLAGdefine,
                              FLAGzip         = FLAGzip,
                              addColLabels    = addColLabels)
    return(NULL)
  }
  if (!is.null(doseNAMES)) {
    if (length(setdiff(doseNAMES,attr(data__,"doseNAMES"))) > 0) {
      stopIQR("Provided input argument doseNAMES contains element(s) that are not defined as doses")
    }
    data__$ADM[data__$EVID==1] <- 999
    data__$YTYPE[data__$EVID==1] <- 0 
    for (k in seq_along(doseNAMES)) {
      data__$ADM[data__$NAME == doseNAMES[k]] <- k
    }
  } else {
    doseNAMES <- attr(data__,"doseNAMES")
  }
  data__ <- data__[data__$ADM != 999,]
  if (!is.null(obsNAMES)) {
    if (length(setdiff(obsNAMES,attr(data__,"obsNAMES"))) > 0) {
      stopIQR("Provided input argument obsNAMES contains element(s) that are not defined as observations.")
    }
    data__$YTYPE[data__$EVID==0] <- 999 
    data__$ADM[data__$EVID==0] <- 0
    for (k in seq_along(obsNAMES)) {
      data__$YTYPE[data__$NAME == obsNAMES[k]] <- k
    }
  } else {
    obsNAMES <- attr(data__,"obsNAMES")
  }
  data__ <- data__[data__$YTYPE != 999,]
  attr(data__,"doseNAMES") <- doseNAMES
  attr(data__,"obsNAMES") <- obsNAMES
  return(list(regressorNames=AddRegrNames__, data=data__))
}
#'@importFrom utils zip
#'@export
zip_IQRdataGENERAL <- function(filenameinput, filenameoutput, FLAGpurge = FALSE) {
  pathname__ <- aux_fileparts(filenameinput)[["pathname"]]
  basename <- gsub("\\..*", "", basename(filenameinput)) 
  oldpath__ <- getwd()
  setwd(pathname__)
  files__ <- dir(pattern=paste0(basename,"\\."))
  files__ <- grep("zip", files__, invert = TRUE, value = TRUE)
  utils::zip(filenameoutput,files__)
  utils::zip()
  if (FLAGpurge) unlink(files__)
  setwd(oldpath__)
}
#'@export
#'@importFrom data.table fread
IQRloadCSVdata <- function(filename) {
  is_zip__ <- grepl("\\.csv\\.zip$", filename, ignore.case = TRUE)
  if (is_zip__) {
    outdir__ <- file.path(tempdirIQR(), "CSV")
    unlink(outdir__, recursive = TRUE)
    utils::unzip(filename, exdir = outdir__)
    myfiles__ <- list.files(outdir__, full.names = TRUE)
    if (length(myfiles__) == 0) stopIQR("Zip archive did not contain files.")
    if (length(myfiles__) > 1) stopIQR("Automatic CSV reading from zip file with multiple files is not supported.")
    if (!grepl("\\.csv$", myfiles__)) stopIQR("The zip file did not contain a csv file.")
    data__ <- as.data.frame(data.table::fread(myfiles__, na.strings=c(".","", "NA","NaN"), strip.white = TRUE,showProgress=FALSE))
    unlink(outdir__, recursive = TRUE)
    filenameATR__ <- paste0(aux_strrep(filename, ".csv.zip",""),".atr")
  } else {
    data__ <- as.data.frame(data.table::fread(filename,
                                              na.strings=c(".","", "NA","NaN"),
                                              strip.white = TRUE))
    filenameATR__ <- gsub('\\.csv(.gz)?$','.atr', filename)
  }
  atrcontents <- loadAttributeFile(filenameATR__)
  attributes(data__) <- c(attributes(data__),atrcontents)
  return(data__)
}
#'@export
#'@importFrom data.table fwrite
IQRsaveCSVdata <- function(data,filename,na=".",quote=FALSE,row.names=FALSE,FLAGattributes=TRUE,replaceComma=NULL) {
  if (is.null(filename)) return()
  aux_mkdir(aux_fileparts(filename)$pathname)
  containsComma__ <- unlist(lapply(data, function(x__) {
    if (is.character(x__)||is.factor(x__)){
      return(any(grepl(",", x__)))
    } else {
      return(FALSE)
    }
  }))
  if (!is.null(replaceComma) & any(containsComma__)) {
    for (i__ in which(containsComma__)) data[[i__]] <- gsub(",", replaceComma, data[[i__]])
  }
  if (is.null(replaceComma) & any(containsComma__)) {
    stopIQR("Column(s) ", paste(names(containsComma__)[containsComma__], collapse = ", "),
            " contain(s) comma. Cannot export as csv.\n",
            "  Use argument 'replaceComma' to define a replacement character.")
  }
  if (!grepl(".csv",filename)) filename <- paste0(filename,".csv")
  data.table::fwrite(x=data, file=filename, na=na, quote=quote, row.names=row.names)
  if (FLAGattributes) {
    attrStandard__ <- c("names","row.names","class", ".internal.selfref") 
    attr__ <- attributes(data)
    for (k in seq_along(attrStandard__)) {
      attr__[[attrStandard__[[k]]]] <- NULL
    }
    if (length(attr__) == 0) return(invisible(NULL))
    ATTRTEXT__ <- paste0("# Attributes file for dataset ",filename,"\n\n")
    ATTRTEXT__ <- paste0(ATTRTEXT__,"atrcontents <- list()\n\n")
    for (k in seq_along(attr__)) {
      n__ <- names(attr__[k])
      v__ <- attr__[[k]]
      ATTRTEXT__ <- paste0(ATTRTEXT__,"atrcontents$",n__," <- ",paste0(deparse(v__),collapse=""),"\n\n")
    }
    filenameATR <- gsub('\\.csv(.gz)?$','.atr', filename)
    aux_filewrite(ATTRTEXT__,filenameATR)
  }
}
#'@export
IQRloadSASdata <- function(data_file,as.data.frame=TRUE,noLabels=TRUE,replaceComma=TRUE) {
  if (grepl(".xpt",tolower(data_file),fixed = TRUE)){
    data__ <- haven::read_xpt(data_file)
  } else {
    if (grepl(".sas7bdat",tolower(data_file),fixed = TRUE)){
      data__ <- haven::read_sas(data_file)
    } else {
      stopIQR("Unknown data file extension")
    }
  }
  if (as.data.frame) data__ <- as.data.frame(data__)
  if (noLabels) {
    data__ <- unlabel_dataframe(data__)
  }
  flagmessage <- TRUE
  if (replaceComma) {
    for (k in seq_along(data__)) {
      col <- data__[[k]]
      if (is.character(col)) {
        newcol <- gsub(","," ",col)
        if (any(newcol!=col) & flagmessage) {
          message("Commata in character elements removed from the data during import and replaced by space (' ')")
          flagmessage <- FALSE
        }
      } else {
        newcol <- col
      }
      data__[[k]] <- newcol
    }
  }
  return(data__)
}
#'@export
unlabel_dataframe <- function(data,removeLabelledClass=TRUE,removeLabel=FALSE) {
  ddddd__ <- sapply(names(data), function (name) {
    if (removeLabel) attr(data[[name]],"label") <<- NULL
    if (removeLabelledClass) class(data[[name]]) <<- setdiff(class(data[[name]]),"labelled")
  })
  return(data)
}
#'@export
removeCommata_dataframe <- function(data,replaceComma=" ") {
  ddddd__ <- sapply(names(data), function (name) {
    if (!is.numeric(data[[name]])) data[[name]] <<- gsub(",",replaceComma,data[[name]])
  })
  return(data)
}
#'@export
getLabels_dataframe <- function (data,orderAlphabetically=FALSE,table=TRUE) {
  out <- do.call(rbind,lapply(names(data), function (name) {
    x <- attr(data[[name]],"label")
    if (is.null(x)) x <- ""
    data.frame(
      COLNAME = name,
      COLLABEL = x,
      stringsAsFactors = FALSE
    )
  }))
  if (orderAlphabetically) out <- dplyr::arrange(out,COLNAME)
  if (table) {
    out <- IQRoutputTable(xtable = out,xtitle="Content information of data.frame")
  }
  out
}
#'@export
date2time_IQRdataProgramming <- function (dateString,format="%Y-%m-%dT%H:%M") {
  time_seconds <- as.numeric(as.POSIXct(dateString,format=format))
  time_minutes <- time_seconds/60
  time_hours <- time_minutes/60
  time_days <- time_hours/24
  time_weeks <- time_days/7
  time_years <- time_days/365
  out <- list(
    time_seconds = time_seconds,
    time_minutes = time_minutes,
    time_hours = time_hours,
    time_days = time_days,
    time_weeks = time_weeks,
    time_years = time_years
  )
  out
}
#'@export
date2dateday_IQRdataProgramming <- function (dateString,format="%Y-%m-%dT%H:%M",formatday="%Y-%m-%d") {
  z <- as.POSIXct(dateString,format=format)
  out <- format(z,formatday)
  out
}
#'@export
date2datetime_IQRdataProgramming <- function (dateString,format="%Y-%m-%dT%H:%M",formattime="%H:%M") {
  z <- as.POSIXct(dateString,format=format)
  out <- format(z,formattime)
  out
}
#'@export
import_IQRsysData <- function(data, CONDITION = NULL, ID = "ID", TIME = "TIME", DV = "DV", YTYPE = "YTYPE",
                              covNames = NULL, catNames = NULL, regressorNames = NULL) {
  if (is.character(data))
    data__ <- IQRloadCSVdata(data)
  else if (is.data.frame(data))
    data__ <- data
  else
    stopIQR("Data is neither a filename nor a data frame.")
  if (is.null(CONDITION)) {
    if ("CONDITION" %in% names(data__))
      CONDITION <- "CONDITION"
    else
      CONDITION <- "ID"
  }
  standardCols__ <- c(CONDITION, ID, TIME, DV, YTYPE)
  requestedCols__ <- unique(c(standardCols__, covNames, catNames, regressorNames))
  contained__ <- sapply(requestedCols__, function(n) n %in% names(data__))
  if (!all(contained__))
    stopIQR("The following requested columns are not provided by the data file: ", paste(requestedCols__[!contained__], collapse = ", "))
  out__ <- data.frame(
    CONDITION        = as.character(data__[[CONDITION]]),
    ID               = as.integer(  data__[[ID]]),
    TIME             = as.double(   data__[[TIME]]),
    DV               = as.double(   data__[[DV]]),
    YTYPE            = as.integer(  data__[[YTYPE]]),
    stringsAsFactors = FALSE
  )
  nlmeCols__ <- c("IXGDF", "USUBJID", "ID", "TIME", "TIMEPOS", "TAD", "DV",
                  "MDV", "EVID", "CENS", "AMT", "ADM", "RATE", "TINF", "YTYPE")
  toImport__ <- setdiff(intersect(nlmeCols__, names(data__)), names(out__))
  for (n in toImport__) {
    out__[[n]] <- data__[[n]]
  }
  user__ <- setdiff(names(data__), standardCols__)
  for (n in user__) {
    out__[[n]] <- data__[[n]]
  }
  toImpute__ <- setdiff(c("IXGDF", "USUBJID", "MDV", "EVID", "CENS", "AMT", "ADM", "TINF", "RATE"), names(out__))
  if (length(toImpute__) > 0) {
    IDs__ <- unique(out__[["ID"]])
    for (n in toImpute__) {
      out__[[n]] <- switch(
        n,
        "IXGDF"   = seq_along(out__[[1]]),
        "USUBJID" = paste0("SJ", match(out__[["ID"]], IDs__)),
        "MDV"     = ifelse(out__[["YTYPE"]] == 0 | is.na(out__[["YTYPE"]]), 1, 0),
        "CENS"    = rep(0, length(out__[[1]])),
        "EVID"    = ifelse(out__[["YTYPE"]] == 0 | is.na(out__[["YTYPE"]]), 1, 0),
        "AMT"     = 0,
        "ADM"     = 0,
        "TINF"    = 0,
        "RATE"    = 0
      )
    }
  }
  for (n in covNames) out__[[n]] <- as.numeric(data__[[n]])
  for (n in catNames) {
    levels__ <- unique(sort(utils::type.convert(as.character(data__[[n]]))))
    out__[[n]] <- as.integer(factor(as.character(data__[[n]]), levels = as.character(levels__)))
  }
  for (n in regressorNames) out__[[n]] <- as.numeric(data__[[n]])
  out__ <- out__[order(out__[["ID"]], out__[["TIME"]]),]
  if (!"TAD" %in% names(out__)) {
    out__ <- IQRcalcTAD(out__)
  }
  if (!"TIMEPOS" %in% names(out__)) {
    out__ <- do.call(rbind,lapply(split(out__,out__[[ID]]), function (d__) {
      d__$TIMEPOS <- d__$TIME-d__$TIME[1]
      d__
    }))
  }
  if (!"ADDL" %in% names(out__)) out__$ADDL <- 0
  if (!"II" %in% names(out__)) out__$II <- 0
  out__$ADDL[is.na(out__$ADDL)] <- 0
  out__$II[is.na(out__$II)] <- 0
  if (any(out__$ADDL!=0 & out__$II==0)) stopIQR("ADDL non-zero/NA defined when II undefined")
  if (any(out__$ADDL==0 & out__$II!=0)) stopIQR("II non-zero/NA defined when ADDL undefined")
  add__ <- as.data.frame(out__[out__$ADDL!=0,])
  if (nrow(add__) > 0) {
    adddoses__ <- do.call(rbind,lapply(1:nrow(add__), function (k__) {
      row__ <- add__[k__,]
      addrows__ <- row__[rep(1,row__$ADDL+1),]
      addrows__$NNN__ <- 0:row__$ADDL
      addrows__$TIME <- addrows__$TIME+addrows__$NNN__*addrows__$II
      addrows__$TIMEPOS <- addrows__$TIMEPOS+addrows__$NNN__*addrows__$II
      addrows__$TAD <- 0
      addrows__$NNN__ <- NULL
      addrows__$ADDL <- 0
      addrows__$II <- 0
      addrows__
    }))
    out__ <- out__[out__$ADDL==0,]
    out__ <- rbind(
      out__,
      adddoses__
    )
    out__ <- dplyr::arrange(out__,CONDITION,ID,TIME,YTYPE)
  }
  out__ <- IQRnlmeData(out__, covNames, catNames, regressorNames,FLAGqsp=TRUE)
  class(out__) <- c("IQRsysData", class(out__))
  return(out__)
}
#'@export
IQRsysData <- function(input, covNames = NULL, catNames = NULL, regressorNames = NULL) {
  data__ <- IQRnlmeData(input, covNames, catNames, regressorNames,FLAGqsp=TRUE)
  if (!"CONDITION" %in% names(data__))
    stopIQR("CONDITION column is missing but is required for IQRsysData. Cosider importing with import_IQRsysData().")
  data__[["CONDITION"]] <- as.character(data__[["CONDITION"]])
  if (is.character(input)) {
    attr(data__, "filename") <- input
  } else {
    attr(data__, "filename") <- NA
  }
  class(data__) <- c("IQRsysData", class(data__))
  return(data__)
}
#'@export
exportSYS_IQRdataGENERAL <- function(data,
                                     regressorNames = NULL,
                                     doseNAMES      = NULL,
                                     obsNAMES       = NULL,
                                     filename       = NULL,
                                     FLAGxpt        = FALSE,
                                     FLAGdefine     = TRUE,
                                     FLAGzip        = FALSE,
                                     addColLabels   = NULL) {
  if (!"CONDITION" %in% names(data))
    data[["CONDITION"]] <- as.character(data[["ID"]])
  exportNLME_IQRdataGENERAL(
    data = data,
    regressorNames = regressorNames,
    doseNAMES = doseNAMES,
    obsNAMES = obsNAMES,
    filename = filename,
    FLAGxpt = FLAGxpt,
    FLAGdefine = FLAGdefine,
    FLAGzip = FLAGzip,
    addColLabels = addColLabels
  )
}
export_IQRsysData <- function(data, filename, ...) {
  filename__ <- paste0(aux_strrep(filename, ".csv", ""), ".csv")
  IQRoutputCSV(data = data, filename = filename__, ...)
}
#'@export
IQRsysEst <- function(model, dosing, data,
                      modelSpec = NULL, dMod_dataSpec = NULL,
                      ...) {
  if (!is.null(modelSpec$COVcentering))
    warningIQR(paste0("Custom centering values are not yet implemented in IQRtools SYSFIT functionality.",
                   "Default reference values generated from the data will be used.", collapse = "\n"))
  parameter_fields__ <- setNames(nm = c("POPvalues0", "POPestimate", "IIVdistribution", "IIVvalues0", "IIVestimate"))
  if (!all(parameter_fields__ %in% names(modelSpec))) {
    stopIQR("For the definition of modelSpec argument please use the modelSpec_IQRsysEst() function")
  }
  sysFit_parameters__ <- do.call(dMod_fill_sysEst_parameters, modelSpec[parameter_fields__])
  modelSpec__ <- modelSpec
  modelSpec__[parameter_fields__] <- sysFit_parameters__[parameter_fields__]
  est <- IQRnlmeEst(model, dosing, data, modelSpec__,FLAGqsp=TRUE)
  if (is.null(attr(est$model, "original")))
    attr(est$model, "original") <- est$model
  parsOfInterest__ <- list(...)[["parsOfInterest"]]
  if (is.null(parsOfInterest__))
    parsOfInterest__ <- union(names(modelSpec$POPvalues0),
                              sapply(names(modelSpec$LOCvalues0), function(n__) paste(n__, names(modelSpec$LOCvalues0[[n__]]), sep = "_")))
  args0__ <- list(
    Scenario = list(
      model = "IQRmodel",
      dosing = "NLME",
      data = "NLME",
      spec = "modelSpec"
    ),
    model = model,
    data = data,
    dosing = dosing,
    modelSpec = modelSpec,
    estSpec = modelSpec,
    parsOfInterest = parsOfInterest__
  )
  class(est) <- c("IQRsysEst", class(est))
  attr(est, "args0") <- args0__
  return(est)
}
#'@export
as_IQRsysEst <- function(sysModel, modelSpec = NULL) {
  if (all(sapply(sysModel$data[[1]], function(x__) nrow(x__) == 0)))
    stopIQR("No data was registered with your sysModel. Cannot convert to estimation object without data.")
  attributes__ <- attributes(sysModel)
  sysModelEst__ <- attributes__[["sysModelEst"]]
  model__ <- sysModelEst__[["model"]]
  dosing__ <- sysModelEst__[["dosing"]]
  data__ <- sysModelEst__[["data"]]
  estSpec__ <- sysModelEst__[["estSpec"]]
  parsOfInterest__ <- sysModelEst__[["parsOfInterest"]]
  fields__ <- c("POPvalues0", "POPestimate",
                "IIVdistribution", "IIVvalues0", "IIVestimate",
                "LOCmodel", "LOCvalues0", "LOCestimate")
  estSpec__[fields__] <- sysModel$parameters[[1]][fields__]
  modelSpec0__ <- modelSpec 
  merge__ <- function(x__, y__) c(y__, x__)[names(x__)]
  if (!is.null(modelSpec0__)) {
    estSpec__$POPestimate <- merge__(estSpec__$POPestimate, modelSpec0__[["POPestimate"]])
    estSpec__$IIVdistribution <- merge__(estSpec__$IIVdistribution, modelSpec0__[["IIVdistribution"]])
    estSpec__$IIVestimate <- merge__(estSpec__$IIVestimate, modelSpec0__[["IIVestimate"]])
    for (n__ in names(estSpec__$LOCestimate)) {
      estSpec__$LOCestimate[[n__]] <- merge__(estSpec__$LOCestimate[[n__]], modelSpec0__[["LOCestimate"]][[n__]])
    }
    estSpec__$POPvalues0 <- merge__(estSpec__$POPvalues0, modelSpec0__[["POPvalues0"]])
    estSpec__$IIVvalues0 <- merge__(estSpec__$IIVvalues0, modelSpec0__[["IIVvalues0"]])
    fields__ <- c("errorModel", "covariateModel", "covariateModelValues", "COVestimate")
    for (f__ in fields__) {
      if (!is.null(modelSpec0__[[f__]]))
        estSpec__[[f__]] <- modelSpec0__[[f__]]
    }
  }
  return(IQRsysEst(model__, dosing__, data__, estSpec__, parsOfInterest = parsOfInterest__))
}
#'@export
is_IQRsysEst <- function(input) {
  methods::is(input,"IQRsysEst")
}
#'@export
print.IQRsysEst <- function(x, ...) {
  print.IQRnlmeEst(x,...)
}
#'@export
modelSpec_IQRsysEst <- function (
  POPvalues0 = NULL,
  POPestimate = NULL,
  IIVdistribution = NULL,
  IIVvalues0 = NULL,
  IIVestimate = NULL,
  errorModel = NULL,
  covarianceModel = NULL,
  covariateModel = NULL,
  covariateModelValues = NULL,
  COVestimate = NULL,
  COVcentering = NULL,
  PriorVarPOP = NULL,
  PriorVarCovariateModelValues = NULL,
  PriorDFerrorModel = NULL,
  PriorIIV = NULL,
  PriorDFIIV = NULL,
  LOCmodel = NULL,
  LOCvalues0 = NULL,
  LOCestimate = NULL,
  LOCdistribution = NULL
) {
  modelSpec__ <- list()
  merge__ <- function(x__, y__, whoCalls__ = "") {
    if (is.null(y__)) return(x__)
    additional__ <- setdiff(names(y__), names(x__))
    if (length(additional__) > 0) {
      warningIQR("Found the following elements in ", whoCalls__,
              " which are disregarded because they are not present in POPvalues0: ",
              paste(additional__, collapse = ", "))
    }
    c(y__, x__)[names(x__)]
  }
  if (is.null(POPvalues0) & is.null(LOCvalues0))
    stopIQR("At least POPvalues0 or LOCvalues0 has to be supplied.")
  modelSpec__$POPvalues0 <- POPvalues0
  if (length(LOCvalues0) > 0) {
    first_LOCvalues0 <- sapply(LOCvalues0, function(v__) v__[[1]])
    POPvalues0 <- c(POPvalues0, first_LOCvalues0[!names(first_LOCvalues0) %in% names(POPvalues0)])
    modelSpec__$POPvalues0 <- POPvalues0
  }
  if (length(LOCestimate) > 0) {
    first_LOCestimate <- sapply(LOCestimate, function(v__) v__[[1]])
    POPestimate <- c(POPestimate, first_LOCestimate[!names(first_LOCestimate) %in% names(POPestimate)])
    modelSpec__$POPestimate <- POPestimate
  }
  modelSpec__$POPestimate <- merge__(0*POPvalues0 + 1, POPestimate)
  modelSpec__$IIVdistribution <-
    merge__(ifelse(POPvalues0 <= 0, "N", "L"), IIVdistribution)
  modelSpec__$IIVvalues0 <- merge__(0*POPvalues0, IIVvalues0)
  modelSpec__$IIVestimate <- merge__(0*POPvalues0, IIVestimate)
  modelSpec__$errorModel <- errorModel
  modelSpec__$covarianceModel <- covarianceModel
  modelSpec__$covariateModel <- covariateModel
  modelSpec__$covariateModelValues <- covariateModelValues
  modelSpec__$COVestimate <- COVestimate
  modelSpec__$COVcentering <- COVcentering
  modelSpec__$PriorVarPOP <- PriorVarPOP
  modelSpec__$PriorVarCovariateModelValues <- PriorVarCovariateModelValues
  modelSpec__$PriorDFerrorModel <- PriorDFerrorModel
  modelSpec__$PriorIIV <- PriorIIV
  modelSpec__$PriorDFIIV <- PriorDFIIV
  parameters__ <- union(names(LOCmodel), names(LOCvalues0))
  if (!all(parameters__ %in% names(POPvalues0)))
    warningIQR("The following parameters listed in LOCmodel or LOCvalues0 ",
            "were not defined in POPvalues0 and were discarded: ",
            paste(setdiff(parameters__, names(POPvalues0)), collapse = ", "))
  parameters <- intersect(parameters__, names(POPvalues0))
  names(parameters__) <- parameters__
  modelSpec__$LOCmodel <- lapply(parameters__, function(n__) {
    union(LOCmodel[[n__]], names(LOCvalues0[[n__]]))
  })
  modelSpec__$LOCvalues0 <- lapply(parameters__, function(n__) {
    conditions__ <- modelSpec__$LOCmodel[[n__]]
    default.values__ <- structure(rep(modelSpec__$POPvalues0[n__], length(conditions__)), names = conditions__)
    merge__(default.values__, LOCvalues0[[n__]])
  })
  modelSpec__$LOCestimate <- lapply(parameters__, function(n__) {
    conditions__ <- modelSpec__$LOCmodel[[n__]]
    default.values__ <- structure(rep(modelSpec__$POPestimate[n__], length(conditions__)), names = conditions__)
    merge__(default.values__, LOCestimate[[n__]])
  })
  modelSpec__$LOCdistribution <- lapply(parameters__, function(n__) {
    conditions__ <- modelSpec__$LOCmodel[[n__]]
    default.values__ <- structure(rep(modelSpec__$IIVdistribution[n__], length(conditions__)), names = conditions__)
    merge__(default.values__, LOCdistribution[[n__]])
  })
  return(modelSpec__)
}
dMod_build_indiv_grids <- function(myNlmeEst__, my_dMod_data, basic_dMod_model__ = NULL) {
  IDs <- stats::setNames(nm = names(my_dMod_data))
  fixed.grid__ <- covariates(my_dMod_data)
  est.grid__       <- fixed.grid__[!names(fixed.grid__)%in%c(attr(my_dMod_data, "covNames"),
                                                             attr(my_dMod_data, "catNames"),
                                                             attr(my_dMod_data, "regressorNames"))]
  est.vec <- NULL
  for(mycatname__ in myNlmeEst__$data$catNames) {
    fixed.grid__ <- dMod_expand_cat(fixed.grid__,
                                  mycatname__,
                                  myNlmeEst__$data$catValues[[mycatname__]],
                                  myNlmeEst__$data$covariateCATreference[[mycatname__]])
  }
  cov_trafo__ <- dMod_build_covcat_trafo(myNlmeEst__)
  if (!is.null(attr(cov_trafo__, "fixed")))
    fixed.grid__ <- cbind(fixed.grid__, as.data.frame(t(attr(cov_trafo__, "fixed"))))
  betas__ <- dMod_get_default_betas(myNlmeEst__, cov_trafo__)
  if (!is.null(betas__))
    est.grid__ <- cbind(est.grid__, as.data.frame(t(stats::setNames(names(betas__), names(betas__))), stringsAsFactors = FALSE))
  est.vec <- c(est.vec, betas__)
  parameters__ <- myNlmeEst__$modelSpec[c("POPvalues0", "POPestimate", "IIVdistribution", "IIVvalues0", "IIVestimate")]
  parameters_est_IIV__ <- names(parameters__[["IIVvalues0"]][parameters__[["IIVestimate"]] != 0])
  IIVpars__ <- dMod_build_IIVpars(parameters = parameters__, conditions = IDs)
  if (!is.null(IIVpars__$fixed.grid_IIV))
    fixed.grid__ <- merge(fixed.grid__, IIVpars__$fixed.grid_IIV, by = "ID")
  if (!is.null(IIVpars__$est.grid_IIV))
    est.grid__ <- merge(est.grid__, IIVpars__$est.grid_IIV, by = "ID")
  est.vec <- c(est.vec, IIVpars__$pars)
  est_pop__ <- parameters__[["POPvalues0"]][parameters__[["POPestimate"]] == 1]
  fixed_pop__ <- parameters__[["POPvalues0"]][parameters__[["POPestimate"]] == 0]
  if (!is.null(fixed_pop__))
    fixed.grid__ <- cbind(fixed.grid__, as.data.frame(t(fixed_pop__)))
  if (!is.null(est_pop__))
    est.grid__ <- cbind(est.grid__, as.data.frame(t(stats::setNames(names(est_pop__), names(est_pop__))), stringsAsFactors = FALSE), stringsAsFactors = FALSE)
  est.vec <- c(est.vec, est_pop__)
  fixed_by_dosing__ <- attr(my_dMod_data, "dosing_pars")
  fixed_by_dosing__ <- fixed_by_dosing__[!names(fixed_by_dosing__)%in%unique(c(names(est_pop__), parameters_est_IIV__))]
  regressionPars__ <- sapply(myNlmeEst__[["modelInfo"]][["param_reg"]], function(x__) x__[["name"]])
  fixed_by_dosing__ <- fixed_by_dosing__[!names(fixed_by_dosing__)%in%regressionPars__]
  if (!is.null(fixed_by_dosing__))
    fixed.grid__ <-  merge(fixed.grid__[ , c("ID", setdiff(names(fixed.grid__), names(fixed_by_dosing__)))], fixed_by_dosing__, by = "ID")
  if (!is.null(basic_dMod_model__$fixed))
    fixed_unspecified__ <- data.frame(ID = IDs, as.data.frame(t(basic_dMod_model__$fixed)))
  wanted_names__ <- c("ID", setdiff(names(fixed_unspecified__), names(fixed.grid__)))
  if (!is.null(fixed_unspecified__[wanted_names__]))
    fixed.grid__ <- merge(fixed.grid__, fixed_unspecified__[wanted_names__], by = "ID", all = FALSE, all.x = TRUE, all.y = FALSE)
  errorModel <- dMod_convert2dMod_errorModel__(myNlmeEst__$modelSpec$errorModel)
  errorPars__ <- attr(errorModel, "values0")
  if (!is.null(errorPars__))
    est.grid__ <- cbind(est.grid__, as.data.frame(t(stats::setNames(names(errorPars__), names(errorPars__))), stringsAsFactors = FALSE))
  est.vec <- c(est.vec, attr(errorModel, "values0"))
  CONDITION_exists__ <- !is.null(c(fixed.grid__$CONDITION, est.grid__$CONDITION))
  if (CONDITION_exists__){
    IDCOND.grid__ <- est.grid__[c("ID", "CONDITION")]
    LOC_grids__ <- dMod_build_LOC.grids(myNlmeEst__, IDCOND.grid__)
    if (!is.null(LOC_grids__$fixed.grid_LOC))
      fixed.grid__ <- merge(fixed.grid__[setdiff(names(fixed.grid__), names(myNlmeEst__$modelSpec$LOCmodel))], LOC_grids__$fixed.grid_LOC)
    if (!is.null(LOC_grids__$est.grid_LOC))
      est.grid__ <- merge(est.grid__[setdiff(names(est.grid__), names(myNlmeEst__$modelSpec$LOCmodel))], LOC_grids__$est.grid_LOC)
    if (!is.null(LOC_grids__$est.vec_LOC))
      est.vec <- c(est.vec, LOC_grids__$est.vec_LOC)
    est.vec <- est.vec[intersect(names(est.vec), unlist(est.grid__))]
  }
  fixed.grid__$ID <- as.character(fixed.grid__$ID)
  est.grid__$ID <- as.character(est.grid__$ID)
  tG0__ <- names(parameters__[["IIVdistribution"]])[parameters__[["IIVdistribution"]] == "G"]
  tL0__ <- names(parameters__[["IIVdistribution"]])[parameters__[["IIVdistribution"]] == "L"]
  tG__ <- tG0__[!tG0__ %in% names(cov_trafo__)]
  tL__ <- tL0__[!tL0__ %in% names(cov_trafo__)]
  base_pars__ <- structure(names(est.vec), names = names(est.vec))
  if (CONDITION_exists__) {
    loc_est_parnames__ <- setdiff(names(LOC_grids__$est.grid_LOC), c("CONDITION", "ID"))
    loc_base_pars__ <- unlist(lapply(loc_est_parnames__, function(n__) {
      value__ <- structure(rep(n__, nrow(LOC_grids__$est.grid_LOC)), names = LOC_grids__$est.grid_LOC[[n__]])
      value__[!is.na(names(value__))]
    }))
    base_pars__[intersect(base_pars__, names(loc_base_pars__))] <- loc_base_pars__[intersect(base_pars__, names(loc_base_pars__))]
  }
  tG1__ <- names(base_pars__)[base_pars__ %in% tG0__]
  tL1__ <- names(base_pars__)[base_pars__ %in% tL0__]
  est.vec[tG1__] <- logit(est.vec[tG1__])
  est.vec[tL1__] <- log(est.vec[tL1__])
  est.vec[est.vec == Inf] <- 750
  est.vec[est.vec == -Inf] <- -750
  tG2__ <- tG0__[tG0__ %in% names(fixed.grid__)]
  tL2__ <- tL0__[tL0__ %in% names(fixed.grid__)]
  fixed.grid__[tG2__] <- lapply(fixed.grid__[tG2__], logit)
  fixed.grid__[tL2__] <- lapply(fixed.grid__[tL2__], log)
  infinites__ <- vapply(fixed.grid__, function(.x) is.numeric(.x) & !is.na(.x) & !is.finite(.x), FUN.VALUE = rep(FALSE, nrow(fixed.grid__)))
  fixed.grid__[infinites__] <- -750 
  return(list(fixed.grid = fixed.grid__, est.grid = est.grid__, est.vec = est.vec))
}
dMod_build_nlme_trafo <- function(myNlmeEst__, IDs, basic_dMod_model__) {
  cov_trafo__ <- dMod_build_covcat_trafo(myNlmeEst__)
  parameters__ <- myNlmeEst__$modelSpec[c("POPvalues0", "POPestimate", "IIVdistribution", "IIVvalues0", "IIVestimate")]
  parameters_est_IIV__ <- names(parameters__[["IIVvalues0"]][parameters__[["IIVestimate"]] != 0])
  IIVpars__ <- dMod_build_IIVpars(parameters = parameters__, conditions = IDs)
  errorModel <- dMod_convert2dMod_errorModel__(myNlmeEst__$modelSpec$errorModel)
  tG0__ <- names(parameters__[["IIVdistribution"]])[parameters__[["IIVdistribution"]] == "G"]
  tL0__ <- names(parameters__[["IIVdistribution"]])[parameters__[["IIVdistribution"]] == "L"]
  tG__ <- tG0__[!tG0__ %in% names(cov_trafo__)]
  tL__ <- tL0__[!tL0__ %in% names(cov_trafo__)]
  trafo__ <- getEquations(basic_dMod_model__[["p"]])[[1]]
  trafo1__ <- setdiff(names(parameters__[["POPvalues0"]]), names(trafo__))
  names(trafo1__) <- trafo1__
  trafo__ <- c(trafo__, trafo1__)
  trafo__ <- repar("x ~ y", x = names(cov_trafo__), y = cov_trafo__, trafo = trafo__)
  trafo__ <- repar("x ~ exp(x)",            x = tL__,                         trafo = trafo__)
  trafo__ <- repar("x ~ exp(x)/(1+exp(x))", x = tG__,                         trafo = trafo__)
  trafo__ <- repar("x ~ exp(x)",            x = getSymbols(errorModel), trafo = trafo__)
  if (any(parameters__[["IIVestimate"]] > 0)) {
    trafo__ <- repar(expr = "x ~ (x + ETA_x)", trafo = trafo__,
                           x = names(parameters__[["IIVvalues0"]])[parameters__[["IIVestimate"]] > 0])
  }
  return(trafo__)
}
dMod_build_nlme_p <- function(trafo__) {
  mywd__ <- getwd()
  setwd(tempdirIQR())
  output__ <- try({
    mymodelname__ <- paste0("p_individual", paste0(sample(c(0:9,letters), 8), collapse = ""))
    p__ <- P(trafo__, modelname = mymodelname__, compile = FALSE)
    files__ <- list.files(pattern = utils::glob2rx(paste0("p_individual", "*.c*")))
    timestamp__ <- format(Sys.time(), "%Y-%m-%d_%H-%M-%S")
    output__ <- paste0("IQRparTrafo_", timestamp__)
    path__ <- gsub("\\", "/", tempdirIQR(), fixed = TRUE)
    .so__ <- .Platform[["dynlib.ext"]]
    clean_loadedDLLs("IQRparTrafo_")
    system(paste0(R.home(component = "bin"), "/R CMD SHLIB ", paste(files__, collapse = " "), " -o ", file.path(path__, output__), .so__, " >xxx"), intern = TRUE)
    dyn.load(paste0(file.path(path__, output__), .so__))
    modelname(p__) <- output__
    unlink(paste0("*p_individual*.c"))
    unlink(paste0("*p_individual*.o"))
    unlink("xxx")
    p__
  }, silent = TRUE)
  setwd(mywd__)
  if (inherits(output__, "try-error"))
    stopIQR("Problems encountered with the generation of the parameter transformations.")
  return(output__)
}
print_IQRpartable <- function(partable, hardExclude = "ETA", softExclude = c("dosing", "ini"), level = 1, NSIGNIF=4, optimum = 1) {
  tasks__ <- c("Error model" = "error",
               "Dosing" = "dosing",
               "Covariates" = "beta",
               "Random effects" = "omega",
               "ETAs" = "ETA",
               "Fixed effects" = "pop")
  cols_l1__ <- c("Parameter" = "parametername",
                 "Value" = "parametervalue_linear",
                 "Estimate" = "estimated",
                 "Condition" = "CONDITION",
                 "Description" = "parametertask",
                 "Transformation" = "trafo",
                 "Base" = "belongs_to")
  cols_l2__ <- c("SE" = "sigma_linear",
                 "L95" = "lower95_parametervalue_linear",
                 "U95" = "upper95_parametervalue_linear")
  cols__ <- switch(as.character(level),
                   "1" = cols_l1__,
                   "2" = c(cols_l1__, cols_l2__))
  for (n__ in setdiff(cols__, names(partable))) partable[[n__]] <- NA
  partable__ <- partable[,cols__]
  partable__ <- filter(partable__, !parametertask %in% softExclude | estimated  == 1)
  partable__ <- filter(partable__, !parametertask %in% hardExclude)
  names(partable__) <- names(cols__)
  partable__[["Description"]] <- names(tasks__)[match(partable__[["Description"]], tasks__)]
  partable__[["Estimate"]] <- ifelse(partable__[["Estimate"]] == 1, paste0("+", partable__[["Transformation"]]), "-")
  pars_with_IIV__ <- match(partable__[["Base"]][partable__[["Description"]] == "Random effects"], partable__[["Parameter"]])
  fixed_pars_with_IIV__ <- pars_with_IIV__[partable__[["Estimate"]][pars_with_IIV__] == ""]
  partable__[["Estimate"]][fixed_pars_with_IIV__] <- partable__[["Transformation"]][fixed_pars_with_IIV__]
  partable__[["Value"]] <- signif(partable__[["Value"]], NSIGNIF)
  printcolumns__ <- 1:3
  if (level > 1) {
    partable__[["RSE (%)"]] <-
      ifelse(is.na(partable__[["SE"]]),
             yes = "--",
             no  = signif(100*partable__[["SE"]]/partable__[["Value"]], NSIGNIF)
      )
    printcolumns__ <- c(1:3, which(names(partable__) == "RSE (%)"))
    if (any(!is.na(c(partable__[["L95"]], partable__[["U95"]])))) {
      partable__[["CI (95%)"]] <-
        ifelse(is.na(partable__[["L95"]]),
               yes = "--",
               no  = paste0("[", signif(partable__[["L95"]], NSIGNIF), ", ", signif(partable__[["U95"]], NSIGNIF), "]")
        )
      printcolumns__ <- c(1:3, which(names(partable__) %in% c("RSE (%)", "CI (95%)")))
    }
  }
  global__ <- dplyr::filter(partable__, is.na(Condition))
  local__ <- dplyr::filter(partable__, !is.na(Condition))
  global__ <- split(global__[printcolumns__], global__[["Description"]])
  local__ <- split(local__[sort(union(printcolumns__, 4))], local__[["Description"]])
  convert2IQRtable <- function(x__) {
    if (length(x__) == 0) return(NULL)
    header.x__ <- names(x__[[1]])
    x__ <- lapply(names(x__), function(n__) {
      header__ <- paste0("**", n__, "**")
      values__ <- as_IQRtable(x__[[n__]])[-1,]
      compose_IQRtable(H = header__, V = values__, pattern = "H\n \n V")
    })
    x__[["rule"]] <- "x\n \n y"
    x__ <- c(list(matrix(header.x__, nrow = 1)), x__)
    x__ <- do.call(composeByRule_IQRtable, x__)
    x__
  }
  global__ <- convert2IQRtable(global__)
  local__ <- convert2IQRtable(local__)
  message__ <- paste0("--- Selected optimum: ", optimum, " ")
  message__ <- paste0(message__, paste(rep("-", 55 - nchar(message__)), collapse = ""), "\n")
  message(message__)
  if (length(global__) > 0) {
    message("--- Global parameters ---------------------------------\n")
    print(global__)
    cat("\n")
  } else {
    message("--- No global parameters defined ----------------------\n")
  }
  if (length(local__) > 0) {
    message("--- Local parameters ----------------------------------\n")
    print(local__)
    cat("\n")
  } else {
    message("--- No local parameters defined -----------------------\n")
  }
  cat(paste0("Values rounded to ", NSIGNIF," significant digits.\n"))
  cat("Estimated/fixed parameters (+/-)\nEstimation on (N) natural / (L) log / (G) logit scale.\n")
  return(invisible())
}
#'@export
comparePars_IQRsysModel <- function(sysmodel,...,SIMOPT.atol = 1e-6,SIMOPT.rtol=1e-6) {
  args__ <- list(...)
  if (!is_IQRsysModel(sysmodel))
    stopIQR("sysmodel argument is not an IQRsysModel")
  if (length(args__) > 0 && (is.null(names(args__)) || any(names(args__) == "")))
    stopIQR("All arguments passed via ... to setPars_IQRsysModel() must be named.")
  if (!all(sapply(args__, is.numeric)))
    stopIQR("Arguments passed via ... to setPars_IQRsysModel() must be numeric.")
  pred <- do.call(rbind,lapply(seq_along(args__), function (k) {
    param <- args__[[k]]
    cbind(Parameters=names(args__)[k],
          sim_IQRsysModel(sysmodel,
                          parameters = param,
                          SIMOPT.atol = SIMOPT.atol,
                          SIMOPT.rtol=SIMOPT.rtol)$prediction[[1]])
  }))
  pred$name <- as.character(pred$name)
  data <- as.data.frame(sysmodel$data[[1]])
  if (nrow(data)>0) {
    data$name <- as.character(data$name)
    dataOrig__ <- as.data.frame(attr(sysmodel, "sysModelEst")$IQRsysData)
    if (!"UNIT" %in% names(dataOrig__)) dataOrig__$UNIT <- NA
    info <- unique(dataOrig__[!is.na(dataOrig__$YTYPE) & dataOrig__$YTYPE>0,c("NAME","YTYPE","UNIT")])
    info$name <- paste0("OUTPUT",info$YTYPE)
    info$TEXT <- paste0(info$NAME," (",info$UNIT,")")
    info <- info[,c("name","TEXT")]
    data <- dplyr::left_join(data,info,by="name")
    pred <- dplyr::left_join(pred,info,by="name")
    data$name <- data$TEXT
    pred$name <- pred$TEXT
  }
  p <- IQRggplot(pred, aes(x = time, y = value)) +
    geom_line(aes(color=Parameters),size=1)
  if (nrow(data)>0) p <- p + geom_point(data = data,aes(x=time,y=value))
  p <- p + facet_wrap(~CONDITION*name,scales = "free") +
    scale_color_IQRtools()
  p
}
#'@export
is_IQRsysModel <- function(input) {
  methods::is(input,"IQRsysModel")
}
#'@export
IQRsysModel <- function(model, dosing = NULL, data = NULL, modelSpec = NULL) {
  args0 <- list(
    model = model,
    dosing = dosing,
    data = data,
    modelSpec = modelSpec
  )
  if (is.character(model) && file.exists(model)) {
    model_scenario__ <- "filename"
    modelCheck__ <- IQRmodel(model,FLAGsim = FALSE)
  } else {
    if (is_IQRmodel(model)) {
      model_scenario__ <- "IQRmodel"
      modelCheck__ <- model
    } else {
      stopIQR("Model argument misspecified.")
    }
  }
  if (length(modelCheck__$outputs)==0) stopIQR("For import to an IQRsysModel the IQRmodel needs to contain at least one OUTPUT* variables")
  if (length(modelCheck__$functions)!=0) stopIQR("IQRsysModel cannot yet handle functions in IQRmodels")
  if (!is.null(modelCheck__$Cfunctions)) stopIQR("IQRsysModel cannot yet handle C-code functions in IQRmodels")
  if (is.null(dosing)) {
    dosing_scenario__ <- "null"
  } else {
    if (is_IQRdosing(dosing)) {
      dosing_scenario__ <- "IQRdosing"
    } else {
      if (is.list(dosing) && all(sapply(dosing, is_IQRdosing))) {
        dosing_scenario__ <- "List of IQRdosing"
      } else {
        if (is.list(dosing) && all(grepl("INPUT", names(dosing))) && all(sapply(dosing, function(x) {is.character(x) & "type" %in% names(x)}))) {
          dosing_scenario__ <- "NLME"
        } else {
          stopIQR("Dosing argument misspecified.")
        }
      }
    }
  }
  if (is.null(data)) {
    data_scenario__ <- "null"
  } else {
    if (is_IQRnlmeData(data) | is_IQRsysData(data)) {
      data_scenario__ <- "IQRsysData"
    } else {
      if (is.list(data) && "datafile" %in% names(data)) {
        data_scenario__ <- "NLME"
      } else {
        stopIQR("Data argument misspecified.")
      }
    }
  }
  if (is.null(modelSpec)) {
    modelSpec_scenario__ <- "null"
  } else {
    if (is.list(modelSpec)) {
      modelSpec_scenario__ <- "modelSpec"
    } else {
      stopIQR("Model specification argument misspecified.")
    }
  }
  args0[["Scenario"]] = list(
    model = model_scenario__,
    dosing = dosing_scenario__,
    data = data_scenario__,
    spec = modelSpec_scenario__
  )
  model__ <- convert2dMod_IQRmodel(list(model = model), FLAGonlyMeta = TRUE, FLAGderiv = FALSE)
  parameters__ <- names(model__$fixed)
  inputs__ <- parameters__[grepl("^INPUT", parameters__)]
  dummyInputs__ <- 0
  if (length(inputs__) == 0) {
    inputs__ <- "INPUT1"
    dummyInputs__ <- 1
  }
  if (model_scenario__ == "filename")
    model <- IQRmodel(model, FLAGsim = FALSE, FLAGsym = FALSE)
  if (dosing_scenario__ == "null" & data_scenario__ == "null") {
    dosingTable__ <- IQRdosing(
      TIME = rep(0, length(inputs__)),
      ADM  = seq_along(inputs__),
      AMT  = rep(0, length(inputs__))
    )
    dosing <- list(dosingTables = dosingTable__)
  }
  if (dosing_scenario__ == "IQRdosing")
    dosing <- list(dosingTables = dosing)
  if (dosing_scenario__ == "List of IQRdosing")
    dosing <- list(dosingTables = dosing)
  data_dosing__ <- NULL
  if (dosing_scenario__ ==  "List of IQRdosing") {
    dosing_table__ <- dplyr::bind_rows(dosing$dosingTables, .id = "CONDITION")
    dosing_table__[["ID"]] <- as.numeric(as.factor(dosing_table__$CONDITION))
    data_dosing__ <- dosing_table__
  }
  if (data_scenario__ == "NLME") {
    data_full__ <- do.call("IQRsysData", list(input = data$datafile,
                                              covNames = data$covNames,
                                              catNames = data$catNames,
                                              regressorNames = data$regressorNames))
  }
  if (data_scenario__ == "IQRsysData") {
    data_full__ <- data
  }
  if (data_scenario__ == "null") {
    data_full__ <- NULL
  }
  if (!is.null(data_full__)) {
    if (!"ADDL" %in% names(data_full__)) data_full__$ADDL <- 0
    if (!"II" %in% names(data_full__)) data_full__$II <- 0
    if (any(data_full__$ADDL != 0)) stopIQR("ADDL column in dataset is used for repeated dosing.\nThis is not yet supported.\nPlease expand the doses - e.g. using import_IQRsysData")
    if (any(data_full__$II != 0)) stopIQR("II column in dataset is used for repeated dosing.\nThis is not yet supported.\nPlease expand the doses - e.g. using import_IQRsysData")
  }
  if (data_scenario__ != "null")
    data_dosing__        <- data_full__[ (data_full__$YTYPE == 0 | is.na(data_full__$YTYPE)),]
  regressorNames__ <- attr(data_full__, "regressorNames")
  pars_noRegressors__ <- setdiff(parameters__, regressorNames__)
  parsOfInterest__ <- pars_noRegressors__
  modelSpec__ <- list()
  modelSpec__[["POPvalues0"]] <- model__$fixed[pars_noRegressors__]
  modelSpec__[["POPestimate"]] <- 0*modelSpec__[["POPvalues0"]]
  modelSpec__[["IIVdistribution"]] <- structure(ifelse(modelSpec__[["POPvalues0"]] <= 0, "N", "L"),
                                                names = pars_noRegressors__)
  if (!is.null(data_dosing__) && nrow(data_dosing__) > 0) {
    if (!is.null(data_full__))
      dosing_pars__ <- dMod_build_dosing_parameters(data_full__, inputs = length(inputs__))
    else
      dosing_pars__ <- dMod_build_dosing_parameters(data_dosing__, inputs = length(inputs__))
    condition_is_unique__ <- sapply(split(dosing_pars__, dosing_pars__[["CONDITION"]]), function(d__) {
      nrow(d__) <= 1 || all(sapply(d__[setdiff(names(d__), c("ID", "CONDITION"))], function(x) length(unique(x)) == 1))
    })
    dosing_lagtimes__ <- names(dosing_pars__)[grepl("^Tlag", names(dosing_pars__))]
    dosing_lagtimes__ <- setdiff(dosing_lagtimes__, regressorNames__)
    for (n__ in dosing_lagtimes__) {
      modelSpec__[["POPvalues0"]][n__] <- structure(0, names = n__)
      modelSpec__[["POPestimate"]][n__] <- structure(0, names = n__)
      modelSpec__[["IIVdistribution"]][n__] <- structure("N", names = n__)
    }
    dosing_parnames__ <- setdiff(names(dosing_pars__), c("ID", "CONDITION", dosing_lagtimes__, regressorNames__))
    modelSpec__[["LOCmodel"]] <- modelSpec__[["LOCvalues0"]] <- modelSpec__[["LOCestimate"]] <- list()
    for (n__ in dosing_parnames__) {
      conditions__ <- unique(dosing_pars__[["CONDITION"]])
      modelSpec__[["IIVdistribution"]][[n__]] <- "N"
      modelSpec__[["LOCmodel"]][[n__]] <- conditions__
      modelSpec__[["LOCvalues0"]][[n__]] <- structure(dosing_pars__[[n__]][!duplicated(dosing_pars__[["CONDITION"]])],
                                                      names = conditions__)
      modelSpec__[["LOCestimate"]][[n__]] <- structure(rep(0, length(conditions__)),
                                                       names = conditions__)
    }
    parsOfInterest__ <- setdiff(parsOfInterest__, dosing_parnames__)
  }
  if (!is.null(args0$modelSpec)) {
    parsOfInterest__ <- intersect(union(names(args0$modelSpec$POPvalues0), names(args0$modelSpec$LOCvalues0)), parsOfInterest__)
    parsOfInterest__ <- union(
      parsOfInterest__,
      sapply(names(args0$modelSpec$LOCvalues0), function(n__) paste(n__, names(args0$modelSpec$LOCvalues0[[n__]]), sep = "_"))
    )
    modelSpec0__ <- do.call("modelSpec_IQRsysEst", args0$modelSpec)
    n_default__ <- names(modelSpec__)
    n_addition__ <- setdiff(names(modelSpec0__), n_default__)
    merge__ <- function(x__, y__) c(y__, x__)[union(names(x__), names(y__))]
    for (n__ in n_default__)
      modelSpec__[[n__]] <- merge__(modelSpec__[[n__]], modelSpec0__[[n__]])
    for (n__ in n_addition__)
      modelSpec__[[n__]] <- modelSpec0__[[n__]]
  }
  modelSpec__ <- do.call("modelSpec_IQRsysEst", modelSpec__)
  condlist__ <- list(dosing = NULL, LOCmodel = NULL, LOCvalues0 = NULL, data = NULL)
  if (is.list(dosing$dosingTables) & (!is_IQRdosing(dosing$dosingTables)))
    condlist__$dosing <- names(dosing$dosingTables)
  if (!is.null(modelSpec__$LOCmodel))
    condlist__$LOCmodel  <- Reduce(union, modelSpec__$LOCmodel)
  if (!is.null(modelSpec__$LOCvalues0))
    condlist__$LOCvalues0 <- Reduce(union, lapply(modelSpec__$LOCvalues0, names))
  if (!is.null(data_full__$CONDITION))
    condlist__$data <- unique(data_full__$CONDITION)
  all_conditions__ <- Reduce(union, condlist__)
  at_least_one_but_not_all__ <- function(x) any(x) & !(all(x))
  cond_tests__ <- list(
    dosing_incomplete = at_least_one_but_not_all__(all_conditions__ %in% condlist__$dosing),
    data_incomplete   = at_least_one_but_not_all__(all_conditions__ %in% condlist__$data),
    conditions_incomplete = is.null(all_conditions__)
  )
  if (cond_tests__[["dosing_incomplete"]])
    stopIQR("Supplied list of dosingTables does not cover all conditions")
  if (cond_tests__[["conditions_incomplete"]])
    all_conditions__ <- "BASE"
  IDCOND.grid__ <- data.frame(unique(data_full__[c("ID", "CONDITION")]), row.names = NULL)
  if (any(duplicated(IDCOND.grid__$ID)))
    stopIQR("One ID is associated with more than one condition. This is not allowed.")
  if (nrow(IDCOND.grid__) == 0)
    IDCOND.grid__ <- data.frame(ID = seq_along(all_conditions__), CONDITION = all_conditions__, stringsAsFactors = FALSE)
  if (is.null(data_full__)) {
    data_dosing__ <- dMod_generate_dosing_data(
      dosingTables    = dosing$dosingTables,
      all_conditions  = all_conditions__,
      IDCOND.grid = IDCOND.grid__)
    data_full__ <- import_IQRsysData(data_dosing__)
  }
  if (data_scenario__ == "null") {
    data <- list(datafile = file.path(tempdirIQR(), "sysData.csv"),
                 covNames = attr(data_full__, "covNames"),
                 catNames = attr(data_full__, "catNames"),
                 regressorNames = attr(data_full__, "regressorNames"))
    IQRsaveCSVdata(data = data_full__, filename = data$datafile, FLAGattributes=FALSE)
  }
  if (data_scenario__ == "IQRsysData") {
    filename__ <- attr(args0[["data"]], "filename")
    if (is.null(filename__)) {
      frompath__ <- gsub("\\", "/", getwd(), fixed = TRUE)
      topath__ <- gsub("\\", "/", tempdirIQR(), fixed = TRUE)
      filename__ <- file.path(aux_getRelPath(frompath__, topath__), "sysData.csv")
    }
    data <- list(datafile = filename__,
                 covNames = attr(data_full__, "covNames"),
                 catNames = attr(data_full__, "catNames"),
                 regressorNames = attr(data_full__, "regressorNames"))
    IQRsaveCSVdata(data = data_full__, filename = data$datafile, FLAGattributes=FALSE)
  }
  dosing <- dosing[!names(dosing) %in% "dosingTables"]
  dosing__ <- structure(lapply(inputs__, function(i__) {
    c(type = "BOLUS")
  }), names = inputs__)
  if (!is.null(dosing)) {
    dosing__[names(dosing)] <- dosing[names(dosing)]
  }
  model_IQR__ <- model
  modelpars_IQR__ <- names(model_IQR__$parameters)
  modelpars_dMod__ <- c(names(modelSpec__$POPvalues0), regressorNames__)
  modelpars_dMod__ <- c(setdiff(modelpars_dMod__, modelpars_IQR__),
                        intersect(modelpars_IQR__, modelpars_dMod__))
  model$parameters <- structure(
    lapply(modelpars_dMod__, function(n__) {
      list(value = c(modelSpec__$POPvalues0, model__$fixed)[[n__]],
           type = NULL,
           compartment = NULL,
           unittype = NULL)
    }),
    names = modelpars_dMod__)
  if (dummyInputs__ == 1) {
    model$inputs <- list(
      INPUT1 = list(
        name = "INPUT1",
        factors = NULL,
        terms = NULL,
        stateindex = NULL,
        parindex = NULL
      )
    )
  }
  attr(model, "original") <- model_IQR__
  sysModelEst <- IQRsysEst(model, dosing__, data, modelSpec__)
  class(sysModelEst) <- c("IQRsysModelEst", class(sysModelEst))
  sysModelEst$data$relPathFromProject <- "."
  sysModelEst$data$fileName <- sysModelEst$data$datafile
  datanames__ <- stats::setNames(nm = c("datafile", "catNames", "covNames", "regressorNames"))
  data__ <- lapply(datanames__, function(i) sysModelEst$data[[i]])
  data__[["inputs"]] <- length(inputs__) 
  my_dMod_data__     <- do.call(convert2dMod_IQRdata, data__)
  basic_dMod_model__ <- convert2dMod_IQRmodel(est = sysModelEst, my_dMod_data = my_dMod_data__, FLAGderiv = FALSE)
  mymodel__          <- combine_model_and_data(basic_dMod_model__, my_dMod_data__, sysModelEst, 1, c(seq(0,20,.1)))
  attr(mymodel__, "args0") <- args0  
  attr(mymodel__, "sysModelEst") <- list(
    model = model,            
    dosing = dosing__,        
    data = data,              
    estSpec = modelSpec__,    
    modelSpec = sysModelEst$modelSpec,   
    parsOfInterest = parsOfInterest__,   
    est = sysModelEst,                    
    IQRsysData = data_full__      
  )
  return(mymodel__)
}
#'@export
model_IQRsysModel <- function(sysmodel) {
  attr(attr(sysmodel, "sysModelEst")[["model"]], "original")
}
#'@export
dataSpec_IQRsysModel <- function(sysmodel) {
  est <- attr(sysmodel, "sysModelEst")
  est$est$original$data
}
#'@export
modelSpec_IQRsysModel <- function(sysmodel) {
  est__ <- attr(sysmodel, "sysModelEst")
  parsOfInterest__ <- unlist(est__[["parsOfInterest"]])
  modelSpec__ <- est__[["modelSpec"]]
  modelSpec__$POPvalues0 <- modelSpec__$POPvalues0[intersect(names(modelSpec__$POPvalues0), parsOfInterest__)]
  modelSpec__$POPestimate <- modelSpec__$POPestimate[intersect(names(modelSpec__$POPestimate), parsOfInterest__)]
  modelSpec__$IIVdistribution <- modelSpec__$IIVdistribution[intersect(names(modelSpec__$IIVdistribution), parsOfInterest__)]
  modelSpec__$IIVestimate <- modelSpec__$IIVestimate[intersect(names(modelSpec__$IIVestimate), parsOfInterest__)]
  modelSpec__$IIVvalues0 <- modelSpec__$IIVvalues0[intersect(names(modelSpec__$IIVvalues0), parsOfInterest__)]
  modelSpec__$LOCmodel <- modelSpec__$LOCmodel[intersect(names(modelSpec__$LOCmodel), parsOfInterest__)]
  modelSpec__$LOCvalues0 <- modelSpec__$LOCvalues0[intersect(names(modelSpec__$LOCvalues0), parsOfInterest__)]
  modelSpec__$LOCestimate <- modelSpec__$LOCestimate[intersect(names(modelSpec__$LOCestimate), parsOfInterest__)]
  modelSpec__$LOCdistribution <- modelSpec__$LOCdistribution[intersect(names(modelSpec__$LOCdistribution), parsOfInterest__)]
  if (length(modelSpec__$LOCmodel) > 0)
    stopIQR("Models with local parameters not yet supported.")
  pars__ <- getPars_IQRsysModel(sysmodel, FLAGverbose = FALSE)
  pars.pop__ <- pars__[parsOfInterest__]
  pars.beta__ <- pars__[grepl("^beta_", names(pars__))]
  pars.error__ <- pars__[grepl("^error_", names(pars__))]
  modelSpec__$POPvalues0[parsOfInterest__] <- pars.pop__[parsOfInterest__]
  for (n__ in names(modelSpec__$covariateModelValues)) {
    currentValues__ <- modelSpec__$covariateModelValues[[n__]]
    for (m__ in names(currentValues__)) {
      newvalue__ <- pars.beta__[grepl(paste0("^beta_", n__, "_", m__), names(pars.beta__))]
      modelSpec__$covariateModelValues[[n__]][m__] <- newvalue__[[1]]
    }
  }
  for (n__ in names(modelSpec__$errorModel)) {
    ADM__ <- sub("OUTPUT", "", n__)
    newvalues__ <- pars.error__[names(pars.error__) %in% paste0("error_", c("ADD", "PROP"), ADM__)]
    modelSpec__$errorModel[[n__]] <- c(modelSpec__$errorModel[[n__]][1], newvalues__)
  }
  return(modelSpec__)
}
#'@export
getPrediction_IQRsysModel <- function(sysmodel) {
  prediction <- sysmodel[["prediction"]][[1]]
  prediction <- prediction[ , -match("condition", names(prediction))]
  return(prediction)
}
#'@export
getPars_IQRsysModel <- function(sysModel, ..., parameters = NULL, FLAGverbose = TRUE) {
  args__ <- list(...)
  if (!is.null(names(args__)))
    warningIQR("Arguments passed via ... to getPars_IQRsysModel() are expected to be unnamed. Names were removed.")
  if (!all(sapply(args__, is.character)))
    warningIQR("Found non-character arguments passed via ... to getPars_IQRsysModel(). Will be ignored.")
  if (!all(sapply(args__, length) == 1))
    warningIQR("Found arguments of length > 1 passed via ... to getPars_IQRsysModel(). Only the first element will be used.")
  names(args__) <- NULL
  args__ <- lapply(args__, function(x__) x__[[1]])
  args__ <- lapply(args__, function(x__) {
    if (!is.character(x__)) return(NULL) else return(x__)
  })
  if (!is.null(parameters)) {
    if (!is.character(parameters))
      stopIQR("Argument parameters must be character.")
    names(parameters) <- NULL
    parameters__ <- as.list(parameters)
    args__ <- c(args__, parameters__)
  }
  args__ <- c(args__, FLAGverbose = FLAGverbose)
  do.call(pars_IQRsysModel, c(list(sysModel), args__))
}
#'@export
setPars_IQRsysModel <- function(sysModel, ..., parameters = NULL, FLAGverbose = FALSE) {
  dosing <- NULL
  args__ <- list(...)
  if (length(args__) > 0 && (is.null(names(args__)) || any(names(args__) == "")))
    stopIQR("All arguments passed via ... to setPars_IQRsysModel() must be named.")
  if (!all(sapply(args__, is.numeric)))
    stopIQR("Arguments passed via ... to setPars_IQRsysModel() must be numeric.")
  if (!is.null(parameters) && !is.numeric(parameters))
    stopIQR("Parameters argument must be numeric or NULL.")
  if (!is.null(dosing) && (!is.list(dosing) & !is_IQRdosing(dosing)))
    stopIQR("Dosing argument must be IQRdosing object or list of IQRdosing objects or NULL.")
  pars_IQRsysModel(sysModel, ..., parameters = parameters, dosing = dosing, FLAGverbose = FLAGverbose)
}
#'@export
getDosing_IQRsysModel <- function(sysmodel) {
  IQmessage <- function(m, width = 55) message(paste0(substr(paste("---", m, paste(rep("_", width), collapse = "")), 1, width), "\n"))
  selectFirst__ <- function(x) x[1]
  partable__ <- sysmodel[["IQRpartable"]][[1]]
  dosingpars__ <- partable__[partable__[["parametertask"]] %in% "dosing",]
  if (nrow(dosingpars__) == 0) {
    IQmessage("No dosing available")
    return()
  }
  conditions__ <- unique(dosingpars__[["CONDITION"]])
  dosings__ <- lapply(conditions__, function(mycond__) {
    d__ <- dosingpars__[dosingpars__[["CONDITION"]] == mycond__, ]
    d__ <- d__[order(d__[["base_par"]]),]
    timepars__ <- d__[["base_par"]][grepl("^TIME", d__[["base_par"]])]
    ADM__  <- sapply(strsplit(gsub("TIME", "", timepars__), split = "_", fixed = TRUE), selectFirst__)
    TIME__ <- d__[["parametervalue_linear"]][grepl("^TIME", d__[["base_par"]])]
    TINF__ <- d__[["parametervalue_linear"]][grepl("^TINF", d__[["base_par"]])]
    AMT__  <- d__[["parametervalue_linear"]][grepl("^AMT" , d__[["base_par"]])]
    is_amountZero__ <- (AMT__ == 0)
    IQRdosing(
      TIME = as.numeric(TIME__[!is_amountZero__]),
      ADM  = as.integer(ADM__[!is_amountZero__]),
      AMT  = as.numeric(AMT__[!is_amountZero__]),
      TINF = as.numeric(TINF__[!is_amountZero__])
    )
  })
  names(dosings__) <- conditions__
  for (i__ in 1:length(dosings__)) {
    IQmessage(conditions__[i__])
    print(as_IQRtable(dosings__[[i__]]))
  }
  return(invisible(dosings__))
}
#'@export
sim_IQRsysModel <- function(sysModel, simtime = NULL, parameters = NULL, FLAGoutputsOnly = TRUE,
                            FLAGverbose  = FALSE,
                            SIMOPT.method = NULL, SIMOPT.atol = NULL, SIMOPT.rtol = NULL,
                            SIMOPT.hmin = NULL, SIMOPT.hmax = NULL, SIMOPT.hini = NULL,
                            SIMOPT.maxsteps = NULL, SIMOPT.nauxtimes = NULL) {
  if (!is_IQRsysModel(sysModel)) stopIQR("sysModel is not an IQRsysModel object")
  dosing <- NULL
  if (!is.null(parameters) | !is.null(dosing))
    sysModel <- pars_IQRsysModel(sysModel, parameters = parameters, dosing = dosing, FLAGverbose = FLAGverbose)
  if (!is.null(simtime))
    sysModel <- mutate_IQRsysModel(sysModel, times = list(simtime))
  prd__ <- sysModel[["prd"]][[1]]
  times__ <- sysModel[["times"]][[1]]
  pars__ <- sysModel[["pars"]][[1]]
  data__ <- sysModel[["data"]][[1]]
  errfn__ <- sysModel[["e"]][[1]]
  controls_g__ <- controls(sysModel[["g"]][[1]], NULL, "attach.input")
  controls_prd__ <- controls(sysModel[["x"]][[1]], NULL, "optionsOde")
  if (FLAGoutputsOnly)
    controls(sysModel[["g"]][[1]], NULL, "attach.input") <- FALSE
  else
    controls(sysModel[["g"]][[1]], NULL, "attach.input") <- TRUE
  SIMOPT__ <- list(method = SIMOPT.method, atol = SIMOPT.atol, rtol = SIMOPT.rtol,
                   hmin = SIMOPT.hmin, hini = SIMOPT.hini, maxsteps = SIMOPT.maxsteps,
                   nauxtimes = SIMOPT.nauxtimes)
  isNULL_SIMOPT__ <- sapply(SIMOPT__, is.null)
  if (!all(isNULL_SIMOPT__)) {
    for (k__ in which(!isNULL_SIMOPT__)) {
      controls(sysModel[["x"]][[1]], NULL, "optionsOde")[[names(SIMOPT__)[k__]]] <- SIMOPT__[[k__]]
    }
  }
  prediction__ <- as.data.frame(prd__(times__, pars__, deriv = FALSE), errfn = errfn__, data = data__)
  if (!is.null(simtime))
    prediction__ <- prediction__[prediction__[["time"]] %in% simtime, ]
  class(prediction__) <- c("IQRsysSimulation", "data.frame")
  controls(sysModel[["g"]][[1]], NULL, "attach.input") <- controls_g__
  controls(sysModel[["x"]][[1]], NULL, "optionsOde") <- controls_prd__
  mutate_IQRsysModel(sysModel,
                     prediction = list(prediction__))
}
#'@export
profile_IQRsysModel <- function(sysModel, parameters = NULL, limits = NULL, fixed = NULL, alpha = 0.05, ncores = 1, ...) {
  obj__ <- sysModel[["obj"]][[1]]
  pars__ <- unclass(sysModel[["pars"]][[1]])
  fixed_on_lower__ <- sysModel[["fixed_on_lower"]][[1]]
  fixed_on_upper__ <- sysModel[["fixed_on_upper"]][[1]]
  selected__ <- as.character(sysModel[["selected"]][[1]])
  dllfolder__ <- sysModel[["dllfolder"]][[1]]
  FLAGderiv__ <- sysModel[["options"]][[1]][["opt.method"]] %in% "trust"
  if (is.null(obj__))
    stopIQR("The sysModel does not contain and objective function. Please run parameter estimation before computing profile likelihood.")
  if (!FLAGderiv__)
    stopIQR("The objective function has been built without support for derivatives. Unable to compute profiles.")
  fixed_by_user__ <- pars__[fixed]
  if (is.null(limits)) limits <- c(lower = -Inf, upper = Inf)
  if (is.null(parameters)) parameters <- names(pars__)[!(grepl("^(omega|ETA|error_ADD|error_PROP)", names(pars__)) |
                                                           names(pars__)%in% names(c(fixed_on_lower__, fixed_on_upper__, fixed_by_user__)))]
  released__ <- intersect(parameters, names(c(fixed_on_lower__, fixed_on_upper__)))
  if (length(released__) > 0) {
    fixed_on_lower__ <- fixed_on_lower__[!names(fixed_on_lower__) %in% released__]
    fixed_on_upper__ <- fixed_on_upper__[!names(fixed_on_upper__) %in% released__]
  }
  mywd__ <- getwd()
  setwd(dllfolder__)
  profiles__ <- try(
    suppressMessages(profile(obj = obj__, pars = pars__, whichPar = parameters,
                                   alpha = alpha, limits = limits, cores = ncores,
                                   fixed = c(fixed_on_lower__, fixed_on_upper__, fixed_by_user__), ...)), silent = TRUE)
  setwd(mywd__)
  if (inherits(profiles__, "try-error")) {
    warningIQR("Profiles could not be computed. SysModel is returned without any changes.")
    return(sysModel)
  }
  if (!is.null(fixed))
    selected__ <- paste(c(selected__, paste(paste(fixed, collapse = ", "), "fixed")), collapse = "\n")
  if (length(released__) > 0)
    selected__ <- paste(c(selected__, paste(paste(released__, collapse = ", "), "released")), collapse = "\n")
  profiles0__ <- sysModel[["profiles"]][[1]]
  if (!is.null(profiles0__)) {
    if (selected__ %in% names(profiles0__)) {
      subprofiles0__ <- profiles0__[[selected__]]
      subprofiles0__ <- subprofiles0__[!subprofiles0__[["whichPar"]] %in% parameters, ] 
      profiles0__[[selected__]] <- rbind(profiles__, subprofiles0__)
    } else {
      profiles0__[[selected__]] <- profiles__
    }
  } else {
    profiles0__[[selected__]] <- profiles__
  }
  sysModel <- mutate_IQRsysModel(sysModel, profiles = list(profiles0__))
  sysModel <- partable_IQRsysModel(sysModel)
  return(sysModel)
}
#'@export
switchOpt_IQRsysModel <- function(sysModel, optimum) {
  parframe__ <- sysModel[["parframes"]][[1]]
  if (is.null(parframe__))
    stopIQR("The sysModel object does not (yet) contain multi-start fit information.")
  if (optimum > nrow(parframe__))
    stopIQR("Selected optimum number too high. Please check against plotWaterfall_IQRsysModel(.).")
  pars__ <- as.parvec(parframe__, optimum)
  selected__ <- optimum
  sysModel <- mutate_IQRsysModel(sysModel,
                                 pars = list(structure(as.numeric(pars__), names = names(pars__))),
                                 selected = list(selected__))
  sysModel <- vcov_IQRsysModel(sysModel)
  sysModel <- partable_IQRsysModel(sysModel)
  sysModel <- pred_IQRsysModel(sysModel)
  return(sysModel)
}
#'@export
plot.IQRsysModel <- function(x, ...,
                             time = NULL, log = NULL,
                             FLAGpred = TRUE, FLAGdata = TRUE,
                             FLAGerror = TRUE) {
  plot_IQRsysModel(x, time, log, FLAGpred, FLAGdata, FLAGerror)
}
#'@export
plot_IQRsysModel <- function(sysModel, time = NULL, log = NULL,
                             FLAGpred = TRUE, FLAGdata = TRUE, FLAGerror = NULL,
                             FLAGgroupCONDITION = FALSE, FLAGrmPredWithoutData = TRUE,
                             FLAGmultipage = FALSE, multipage.nrow = 2, multipage.ncol = 2,
                             states = NULL, conditions = NULL, IDs = NULL,
                             group = "ID") {
  if (group!="ID") warningIQR("Use of 'group' argument has been deprecated. Use 'FLAGgroupCONDITION=TRUE' instead")
  if (FLAGgroupCONDITION) {
    group = "CONDITION"
  } else {
    group = "ID"
  }
  group <- match.arg(group, c("ID", "CONDITION"))
  data__ <- as.data.frame(sysModel[["data"]][[1]])
  prediction__ <- as.data.frame(sysModel[["prediction"]][[1]])
  if (!is.null(states)) {
    if (!all(states %in% as.character(unique(prediction__$name)))) {
      stopIQR("At least one of the provided state names are not in the simulation output.\n  Check if you set FLAGoutputsOnly=FALSE in the sim_IQRsysModel() function.")
    }
  }
  if (!is.null(time) && !is.numeric(time) && length(time) < 2)
    stopIQR("Unable to compute time frame from argument 'time'. Please check 'time'.")
  if (!is.null(log) && !is.character(log))
    stopIQR("Argument 'log' must be character.")
  if (!is.null(log) && (log != "x" & log != "y" & log != "xy"))
    stopIQR("When argument 'log' is specified, it must be either 'x' or 'y' or 'xy'.")
  if (is.null(FLAGerror)) {
    pars__ <- utils::capture.output(suppressMessages(getPars_IQRsysModel(sysModel)))
    pars__ <- pars__[grepl("^error_", names(pars__))]
    if (inherits(sysModel, "optIQRsysModel")) {
      FLAGerror <- TRUE
    } else if (length(pars__) > 0 && any(pars__ != pi/10)) {
      FLAGerror <- TRUE
    } else {
      FLAGerror <- FALSE
    }
  }
  levels__ <- try(alphnumsort(unique(c(data__[["condition"]], prediction__[["condition"]]))), silent = TRUE)
  if (!inherits(levels__, "try-error")) {
    data__[["condition"]] <- factor(data__[["condition"]], levels = levels__)
    prediction__[["condition"]] <- factor(prediction__[["condition"]], levels = levels__)
  }
  if (!is.null(data__)) {
    if (!is.null(states)) {
      data__ <- filter(data__, name %in% states)
    }
    if (!is.null(conditions))
      data__ <- filter(data__, CONDITION %in% conditions)
    if (!is.null(IDs))
      data__ <- filter(data__, ID %in% IDs)
  }
  if (!is.null(prediction__)) {
    if (!is.null(states))
      prediction__ <- filter(prediction__, name %in% states)
    if (!is.null(conditions))
      prediction__ <- filter(prediction__, CONDITION %in% conditions)
    if (!is.null(IDs))
      prediction__ <- filter(prediction__, ID %in% IDs)
  }
  d__ <- suppressWarnings(
    dplyr::bind_rows(data = data__, prediction = prediction__, .id = ".source")
  )
  dataOrig__ <- as.data.frame(attr(sysModel, "sysModelEst")$IQRsysData)
  outputIX__ <- sort(as.numeric(gsub("OUTPUT","",as.character(unique(d__$name[grepl("OUTPUT[0-9]+",d__$name)])))))
  dataOutputIX__ <- unique(sort(dataOrig__$YTYPE))
  dataOutputIX__ <- dataOutputIX__[!is.na(dataOutputIX__)]
  if (length(outputIX__) > 0 & length(dataOutputIX__) > 0) {
      if (!"UNIT" %in% names(dataOrig__)) dataOrig__$UNIT <- "NA"
      outputInfo__ <- unique(dataOrig__[dataOrig__$YTYPE %in% outputIX__,c("NAME","UNIT","YTYPE")])
      outputInfo__$OUTPUT <- paste0("OUTPUT",outputInfo__$YTYPE)
      outputInfo__$TEXT <- gsub(":::"," ",paste0(outputInfo__$NAME," [",outputInfo__$UNIT,"]\n(",outputInfo__$OUTPUT,")"))
      d__$name <- as.character(d__$name)
      for (k in 1:nrow(outputInfo__)) {
        d__$name[d__$name==outputInfo__$OUTPUT[k]] <- outputInfo__$TEXT[k]
      }
      data__$name <- as.character(data__$name)
      for (k in 1:nrow(outputInfo__)) {
        data__$name[data__$name==outputInfo__$OUTPUT[k]] <- outputInfo__$TEXT[k]
      }
      prediction__$name <- as.character(prediction__$name)
      for (k in 1:nrow(outputInfo__)) {
        prediction__$name[prediction__$name==outputInfo__$OUTPUT[k]] <- outputInfo__$TEXT[k]
      }
      d__$CONDITION <- gsub(":::"," ",d__$CONDITION)
      data__$CONDITION <- gsub(":::"," ",data__$CONDITION)
      prediction__$CONDITION <- gsub(":::"," ",prediction__$CONDITION)
  }
  if (!"TIMEUNIT" %in% names(dataOrig__)) {
    xlab <- "Time"
  } else {
    xlab <- paste0("Time [",dataOrig__$TIMEUNIT[1],"]")
  }
  if (nrow(data__) > 0 & FLAGdata & FLAGrmPredWithoutData) {
    dataSelection__ <- Reduce(paste, unique(data__[, c("name", "ID", "CONDITION")]))
    if (nrow(prediction__) > 0) prediction__ <- prediction__[Reduce(paste, prediction__[, c("name", "ID", "CONDITION")]) %in% dataSelection__, ]
    d__ <- d__[Reduce(paste, d__[, c("name", "ID", "CONDITION")]) %in% dataSelection__, ]
  }
  facetLevels <- 1
  if (FLAGmultipage) facetLevels <- unique(paste(d__$CONDITION, d__$name))
  plots__ <- lapply(facetLevels, function(mylevel) {
    if (FLAGmultipage) {
      myd__ <- d__[paste(d__$CONDITION, d__$name) == mylevel,]
      mydata__ <- data__[paste(data__$CONDITION, data__$name) == mylevel,]
      myprediction__ <- prediction__[paste(prediction__$CONDITION, prediction__$name) == mylevel,]
    } else {
      myd__ <- d__
      mydata__ <- data__
      myprediction__ <- prediction__
    }
    if (group == "ID") {
      p__ <- ggplot(myd__, aes(x = time, y = value, color = condition, fill = condition)) +
        facet_wrap(~CONDITION*name, scales = "free")
    } else if (group == "CONDITION") {
      p__ <- ggplot(myd__, aes(x = time, y = value, group = condition, color = CONDITION, fill = CONDITION)) +
        facet_wrap(~name, scales = "free")
    }
    if (nrow(myprediction__) > 0 & FLAGpred) {
      if (FLAGerror && !is.null(myprediction__$sigma) && any(!is.na(myprediction__$sigma))) {
        p__ <- p__ + geom_ribbon(data = myprediction__,
                                 aes(ymin = value - sigma, ymax = value + sigma),
                                 alpha = .3, lty = 0)
      }
      p__ <- p__ + geom_line(data = myprediction__,size=1)
    }
    if (nrow(mydata__) > 0 & FLAGdata) {
      if (FLAGerror && !is.null(mydata__$sigma) && any(!is.na(mydata__$sigma))) {
        p__ <- p__ + geom_errorbar(data = mydata__,
                                   aes(ymin = value - sigma, ymax = value + sigma))
      }
      if (any(mydata__[["value"]] <= mydata__[["lloq"]]))
        p__ <- p__ +
          geom_point(data = mydata__, aes(pch = ifelse(value <= lloq, "yes", "no"))) +
          scale_shape_manual(name = "BLOQ", values = c(yes = 4, no = 19))
      else
        p__ <- p__ +
          geom_point(data = mydata__)
    }
    nID__ <- length(unique(c(mydata__[["ID"]], myprediction__[["ID"]])))
    mycolors__ <- rep_len(IQRtoolsColors[1:9], nID__)
    p__ <- p__ + scale_color_manual(name = group, values = mycolors__)
    p__ <- p__ + scale_fill_manual(name = group, values = mycolors__)
    if (!is.null(log)) {
      if (grepl("x", log)) p__ <- p__ + scale_x_log10()
      if (grepl("y", log)) p__ <- p__ + scale_y_log10()
    }
    if (!is.null(time)) {
      timerange__ <- range(time)
      p__ <- p__ + coord_cartesian(xlim = timerange__)
    }
    p__ <- p__ + ylab(label = NULL) + xlab(xlab)
    p__ + themeIQRtools()
  })
  if (FLAGmultipage) {
    fig__ <- IQRoutputFigure(plots__,
                             opt.layout = opt.layout(legend.option = "common",
                                                     nrow = multipage.nrow, ncol = multipage.ncol))
  } else {
    fig__ <- IQRoutputFigure(plots__,
                             opt.layout = opt.layout(legend.option = "common"),
                             npage = 1)
  }
  fig__
}
#'@export
print.optIQRsysModel <- function(x, ...) {
  args0__ <- attr(x, "args0")
  sysModelEst__ <- attr(x, "sysModelEst")
  model__ <- switch(args0__[["Scenario"]][["model"]],
                    filename = args0__$model,
                    IQRmodel = "IQRmodel object")
  if (is.null(model__)) model__ <- "No model information available!"
  dosing__ <- switch(args0__[["Scenario"]][["dosing"]],
                     null = "No dosing.",
                     IQRdosing = "IQRdosing object",
                     `List of IQRdosing` = "List of IQRdosing objects",
                     NLME = "Dosing provided with data")
  if (is.null(dosing__)) dosing__ <- "No dosing information available!"
  data__ <- switch(args0__[["Scenario"]][["data"]],
                   null = "No data",
                   IQRsysData = "IQRsysData object.",
                   NLME = sysModelEst__[["data"]][["datafile"]])
  if (is.null(data__)) data__ <- "No data information available!"
  spec__ <- switch(args0__[["Scenario"]][["spec"]],
                   null = "No model specification",
                   modelSpec = "Model was specified.")
  if (is.null(spec__)) spec__ <- "No model specification information available!"
  conditions__ <- unique(x[["fixed.grid"]][[1]][["CONDITION"]])
  if (is.null(conditions__)) conditions__ <- "No conditions available"
  prediction__ <- FALSE
  if (!is.null(x[["prediction"]][[1]]))
    prediction <- TRUE
  multistart__ <- FALSE
  if (!is.null(x[["parframes"]][[1]]))
    multistart__ <- TRUE
  profiles__ <- FALSE
  if (!is.null(x[["profiles"]][[1]]))
    profiles__ <- TRUE
  message("--- Optimized IQRsysModel object - basic information: --")
  cat("\n")
  cat("Model:      ", model__, "\n")
  cat("Dosing:     ", dosing__, "\n")
  cat("Data:       ", data__, "\n")
  cat("Specs:      ", spec__, "\n")
  cat("\n")
  cat("Conditions: ", conditions__[1], "\n")
  if (length(conditions__) > 1)
    for (i__ in 2:length(conditions__)) cat("            ", conditions__[i__], "\n")
  cat("\n")
  message("--- Additional information stored: --------------------")
  cat("\n")
  cat("Multistart estimation results: ", ifelse(multistart__, "yes", "no"), "\n")
  cat("Profile likelihood analysis: ", ifelse(profiles__, "yes", "no"), "\n")
  cat("\n")
  pars_IQRsysModel(x)
}
#'@export
print.IQRsysModel <- function(x, ...) {
  args0__ <- attr(x, "args0")
  sysModelEst__ <- attr(x, "sysModelEst")
  model__ <- switch(args0__[["Scenario"]][["model"]],
                    filename = args0__$model,
                    IQRmodel = "IQRmodel object")
  if (is.null(model__)) model__ <- "No model information available!"
  dosing__ <- switch(args0__[["Scenario"]][["dosing"]],
                     null = "No dosing.",
                     IQRdosing = "IQRdosing object",
                     `List of IQRdosing` = "List of IQRdosing objects",
                     NLME = "Dosing provided with data")
  if (is.null(dosing__)) dosing__ <- "No dosing information available!"
  data__ <- switch(args0__[["Scenario"]][["data"]],
                   null = "No data",
                   IQRsysData = "IQRsysData object.",
                   NLME = sysModelEst__[["data"]][["datafile"]])
  if (is.null(data__)) data__ <- "No data information available!"
  spec__ <- switch(args0__[["Scenario"]][["spec"]],
                   null = "No model specification",
                   modelSpec = "Model was specified.")
  if (is.null(spec__)) spec__ <- "No model specification information available!"
  conditions__ <- unique(x[["fixed.grid"]][[1]][["CONDITION"]])
  if (is.null(conditions__)) conditions__ <- "No conditions available"
  prediction__ <- FALSE
  if (!is.null(x[["prediction"]][[1]]))
    prediction <- TRUE
  multistart__ <- FALSE
  if (!is.null(x[["parframes"]][[1]]))
    multistart__ <- TRUE
  profiles__ <- FALSE
  if (!is.null(x[["profiles"]][[1]]))
    profiles__ <- TRUE
  message("--- IQRsysModel object - basic information: -----------")
  cat("\n")
  cat("Model:      ", model__, "\n")
  cat("Dosing:     ", dosing__, "\n")
  cat("Data:       ", data__, "\n")
  cat("Specs:      ", spec__, "\n")
  cat("\n")
  cat("Conditions: ", conditions__[1], "\n")
  if (length(conditions__) > 1)
    for (i__ in 2:length(conditions__)) cat("            ", conditions__[i__], "\n")
  cat("\n")
  message("--- Additional information stored: --------------------")
  cat("\n")
  cat("Multistart estimation results: ", ifelse(multistart__, "yes", "no"), "\n")
  cat("Profile likelihood analysis: ", ifelse(profiles__, "yes", "no"), "\n")
  cat("\n")
}
#'@export
plotProfile_IQRsysModel <- function(res) {
  partable__ <- res[["IQRpartable"]][[1]]
  profiles__ <- res[["profiles"]][[1]]
  parframe__ <- res[["parframes"]][[1]]
  selected__ <- names(profiles__)
  if (is.null(profiles__)) {
    message("The IQRsysModel object did not contain profile information.")
    return(invisible())
  }
  profiles__ <- dplyr::bind_rows(profiles__, .id = "selected")
  profiles__ <- split(profiles__, profiles__[["whichPar"]])
  profiles__ <- lapply(seq_len(length(profiles__)), function(i__) {
    whichPar__ <- names(profiles__)[i__]
    trafo__ <- partable__[["trafo"]][match(whichPar__, partable__[["parametername"]])]
    myprofile__ <- profiles__[[i__]]
    if (trafo__ == "L") myprofile__[[whichPar__]] <- exp(myprofile__[[whichPar__]])
    if (trafo__ == "G") myprofile__[[whichPar__]] <- inv_logit(myprofile__[[whichPar__]])
    myprofile__
  })
  colors__ <- c("#000000", "#C5000B", "#0084D1", "#579D1C", "#FF950E", "#4B1F6F", "#CC79A7", "#006400", "#F0E442", "#8B4513")
  plots__ <- lapply(seq_along(profiles__), function(i__) {
    myprofile__ <- profiles__[[i__]]
    whichPar__ <- myprofile__[["whichPar"]][1]
    parvalues__ <- myprofile__[[whichPar__]]
    FLAGlog__ <- FALSE
    if (all(parvalues__ > 0) && log10(max(parvalues__)) - log10(min(parvalues__)) > 2)
      FLAGlog__ <- TRUE
    proflist__ <- split(myprofile__, myprofile__[["selected"]])
    proflist__ <- lapply(proflist__, function(p__) {
      p__ <- p__[, -1]
      p__ <- parframe(p__, obj.attributes = c("data", "prior"))
      p__
    })
    myplot__ <- plotProfile(proflist__, mode == "data")
    myplot__ <- myplot__ + theme(legend.position = "none")
    myplot__ <- suppressMessages(
      myplot__ +
        scale_y_continuous(breaks = c(0, 1, 2.71, 3.84),
                           labels = c(" 0%", "68%", "90%", "95%")))
    myplot__ <- myplot__ + ylab("Confidence Level")
    myselected__ <- unique(myprofile__[["selected"]])
    mycolors__ <- colors__[match(myselected__, selected__)]
    names(mycolors__) <- myselected__
    myplot__ <- suppressMessages(myplot__ + scale_color_manual(values = mycolors__))
    if (FLAGlog__)
      myplot__ <- myplot__ + scale_x_log10()
    return(myplot__)
  })
  legend__ <- NULL
  if (length(selected__) > 1) {
    index_selected__ <- as.numeric(sapply(strsplit(selected__, "\n", fixed = TRUE), function(x__) x__[[1]]))
    lines__ <- max(as.numeric(sapply(strsplit(selected__, "\n", fixed = TRUE), function(x__) length(x__))))
    full_plot__ <- plotProfile(res[["profiles"]][[1]], mode == "data")
    legend__ <- cowplot::get_legend(
      suppressMessages(
        full_plot__ +
          scale_color_manual(name = "-2LL, optimum",
                             values = colors__[1:length(selected__)],
                             labels = paste0(round(parframe__[["value"]][index_selected__], 3),
                                             ", ", selected__)) +
          guides(linetype = FALSE) +
          theme(legend.position = "right", legend.key.height = unit(lines__, "lines"))
      )
    )
    fig__ <- IQRoutputFigure(plots__, nrow = 3, ncol = 3,
                             opt.layout = list(legend.option = "common",
                                               legend.object = legend__,
                                               legend.relsize = 0.2))
  } else {
    fig__ <- IQRoutputFigure(plots__, nrow = 3, ncol = 3)
  }
  fig__
}
#'@export
plotWaterfall_IQRsysModel <- function(res, tol = 0.1, maxSteps = 8, maxDiff = 100) {
  if (maxSteps < 1)
    stopIQR("maxSteps must be >= 1")
  if (tol <= 0)
    stopIQR("Tolerance must be positive")
  digits__ <- -floor(log10(max(tol, 1e-5)))
  parframes__ <- res[["parframes"]][[1]]
  if (is.null(parframes__)) {
    message("The IQRsysModel object did not contain multi-start estimation information.")
    return(invisible())
  }
  parframes__[["converged"]] <- c("no", "yes")[parframes__[["converged"]] + 1]
  parframes__ <- parframes__[parframes__$value <= min(parframes__$value) + maxDiff,]
  myplot__ <- plotValues(parframes__, tol = tol)
  data__ <- attr(myplot__, "data")
  jumps__ <- attr(myplot__, "jumps")
  if (length(jumps__) > maxSteps) jumps__ <- jumps__[seq_len(maxSteps)]
  jumpdata__ <- do.call(rbind, lapply(jumps__, function(j__) {
    index__ <- j__
    value__ <- data__[j__, "value"]
    data.frame(index = index__, value = value__, optimum = as.character(match(j__, jumps__)))
  }))
  data__[["optimum"]] <- as.factor(sapply(1:nrow(data__), function(i__) tail(which(i__ >= jumps__), 1)))
  nopt__ <- length(levels(data__[["optimum"]]))
  myplot__ <- ggplot(data__, aes(x = 1:nrow(data__), y = value, pch = converged, color = optimum)) +
    geom_segment(data = jumpdata__,
                 aes(x = index, xend = index, y = -Inf, yend = value, color = optimum),
                 inherit.aes = FALSE, lty = 2) +
    geom_segment(data = jumpdata__,
                 aes(x = index, xend = Inf, y = value, yend = value, color = optimum),
                 inherit.aes = FALSE, lty = 2) +
    scale_y_continuous(sec.axis = dup_axis(breaks = round(jumpdata__$value, 3), name = NULL)) +
    scale_x_continuous(breaks = jumpdata__$index, sec.axis = dup_axis(breaks = scales::pretty_breaks(), name = NULL)) +
    expand_limits(y = min(data__[["value"]]) + tol) +
    geom_point() +
    scale_shape_manual(values = c("no" = 4, "yes" = 19)) +
    xlab("fit index (sorted by log-likelihood)") +
    ylab("objective value (-2LL)") +
    ggtitle("Final objective values of multi-start estimation") +
    scale_color_manual(values = rep_len(IQRtoolsColors[1:9], nopt__)) +
    themeIQRtools() +
    theme(axis.text.x.top = element_text(vjust = 1, margin = margin(2, 0, 6, 0)))
  attr_out__ <- list(
    data = data__,
    jumps = jumps__
  )
  out <- IQRoutputFigure(myplot__)
  attr(out, "plotData") <- attr_out__
  return(out)
}
#'@export
plotPars_IQRsysModel <- function(res, tol = 0.1, maxSteps = 8) {
  digits__ <- -floor(log10(max(tol, 1e-5)))
  out__ <- plotWaterfall_IQRsysModel(res, tol, maxSteps)
  data__ <- attr(out__, "plotData")[["data"]]
  jumps__ <- attr(out__, "plotData")[["jumps"]]
  objvalues__ <- round(data__[["value"]][jumps__], digits = digits__)
  partable__ <- res[["IQRpartable"]][[1]]
  data__[["optimum, -2LL"]] <- paste0(jumps__[sapply(1:nrow(data__), function(i__) tail(which(i__ >= jumps__), 1))],
                                      ", ",
                                      objvalues__[sapply(1:nrow(data__), function(i__) tail(which(i__ >= jumps__), 1))])
  data__[["optimum, -2LL"]] <- factor(data__[["optimum, -2LL"]], levels = unique(data__[["optimum, -2LL"]]))
  data__ <- data__[, !grepl("^ETA_", names(data__))]
  data__ <- tidyr::gather(data__, key = "parameter", value = "parvalue", attr(data__, "parameters"))
  data__[["trafo"]] <- partable__[["trafo"]][match(data__[["parameter"]], partable__[["parametername"]])]
  data__ <- dplyr::mutate(data__, parvalue = ifelse(trafo %in% "L", exp(parvalue), parvalue))
  data__ <- dplyr::mutate(data__, parvalue = ifelse(trafo %in% "G", inv_logit(parvalue), parvalue))
  plots__ <- lapply(unique(data__[["trafo"]]), function(trafo__) {
    ylab__ <- "estimated value"
    if (trafo__ == "N") ylab__ <- "estimated value (natural scale)"
    if (trafo__ == "L") ylab__ <- "estimated value (log scale)"
    if (trafo__ == "G") ylab__ <- "estimated value (logit scale)"
    subdata__ <- dplyr::filter(data__, trafo %in% trafo__)
    ncol__ <- length(unique(subdata__[["optimum, -2LL"]]))
    myplot__ <- ggplot(subdata__, aes(y = parvalue, x = parameter, color = `optimum, -2LL`)) +
      geom_point(aes(pch = converged)) +
      geom_boxplot(fill = "white", position = "identity", width = 0.33) +
      scale_shape_manual(values = c("no" = 4, "yes" = 19)) +
      scale_x_discrete(name = NULL) +
      ylab(ylab__) +
      scale_color_manual(values = rep_len(IQRtoolsColors[1:9], ncol__)) +
      themeIQRtools() +
      theme(legend.position = "none")
    if (trafo__ == "L")
      myplot__ <- myplot__ + scale_y_log10()
    myplot__ <- myplot__ + coord_flip()
    return(myplot__)
  })
  legend__ <- cowplot::get_legend(plots__[[1]] + theme(legend.position = "right"))
  counts__ <- sapply(unique(data__[["trafo"]]), function(n__) length(which(data__[["trafo"]] %in% n__)))
  counts__ <- counts__/min(counts__)
  out__ <- IQRoutputFigure(plots__,
                           opt.layout = opt.layout(ncol = 1, npage = 1,
                                                   legend.option = "common",
                                                   legend.relsize = 0.2,
                                                   legend.position = "right"))
  attr(out__, "plotData") <- data__
  return(out__)
}
#'@export
plotPred_IQRsysModel <- function(sysModel, tol = 0.1, states = NULL, conditions = NULL, IDs = NULL) {
  data__ <- sysModel[["data"]][[1]]
  parframe__ <- sysModel[["parframes"]][[1]]
  prd__ <- sysModel[["prd"]][[1]]
  times__ <- sysModel[["times"]][[1]]
  g__ <- sysModel[["g"]][[1]]
  controls(g__, NULL, "attach.input") <- TRUE
  if (is.null(parframe__))
    stopIQR("No multi-start estimation results available.")
  pars__ <- unique(parframe__, tol = tol)
  jumps__ <- match(pars__[["index"]], parframe__[["index"]])
  objvals__ <- round(parframe__[["value"]][jumps__], 3)
  prediction__ <- lapply(1:nrow(pars__), function(i__) {
    parvec__ <- as.parvec(pars__, i__)
    simulation__ <- as.data.frame(prd__(times__, parvec__), data = data__)
    simulation__ <- dplyr::filter(simulation__, time %in% times__)
  })
  names(prediction__) <- paste0(jumps__, ", ", objvals__)
  prediction__ <- dplyr::bind_rows(prediction__, .id = "optimum")
  prediction__[["optimum"]] <- factor(prediction__[["optimum"]], levels = unique(prediction__[["optimum"]]))
  if (!is.null(states))
    prediction__ <- filter(prediction__, name %in% states)
  if (!is.null(conditions))
    prediction__ <- filter(prediction__, CONDITION %in% conditions)
  if (!is.null(IDs))
    prediction__ <- filter(prediction__, ID %in% IDs)
  levels__ <- try(unique(alphnumsort(prediction__[["condition"]])), silent = TRUE)
  if (!inherits(levels__, "try-error"))
    prediction__[["condition"]] <- factor(prediction__[["condition"]], levels = levels__)
  ncols__ <- length(unique(prediction__[["optimum"]]))
  p__ <- ggplot(prediction__, aes(x = time, y = value, color = optimum, group = paste(optimum, ID))) +
    facet_wrap(~name*CONDITION, scales = "free") +
    geom_line() +
    scale_color_manual(name = "optimum, -2LL", values = rep_len(IQRtoolsColors[1:9], ncols__)) +
    themeIQRtools()
  out <- list(p__)
  attr(out, "plotData") <- prediction__
  class(out) <- "IQRslideplot"
  return(out)
}
#'@export
plotFit_IQRsysModel <- function(res, OUTPUT = 1) {
  if (is.null(res[["parframes"]][[1]])) {
    warningIQR("The IQRsysModel object did not contain estimation information.",
            "The plot shows the data and prediction as they were found in the object.")
  }
  prediction__ <- res[["prediction"]][[1]]
  datalist__ <- res[["data"]][[1]]
  data__ <- as.data.frame(datalist__)
  times__ <- sort(unique(prediction__[["time"]]))
  pars__ <- res[["pars"]][[1]]
  prd__ <- res[["prd"]][[1]]
  errfn__ <- res[["errfn"]][[1]]
  pars_pop__ <- pars__
  if (any(grepl("^ETA_", names(pars_pop__)))) {
    pars_pop__[grepl("^ETA_", names(pars_pop__))] <- 0
    prediction_pop__ <- as.data.frame(prd__(times__, pars_pop__, deriv = FALSE), errfn = errfn__, data = datalist__)
    prediction__ <- dplyr::bind_rows(
      dplyr::mutate(prediction__, which = "individual"),
      dplyr::mutate(prediction_pop__, which = "population")
    )
  }
  prediction__ <- dplyr::filter(prediction__, name == paste0("OUTPUT", OUTPUT))
  data__ <- dplyr::filter(data__, name == paste0("OUTPUT", OUTPUT))
  if (!"CONDITION" %in% names(prediction__))
    prediction__[["CONDITION"]] <- prediction__[["ID"]]
  if (!"CONDITION" %in% names(data__))
    data__[["CONDITION"]] <- data__[["ID"]]
  levels_ID__ <- try(unique(alphnumsort(c(data__[["ID"]], prediction__[["ID"]]))), silent = TRUE)
  levels_CONDITION__ <- try(unique(alphnumsort(c(data__[["CONDITION"]], prediction__[["CONDITION"]]))), silent = TRUE)
  if (!inherits(levels_ID__, "try-error")) {
    prediction__[["ID"]] <- factor(prediction__[["ID"]], levels = levels_ID__)
    data__[["ID"]] <- factor(data__[["ID"]], levels = levels_ID__)
  } else {
    prediction__[["ID"]] <- as.factor(prediction__[["ID"]])
    data__[["ID"]] <- as.factor(data__[["ID"]])
  }
  if (!inherits(levels_CONDITION__, "try-error")) {
    prediction__[["CONDITION"]] <- factor(prediction__[["CONDITION"]], levels = levels_CONDITION__)
    data__[["CONDITION"]] <- factor(data__[["CONDITION"]], levels = levels_CONDITION__)
  } else {
    prediction__[["CONDITION"]] <- as.factor(prediction__[["CONDITION"]])
    data__[["CONDITION"]] <- as.factor(data__[["CONDITION"]])
  }
  prediction__ <- split(prediction__, prediction__[["CONDITION"]], drop = TRUE)
  data__ <- split(data__, data__[["CONDITION"]], drop = TRUE)
  conditions__ <- union(names(prediction__), names(data__))
  attr_out__ <- list(
    prediction = prediction__,
    data = data__,
    conditions = conditions__
  )
  plots__ <- lapply(conditions__, function(c__) {
    mypred__ <- prediction__[[c__]]
    mydata__ <- data__[[c__]]
    tmin__ <- suppressWarnings(min(mydata__[["time"]]))
    tmax__ <- suppressWarnings(max(mydata__[["time"]]))
    if (is.infinite(tmin__))
      tmin__ <- suppressWarnings(min(mypred__[["time"]]))
    if (is.infinite(tmax__))
      tmax__ <- suppressWarnings(max(mypred__[["time"]]))
    if (is.infinite(tmin__))
      tmin__ <- 0
    if (is.infinite(tmax__))
      tmax__ <- 1
    myplot__ <- ggplot(mapping = aes(x = time, y = value,
                                     color = ID, fill = ID)) + 
      facet_wrap(~CONDITION, scales = "free") +
      theme(legend.position = c(1, 1), legend.justification = c(1, 1),
            legend.background = element_rect(fill = grDevices::rgb(1, 1, 1, .2)))
    if (!is.null(mypred__)) {
      mypred__ <- dplyr::filter(mypred__, time >= tmin__ & time <= tmax__)
      if ("which" %in% names(mypred__)) {
        if (any(!is.na(mypred__[["sigma"]])))
          myplot__ <- myplot__ +
            geom_ribbon(data = filter(mypred__, which == "individual"),
                        aes(ymin = value - sigma, ymax = value + sigma), alpha = .3, lty = 0)
        myplot__ <- myplot__ +
          geom_line(data = mypred__, aes(linetype = which, size = which) ) +
          scale_linetype_manual("Prediction", values = c("individual"=1,"population"=2)) +
          scale_size_manual("Prediction", values = c("individual"=0.6,"population"=1))
      } else {
        if (any(!is.na(mypred__[["sigma"]])))
          myplot__ <- myplot__ +
            geom_ribbon(data = mypred__,
                        aes(ymin = value - sigma, ymax = value + sigma), alpha = .3, lty = 0)
        myplot__ <- myplot__ +
          geom_line(data = mypred__)
      }
    }
    if (!is.null(mydata__)) {
      mydata__ <- dplyr::filter(mydata__, time >= tmin__ & time <= tmax__)
      if (any(!is.na(mydata__[["sigma"]])))
        myplot__ <- myplot__ +
          geom_errorbar(data = mydata__,
                        aes(ymin = value - sigma, ymax = value + sigma), width = 0)
      if (any(mydata__[["value"]] <= mydata__[["lloq"]]))
        myplot__ <- myplot__ +
          geom_point(data = mydata__, aes(pch = ifelse(value <= lloq, "yes", "no"))) +
          scale_shape_manual(name = "BLOQ", values = c(yes = 4, no = 19))
      else
        myplot__ <- myplot__ +
          geom_point(data = mydata__)
    }
    return(myplot__ + themeIQRtools())
  })
  out__ <- IQRoutputFigure(plots__, nrow = 2, ncol = 2)
  attr(out__, "plotData") <- attr_out__
  return(out__)
}
#'@export
plotWRES_IQRsysModel <- function(res, OUTPUT = 1) {
  if (is.null(res[["parframes"]][[1]])) {
    warningIQR("The IQRsysModel object did not contain estimation information.",
            "The plot shows the data and prediction as they were found in the object.")
  }
  data__ <- res[["IQRpredtable"]][[1]]
  data__ <- dplyr::filter(data__, name == paste0("OUTPUT", OUTPUT))
  attr_out__ <- data__
  data__[["ID"]] <- as.factor(data__[["ID"]])
  data__[["CONDITION"]] <- as.factor(data__[["CONDITION"]])
  IDs__ <- unique(data__[["ID"]])
  data__[["wres_indiv"]][data__[["wres_indiv"]] < -5] <- -Inf
  plot1__ <- ggplot(data__, aes(x = time, y = wres_indiv, color = ID)) +
    facet_wrap(~CONDITION, scales = "free") +
    geom_hline(yintercept = -1, lty = 2, color = c("gray60")) +
    geom_hline(yintercept = 0, lty = 2, color = c("black")) +
    geom_hline(yintercept = 1, lty = 2, color = c("gray60")) +
    geom_point(aes(pch = ifelse(value <= lloq, "yes", "no"))) +
    scale_shape_manual(name = "BLOQ", values = c(yes = 4, no = 19)) +
    ggtitle("Weighted residuals vs time", paste0("OUTPUT", OUTPUT)) +
    xlab("time") + ylab("weighted residual")
  plot2__ <- ggplot(data__, aes(x = pred_indiv, y = wres_indiv, color = ID)) +
    facet_wrap(~CONDITION, scales = "free") +
    geom_hline(yintercept = -1, lty = 2, color = c("gray60")) +
    geom_hline(yintercept = 0, lty = 2, color = c("black")) +
    geom_hline(yintercept = 1, lty = 2, color = c("gray60")) +
    geom_point(aes(pch = ifelse(value <= lloq, "yes", "no"))) +
    scale_shape_manual(name = "BLOQ", values = c(yes = 4, no = 19)) +
    ggtitle("Weighted residuals vs prediction", paste0("OUTPUT", OUTPUT)) +
    xlab("prediction") + ylab("weighted residual")
  plot1__ <- plot1__ + scale_color_manual(values = rep_len(IQRtoolsColors[1:9], length(IDs__)))
  plot2__ <- plot2__ + scale_color_manual(values = rep_len(IQRtoolsColors[1:9], length(IDs__)))
  out <- list(plot1__ + themeIQRtools(),
              plot2__ + themeIQRtools())
  attr(out, "plotData") <- attr_out__
  class(out) <- "IQRslideplot"
  return(out)
}
#'@export
plotDVPRED_IQRsysModel <- function(res, OUTPUT = 1) {
  if (is.null(res[["parframes"]][[1]])) {
    warningIQR("The IQRsysModel object did not contain estimation information.",
            "The plot shows the data and prediction as they were found in the object.")
  }
  data__ <- res[["IQRpredtable"]][[1]]
  if (is.null(data__)) {
    res <- pred_IQRsysModel(res)
    data__ <- res[["IQRpredtable"]][[1]]
  }
  data__ <- dplyr::filter(data__, name == paste0("OUTPUT", OUTPUT))
  attr_out__ <- data__
  data__[["ID"]] <- as.factor(data__[["ID"]])
  data__[["CONDITION"]] <- as.factor(data__[["CONDITION"]])
  IDs__ <- unique(data__[["ID"]])
  plot3__ <- ggplot(data__, aes(x = pred_indiv, y = value, color = ID)) +
    facet_wrap(~CONDITION, scales = "free") +
    geom_abline(slope = 1, intercept = 0, lty = 2, color = "black") +
    geom_point(aes(pch = ifelse(value <= lloq, "yes", "no"))) +
    scale_shape_manual(name = "BLOQ", values = c(yes = 4, no = 19)) +
    ggtitle("Data vs prediction", paste0("OUTPUT", OUTPUT)) +
    xlab("prediction") + ylab("data")
  plot3__ <- plot3__ + scale_color_manual(values = rep_len(IQRtoolsColors[1:9], length(IDs__)))
  out <- list(plot3__ + themeIQRtools())
  attr(out, "plotData") <- attr_out__
  class(out) <- "IQRslideplot"
  return(out)
}
#'@export
tablePars_IQRsysModel <- function(res, digits = NA, parameters = NULL, showInitial = FALSE, FLAGBICc = FALSE) {
  partable__ <- res[["IQRpartable"]][[1]]
  parsOfInterest__ <- attr(res, "sysModelEst")[["parsOfInterest"]]
  partable__ <- dplyr::filter(partable__, !parametertask %in% "dosing" | estimated == 1)
  partable__ <- dplyr::filter(partable__, !parametertask %in% "ETA")
  if (!is.null(parsOfInterest__)) {
    if (!is.null(parameters)) {
      ismatch__ <- sapply(parsOfInterest__, function(mypar__) mypar__ %in% parameters)
      parsOfInterest__ <- parsOfInterest__[ismatch__]
      partable__ <- dplyr::filter(partable__, parametername %in% parsOfInterest__ | base_par %in% parsOfInterest__ | belongs_to %in% parsOfInterest__)
    } else {
      partable__ <- dplyr::filter(partable__, parametertask != "pop" | parametername %in% parsOfInterest__ | base_par %in% parsOfInterest__)
    }
  }
  partable__[["digits"]] <- digits
  if (is.null(partable__[["sigma_linear"]])) partable__[["sigma_linear"]] <- NA
  table__ <- IQRtable(partable__,
                      stat = statSE(value = parametervalue_linear, se = sigma_linear, digits = digits),
                      "PARAMETER" = "printname",
                      "VALUE" = "value",
                      "RSE" = "rse%",
                      "COMMENT" = "Notes")
  table__[, 3] <- gsub("--%", "-", table__[, 3], fixed = TRUE)
  table__[is.na(table__[, 4]), 4] <- "-"
  table__[-1, 2] <- paste0(table__[-1, 2], ifelse(partable__[["estimated"]] == 0, " (FIX)", ""))
  if ("lower95_parametervalue_linear" %in% names(partable__)) {
    tableCI__ <- IQRtable(partable__,
                          stat = statCI(value = parametervalue_linear,
                                        lower = lower95_parametervalue_linear,
                                        upper = upper95_parametervalue_linear,
                                        digits = digits),
                          "PARAMETER" = "printname",
                          "VALUE" = "value",
                          "CI (95%)" = "[lower.95, upper.95]")
    tableCI__[, 3] <- gsub("[--, --]", "-", tableCI__[, 3], fixed = TRUE)
    table__ <- cjoin_IQRtable(table__, tableCI__[, -2])
  }
  if ("shrinkage" %in% names(partable__) && any(!is.na(partable__[["shrinkage"]]))) {
    tableShrinkage__ <- as_IQRtable(data.frame(
      PARAMETER = partable__[["printname"]],
      SHRINKAGE = ifelse(is.na(partable__[["shrinkage"]]),
                         yes = "-",
                         no = paste0(round(100*partable__[["shrinkage"]]), "%"))
    ))
    table__ <- cjoin_IQRtable(table__, tableShrinkage__)
  }
  if (showInitial) {
    parameter__ <- table__[-1, 1]
    selected__ <- res[["selected"]][[1]][1]
    if (is.null(selected__)) selected__ <- 1
    index__ <- res[["parframes"]][[1]][["index"]][selected__]
    if (is.null(index__)) index__ <- 1
    initial__ <- unlist(res[["startpars"]][[1]][index__, ])
    initial__ <- initial__[names(initial__) %in% parameter__]
    transformation__ <- partable__$trafo[match(names(initial__), partable__$parametername)]
    names(transformation__) <- names(initial__)
    initial__ <- dplyr::case_when(
      transformation__ == "N" ~ initial__,
      transformation__ == "G" ~ inv_logit(initial__),
      transformation__ == "L" ~ exp(initial__),
      TRUE ~ initial__
    )
    names(initial__) <- names(transformation__)
    if (is.na(digits))
      initial__ <- sapply(initial__, function(x__) format(x__, digits = 2))
    else
      initial__ <- sapply(initial__, function(x__) format(x__, digits = digits))
    outinitial__ <- rep("", length(parameter__))
    outinitial__[match(names(initial__), parameter__)] <- initial__
    outinitial__ <- matrix(c("INITIAL GUESS", outinitial__), ncol = 1)
    table__ <- cbind(table__[, 1], outinitial__, table__[, -1])
    class(table__) <- c("IQRtable", "matrix")
  }
  states__ <- names(getEquations(res$x[[1]])[[1]])
  ini_pars__ <- partable__$printname[partable__$parametername %in% states__ | partable__$base_par %in% states__]
  err_pars__ <- partable__$printname[partable__$parametertask %in% "error"]
  omg_pars__ <- partable__$printname[partable__$parametertask %in% "omega"]
  bet_pars__ <- partable__$printname[partable__$parametertask %in% "beta"]
  pop_pars__ <- setdiff(partable__$printname, c(ini_pars__, err_pars__, bet_pars__, omg_pars__))
  pattern <- "Z[1, ]\n "
  if (length(pop_pars__) > 0)
    pattern <- paste0(pattern, "\n **Typical parameters**\n Z[match(pop, Z[,1]), ]\n ")
  if (length(omg_pars__) > 0)
    pattern <- paste0(pattern, "\n **Inter-individual variability**\n Z[match(omg, Z[,1]), ]\n ")
  if (length(bet_pars__) > 0)
    pattern <- paste0(pattern, "\n **Parameter-Covariate relationships**\n Z[match(bet, Z[,1]), ]\n ")
  if (length(err_pars__) > 0)
    pattern <- paste0(pattern, "\n **Residual variability**\n Z[match(err, Z[,1]), ]\n ")
  metric.keys__ <- c("OBJ", "BIC", "AIC")
  if (FLAGBICc) metric.keys__ <- c("OBJ", "BICc", "AIC")
  if (!is.null(res[["metrics"]][[1]])) {
    metrics__ <- res[["metrics"]][[1]]
    metrics__ <- data.frame(
      metric = c("OBJ", "BIC", "AIC"),
      value = round(metrics__[["value"]][match(metric.keys__, metrics__[["metric"]])]),
      stringsAsFactors = FALSE
    )
    metrics__ <- as_IQRtable(metrics__)
  } else {
    metrics__ <- data.frame(
      metric = c("OBJ", "BIC", "AIC"),
      value = c("-", "-", "-"),
      stringsAsFactors = FALSE
    )
  }
  pattern <- paste0(pattern, "\n **Model metrics**\n N[-1, ]\n ")
  out__ <-   compose_IQRtable(
    Z = table__,
    N = metrics__,
    pop = pop_pars__,
    ini = ini_pars__,
    bet = bet_pars__,
    omg = omg_pars__,
    err = err_pars__,
    pattern = pattern
  )
  colnames__ <- intersect(c("PARAMETER", "INITIAL GUESS", "VALUE", "RSE", "CI (95%)", "SHRINKAGE", "COMMENT"),
                          out__[1,])
  as_IQRtable(out__[, match(colnames__, out__[1,]), drop = FALSE])
}
is_IQRsysModelEst <- function(input) {
  methods::is(input, "IQRsysModelEst")
}
is_IQRsysData <- function(input) {
  methods::is(input, "IQRsysData")
}
is_IQRsysModel <- function(input) {
  methods::is(input, "IQRsysModel")
}
pars_IQRsysModel <- function(sysModel, ..., parameters = NULL, dosing = NULL, FLAGverbose = FALSE) {
  if (!is_IQRsysModel(sysModel)) stopIQR("sysModel is not an IQRsysModel object")
  dots__ <- list(...)
  get__ <- set__ <- numeric(0)
  if (length(dots__) > 0) {
    get__ <- as.integer(which(sapply(dots__, is.character)))
    set__ <- as.integer(which(sapply(dots__, is.numeric)))
  }
  parameters.arg__ <- parameters
  dosing.arg__ <- dosing
  IQRpartable__ <- sysModel[["IQRpartable"]][[1]]
  if (length(set__) == 0) {
    parameters__ <- NULL
  } else {
    parameters__ <- unlist(
      lapply(set__, function(i__) {
        n__ <- names(dots__)[i__]
        v__ <- dots__[[i__]]
        if (is.null(names(v__))) names(v__) <- rep("", length(v__))
        is_condition <- !names(v__) %in% c("", n__, "BASE")
        names(v__)[is_condition] <- paste(n__, names(v__)[is_condition], sep = "_")
        names(v__)[!is_condition] <- n__
        if (any(duplicated(names(v__))))
          stopIQR("Vector of parameter values for ", n__, " were badly defined. ",
               "Names should correspond to CONDITIONs or should be omitted if referring to the BASE parameter.")
        v__
      })
    )
  }
  parameters__ <- c(parameters__, parameters.arg__)[union(names(parameters__), names(parameters.arg__))]
  if (!is.null(dosing) & any(grepl("^INPUT[1-9]", names(attr(sysModel$model[[1]]$func, "equations"))))) {
    meta__ <- attr(sysModel$data[[1]], "condition.grid")
    dosing__ <- NULL
    if (is_IQRdosing(dosing)) {
      dosing__ <- do.call(rbind, lapply(seq_len(nrow(meta__)), function(i__) {
        mymeta__ <- meta__[i__,]
        mymeta__$CONDITION <- "BASE"
        rownames(dosing) <- NULL
        rownames(mymeta__) <- NULL
        cbind(mymeta__, dosing)
      }))
    } else if (is.list(dosing) && all(sapply(dosing, is_IQRdosing))) {
      available__ <- intersect(meta__$CONDITION, names(dosing))
      meta__ <- meta__[meta__$CONDITION %in% available__,]
      dosing__ <- suppressWarnings(do.call(rbind, lapply(seq_len(nrow(meta__)), function(i__) {
        mymeta__ <- meta__[i__,]
        cbind(mymeta__, dosing[[mymeta__$CONDITION]])
      })))
    }
    if (!is.null(dosing__)) {
      inputs__ <- grep("^INPUT[1-9]", names(attr(sysModel$model[[1]]$func, "equations")), value = TRUE)
      dosing_pars__ <- dMod_build_dosing_parameters(dosing__, inputs = length(inputs__))
      dosing_pars__ <- dosing_pars__[!grepl("^Tlag", names(dosing_pars__))]
      dosing_parnames__ <- setdiff(names(dosing_pars__), names(meta__))
      if (any(dosing_pars__$CONDITION %in% "BASE")) {
        base_dosing_pars__ <- dosing_pars__[match("BASE", dosing_pars__$CONDITION), dosing_parnames__]
        parameters__ <- c(parameters__, unlist(base_dosing_pars__))
      }
      conditions__ <- setdiff(dosing_pars__$CONDITION, "BASE")
      specific_dosing_pars__ <- dosing_pars__[match(conditions__, dosing_pars__$CONDITION), dosing_parnames__]
      if (nrow(specific_dosing_pars__) > 0) {
        specific_dosing_pars__ <- lapply(seq_len(nrow(specific_dosing_pars__)), function(i__) {
          structure(
            unlist(specific_dosing_pars__[i__, dosing_parnames__], use.names = FALSE),
            names = paste(dosing_parnames__, dosing_pars__$CONDITION[i__], sep = "_")
          )
        })
        parameters__ <- c(parameters__, unlist(specific_dosing_pars__))
      }
    }
  }
  if (!is.null(parameters__)) {
    not_defined__ <- setdiff(names(parameters__), IQRpartable__[["parametername"]])
    if (length(not_defined__) > 0) {
      warningIQR("The following parameters were not recognized and were ignored: ",
              paste(not_defined__, collapse = ", "))
    }
    defined__ <- intersect(names(parameters__), IQRpartable__[["parametername"]])
    rowindex__ <- match(defined__, IQRpartable__[["parametername"]])
    IQRpartable__[["parametervalue_linear"]][rowindex__] <- parameters__[defined__]
    IQRpartable__[["parametervalue"]] <- IQRpartable__[["parametervalue_linear"]]
    IQRpartable__[["parametervalue"]][IQRpartable__$trafo == "L"] <- pmax(-750, log(IQRpartable__$parametervalue[IQRpartable__$trafo == "L"]))
    IQRpartable__[["parametervalue"]][IQRpartable__$trafo == "G"] <- logit(IQRpartable__$parametervalue[IQRpartable__$trafo == "G"])
    uncertainty_cols__ <- c("sigma", "sigma_linear", "RSE_linear",
                            "lower95_parametervalue_linear", "upper95_parametervalue_linear",
                            "lower68_parametervalue_linear", "upper68_parametervalue_linear")
    for (n__ in uncertainty_cols__) {
      if (n__ %in% names(IQRpartable__))
        IQRpartable__[[n__]][rowindex__] <- NA
    }
  }
  if (length(get__) == 0) {
    parameters_df_print__ <- IQRpartable__
  } else {
    parameters__ <- as.character(unlist(dots__[get__]))
    select__ <-
      IQRpartable__[["parametername"]] %in% parameters__ |
      IQRpartable__[["base_par"]] %in% parameters__
    parameters_df_print__ <- IQRpartable__[select__, ]
  }
  if (FLAGverbose)
    print_IQRpartable(parameters_df_print__, level = ifelse("bestfit" %in% names(sysModel), 2, 1), optimum = sysModel[["selected"]][[1]])
  if (length(set__) == 0 & is.null(parameters) & is.null(dosing)) {
    parvec__ <- parameters_df_print__[["parametervalue_linear"]]
    names(parvec__) <- parameters_df_print__[["parametername"]]
    attr(parvec__, "se") <- parameters_df_print__[["sigma_linear"]]
    attr(parvec__, "lower95") <- parameters_df_print__[["lower95_parametervalue_linear"]]
    attr(parvec__, "upper95") <- parameters_df_print__[["upper95_parametervalue_linear"]]
    return(invisible(parvec__))
  }
  sysModel <- mutate_IQRsysModel(sysModel, IQRpartable = list(IQRpartable__))
  sysModel <- grids_IQRsysModel(sysModel)
  sysModel <- spec_IQRsysModel(sysModel)
  p0__ <- sysModel[["p0"]][[1]]
  prd0__ <- sysModel[["g"]][[1]]*sysModel[["x"]][[1]]*p0__
  fixed.grid__ <- sysModel[["fixed.grid"]][[1]]
  est.grid__ <- sysModel[["est.grid"]][[1]]
  prd__ <- dMod_PRD_indiv(prd = prd0__, fixed.grid = fixed.grid__, est.grid = est.grid__)
  p__   <- dMod_P_indiv(p = p0__, fixed.grid = fixed.grid__, est.grid = est.grid__)
  sysModel <- mutate_IQRsysModel(sysModel, prd = list(prd__), p = list(p__))
  return(sysModel)
}
vcov_IQRsysModel <- function(mymodel) {
  fixed__ <- c(mymodel[["fixed_on_lower"]][[1]], mymodel[["fixed_on_upper"]][[1]])
  FLAGderiv__ <- mymodel[["options"]][[1]][["opt.method"]] %in% "trust"
  if (FLAGderiv__) {
    mymodel <- mutate_IQRsysModel(mymodel, hessian = list(structure(obj(pars)[["hessian"]], dimnames = list(names(pars), names(pars)))))
  } else {
    mymodel <- mutate_IQRsysModel(mymodel, hessian = list(dMod_approxHessian(obj, pars, diag = TRUE)))
  }
  hessian__ <- mymodel[["hessian"]][[1]]
  vcov__ <- 0*hessian__
  is_fixed__ <- colnames(hessian__) %in% names(fixed__)
  subhessian__ <- hessian__[!is_fixed__, !is_fixed__, drop = FALSE]
  subvcov__ <- try(solve(0.5*subhessian__), silent = TRUE)
  if (inherits(subvcov__, "try-error")) subvcov__ <- MASS::ginv(subhessian__)
  vcov__[!is_fixed__, !is_fixed__] <- subvcov__
  mymodel <- mutate_IQRsysModel(mymodel, vcov = list(structure(vcov__, dimnames = list(names(pars), names(pars)))))
  subhessian__ <- mymodel[["hessian"]][[1]][!is_fixed__, !is_fixed__, drop = FALSE]
  subvcov__ <- mymodel[["vcov"]][[1]][!is_fixed__, !is_fixed__, drop = FALSE]
  eigen__ <- eigen(subhessian__)
  tol__ <- sqrt(.Machine$double.eps)
  V__ <- eigen__[["vectors"]][, abs(eigen__[["values"]]) < tol__, drop = FALSE]
  identifiable__ <- apply(V__, 1, function(v) all(abs(v) < tol__))
  diag(subvcov__)[!identifiable__] <- Inf
  vcov__ <- mymodel[["vcov"]][[1]]
  vcov__[!is_fixed__, !is_fixed__] <- subvcov__
  mymodel <- mutate_IQRsysModel(mymodel, vcov = list(vcov__))
  return(mymodel)
}
pred_IQRsysModel <- function(res) {
  datalist__ <- res[["data"]][[1]]
  data_indiv__ <- as.data.frame(datalist__)
  timesD__ <- unique(data_indiv__[["time"]])
  prd__ <- res[["prd"]][[1]]
  pars__ <- res[["pars"]][[1]]
  data__ <- res[["data"]][[1]]
  errfn__ <- res[["e"]][[1]]
  prediction_indiv__ <- as.data.frame(prd__(timesD__, pars__, deriv = FALSE), errfn = errfn__, data = datalist__)
  pars_pop__ <- pars__
  pars_pop__[grepl("^ETA_", names(pars_pop__))] <- 0
  prediction_pop__ <- as.data.frame(prd__(timesD__, pars_pop__, deriv = FALSE), errfn = errfn__, data = datalist__)
  if (!"CONDITION" %in% names(prediction_indiv__))
    prediction_indiv__[["CONDITION"]] <- prediction_indiv__[["ID"]]
  if (!"CONDITION" %in% names(prediction_pop__))
    prediction_pop__[["CONDITION"]] <- prediction_pop__[["ID"]]
  if (!"CONDITION" %in% names(data_indiv__))
    data_indiv__[["CONDITION"]] <- data_indiv__[["ID"]]
  match.approx <- function(x, table, tol = getOption("approx.tol", default = 1e-6)) {
    stopifnot(is.numeric(x), is.numeric(table))
    metric <- outer(x, table, function(x, y) abs(x - y))
    position <- apply(metric, 1, which.min)
    position[abs(x - table[position]) > tol] <- NA
    return(position)
  }
  outputs__ <- as.character(unique(prediction_indiv__[["name"]]))
  predframe__ <- do.call(rbind, lapply(outputs__, function(OUTPUT) {
    pred_indiv__ <- dplyr::filter(prediction_indiv__, name == OUTPUT)
    pred_pop__   <- dplyr::filter(prediction_pop__, name == OUTPUT)
    data__       <- dplyr::filter(data_indiv__, name == OUTPUT)
    if (nrow(pred_indiv__) == 0 | nrow(data__) == 0)
      return()
    data__[["pred_indiv"]] <- NA
    data__[["pred_pop"]] <- NA
    data__[["res_indiv"]] <- NA
    data__[["res_pop"]] <- NA
    data__[["wres_indiv"]] <- NA
    data__[["wres_pop"]] <- NA
    data__[["CONDID"]] <- paste0(data__[["ID"]],"-", data__[["CONDITION"]])
    pred_indiv__[["CONDID"]] <- paste0(pred_indiv__[["ID"]],"-", pred_indiv__[["CONDITION"]])
    pred_pop__[["CONDID"]] <- paste0(pred_pop__[["ID"]],"-", pred_pop__[["CONDITION"]])
    condids__ <- as.character(unique(data__[["CONDID"]]))
    for (ci__ in condids__) {
      idxCONDID_d__ <- data__[["CONDID"]] == ci__
      idxCONDID_i__ <- pred_indiv__[["CONDID"]] == ci__
      idxCONDID_p__ <- pred_pop__[["CONDID"]] == ci__
      idxMatch_i__ <- match.approx(data__$time[idxCONDID_d__], pred_indiv__$time[idxCONDID_i__])
      idxMatch_p__ <- match.approx(data__$time[idxCONDID_d__], pred_pop__$time[idxCONDID_p__])
      y__       <- data__[["value"]][idxCONDID_d__]
      sigma_y__ <- data__[["sigma"]][idxCONDID_d__]
      value_indiv__ <- pred_indiv__[["value"]][idxCONDID_i__][idxMatch_i__]
      value_pop__   <- pred_pop__[["value"]][idxCONDID_p__][idxMatch_p__]
      sigma_value_indiv__ <- pred_indiv__[["sigma"]][idxCONDID_i__][idxMatch_i__]
      sigma_value_pop__   <- pred_pop__[["sigma"]][idxCONDID_p__][idxMatch_p__]
      res_indiv__ <- value_indiv__ - y__
      res_pop__   <- value_pop__   - y__
      wres_indiv__ <- wres_pop__ <- rep(NA, sum(idxCONDID_d__))
      idxSigObs__ <- !is.na(sigma_y__)
      wres_indiv__[idxSigObs__] <- res_indiv__[idxSigObs__]/sigma_y__[idxSigObs__]
      wres_pop__[idxSigObs__]   <- res_pop__[idxSigObs__]/sigma_y__[idxSigObs__]
      idxSigPred__ <- is.na(sigma_y__)
      wres_indiv__[idxSigPred__] <- res_indiv__[idxSigPred__]/sigma_value_indiv__[idxSigPred__]
      wres_pop__[idxSigPred__]   <- res_pop__[idxSigPred__]/sigma_value_pop__[idxSigPred__]
      data__[idxCONDID_d__, "pred_indiv"] <- value_indiv__
      data__[idxCONDID_d__, "pred_pop"]     <- value_pop__
      data__[idxCONDID_d__, "res_indiv"]  <- res_indiv__
      data__[idxCONDID_d__, "res_pop"]      <- res_pop__
      data__[idxCONDID_d__, "wres_indiv"] <- wres_indiv__
      data__[idxCONDID_d__, "wres_pop"]     <- wres_pop__
    }
    data__[["CONDID"]] <- NULL
    return(data__)
  }))
  mutate_IQRsysModel(res, IQRpredtable = list(predframe__))
}
metrics_IQRsysModel <- function(res) {
  parframes__ <- res$parframes[[1]]
  if (is.null(parframes__) || nrow(parframes__) == 0)
    return(mutate_IQRsysModel(res, metrics = list(NULL)))
  partable__ <- res$IQRpartable[[1]]
  ndata__ <- nrow(as.data.frame(res$data[[1]]))
  nsubjects__ <- length(res$data[[1]])
  neta__ <-  sum(res$IQRpartable[[1]]$parametertask == "ETA")
  npars__ <- length(res$bestfit[[1]])
  parsWithIIV__ <- unique(partable__$belongs_to[partable__$parametertask == "ETA"])
  parsF__ <- partable__$parametername[partable__$parametertask %in% c("pop", "error")]
  parsR__ <- partable__$parametername[partable__$parametertask %in% c("omega")]
  parsR__ <- c(parsR__, partable__$parametername[partable__$parametertask %in% c("beta") & partable__$belongs_to %in% partable__$belongs_to[partable__$parametertask == "ETA"]])
  parsF__ <- c(parsF__, partable__$parametername[partable__$parametertask %in% c("beta") & !partable__$belongs_to %in% partable__$belongs_to[partable__$parametertask == "ETA"]])
  dim_parsR__ <- length(which(partable__$parametername %in% parsR__ & partable__$estimated == 1))
  dim_parsF__ <- length(which(partable__$parametername %in% parsF__ & partable__$estimated == 1))
  obj__ <- data.frame(
    metric = c("OBJ", "AIC", "BIC", "BICc"),
    value = c(
      parframes__[1, "value", drop = TRUE],
      parframes__[1, "value", drop = TRUE] + 2*(dim_parsR__ + dim_parsF__),
      parframes__[1, "value", drop = TRUE] + (dim_parsR__ + dim_parsF__)*log(ndata__),
      parframes__[1, "value", drop = TRUE] + dim_parsR__*log(nsubjects__) + dim_parsF__*log(ndata__)
    )
  )
  mutate_IQRsysModel(res, metrics = list(obj__))
}
mutate_IQRsysModel <- function(sysModel, ...) {
  args0__ <- attr(sysModel, "args0")
  sysModelEst__ <- attr(sysModel, "sysModelEst")
  out__ <- dplyr::mutate(sysModel, ...)
  attr(out__, "args0") <- args0__
  attr(out__, "sysModelEst") <- sysModelEst__
  class(out__) <- class(sysModel)
  out__
}
grids_IQRsysModel <- function(sysModel) {
  IQRpartable__ <- sysModel$IQRpartable[[1]]
  data__ <- sysModel$data[[1]]
  name_loc__ <- unique(IQRpartable__$base_par[!is.na(IQRpartable__$CONDITION)])
  name_eta__ <- unique(IQRpartable__$belongs_to[IQRpartable__$parametertask == "ETA"])
  name_glob__ <- setdiff(
    unique(IQRpartable__$parametername)[is.na(IQRpartable__$CONDITION) & IQRpartable__$parametertask != "ETA"],
    c(name_loc__)
  )
  condition.grid__ <- attr(data__, "condition.grid")
  est__ <- attr(sysModel, "sysModelEst")$est
  for(mycatname__ in est__$data$catNames) {
    condition.grid__ <- dMod_expand_cat(condition.grid__,
                                        mycatname__,
                                        est__$data$catValues[[mycatname__]],
                                        est__$data$covariateCATreference[[mycatname__]])
  }
  fixed.grid__ <- est.grid__ <- condition.grid__
  est.grid__ <- est.grid__[intersect(names(est.grid__), c("ID", "CONDITION"))]
  for (n__ in name_glob__) {
    info__ <- filter(IQRpartable__, parametername == n__)
    if (info__$estimated[1] == 1) {
      est.grid__[[n__]] <- n__
    } else {
      fixed.grid__[[n__]] <- info__[["parametervalue"]]
    }
  }
  for (n__ in name_eta__) {
    info__ <- filter(IQRpartable__, belongs_to == n__)
    parametername__ <- paste("ETA", n__, est.grid__[["ID"]], sep = "_")
    if (info__$estimated[1] == 1) {
      est.grid__[[n__]] <- n__
      est.grid__[[paste0("ETA_", n__)]] <- parametername__
    } else {
      fixed.grid__[[n__]] <- IQRpartable__[["parametervalue"]][IQRpartable__$parametername == n__]
      fixed.grid__[[paste0("ETA_", n__)]] <- info__[["parametervalue"]][match(parametername__, info__[["parametername"]])]
    }
  }
  for (n__ in name_loc__) {
    fixed.grid__[[n__]] <- est.grid__[[n__]] <- NA
    info__ <- filter(IQRpartable__, parametername == n__)
    if (nrow(info__) > 0) {
      if (info__$estimated == 1) {
        est.grid__[[n__]] <- n__
      } else {
        fixed.grid__[[n__]] <- info__[["parametervalue"]]
      }
    }
    info__ <- filter(IQRpartable__, base_par == n__)
    estimated__ <- info__$estimated == 1
    base_estimated__ <- rep(FALSE, nrow(est.grid__))
    if ("BASE" %in% info__$CONDITION[estimated__]) {
      base_estimated__ <- !est.grid__$CONDITION %in% info__$CONDITION[!estimated__]
    }
    condition_estimated__ <- est.grid__$CONDITION %in% info__$CONDITION[estimated__]
    est.grid__[[n__]][condition_estimated__] <- info__$parametername[match(est.grid__$CONDITION[condition_estimated__], info__$CONDITION)]
    est.grid__[[n__]][!condition_estimated__ & !base_estimated__] <- NA
    fixed.grid__[[n__]][!condition_estimated__ & !base_estimated__] <-
      info__$parametervalue[match(est.grid__$CONDITION[!condition_estimated__ & !base_estimated__], info__$CONDITION)]
  }
  pars__ <- structure(IQRpartable__$parametervalue[IQRpartable__$estimated == 1], names = IQRpartable__$parametername[IQRpartable__$estimated == 1])
  mutate_IQRsysModel(sysModel,
                     fixed.grid = list(fixed.grid__),
                     est.grid = list(est.grid__),
                     pars = list(pars__))
}
spec_IQRsysModel <- function(sysModel) {
  spec__ <- sysModel[["parameters"]][[1]]
  IQRpartable__ <- sysModel[["IQRpartable"]][[1]]
  for (n__ in names(spec__$POPvalue0)) {
    row__ <- match(n__, IQRpartable__$parametername)
    if (length(row__) > 0) {
      spec__$POPvalue0[n__] <- IQRpartable__[row__[1], "parametervalue_linear"]
      spec__$POPestimate[n__] <- IQRpartable__[row__[1], "estimated"]
      spec__$IIVdistribution[n__] <- IQRpartable__[row__[1], "trafo"]
    }
    row__ <- match(paste0("omega_", n__), IQRpartable__$parametername)
    if (length(row__) > 0) {
      spec__$IIVvalue0[n__] <- IQRpartable__[row__[1], "parametervalue_linear"]
      spec__$IIVestimate[n__] <- IQRpartable__[row__[1], "estimated"]
      if (spec__$IIVvalue0[n__] != 0 & spec__$IIVestimate[n__] == 0) spec__$IIVestimate[n__] <- 2
    }
  }
  for (n__ in names(spec__$LOCmodel)) {
    loc_pars__ <- paste(n__, spec__$LOCmodel[[n__]], sep = "_")
    row__ <- match(loc_pars__, IQRpartable__$parametername)
    if (length(row__) > 0) {
      spec__$LOCvalues0[[n__]] <- IQRpartable__[row__, "parametervalue_linear"]
      spec__$LOCestimate[[n__]] <- IQRpartable__[row__, "estimated"]
      names(spec__$LOCvalues0[[n__]]) <- names(spec__$LOCestimate[[n__]]) <- IQRpartable__[row__, "CONDITION"]
    }
  }
  sysModel <- mutate_IQRsysModel(sysModel, parameters = list(spec__))
}
dMod_generate_dosing_data <- function(dosingTables,
                                      all_conditions,
                                      IDCOND.grid) {
  if (is_IQRdosing(dosingTables))
    dosingTables <- lapply(stats::setNames(nm = all_conditions), function(.x) dosingTables)
  if (length(setdiff(all_conditions, names(dosingTables)) > 0)) {
    dosingTables0__ <- lapply(stats::setNames(nm = setdiff(all_conditions, names(dosingTables))), function(i)
      IQRdosing(TIME = dosingTables[[1]][["TIME"]][[1]],1,0))
    dosingTables <- c(dosingTables, dosingTables0__)
  }
  data_dosing__ <- mapply(cbind, dosingTables, CONDITION = names(dosingTables),
                          MoreArgs = list(stringsAsFactors = FALSE), SIMPLIFY = FALSE)
  data_dosing__ <- mapply(function(.x,.y) {
    dT__ <- data_dosing__[[.x]]
    cbind(dT__, ID = .y, stringsAsFactors = FALSE)
  }, .x = IDCOND.grid$CONDITION, .y = IDCOND.grid$ID, SIMPLIFY = FALSE)
  data_dosing__ <- do.call(rbind, data_dosing__)
  data_dosing__ <- data.frame(data_dosing__, YTYPE = 0, NAME = paste0("DOSE_INPUT", data_dosing__[["ADM"]]), DV = 0, stringsAsFactors = FALSE)
  return(data_dosing__)
}
#'@export
run_IQRsysProjectMulti <- function (projectPath,
                                    ncores=1,
                                    Nparallel=1,
                                    FLAGgof=TRUE,
                                    FLAGgofStratify=FALSE,
                                    FLAGrequireConverged=FALSE) {
  projectPath <- lapply(projectPath, function (x) {
    if (!is_IQRsysProject(x)) return(NULL)
    x
  })
  if (Nparallel==1) {
    cat(sprintf("run_IQRsysProjectMulti: Running %d models\n",length(projectPath)))
  } else {
    cat(sprintf("Running %d models, %d in parallel at the same time (output suppressed)\n",length(projectPath),Nparallel))
  }
  cat("(Projects are only run if not run yet)\n")
  PASS_COMPLIANCEINFO_LOCAL_ENVIR__ <- globalenv()$COMPLIANCE_MODE_SCRIPT_NAME
  if (Nparallel > 1) {
    cluster__ <- parallel::makeCluster(Nparallel)
    doParallel::registerDoParallel(cluster__)
    parallel::clusterCall(cl=cluster__,function (x__) .libPaths(x__), .libPaths())
    parallel::clusterExport(cluster__,envir=environment(),varlist=ls())
    "%dopar%" <- foreach::"%dopar%"
  } else {
    DLLloaded__ <- FALSE
    "%dopar%" <- foreach::"%do%"
  }
  .packages = c("IQRtools")
  foreach::foreach (k__=1:length(projectPath), .packages=.packages, .inorder=TRUE) %dopar% {
    e__ <- globalenv()
    e__$COMPLIANCE_MODE_SCRIPT_NAME <- PASS_COMPLIANCEINFO_LOCAL_ENVIR__
    out <- try(run_IQRsysProject(projectPath=projectPath[[k__]],
                                 ncores=ncores,
                                 FLAGgof=FLAGgof,
                                 FLAGgofStratify=FLAGgofStratify,
                                 FLAGrequireConverged = FLAGrequireConverged), silent = FALSE)
    if (inherits(out, "try-error")) {
      message("An error was encountered in run_IQRsysProject(). Continuing anyway.")
      return()
    }
    out
  }
  if (Nparallel > 1) {
    parallel::stopCluster(cluster__)
    doParallel::stopImplicitCluster()
  }
  return(as_IQRsysProjectMulti(projectPath))
}
#'@export
as_IQRsysProjectMulti <- function (input, FLAGrecursive=FALSE) {
  if (is_IQRsysProjectMulti(input)) {
    return(input)
  }
  output__ <- list()
  if ("character" %in% class(input)) {
    for (k__ in seq_along(input)) {
      if (!dir.exists(input[k__]))
        stopIQR("provided path does not exist.")
      if (is_IQRsysProject(input[k__])) {
        output__[[length(output__)+1]] <- as_IQRsysProject(input[k__])
      } else {
        dirs__ <- list.dirs(input[k__],recursive=FLAGrecursive)
        dirs__ <- dirs__[!grepl(".Internals",dirs__)]
        lapply(dirs__,function(x) {if (is_IQRsysProject(x)) {
          output__[[length(output__)+1]] <<- as_IQRsysProject(x) }
        })
      }
    }
  } else {
    tst <- sapply(input, function (x) is_IQRsysProject(x))
    if (all(tst)) {
      output__ <- input
    } else {
      stopIQR("argument 'input' of incorrect type")
    }
  }
  names(output__) <- unclass(output__)
  attr(output__,"class") <- "IQRsysProjectMulti"
  return(output__)
}
#'@export
is_IQRsysProjectMulti <- function (input) {
  methods::is(input,"IQsysProjectMulti")
}
#'@export
as_IQRsysProject <- function (projectPath) {
  if (!is_IQRsysProject(projectPath))
    stopIQR("Provided path does not point to an IQRsysProject")
  output__ <- as_IQRnlmeProject(projectPath)
  attr(output__,"class") <- "IQRsysProject"
  return(output__)
}
#'@export
is_IQRsysProject <- function (projectPath) {
  testfile__ <- file.path(projectPath, 'project_sysfit.R')
  return(file.exists(testfile__))
}
#'@export
print.IQRsysProject <- function(x, ...) {
  if (!hasrun_IQRsysProject(x)) {
    cat(paste0("IQRsysProject: ",x,"\n"))
    cat("Project has not been run yet (most likely)\n\n")
    return()
  }
  cat(paste0("\n\nIQRsysProject: ",x,"\n\n"))
}
#'@export
hasrun_IQRsysProject <- function(projectPath) {
  file.exists(file.path(projectPath,"RESULTSORIG","project_result.sysfit"))
}
#'@export
IQRsysProject <- function(est,
                          projectPath,
                          comment = "",
                          keepProjectFolder = FALSE,
                          SIMOPT.method    = "lsodes",
                          SIMOPT.atol      = 1e-6,
                          SIMOPT.rtol      = 1e-6,
                          SIMOPT.hmin      = 0,
                          SIMOPT.hmax      = NULL,
                          SIMOPT.hini      = 0,
                          SIMOPT.maxsteps  = 5000,
                          SIMOPT.nauxtimes = 0,
                          SIMOPT.cores     = 1,
                          opt.method = "trust",
                          opt.nfits = 1,
                          opt.sd = 1,
                          opt.rinit = 1,
                          opt.rmax = 10,
                          opt.iterlim = 100,
                          opt.prior_sigma = 10,
                          opt.parlower = NULL,
                          opt.parupper = NULL,
                          algOpt.SEED = 123456,
                          FLAGprofileLL = F,
                          FLAGkeepFits = F,
                          FLAGchecks = T,
                          ...
) {
  argnames__ <- names(formals())
  SIMOPTnames__ <- grep("^SIMOPT\\.", argnames__, value = TRUE)
  OPTnames__ <- grep("^opt\\.", argnames__, value = TRUE)
  SIMOPT__ <- OPT__ <- list()
  for (n__ in SIMOPTnames__) SIMOPT__[[n__]] <- get(n__)
  for (n__ in OPTnames__) OPT__[[n__]] <- get(n__)
  if (FLAGprofileLL & !opt.method %in% "trust") {
    stopIQR("When derivative-free optimization method is used, profiles cannot be computed. Set FLAGprofileLL to FALSE or use trust as optim.method.")
  }
  if (!is_IQRsysEst(est))
    stopIQR("Input argument 'est' needs to be of class IQRsysEst")
  estInputOriginal__ <- est
  if (!is.character(projectPath))
    stopIQR("projectPath argument needs to be a character string with a absolute (avoid) or relative (better) path definition")
  est$projectPath <- projectPath
  oldpath__ <- getwd()
  if (!keepProjectFolder) aux_rmdir(est$projectPath)
  tryCatch({
    aux_mkdir(est$projectPath)
    setwd(est$projectPath)
  }, error = function (err) {
    aux_rmdir(est$projectPath)
    aux_mkdir(est$projectPath)
    setwd(est$projectPath)
  })
  aux_rmdir("RESULTS")
  aux_rmdir("RESULTSORIG")
  aux_mkdir("RESULTS")
  aux_mkdir("RESULTSORIG")
  setwd(oldpath__)
  oldpath__ <- getwd()
  setwd(est$projectPath)
  path__ <- getwd()
  if (nchar(path__) != nchar(aux_strrep(path__," ",""))) {
    setwd(oldpath__)
    aux_rmdir(est$projectPath)
    if (allowed_spaces_IQR()) {
      stopIQR("The absolute path to the project contains spaces. This is not allowed (thanks to NONMEM)")
    } else {
      warningIQR("The absolute path to the project contains spaces. If you plan to use NONMEM - then it will not work!")
    }
  }
  setwd(oldpath__)
  oldpath__ <- getwd()
  setwd(est$projectPath)
  absPathProject__ <- getwd()
  setwd(oldpath__)
  setwd(aux_fileparts(est$data$datafile)$pathname)
  absPathData__ <- getwd()
  setwd(oldpath__)
  fromFolder__ <- absPathProject__
  toFolder__ <- absPathData__
  relPathData__ <- aux_getRelPath(fromFolder__,toFolder__)
  est$data$relPathFromProject <- "."  
  est$data$fileName <- paste0(aux_fileparts(est$data$datafile)$filename,
                              aux_fileparts(est$data$datafile)$fileext)
  file.copy(est$data$datafile, est$projectPath)
  atrfile <- sub("\\.csv$", ".atr", est$data$datafile)
  if (file.exists(atrfile)) {
    file.copy(atrfile, est$projectPath)
  }
  est$data$datafile <- file.path(est$data$relPathFromProject, est$data$fileName)
  dMod_gen_IQRsysProject(est,
                         SIMOPT__,
                         OPT__,
                         algOpt.SEED,
                         FLAGprofileLL,
                         FLAGkeepFits,
                         FLAGchecks,
                         comment = comment)
  text__ <- export_IQRmodel(attr(est$model, "original"))
  aux_filewrite(text__,file.path(est$projectPath,"model.txt"))
  saveRDS(est, file = file.path(est$projectPath,"project.est"))
  output__ <- as_IQRsysProject(est$projectPath)
  return(output__)
}
#'@export
run_IQRsysProject <- function(projectPath,
                              ncores = 1,
                              FLAGrequireConverged = TRUE,
                              FLAGgof = TRUE,
                              FLAGgofStratify=FALSE,
                              FLAGclean=TRUE) {
  if (!is_IQRsysProject(projectPath))
    tryCatch(projectPath <- as_IQRsysProject(projectPath), error = function(x) x)
  oldPath__ <- getwd() 
  setwd(projectPath)   
  absProjectPath__ <- getwd() 
  absProjectPath__ <- as_IQRsysProject(absProjectPath__)
  if (hasrun_IQRsysProject(projectPath)) {
    message("IQRsysProject was already run - not rerun")
    return(invisible(NULL))
  }
  setwd(absProjectPath__)
  terminationMessage <- ""
  if (!hasrun_IQRsysProject(file.path(oldPath__,projectPath)))
    tryCatch({
      source("project_sysfit.R", local = TRUE)
    }, error = function (err__) {
      terminationMessage <<- paste0("dMod stopped with the following error message:\n",err__$message)
    })
  setwd(absProjectPath__)
  if (terminationMessage != "") {
    setwd(oldPath__)
    suppressWarnings(try(detach("package:dMod", unload=TRUE, character.only = TRUE), silent = TRUE))
    suppressWarnings(try(detach("package:cOde", unload=TRUE, character.only = TRUE), silent = TRUE))
    suppressWarnings(try(detach("package:deSolve", unload=TRUE, character.only = TRUE), silent = TRUE))
    stopIQR(terminationMessage)
  }
  mymodel__ <- readRDS("RESULTSORIG/project_result.sysfit")
  digits__ <- 3
  table__ <- tablePars_IQRsysModel(mymodel__, digits = digits__)
  filenames__ <- c("project_parameters_table.txt", "RESULTS/project_results.txt")
  for (f__ in filenames__) {
    IQRoutputTable(as.data.frame(table__),
                   xfooter = paste(aux_getRelPath(oldPath__, absProjectPath__),
                                   "RSE (relative standard error)",
                                   "CI (confidence interval)",
                                   paste("Significant digits:", digits__),
                                   "omega values reported in standard deviations.",
                                   sep = ", "),
                   xtitle = "Sysfit parameter estimates",
                   filename = f__)
  }
  standardOutput_IQRsysModel(mymodel__, projectPath = projectPath)
  setwd(oldPath__)
  PROJECTINFO     <- parseNLMEprojectHeader(projectPath)
  outputNumberALL <- 1:length(PROJECTINFO$OUTPUTS)
  outputNamesALL  <- PROJECTINFO$OUTPUTS
  setwd(absProjectPath__)
  if (FLAGgof) {
    cat("Producing SYSFIT GOF plots ------------------\n")
    tryCatch({
      aux_mkdir("RESULTS/GOF_GENERAL")
      setwd(file.path(absProjectPath__, "RESULTS", "GOF_GENERAL"))
      if (!is.null(mymodel__[["parframes"]][[1]])) {
        plots__ <- plotWaterfall_IQRsysModel(mymodel__)
        IQRoutputFigure(plots__, filename = "11_Sys_Objvalues_Multistart.pdf",scale=1.5)
      }
      if (!is.null(mymodel__[["parframes"]][[1]])) {
        plots__ <- plotPars_IQRsysModel(mymodel__)
        IQRoutputFigure(plots__,filename = "12_Sys_Parameters_Multistart.pdf",scale=1.5)
      }
      if (!is.null(mymodel__[["profiles"]][[1]])) {
        plots__ <- plotProfile_IQRsysModel(mymodel__)
        IQRoutputFigure(plots__,filename = "13_Sys_Profile_Likelihood.pdf",scale=2)
      }
      setwd(absProjectPath__)
      outputs__ <- paste0("OUTPUT", outputNumberALL)
      for (i__ in seq_along(outputs__)) {
        myfolder__ <- paste0("RESULTS/GOF_OUTPUT_", outputNumberALL[i__], "_", outputNamesALL[i__])
        aux_mkdir(myfolder__)
        setwd(myfolder__)
        setwd(absProjectPath__)
      }
    }, error = function(e__) {
      warningIQR("Problem with generation of SYSFIT diagnostic plots. Please check if model run had issues.")
    })
    cat("---------------------------------------------\n")
  }
  setwd(oldPath__)
  if (FLAGgof) {
    tryCatch({
      suppressWarnings(plot.IQRnlmeProject(projectPath,
                                           FLAGgofStratify=FLAGgofStratify,
                                           CORR_THRESHOLD=0.3,
                                           pathname=file.path(projectPath, "RESULTS")))
    }, error = function(e__) {
      warningIQR("Problem with generation of NLME-type of diagnostic plots. Please check if model run had issues.")
    })
  }
  setwd(oldPath__)
  relProjectPath__ <- aux_getRelPath(oldPath__, absProjectPath__)
  relDataPath__ <- file.path(relProjectPath__, basename(attr(mymodel__, "sysModelEst")[["data"]][["datafile"]]))
  attr(mymodel__, "sysModelEst")[["data"]][["datafile"]] <- relDataPath__
  class(mymodel__) <- union("optIQRsysModel", class(mymodel__))
  if (FLAGclean) {
    unlink(paste0(absProjectPath__,"/RESULTSORIG/project_result.sysfit"),force = TRUE)
    unlink(paste0(absProjectPath__,"/project_model.sysfit"),force = TRUE)
  }
  return(mymodel__)
}
#'@export
load_IQRsysProject <- function(projectPath, FLAGresultsOnly = FALSE) {
  stopifnot(is_IQRsysProject(projectPath))
  mywd__ <- getwd()
  setwd(projectPath)
  mymodel__ <- NULL
  if (file.exists("RESULTSORIG/project_result.sysfit"))
    mymodel__ <- readRDS("RESULTSORIG/project_result.sysfit")
  else
    warningIQR("Project result not available. Might lead to problems in recompilation")
  if (FLAGresultsOnly) {
    setwd(mywd__)
    return(mymodel__)
  }
  cat("Rebuilding IQRsysModel ...\n\n")
  est__ <- readRDS("project.est")
  options__ <- mymodel__[["options"]][[1]]
  newmodel__ <- do.call("dMod_nlmeEst2dModFrame", c(list(est = est__), options__))
  newmodel__[["dllfolder"]][[1]] <- tempdirIQR()
  cat("\n")
  cat("... successful.\n")
  if (!is.null(mymodel__)) {
    cat("Transferring results of previously executed project ... ")
    keep__ <- c("g", "x", "p", "data", "e", "p0", "model", "prd", "obj_data", "obj", "constr_fit", "dllpaths", "dllfolder")
    for (n__ in setdiff(names(mymodel__), keep__)) newmodel__[[n__]] <- mymodel__[[n__]]
    sysModelEst__ <- attr(newmodel__, "sysModelEst")
    if (!is.null(sysModelEst__[["data"]][["datafile"]]))
      sysModelEst__[["data"]][["datafile"]] <- file.path(projectPath, sysModelEst__[["data"]][["datafile"]])
    if (!is.null(newmodel__[["obj"]]))
      modelname(newmodel__[["obj"]][[1]]) <- file.path(tempdirIQR(), modelname(newmodel__[["obj"]][[1]]))
    attr(newmodel__, "sysModelEst") <- sysModelEst__
    attr(newmodel__, "args0") <- attr(mymodel__, "args0")
    class(newmodel__) <- union("optIQRsysModel", class(newmodel__))
    cat("done.\n")
  }
  setwd(mywd__)
  return(newmodel__)
}
#'@export
duplicate_IQRsysProject <- function(projectSource, projectDestination) {
  projectSource <- as_IQRsysProject(projectSource)
  aux_rmdir(projectDestination)
  aux_mkdir(projectDestination)
  oldpath__ <- getwd()
  setwd(projectDestination)
  absPathDestination__ <- getwd()
  setwd(oldpath__)
  oldpath__ <- getwd()
  setwd(projectSource)
  file.copy(from=".", to=absPathDestination__,recursive=TRUE)
  setwd(oldpath__)
  relPathSourceDataInfo__ <- aux_fileparts(parseNLMEprojectHeader(projectSource)$DATA)
  datafile__ <- paste0(relPathSourceDataInfo__$filename,relPathSourceDataInfo__$fileext)
  dataRelPathSource__ <- relPathSourceDataInfo__$pathname
  oldpath__ <- getwd()
  setwd(projectSource)
  setwd(dataRelPathSource__)
  absDataPath__ <- getwd()
  setwd(oldpath__)
  oldpath__ <- getwd()
  setwd(projectDestination)
  absDestinationPath__ <- getwd()
  setwd(oldpath__)
  FLAGcopyData <- FALSE
  if (FLAGcopyData | dataRelPathSource__==".") {
    dataRelPathDestination__ <- "."
  } else {
    dataRelPathDestination__ <- aux_getRelPath(absDestinationPath__,absDataPath__)
  }
  content__ <- aux_fileread(paste0(projectDestination,"/project_sysfit.R"))
  content__ <- aux_strrep(content__,paste0(dataRelPathSource__,"/"),paste0(dataRelPathDestination__,"/"))
  aux_filewrite(content__,paste0(projectDestination,"/project_sysfit.R"))
  return(as_IQRsysProject(projectDestination))
}
#'@export
getOptTrace_IQRsysProject <- function(projectPath, index = NULL) {
  if (!is_IQRsysProject(projectPath))
    stopIQR("Project path does not point to an IQRsysProject.")
  if (!file.exists(file.path(projectPath, "RESULTSORIG")))
    stopIQR("Project has not yet run.")
  trialfolder__ <- tail(list.files(file.path(projectPath, "RESULTSORIG"), pattern = "^trial-"), 1)
  tracefiles__ <- list.files(file.path(projectPath, "RESULTSORIG", trialfolder__), pattern = "_optTrace\\.csv")
  fitindex__ <- sapply(tracefiles__, function(t__) strsplit(t__, "_", fixed = TRUE)[[1]][1])
  if (!is.null(index)) fitindex__ <- fitindex__[as.numeric(fitindex__) %in% index]
  traces__ <- do.call(rbind, lapply(fitindex__, function(f__) {
    data__ <- IQRloadCSVdata(paste0(file.path(projectPath, "RESULTSORIG", trialfolder__, f__), "_optTrace.csv"))
    data.frame(Index = as.numeric(f__), data__)
  }))
  rownames(traces__) <- NULL
  results__ <- readRDS(file.path(projectPath, "project_model.sysfit"))
  partable__ <- results__[["IQRpartable"]][[1]]
  partable__ <- partable__[partable__[["estimated"]] == 1, c("parametername", "trafo", "parametertask", "belongs_to")]
  parameters__ <- partable__[["parametername"]]
  for (i__ in seq_along(parameters__)) {
    parname__ <- partable__[["parametername"]][i__]
    trafo__ <- partable__[["trafo"]][i__]
    traces__[[parname__]] <- dplyr::case_when(trafo__ == "L" ~ exp(traces__[[parname__]]),
                                              trafo__ == "G" ~ inv_logit(traces__[[parname__]]),
                                              trafo__ == "N" ~ traces__[[parname__]])
  }
  traces__ <- data.frame(traces__[ , setdiff(names(traces__), parameters__)],
                         Parameter = rep(parameters__, each = nrow(traces__)),
                         Value = unlist(traces__[, parameters__]),
                         stringsAsFactors = FALSE)
  names(partable__) <- c("Parameter", "Trafo", "Task", "Parent")
  dplyr::left_join(traces__, partable__, by = "Parameter")
}
#'@export
plot_IQRoptTrace <- function(trace, cutObj = 20) {
  obj <- trace[!duplicated(paste(trace[["Index"]], trace[["Iteration"]])),]
  obj[["Parent"]] <- "obj"
  obj[["Task"]] <- "obj"
  obj[["Value"]] <- obj[["Obj"]]
  obj[["Trafo"]] <- "N"
  obj[["Parameter"]] <- "Objective Value"
  obj[["Value"]][obj[["Value"]] > min(obj[["Value"]] + cutObj, na.rm = TRUE)] <- Inf
  trace <- rbind(trace, obj)
  trace[["Parameter"]] <- factor(
    trace[["Parameter"]],
    levels = c("Objective Value", sort(setdiff(trace[["Parameter"]], "Objective Value")))
  )
  IQRggplot(trace, aes(x = Iteration, y = Value, group = Index, color = Task)) +
    facet_wrap(~Parameter, scales = "free_y") +
    geom_line() +
    scale_color_IQRtools()
}
#'@export
getPars_IQRoptTrace <- function(trace,
                                index = trace$Index[1],
                                iteration = max(trace$Iteration[trace$Index == index])) {
  trace__ <- trace[trace$Index == index[1] & trace$Iteration == iteration[1],]
  if (nrow(trace__) == 0) stopIQR("The requested index or iteration is not contained in trace data.")
  structure(as.numeric(trace__$Value), names = as.character(trace__$Parameter))
}
#'@export
sample_IQRsysModel <- function(sysmodel, covariates = NULL, parameters = NULL, returnCovariates = FALSE) {
  sysobj__ <- sysmodel
  sysModelEst__ <- attr(sysobj__, "sysModelEst")
  model0__ <- attr(sysModelEst__[["model"]], "original")
  partable__ <- sysobj__$IQRpartable[[1]]
  covtable__ <- unique(partable__[partable__$parametertask == "beta", c("covname", "covref")])
  parsOfInterest__ <- unlist(sysModelEst__[["parsOfInterest"]])
  if (!is.null(parameters)) parsOfInterest__ <- parameters
  var.equations__ <- sapply(model0__[["variables"]], function(x__) x__[["formula"]])
  var.equations__ <- var.equations__[intersect(names(var.equations__), parsOfInterest__)]
  par.equations__ <- getEquations(sysobj__[["p0"]][[1]])[[1]]
  par.equations__ <- par.equations__[intersect(names(par.equations__), union(parsOfInterest__,
                                                                             getSymbols(var.equations__)))]
  varpar.equations__ <- resolveRecurrence(c(par.equations__, var.equations__))[parsOfInterest__]
  symbols__ <- getSymbols(varpar.equations__)
  etas__ <- symbols__[grepl("^ETA_", symbols__)]
  etas.values__ <- structure(rep(0, length(etas__)), names = etas__)
  bestfit.values__ <- sysobj__[["pars"]][[1]]
  fixedgrid__ <- sysobj__[["fixed.grid"]][[1]]
  states__ <- names(model0__[["states"]])
  parameters__ <- names(model0__[["parameters"]])
  parameters.values__ <- sapply(parameters__, function(x__) model0__[["parameters"]][[x__]][["value"]])
  states.values__ <- sapply(states__, function(x__) as.numeric(model0__[["states"]][[x__]][["IC"]]))
  catNames__ <- sysModelEst__[["data"]][["catNames"]]
  covNames__ <- sysModelEst__[["data"]][["covNames"]]
  covNames__ <- covNames__[covNames__ %in% covtable__[["covname"]]]
  catNames__ <- catNames__[sapply(catNames__, function(.) any(grepl(paste0("^", ., "_"), covtable__[["covname"]])))]
  cov.expanded__ <- as.list(do.call(cbind, lapply(covNames__, function(myname__) {
    out__ <- rep(covtable__[["covref"]][covtable__[["covname"]] == myname__], nrow(covariates))
    if (myname__ %in% names(covariates))
      out__[!is.na(covariates[[myname__]])] <- covariates[[myname__]][!is.na(covariates[[myname__]])]
    return(out__)
  })))
  cat.expanded__ <- as.list(do.call(cbind, lapply(catNames__, function(myname__) {
    catlevels__ <- unique(covtable__[["covname"]][grepl(paste0("^", myname__, "_[1-9]"), covtable__[["covname"]])])
    out__ <- as.data.frame(matrix(0, nrow = nrow(covariates), ncol = length(catlevels__), dimnames = list(NULL, catlevels__)))
    if (myname__ %in% names(covariates)) {
      catvalues__ <- tail(strsplit(catlevels__, "_")[[1]], 1)
      for (i__ in 1:length(catlevels__)) {
        out__[ , i__] <- as.numeric(covariates[[myname__]] == catvalues__[i__])
      }
    }
    return(out__)
  })))
  catcov.expanded__ <- as.data.frame(c(cov.expanded__, cat.expanded__))
  par2out <- function(estimated_pars) {
    output__ <- do.call(rbind, lapply(1:nrow(covariates), function(i__) {
      mycatcov.expanded__ <- catcov.expanded__[i__, , drop = FALSE]
      cols__ <- names(mycatcov.expanded__)[sapply(strsplit(names(mycatcov.expanded__), "_"), function(x__) paste(x__[-length(x__)], collapse = "_")) %in% names(covariates)]
      fixedgrid.values__ <- fixedgrid__[, intersect(names(fixedgrid__), c(cols__, symbols__)), drop = FALSE]
      indx__ <- try({
        which(Reduce("&", lapply(cols__, function(n__) {
          as.numeric(fixedgrid.values__[[n__]]) == as.numeric(mycatcov.expanded__[[n__]])
        })))
      }, silent = TRUE)
      if (inherits(indx__, "try-error") | length(indx__) == 0) {
        warningIQR("Requested covariate combination was not used in model. Use output parameter values with caution.")
        indx__ <- 1
      }
      parlist__ <- c(as.list(mycatcov.expanded__),
                     as.list(etas.values__), as.list(estimated_pars),
                     as.list(fixedgrid.values__[indx__[1], intersect(names(fixedgrid.values__), symbols__), drop = FALSE]),
                     as.list(parameters.values__),
                     as.list(states.values__))
      myexpr__ <- parse(text = paste0("c(", paste(varpar.equations__, collapse = ", "), ")"))
      with(parlist__, eval(myexpr__))
    }))
    colnames(output__) <- names(varpar.equations__)
    output__ <- as.data.frame(output__)
    return(output__)
  }
  output__ <- par2out(bestfit.values__)
  vcov__ <- sysobj__[["vcov"]][[1]]
  sd__ <- NULL
  rse__ <- NULL
  if (length(vcov__) > 0) {
    N__ <- 1000
    set.seed(0)
    sample__ <- MASS::mvrnorm(n = N__, mu = bestfit.values__, Sigma = vcov__)
    parvalues__ <- lapply(1:N__, function(i__) par2out(sample__[i__,]))
    ncol__ <- ncol(output__)
    sd__ <- lapply(seq_len(ncol__), function(i__) {
      values__ <- sapply(parvalues__, function(d__) d__[[i__]])
      values__ <- apply(values__, 1, function(x) sd(x, na.rm = TRUE))
      values__
    })
    names(sd__) <- names(output__)
    sd__ <- as.data.frame(sd__)
    rse__ <- sd__/output__ 
  }
  if (returnCovariates) {
    output__ <- cbind(covariates, output__)
    if (!is.null(sd__)) sd__ <- cbind(covariates, sd__)
    if (!is.null(rse__)) rse__ <- cbind(covariates, rse__)
  }
  attr(output__, "se") <- sd__
  attr(output__, "rse") <- rse__
  return(output__)
}
#'@export
plot.IQRsysProject <- function(x, ..., FLAGgofStratify=FALSE, CORR_THRESHOLD=0.3,nindiv=16) {
  NULL
}
parseSYSprojectHeader <- function(projectPath) {
  if (!is_IQRsysProject(projectPath))
    stopIQR("Provided projectPath does not point to an IQRsysProject")
  project__ <- readLines(file.path(projectPath, "project_sysfit.R"))
  project__ <- paste0(project__, collapse = "\n")
  ixstart__ <- aux_strFindAll(project__,'# ==PROJECT HEADER START===================================================')$end
  ixend__   <- aux_strFindAll(project__,  '# ==PROJECT HEADER END=====================================================')$start
  if (is.null(ixstart__) | is.null(ixend__)) stopIQR('Project header could not be found in project_NLMIXR.R file.')
  headertext__ <- aux_strtrim(substr(project__,ixstart__+1,ixend__-1))
  headertext__  <- aux_strrep(headertext__,"# ","")
  headertext__  <- aux_strrep(headertext__,"\n",",\n")
  projectinfo__ <- eval(parse(text=paste0("list(",headertext__,")")))
  projectinfo__ <- lapply(projectinfo__,function(x) aux_explodePC(x))
  return(projectinfo__)
}
sampleSYSFITpopulationParameters <- function(input, FLAG_SAMPLE=FALSE, verbose=TRUE) {
  if (is.na(input$objectivefunction$OBJ)) return(NULL)
  output__                                      <- list()
  output__$type                                 <- 'SYSFIT'
  output__$path                                 <- input$path
  paramNames                                  <- input$parameters$names
  values                                      <- input$parameters$values
  covariance                                  <- input$parameters$covariancematrix
  covariance[abs(covariance)<100*.Machine$double.eps] <- 0
  covariance <- matrix(covariance,ncol=ncol(input$parameters$covariancematrix))
  rownames(covariance) <- rownames(input$parameters$covariancematrix)
  colnames(covariance) <- colnames(input$parameters$covariancematrix)
  RUN__ <- TRUE
  count__ <- 1
  while (RUN__) {
    if (FLAG_SAMPLE) {
      if (!is.null(covariance)) {
        samples__ <- mvrnorm(n=1,mu=values,Sigma=covariance)
      } else {
        if (verbose) {
          warningIQR('The covariance matrix was not determined => No sampling of population parameters from uncertainty distributions.')
        }
        samples__ <- values
      }
    } else {
      samples__ <- values
      if (verbose) {
        message('No sampling of population parameters from uncertainty distributions.')
      }
    }
    ixo__     <- which(grepl('omega\\(',paramNames))
    n       <- paramNames[ixo__]
    ixno__    <- which(aux_strFindAll(n,',')$start < 0)
    no      <- n[ixno__]
    ixouseo__ <- sapply(no, function(x) which(x==paramNames))
    no      <- gsub(x=no,pattern='omega\\(',replacement='')
    no      <- gsub(x=no,pattern='\\)',replacement='')
    output__$randomEffects$names  <- no
    output__$randomEffects$values <- abs(samples__[ixouseo__])
    covariancematrix <- diag(samples__[ixouseo__])^2
    ixo__              <- which(grepl('omega\\(',paramNames))
    n                <- paramNames[ixo__]
    ixousec__          <- which(aux_strFindAll(n,',')$start > 0)
    if (length(ixousec__) > 0) {
      warningIQR(paste(
        "Found off-diagonal random effects.",
        "This is currently not supported by SYSFIT.",
        "Offdiagonal elements were ignored."))
    }
    suppressWarnings(output__$randomEffects$covariancematrix <- nearPD(covariancematrix))
    if (min(eigen(covariancematrix)$values) >= 0) RUN__ <- FALSE
    count__ <- count__ + 1
    if (count__ > 100) {
      warningIQR("Difficulty to get a possemidef covariance matrix.")
      break()
    }
  }
  corrmatrix <- matrix(NaN, ncol=ncol(covariancematrix),nrow=ncol(covariancematrix))
  for (krow in 1:nrow(corrmatrix)) {
    for (kcol in 1:ncol(corrmatrix)) {
      corrmatrix[krow,kcol] <- covariancematrix[krow,kcol]/sqrt(abs(covariancematrix[krow,krow]*covariancematrix[kcol,kcol]))
    }
  }
  output__$randomEffects$correlationmatrix <- corrmatrix
  ix__ <- c(ixouseo__, ixousec__)
  ix_keep <- setdiff(seq_along(samples__),ix__)
  samples__ <- samples__[ix_keep]
  paramNames <- paramNames[ix_keep]
  output__$fixedEffects$names <- output__$randomEffects$names
  ixfe <- c()
  for (k__ in seq_along(output__$fixedEffects$names)) {
    ix__ <- which(output__$fixedEffects$names[k__]==paramNames)
    output__$fixedEffects$values[k__] <- samples__[ix__]
    ixfe <- c(ixfe, ix__)
  }
  ix_keep <- setdiff(seq_along(samples__),ixfe)
  samples__ <- samples__[ix_keep]
  paramNames <- paramNames[ix_keep]
  output__$randomEffects$transformation     <- input$trans_randeffects
  output__$randomEffects$inv_transformation <- input$inv_trans_randeffects
  output__$fixedEffects$transformation      <- input$trans_randeffects
  Noutput <- length(input$residualerrormodels)
  removeIX <- c()
  for (k__ in 1:Noutput) {
    outputInfo   <- list()
    outputInfo$alias <- input$residualerrormodels[k__]
    outputInfo$abcr <- c(NA,NA)
    ix__ <- which(paste0('error_ADD', k__)==paramNames)
    if (length(ix__)>0) {
      outputInfo$abcr[1] <- samples__[ix__]
      removeIX <- c(removeIX, ix__)
    }
    ix__ <- which(paste0('error_PROP', k__)==paramNames)
    if (length(ix__)>0) {
      outputInfo$abcr[2] <- samples__[ix__]
      removeIX <- c(removeIX, ix__)
    }
    output__$residualErrorModel[[k__]] <- outputInfo
  }
  ix_keep <- setdiff(seq_along(samples__),removeIX)
  samples__ <- samples__[ix_keep]
  paramNames <- paramNames[ix_keep]
  for (k__ in 1:Noutput) {
    ix__ <- which(output__$residualErrorModel[[k__]]$alias=='abs')
    if (length(ix__)>0) {
      output__$residualErrorModel[[k__]]$formula <- 'abcr(1).*ones(size(f))'
      output__$residualErrorModel[[k__]]$FlagTransf <- 0
    }
    ix__ <- which(output__$residualErrorModel[[k__]]$alias=='rel')
    if (length(ix__)>0) {
      output__$residualErrorModel[[k__]]$formula <- 'abcr(2).*f'
      output__$residualErrorModel[[k__]]$FlagTransf <- 0
    }
    ix__ <- which(output__$residualErrorModel[[k__]]$alias=='absrel')
    if (length(ix__)>0) {
      output__$residualErrorModel[[k__]]$formula <- 'abcr(1) + abcr(2).*f'
      output__$residualErrorModel[[k__]]$FlagTransf <- 0
    }
  }
  ix__            <- which(grepl('beta_',paramNames))
  covariates      <- paramNames[ix__]
  covariatevalues <- samples__[ix__]
  ix_keep    <- setdiff(seq_along(samples__),ix__)
  samples__    <- samples__[ix_keep]
  paramNames   <- paramNames[ix_keep]
  categorical_covariates              <- list()
  categorical_covariates$parameter    <- c()
  categorical_covariates$covariate    <- c()
  for (k__ in seq_along(input$PROJECTINFO$BETACATNAMES)) {
    if (nchar(input$PROJECTINFO$BETACATNAMES[k__]) > 0) {
      bcnk <- input$PROJECTINFO$BETACATNAMES[k__]
      bcnk <- aux_strrep(bcnk,'beta_','')
      bcnk <- aux_strrep(bcnk,'(',',')
      bcnk <- aux_strrep(bcnk,')','')
      terms <- aux_explodePC(bcnk)
      xx <- aux_strrep(input$PROJECTINFO$BETACATCATEGORIES[k__],"[","c(")
      xx <- aux_strrep(xx,"]",")")
      xx <- aux_strrep(xx," ",",")
      categories <- eval(parse(text=xx))
      reference  <- as.double(input$PROJECTINFO$BETACATREFERENCE[k__])
      categorical_covariates$parameter <- c(categorical_covariates$parameter, terms[1])
      categorical_covariates$covariate <- c(categorical_covariates$covariate, terms[2])
      categorical_covariates$categories[[k__]] <- categories
      categorical_covariates$reference <- c(categorical_covariates$reference, reference)
      values_cat <- c()
      for (k2__ in seq_along(categories)) {
        n <- aux_strrep(input$PROJECTINFO$BETACATNAMES[k__],')',sprintf('==%d)',categories[k2__]))
        if (categories[k2__] == reference) {
          value <- 0
        } else {
          value <- covariatevalues[which(n==covariates)]
        }
        values_cat <- c(values_cat,value)
      }
      categorical_covariates$value[[k__]] <- values_cat
    }
  }
  continuous_covariates <- list()
  continuous_covariates$parameter <- c()
  continuous_covariates$covariate <- c()
  continuous_covariates$formula   <- c()
  continuous_covariates$value     <- c()
  for (k__ in seq_along(input$PROJECTINFO$BETACOVNAMES)) {
    if (nchar(input$PROJECTINFO$BETACOVNAMES[k__]) > 0) {
      bcnk <- input$PROJECTINFO$BETACOVNAMES[k__]
      bcnk <- aux_strrep(bcnk,'beta_','')
      bcnk <- aux_strrep(bcnk,'(',',')
      bcnk <- aux_strrep(bcnk,')','')
      terms <- aux_explodePC(bcnk)
      continuous_covariates$parameter  <- c(continuous_covariates$parameter, terms[1])
      continuous_covariates$covariate  <- c(continuous_covariates$covariate, terms[2])
      continuous_covariates$formula    <- c(continuous_covariates$formula, input$PROJECTINFO$BETACOVTRANS[k__])
      continuous_covariates$value      <- c(continuous_covariates$value, covariatevalues[which(input$PROJECTINFO$BETACOVNAMES[k__]==covariates)])
    }
  }
  continuous <- list()
  for (k__ in seq_along(continuous_covariates$parameter)) {
    if (k__==1) {
      continuous[[k__]] <- list(
        parameter  = continuous_covariates$parameter[k__],
        covariates = continuous_covariates$covariate[k__],
        values     = continuous_covariates$value[k__],
        formula    = continuous_covariates$formula[k__])
    } else {
      ix__ <- which(continuous_covariates$parameter[k__]==sapply(continuous,function(x) x$parameter))
      if (length(ix__) == 0) {
        continuous[[length(continuous)+1]] <- list(
          parameter  = continuous_covariates$parameter[k__],
          covariates = continuous_covariates$covariate[k__],
          values     = continuous_covariates$value[k__],
          formula    = continuous_covariates$formula[k__])
      } else {
        continuous[[ix__]]$covariates <- c(continuous[[ix__]]$covariates, continuous_covariates$covariate[k__])
        continuous[[ix__]]$values     <- c(continuous[[ix__]]$values, continuous_covariates$value[k__])
        continuous[[ix__]]$formula    <- c(continuous[[ix__]]$formula, continuous_covariates$formula[k__])
      }
    }
  }
  output__$covariates$continuous <- continuous
  categorical <- list()
  for (k__ in seq_along(categorical_covariates$parameter)) {
    if (k__==1) {
      information <- list()
      information[[1]] <- list(
        categories = categorical_covariates$categories[k__],
        values = categorical_covariates$value[k__]
      )
      categorical[[k__]] <- list(
        parameter  = categorical_covariates$parameter[k__],
        covariates = categorical_covariates$covariate[k__],
        information = information)
    } else {
      ix__ <- which(categorical_covariates$parameter[k__]==sapply(categorical,function(x) x$parameter))
      if (length(ix__) == 0) {
        information <- list()
        information[[1]] <- list(categories = categorical_covariates$categories[k__],
                                 values = categorical_covariates$value[k__]
        )
        categorical[[length(categorical)+1]] <- list(
          parameter  = categorical_covariates$parameter[k__],
          covariates = categorical_covariates$covariate[k__],
          information = information)
      } else {
        information <- list()
        information[[1]] <- list(
          categories = categorical_covariates$categories[k__],
          values = categorical_covariates$value[k__]
        )
        categorical[[ix__]]$covariates <- c(categorical[[ix__]]$covariates, categorical_covariates$covariate[k__])
        categorical[[ix__]]$information[[length(categorical[[ix__]]$information)+1]] <- list(
          categories = categorical_covariates$categories[k__],
          values = categorical_covariates$value[k__]
        )
      }
    }
  }
  output__$covariates$categorical <- categorical
  if (length(paramNames)>0) {
    if (!is.na(paramNames[1])) {
      warningIQR('The NONMEM output contained information that are currently not handled.')
    }
  }
  values  <- output__$fixedEffects$values
  trans   <- output__$fixedEffects$transformation
  tvalues <- c()
  for (k__ in seq_along(values)) {
    phi <- values[k__]
    tvalues[k__] <- eval(parse(text=trans[k__]))
  }
  output__$fixedEffects$values <- tvalues
  output__$fixedEffects$transformation <- NULL
  return(output__)
}
dMod_fill_sysEst_parameters <- function(POPvalues0, POPestimate = NULL, IIVdistribution = NULL, IIVvalues0 = NULL, IIVestimate = NULL) {
  if (!is.numeric(c(POPvalues0, IIVvalues0)))
    stopIQR("Initial guesses are not numeric.")
  if (any(!(c(IIVestimate, 1) %in% 0:2)))
    stopIQR("IIVestimate parameters not 0, 1 or 2")
  if (any(!(c(POPestimate, 1) %in% 0:1)))
    stopIQR("IIVestimate parameters not 0, 1 or logical")
  if (any(!(c(IIVdistribution, "L") %in% c("N", "G", "L"))))
    stopIQR("Not all IIVdistribution parameters are N, G or L")
  if (any(!(c(names(POPestimate),
              names(IIVdistribution),
              names(IIVvalues0),
              names(IIVestimate),
              names(POPvalues0)) %in% names(POPvalues0))))
    stopIQR("Parameters which are not defined in POPvalues0 have been passed into another argument.")
  n__ <- names(POPvalues0)
  POPestimate__ <- stats::setNames(rep(1, length(n__)), n__)
  IIVdistribution__ <- stats::setNames(rep("L", length(n__)), n__)
  IIVvalues0__ <- stats::setNames(rep(1, length(n__)), n__)
  IIVestimate__ <- stats::setNames(rep(0, length(n__)), n__)
  if (!is.null(POPestimate))
    POPestimate__[intersect(names(POPestimate), n__)] <- POPestimate[intersect(names(POPestimate), n__)]
  if (!is.null(IIVdistribution))
    IIVdistribution__[intersect(names(IIVdistribution), n__)] <- IIVdistribution[intersect(names(IIVdistribution), n__)]
  if (!is.null(IIVvalues0))
    IIVvalues0__[intersect(names(IIVvalues0), n__)] <- IIVvalues0[intersect(names(IIVvalues0), n__)]
  if (!is.null(IIVestimate))
    IIVestimate__[intersect(names(IIVestimate), n__)] <- IIVestimate[intersect(names(IIVestimate), n__)]
  out__ <- list(POPvalues0 = POPvalues0, POPestimate = POPestimate__,
                IIVdistribution = IIVdistribution__,
                IIVvalues0 = IIVvalues0__, IIVestimate = IIVestimate__)
  out__ <- lapply(out__, function(i) {
    i[order(names(i))]
  })
  return(out__)
}
dMod_fill_LOC_fields <- function(myNlmeEst__) {
  all_conditions <- unique(c(
    unlist(myNlmeEst__$modelSpec$LOCmodel),
    unlist(lapply(myNlmeEst__$modelSpec$LOCvalues0, names)),
    myNlmeEst__$modelSpec$CONDITIONS,
    myNlmeEst__$data$dataModeling$CONDITION)
  )
  LOCmodel__   <- myNlmeEst__$modelSpec$LOCmodel
  LOCvalues0__ <- myNlmeEst__$modelSpec$LOCvalues0[names(LOCmodel__)]
  if (is.null(LOCvalues0__))
    LOCvalues0__ <- structure(vector("list", length = length(LOCmodel__)), names = names(LOCmodel__))
  LOCestimate__ <- myNlmeEst__$modelSpec$LOCestimate[names(LOCmodel__)]
  if (is.null(LOCestimate__))
    LOCestimate__ <- structure(vector("list", length = length(LOCmodel__)), names = names(LOCmodel__))
  LPOPvalues0__  <-  myNlmeEst__$modelSpec$POPvalues0[names(LOCmodel__)]
  LPOPestimate__ <-  myNlmeEst__$modelSpec$POPestimate[names(LOCmodel__)]
  LOCvalues0__ <- mapply(function(L, P, all_conditions) {
    nm <- all_conditions[!all_conditions %in% names(L)]
    defaults__ <- stats::setNames(rep(P, length(nm)), nm)
    return(c(L, defaults__)[all_conditions])
  }, L = LOCvalues0__, P = LPOPvalues0__, MoreArgs = list(all_conditions = all_conditions), SIMPLIFY = FALSE)
  LOCestimate__ <- mapply(function(L, P, all_conditions) {
    nm <- all_conditions[!all_conditions %in% names(L)]
    defaults__ <- stats::setNames(rep(P, length(nm)), nm)
    return(c(L, defaults__)[all_conditions])
  }, L = LOCestimate__, P = LPOPestimate__, MoreArgs = list(all_conditions = all_conditions), SIMPLIFY = FALSE)
  LOCparameters__ <- mapply(function(LM, all_conditions, parameter) {
    nm <- setdiff(all_conditions, LM)
    defaults__ <- stats::setNames(rep(parameter, length(nm)), nm = nm)
    uniques__ <- stats::setNames(paste0(parameter, "_", LM), nm = LM)
    return(c(uniques__, defaults__)[all_conditions])
  }, parameter = names(LOCmodel__), LM = LOCmodel__, MoreArgs = list(all_conditions = all_conditions), SIMPLIFY = FALSE)
  out__ <- list(CONDITIONS    = all_conditions,
                LOCmodel      = LOCmodel__,
                LOCvalues0    = LOCvalues0__,
                LOCestimate   = LOCestimate__,
                LOCparameters = LOCparameters__)
  return(out__)
}
dMod_convert2dMod_errorModel__ <- function(errorModel) {
  log_safe <- function(x__) ifelse(x__ <= 0, -750, log(x__))
  error_eqns__ <- lapply(seq_along(errorModel), function(i) {
    myname__ <- names(errorModel)[i]
    output_index__ <- gsub("OUTPUT", "", names(errorModel)[i])
    type__ <- errorModel[[i]][[1]]
    if (type__ == "abs"){
      out_eqn__ <- structure(paste0("error_ADD", output_index__), names = myname__)
      attr(out_eqn__, "values0") <- structure(log_safe(as.numeric(errorModel[[i]][[2]])),
                                              names = paste0("error_ADD", output_index__))
      return(out_eqn__)}
    if (type__ == "rel"){
      out_eqn__ <- structure(paste0("error_PROP", output_index__, " * ", myname__), names = myname__)
      attr(out_eqn__, "values0") <- structure(log_safe(as.numeric(errorModel[[i]][[2]])),
                                              names = paste0("error_PROP", output_index__))
      return(out_eqn__)}
    if (type__ == "absrel")    {
      out_eqn__ <- structure(paste0("sqrt(error_ADD", output_index__, "^2 + ", "error_PROP", output_index__, "^2 * ", myname__, "^2)"), names = myname__)
      attr(out_eqn__, "values0") <- structure(log_safe(as.numeric(unlist(errorModel[[i]][c(2,3)]))),
                                              names = paste0(c("error_ADD", "error_PROP"), output_index__))
      return(out_eqn__)}
    if (!(type__ %in% c("abs", "rel", "absrel")))
      stopIQR("errorModel type not defined")
  })
  names(error_eqns__) <- names(errorModel)
  out__ <- do.call(c, unname(error_eqns__))
  attr(out__, "values0") <- do.call(c, lapply(unname(error_eqns__), function(error_eqn) attr(error_eqn, "values0")))
  return(out__)
}
dMod_build_dosing_events <- function(inputs__, ndoses) {
  N__ <- length(inputs__)
  events__ <- do.call(rbind, lapply(1:N__, function(i__) {
    input__ <- inputs__[i__]
    ndose__ <- ndoses[i__]
    var__    <- rep(input__, 2*ndose__) 
    time__   <- c(paste("ton" , input__, seq_len(ndose__), sep = "_"),
                  paste("toff", input__, seq_len(ndose__), sep = "_"))
    value__  <- c(paste("xon" , input__, seq_len(ndose__), sep = "_"),
                  rep("0", ndose__))
    method__ <- rep("replace", length(var__))
    data.frame(var = var__, time = time__, value = value__, method = method__, stringsAsFactors = FALSE)
  }))
  as.eventlist(events__)
}
dMod_build_dosing_trafo <- function(max_scheme) {
  as.eqnvec(do.call(c,lapply(1:length(max_scheme), function(ADM__) {
    nDOSE__ <- max_scheme[ADM__]
    TIME <- paste0("TIME", ADM__, "_", 1:nDOSE__)
    Tlag <- paste0("Tlag", ADM__)
    TINF <- paste0("TINF", ADM__, "_", 1:nDOSE__)
    AMT <-  paste0("AMT", ADM__, "_", 1:nDOSE__)
    names.ton__ <- paste0("ton_INPUT", ADM__, "_", 1:nDOSE__)
    ton__ <- paste0("(", TIME, " + ", Tlag, ")")
    names.toff__ <- paste0("toff_INPUT", ADM__, "_", 1:nDOSE__)
    toff__ <- paste0("(", TIME, " + ", TINF, " + ",Tlag, ")")
    names.xon__ <- paste0("xon_INPUT", ADM__, "_", 1:nDOSE__)
    xon__ <- paste0("(", AMT, "/", TINF, ")")
    stats::setNames(c(ton__, toff__, xon__), c(names.ton__, names.toff__, names.xon__))
  })))
}
dMod_build_dosing_parameters <- function(dataNLME, inputs = NULL) {
  if ("EVID" %in% names(dataNLME)) {
    data_dosing__ <- dataNLME[dataNLME[["EVID"]] == 1,]
  } else {
    data_dosing__ <- dataNLME[!is.na(dataNLME[["ADM"]]) && dataNLME[["ADM"]] > 0,]
  }
  merge_by_var1__<- function(x, y) merge(x, y, by = "Var1", all = TRUE)
  nDoses_per_ADM__ <- Reduce("merge_by_var1__", lapply(split(data_dosing__, data_dosing__[["ADM"]]), function(ADM__) {
    as.data.frame(table(ADM__[, "ID"]))
  }))
  max_nDoses_per_ADM__ <- data.frame(
    ADM = 1:(ncol(nDoses_per_ADM__) - 1),
    N  = apply(
      as.matrix(nDoses_per_ADM__[, -1, drop = FALSE]),
      2, 
      function(x) {
        x[is.na(x)] <- 0
        max(x)
      })
  )
  if (!is.null(inputs)) {
    missingADM__ <- setdiff(seq_len(inputs), max_nDoses_per_ADM__[["ADM"]])
    if (length(missingADM__) > 0) {
      addDoses__ <- data.frame(ADM = missingADM__, N = 1)
      max_nDoses_per_ADM__ <- rbind(max_nDoses_per_ADM__, addDoses__)
    }
  }
  IDs__ <- unique(dataNLME[["ID"]])
  dosing_pars__ <- lapply(IDs__, function(myID__) {
    d__ <- data_dosing__[data_dosing__[["ID"]] %in% myID__, ]
    d__ <- d__[order(d__[["TIME"]], d__[["ADM"]]),]
    unlist(lapply(seq_along(max_nDoses_per_ADM__[["ADM"]]), function(i__) {
      ADM__ <- max_nDoses_per_ADM__[["ADM"]][i__]
      dminor__ <- d__[d__[["ADM"]] == ADM__,]
      seqN__ <- seq_len(max_nDoses_per_ADM__[i__, "N"])
      TIME__ <- structure(dminor__[["TIME"]][seqN__], names = paste0("TIME", ADM__, "_", seqN__))
      AMT__  <- structure(dminor__[["AMT" ]][seqN__], names = paste0("AMT" , ADM__, "_", seqN__))
      TINF__ <- structure(dminor__[["TINF"]][seqN__], names = paste0("TINF", ADM__, "_", seqN__))
      Tlag__ <- structure(0, names = paste0("Tlag", ADM__))
      TINF__[TINF__ == 0] <- 1e-4
      AMT__[is.na(AMT__)] <- 0
      TINF__[is.na(TINF__)] <- 1
      if (all(is.na(TIME__))) TIME__[1] <- 0
      if (any(is.na(TIME__))) {
        for (i__ in which(is.na(TIME__))) {
          last__ <- max(1, tail(which(!is.na(TIME__[1:i__])), 1))
          TIME__[i__] <- TIME__[last__] + TINF__[last__]
        }
      }
      as.data.frame(as.list(c(TIME__, AMT__, TINF__, Tlag__)))
    }))
  })
  dosing_pars__ <- as.data.frame(do.call("rbind", dosing_pars__))
  dosing_pars__ <- cbind(data.frame(ID = IDs__), dosing_pars__)
  if ("CONDITION" %in% names(data_dosing__))
    dosing_pars__[["CONDITION"]] <- dataNLME[["CONDITION"]][match(dosing_pars__[["ID"]], dataNLME[["ID"]])]
  attr(dosing_pars__, "max_nDoses_per_ADM") <- max_nDoses_per_ADM__
  return(dosing_pars__)
}
dMod_build_IIVpars <- function(parameters, conditions) {
  ETApars.est__ <- lapply(names(parameters[["IIVvalues0"]])[parameters[["IIVestimate"]] == 1],
                          function(myiiv) {paste("ETA", myiiv, conditions, sep = "_")})
  names(ETApars.est__) <- names(parameters[["IIVvalues0"]])[parameters[["IIVestimate"]] == 1]
  ETApars.fix__ <- lapply(names(parameters[["IIVvalues0"]])[parameters[["IIVestimate"]] == 2],
                          function(myiiv) {paste("ETA", myiiv, conditions, sep = "_")})
  names(ETApars.fix__) <- names(parameters[["IIVvalues0"]])[parameters[["IIVestimate"]] == 2]
  omegapars.est__ <- lapply(names(parameters[["IIVvalues0"]])[parameters[["IIVestimate"]] == 1], function(myiiv) {
    stats::setNames(rep(paste0("omega_", myiiv), length(ETApars.est__[[myiiv]])), ETApars.est__[[myiiv]]) })
  omegapars.fix__ <- lapply(names(parameters[["IIVvalues0"]])[parameters[["IIVestimate"]] == 2], function(myiiv) {
    stats::setNames(rep(paste0("omega_", myiiv), length(ETApars.fix__[[myiiv]])), ETApars.fix__[[myiiv]]) })
  ETAnames.est__ <- unlist(ETApars.est__, use.names = FALSE)
  ETAnames.fix__ <- unlist(ETApars.fix__, use.names = FALSE)
  omeganames.est__ <- unique(unlist(omegapars.est__, use.names = FALSE))
  omeganames.fix__ <- unique(unlist(omegapars.fix__, use.names = FALSE))
  ETA.est__ <- stats::setNames(rep(0, length(ETAnames.est__)), ETAnames.est__)
  ETA.fix__ <- stats::setNames(rep(0, length(ETAnames.fix__)), ETAnames.fix__)
  omega.est__ <- with(parameters, stats::setNames(log(IIVvalues0[IIVestimate == 1]), omeganames.est__))
  omega.fix__ <- with(parameters, stats::setNames(log(IIVvalues0[IIVestimate == 2]), omeganames.fix__))
  pars <- c(ETA.est__, ETA.fix__, omega.est__)
  fixed    <- c(omega.fix__)
  est.grid_IIV__ <- NULL
  if ((length(ETApars.est__) > 0) || (length(ETApars.fix__) > 0) || (length(omega.est__) > 0))
    est.grid_IIV__ <- data.frame(ID = conditions, stringsAsFactors = FALSE)
  if (length(ETApars.est__) > 0)
    est.grid_IIV__ <- cbind(est.grid_IIV__, stats::setNames(as.data.frame(ETApars.est__, stringsAsFactors = FALSE), paste0("ETA_", names(ETApars.est__))))
  if (length(ETApars.fix__) > 0)
    est.grid_IIV__ <- cbind(est.grid_IIV__, stats::setNames(as.data.frame(ETApars.fix__, stringsAsFactors = FALSE), paste0("ETA_", names(ETApars.fix__))))
  if (length(omega.est__) > 0)
    est.grid_IIV__ <- cbind(est.grid_IIV__, stats::setNames(as.data.frame(t(names(omega.est__)), stringsAsFactors = FALSE), names(omega.est__)))
  fixed.grid_IIV__ <- NULL
  if (length(omega.fix__) > 0)
    fixed.grid_IIV__ <- data.frame(ID = conditions, stringsAsFactors = FALSE)
  if (length(omega.fix__) > 0)
    fixed.grid_IIV__ <- cbind(fixed.grid_IIV__, as.data.frame(t(omega.fix__)))
  return(list(pars = pars, fixed = fixed,
              est.grid_IIV = est.grid_IIV__,
              fixed.grid_IIV = fixed.grid_IIV__,
              ETA.est = ETA.est__,
              ETA.fix = ETA.fix__,
              omega.est = omega.est__,
              omega.fix = omega.fix__,
              ETApars.est = ETApars.est__,
              ETApars.fix = ETApars.fix__,
              omegapars.est = omegapars.est__,
              omegapars.fix = omegapars.fix__))
}
dMod_make_pars <- function(est.vec, condition, est.grid, p) {
  est_lookup__ <- unlist(est.grid[est.grid$ID == condition, !(names(est.grid) %in% c("ID", "CONDITION"))])
  est_pars__ <- stats::setNames(est.vec[est_lookup__], nm = names(est_lookup__))
  est_pars__ <- est_pars__[!is.na(est_pars__)]
  est_pars__ <- est_pars__[names(est_pars__) %in% getParameters(p)]
  return(est_pars__)
}
dMod_make_fixed <- function(condition, fixed.grid, p) {
  fixed_pars__ <- unlist(fixed.grid[fixed.grid$ID == condition, !(names(fixed.grid) %in% c("ID", "CONDITION"))])
  fixed_pars__ <- fixed_pars__[!is.na(fixed_pars__)]
  fixed_pars__ <- fixed_pars__[names(fixed_pars__) %in% getParameters(p)]
  return(fixed_pars__)
}
dMod_init_empty_objlist <- function(pars, deriv = TRUE) {
  if (!deriv)
    return(objlist(0,NULL,NULL))
  objlist(value = 0,
                gradient = setNames(rep(0, length(pars)), names(pars)),
                hessian = matrix(0, nrow = length(pars), ncol = length(pars),
                                 dimnames = list(names(pars), names(pars))))
}
dMod_rename_objlist <- function(myobjlist, condition, est.grid) {
  est_lookup__ <- unlist(est.grid[est.grid$ID == condition,])
  if (!is.null(myobjlist$gradient)){
    grad_names__ <- stats::setNames(names(myobjlist$gradient), names(myobjlist$gradient))
    est_lookup_used__ <- names(est_lookup__)[names(est_lookup__) %in% grad_names__]
    grad_names__[est_lookup_used__] <- est_lookup__[est_lookup_used__]
    names(myobjlist$gradient) <- grad_names__
  }
  if (!is.null(myobjlist$hessian))
    dimnames(myobjlist$hessian) <- list(grad_names__, grad_names__)
  return(myobjlist)
}
#'@export
#'@importFrom stats setNames
dMod_res <- function(data, out, err = NULL) {
  match.num <- function(x, y, tol = 1e-8) {
    digits <- -log10(tol)
    match(round(x, digits), round(y, digits))
  }
  data$name <- as.character(data$name)
  times <- sort(unique(data$time))
  names <- unique(data$name)
  data.time <- match.num(data$time, times)
  if (any(is.na(data.time)))
      stopIQR("Missing data time in prediction. Possible reason: premature termination of integration. Try setting different integrator tolerances.")
  data.name <- match(data$name, names)
  out.time <- match.num(times, out[,1])
  out.name <- match(names, colnames(out))
  timeIndex <- out.time[data.time]
  nameIndex <- out.name[data.name]
  prediction <- sapply(1:nrow(data), function(i) out[timeIndex[i], nameIndex[i]])
  deriv <- attr(out, "deriv")
  deriv.data <- NULL
  if (!is.null(deriv)) {
    pars <- unique(unlist(lapply(strsplit(colnames(deriv)[-1], split = ".", fixed = TRUE), function(i) i[2])))
    sensnames <- as.vector(outer(names, pars, paste, sep = "."))
    names.sensnames <- t(matrix(1:length(sensnames), nrow = length(names), ncol = length(pars)))
    sensnames.deriv <- match(sensnames, colnames(deriv))
    derivnameIndex <- matrix(sensnames.deriv[names.sensnames[, data.name]], ncol = length(data.name))
    deriv.prediction <- do.call(rbind, lapply(1:nrow(data), function(i) submatrix(deriv, timeIndex[i], derivnameIndex[, i])))
    colnames(deriv.prediction) <- pars
    deriv.data <- data.frame(time = data$time, name = data$name, deriv.prediction)
  }
  if (any(is.na(data$sigma)) & is.null(err))
    stopIQR("In data, some sigmas are NA and no errmodel exists for the respective condition. Please fix data$sigma or supply errmodel.")
  sNAIndex <- is.na(data$sigma)
  if (!any(sNAIndex))
    err <- NULL 
  if (!is.null(err)) {
    time.err <- match.num(times, err[,1])
    name.err <- match(names, colnames(err))
    timeIndex <- time.err[data.time]
    nameIndex <- name.err[data.name]
    errprediction <- sapply(1:nrow(data), function(i) err[timeIndex[i], nameIndex[i]])
    if (any(sNAIndex & is.na(errprediction)))
      stopIQR("errmodel predicts NA for some observables with is.na(data$sigma).")
    data$sigma[sNAIndex] <- errprediction[sNAIndex]
  }
  deriv.err <- attr(err, "deriv")
  deriv.err.data <- NULL
  if (!is.null(err) && !is.null(deriv.err)) {
    pars <- unique(unlist(lapply(strsplit(colnames(deriv.err)[-1], split = ".", fixed = TRUE), function(i) i[2])))
    sensnames <- as.vector(outer(names, pars, paste, sep = "."))
    names.sensnames <- t(matrix(1:length(sensnames), nrow = length(names), ncol = length(pars)))
    sensnames.deriv <- match(sensnames, colnames(deriv.err))
    derivnameIndex <- matrix(sensnames.deriv[names.sensnames[, data.name]], ncol = length(data.name))
    deriv.prediction <- do.call(rbind, lapply(1:nrow(data), function(i) submatrix(deriv.err, timeIndex[i], derivnameIndex[, i])))
    colnames(deriv.prediction) <- pars
    deriv.prediction[is.na(deriv.prediction)] <- 0
    deriv.prediction[!sNAIndex, ] <- 0 
    deriv.err.data <- data.frame(time = data$time, name = data$name, deriv.prediction)
  }
  data$value <- pmax(data$value, data$lloq)
  is.bloq <- data$value <= data$lloq
  residuals <- prediction - data$value
  weighted.residuals <- (prediction - data$value)/data$sigma
  weighted.0 <- prediction/data$sigma
  data[["prediction"]] <- prediction
  data[["residual"]] <- residuals
  data[["weighted.residual"]] <- weighted.residuals
  data[["weighted.0"]] <- weighted.0
  data[["bloq"]] <- is.bloq
  dMod_objframe(data, deriv = deriv.data, deriv.err = deriv.err.data)
}
dMod_objframe <- function(mydata, deriv = NULL, deriv.err = NULL) {
  mydata <- as.data.frame(mydata)
  correct.names <- c("time", "name", "value", "prediction",
                     "sigma", "residual", "weighted.residual", "bloq", "weighted.0") 
  ok <- all(correct.names %in% names(mydata))
  if (!ok) stopIQR("mydata does not have required names")
  out <- mydata[, correct.names]
  attr(out, "deriv") <- deriv
  attr(out, "deriv.err") <- deriv.err
  class(out) <- c("objframe", "data.frame")
  return(out)
}
#'@importFrom stats pnorm dnorm
dMod_nll_ALOQ <- function(nout,
                          derivs,
                          derivs.err,
                          opt.BLOQ = c("M3", "M4NM", "M4BEAL", "M1"),
                          opt.hessian = c(
                            ALOQ_part1 = TRUE,
                            ALOQ_part2 = TRUE,
                            ALOQ_part3 = TRUE
                          )) {
  wr <- nout$weighted.residual
  w0 <- nout$weighted.0
  s  <- nout$sigma
  obj <- sum(wr^2)
  if (!is.null(derivs.err))
    obj <- obj + sum(log(2*pi*s^2))
  if (opt.BLOQ %in% "M4BEAL")
    obj <- obj + 2 * sum(stats::pnorm(w0, log.p = TRUE))
  grad <- NULL
  hessian <- NULL
  if (!is.null(derivs) && nrow(derivs) > 0) {
    dxdp <- as.matrix(derivs[, -(1:2), drop = FALSE])
    dsdp <- 0 * dxdp
    if (!is.null(derivs.err))
      dsdp <- as.matrix(derivs.err[, -(1:2), drop = FALSE])
    dwrdp <- 1/s*dxdp - wr/s*dsdp
    dw0dp <- 1/s*dxdp - w0/s*dsdp
    dlogsdp <- (1/s)*dsdp 
    G_by_Phi <- function(w) exp(stats::dnorm(w, log = TRUE)- stats::pnorm(w, log.p = TRUE))
    grad <- as.vector(2*matrix(wr, nrow = 1) %*% dwrdp + 2*apply(dlogsdp,2, sum))
    if (opt.BLOQ %in% "M4BEAL")
      grad <- grad + as.vector((2 * matrix(G_by_Phi(w0), nrow = 1)) %*% (dw0dp))
    names(grad) <- colnames(dxdp)
    hessian <- matrix(0, nrow = ncol(dwrdp), ncol = ncol(dwrdp), dimnames = list(colnames(dwrdp), colnames(dwrdp)))
    hessian <- hessian + 2 * t(dwrdp) %*% dwrdp 
    if (opt.hessian["ALOQ_part1"])  
      hessian <- hessian + 2 * (t(-wr/s^2 * dxdp) %*% dsdp + t(-wr/s^2 * dsdp) %*% dxdp) 
    if (opt.hessian["ALOQ_part2"])  
      hessian <- hessian + 2 * t(2 * wr^2/(s^2) * dsdp)%*%dsdp 
    if (opt.hessian["ALOQ_part3"]) 
      hessian <- hessian - 2 * t(dlogsdp) %*% dlogsdp
    if (opt.BLOQ %in% "M4BEAL") {
      hessian <- hessian + 2 * t((-w0 * G_by_Phi(w0) - G_by_Phi(w0)^2) * dw0dp) %*% dw0dp 
      hessian <- hessian + 2 * t(G_by_Phi(w0) * (-1)/(s^2) * dxdp ) %*% dsdp + 2 * t(G_by_Phi(w0) * (-1)/(s^2) * dsdp ) %*% dxdp 
      if (opt.hessian["ALOQ_part1"]) 
        hessian <- hessian + 2 * t(2 * G_by_Phi(w0) * w0/(s^2) * dsdp)%*%dsdp
    }
  }
  objlist(value = obj, gradient = grad, hessian = hessian)
}
#'@importFrom stats pnorm dnorm
dMod_nll_BLOQ <- function(nout.bloq,
                          derivs.bloq,
                          derivs.err.bloq,
                          opt.BLOQ = c("M3", "M4NM", "M4BEAL", "M1"),
                          opt.hessian = c(
                            BLOQ_part1 = TRUE,
                            BLOQ_part2 = TRUE,
                            BLOQ_part3 = TRUE
                          )) {
  if (opt.BLOQ %in% c("M4NM", "M4BEAL") & any(nout.bloq$value < 0))
    stopIQR("M4-Method cannot handle LLOQ < 0. Possible solutions:
      * Use M3 which allows negative LLOQ (recommended)
      * If you are working with log-transformed DV, exponentiate DV and LLOQ\n")
  wr <- nout.bloq$weighted.residual
  w0 <- nout.bloq$weighted.0
  s  <- nout.bloq$sigma
  if (opt.BLOQ == "M3"){
    objvals.bloq <- -2*stats::pnorm(-wr, log.p = TRUE)
  }
  if (opt.BLOQ %in% c("M4NM", "M4BEAL")){
    objvals.bloq <- -2*log(1 - stats::pnorm(wr) / stats::pnorm(w0))
    intercept = ifelse(log(w0-wr) > 0, 1.8, -1.9 * log(w0-wr) +0.9)
    lin = ifelse(log(w0-wr) > 0, 0.9, 0.5 )
    objvals.bloq[!is.finite(objvals.bloq)] <-  (intercept + lin * w0 + 0.95 * w0^2)[!is.finite(objvals.bloq)]
  }
  obj.bloq <- sum(objvals.bloq)
  grad.bloq <- NULL
  hessian.bloq <- NULL
  if (!is.null(derivs.bloq) && nrow(derivs.bloq) > 0){
    dxdp <- as.matrix(derivs.bloq[, -(1:2), drop = FALSE])
    dsdp <- 0 * dxdp
    if (!is.null(derivs.err.bloq))
      dsdp <- as.matrix(derivs.err.bloq[, -(1:2), drop = FALSE])
    dwrdp <- 1/s*dxdp - wr/s*dsdp
    dw0dp <- 1/s*dxdp - w0/s*dsdp
    dlogsdp <- (1/s)*dsdp 
    G_by_Phi <- function(w1, w2 = w1) exp(stats::dnorm(w1, log = TRUE) - stats::pnorm(w2, log.p = TRUE))
    if (opt.BLOQ == "M3"){
      grad.bloq <- -2 * as.vector(matrix( G_by_Phi(-wr), nrow = 1) %*% (-dwrdp)) 
    }
    if (opt.BLOQ %in% c("M4NM", "M4BEAL")){
      grad.bloq <-             as.vector(matrix(2 / (1/G_by_Phi(wr,w0) - 1/G_by_Phi(wr,wr)), nrow = 1) %*% dwrdp)
      grad.bloq <- grad.bloq - as.vector(matrix(2 / (1/G_by_Phi(w0,w0) - 1/G_by_Phi(w0,wr)), nrow = 1) %*% dw0dp)
      grad.bloq <- grad.bloq + as.vector(matrix(2 * G_by_Phi(w0), nrow = 1) %*% dw0dp)
    }
    names(grad.bloq) <- colnames(dxdp)
    if (opt.BLOQ %in% "M3") {
      hessian.bloq <- matrix(0, nrow = ncol(dxdp), ncol = ncol(dxdp), dimnames = list(colnames(dxdp), colnames(dxdp)))
      if (opt.hessian["BLOQ_part1"])
        hessian.bloq <- hessian.bloq + 2 * t((-wr * G_by_Phi(-wr) + G_by_Phi(-wr)^2) * dwrdp) %*% dwrdp 
      if (opt.hessian["BLOQ_part2"]){
        hessian.bloq <- hessian.bloq - 2 * t(G_by_Phi(-wr) * (+1)/(s^2) * dxdp) %*% dsdp 
        hessian.bloq <- hessian.bloq - 2 * t(G_by_Phi(-wr) * (+1)/(s^2) * dsdp) %*% dxdp
      }
      if (opt.hessian["BLOQ_part3"])
        hessian.bloq <- hessian.bloq - 2 *  t(G_by_Phi(-wr) * (2 * (-wr))/(s^2) * dsdp)%*%dsdp
    }
    if (opt.BLOQ %in% c("M4NM", "M4BEAL")) {
      d_dp_sq <- function(A, w = wr, sign = 1) {
        dwdp <- 1/s*dxdp - w/s*dsdp
        out <- matrix(0, nrow = ncol(dxdp), ncol = ncol(dxdp), dimnames = list(colnames(dxdp), colnames(dxdp)))
        out <- out + t(A * dwdp) %*% dwdp
      }
      d2_dp2 <- function(A, w = wr, sign = 1) {
        out <- matrix(0, nrow = ncol(dxdp), ncol = ncol(dxdp), dimnames = list(colnames(dxdp), colnames(dxdp)))
        out <- out + t(A * (-1*sign)/(s^2) * dxdp) %*% dsdp
        out <- out + t(A * (-1*sign)/(s^2) * dsdp) %*% dxdp
        out <- out + t(A * (2 * (w*sign))/(s^2) * dsdp) %*% dsdp
      }
      stable <- function(wn, w0, wr) {
        if(!(identical(wn, w0) | identical(wn, wr)))
          stopIQR("The first argument wn needs to be identical to either the second or third")
        out <- stats::dnorm(wn)/(stats::pnorm(w0)-stats::pnorm(wr))
        if (identical(wn, w0)){
          out[is.infinite(out)] <- 0
          return(out)
        }
        if (identical(wn, wr)){
          out[is.infinite(out)] <- 1/(w0-wr) + wr 
          return(out)
        }
      }
      part1 <- d_dp_sq(-wr * stable(wr,w0,wr)) +
        d2_dp2(stable(wr,w0,wr)) -
        (d_dp_sq(-w0 * stable(w0,w0,wr), w = w0) +
           d2_dp2(stable(w0,w0,wr), w = w0))
      part1 <- 2 * part1
      part2 <- stable(wr,w0,wr) * dwrdp - stable(w0,w0,wr) * dw0dp
      part2 <- -2 * t(part2) %*% part2
      part3 <- d_dp_sq(-w0 * G_by_Phi(w0) - (G_by_Phi(w0))^2, w = w0) + d2_dp2(G_by_Phi(w0), w = w0)
      part3 <- 2 * part3
      hessian.bloq <- matrix(0, nrow = ncol(dxdp), ncol = ncol(dxdp), dimnames = list(colnames(dxdp), colnames(dxdp)))
      if (opt.hessian["BLOQ_part1"])
        hessian.bloq <- hessian.bloq + part1
      if (opt.hessian["BLOQ_part2"])
        hessian.bloq <- hessian.bloq + part2
      if (opt.hessian["BLOQ_part3"])
        hessian.bloq <- hessian.bloq + part3
    }
  }
  out <- objlist(value = obj.bloq, gradient = grad.bloq, hessian = hessian.bloq)
  return(out)
}
dMod_normL2_indiv <- function(data, prd, errmodel = NULL, fixed.grid, est.grid,
                              SIMOPT.nauxtimes = 500, SIMOPT.cores = 1, opt.method = "trust",
                              attr.name = "data") {
  x.conditions__ <- fixed.grid[["ID"]]
  data.conditions__ <- names(data)
  if (!all(data.conditions__ %in% x.conditions__))
    stopIQR("The prediction function does not provide predictions for all conditions in the data.")
  timesD <- sort(unique(c(0, do.call(c, lapply(data, function(d) d$time)))))
  timesD <- sort(union(timesD, seq(min(timesD), max(timesD), length.out = SIMOPT.nauxtimes)))
  controls <- list(timesD = timesD, attr.name = attr.name, conditions = x.conditions__)
  force(errmodel)
  e.conditions__ <- names(attr(errmodel, "mappings"))
  force(fixed.grid)
  force(est.grid)
  if (Sys.info()["sysname"] == "Windows" & SIMOPT.cores > 1) {
    warningIQR("Parallelization of conditions on Windows not yet implemented. Unsing only 1 core.")
    SIMOPT.cores <- 1
  }
  useDerivs <- ifelse(opt.method %in% "trust", TRUE, FALSE)
  opt.BLOQ = c("M3", "M4NM", "M4BEAL", "M1")
  opt.hessian = c(
    ALOQ_part1 = TRUE, ALOQ_part2 = TRUE, ALOQ_part3 = TRUE,
    BLOQ_part1 = TRUE, BLOQ_part2 = TRUE, BLOQ_part3 = TRUE,
    PD = TRUE  
  )
  controls <- c(controls, list(opt.BLOQ = opt.BLOQ, opt.hessian = opt.hessian)  )
  myfn__ <- function(..., fixed = NULL, deriv=useDerivs, conditions = controls$conditions, env = NULL,
                     opt.BLOQ    = controls$opt.BLOQ,
                     opt.hessian = controls$opt.hessian) {
    opt.hessian0 <- c(
      ALOQ_part1 = TRUE, ALOQ_part2 = TRUE, ALOQ_part3 = TRUE,
      BLOQ_part1 = TRUE, BLOQ_part2 = TRUE, BLOQ_part3 = TRUE,
      PD = FALSE 
    )
    opt.hessian <- c(opt.hessian, opt.hessian0[setdiff(names(opt.hessian0), names(opt.hessian))])
    opt.BLOQ    <- opt.BLOQ[1]
    arglist__    <- list(...)
    arglist__    <- arglist__[match.fnargs(arglist__, "pars")]
    pouter__     <- arglist__[[1]]
    fixedouter__ <- fixed
    if (!is.null(attr(pouter__, "deriv"))){
      pouter__ <- unclass(pouter__)
      attr(pouter__, "deriv") <- NULL
    }
    outlist__ <- parallel::mclapply(conditions, function(cn__) {
      fixed <- fixedouter__
      pars_from_grid__ <- dMod_make_pars(c(pouter__, fixed), cn__, est.grid, prd)
      fixed_from_grid__ <- dMod_make_fixed(cn__, fixed.grid, prd)
      pars <- pars_from_grid__[!(names(pars_from_grid__) %in% names(fixed))]
      fixed <- c(fixed_from_grid__, fixed)
      cn_prd__ <- intersect(cn__, getConditions(prd))
      if (length(cn_prd__) == 0 & !is.null(cn_prd__)) {
        cn_prd__ <- getConditions(prd)[1]
        warningIQR("Condition ", cn__, " not provided with prd. Used first condition of prd instead.")
      }
      prediction <- prd(times = controls$timesD, pars = pars, fixed = fixed, deriv = deriv, conditions = cn_prd__)
      if (nrow(prediction[[1]]) < length(timesD))
        warningIQR("Integrator has problems reaching tmax. Try increasing SIMOPT.nauxtimes")
      if (length(intersect(data[[cn__]][["name"]], colnames(prediction[[1]]))) == 0){
        mywrss__ <- dMod_init_empty_objlist(pars, deriv = deriv)
        mywrss__ <- dMod_rename_objlist(mywrss__, cn__, est.grid)
        return(mywrss__)
      }
      err <- NULL
      if ((!is.null(errmodel) & is.null(e.conditions__)) | (!is.null(e.conditions__) && (cn__ %in% e.conditions__)))
        err <- errmodel(out = prediction[[1]], pars = getParameters(prediction[[1]]), conditions = cn__)
      nout <- dMod_res(data[[cn__]], prediction[[1]], err[[cn__]])
      is.bloq <- nout$bloq
      nout.bloq <- nout[is.bloq, , drop = FALSE]
      nout <- nout[!is.bloq, , drop = FALSE]
      derivs <- derivs.err <- derivs.bloq <- derivs.err.bloq <- NULL
      derivs <- attr(nout, "deriv")
      derivs.err <- attr(nout, "deriv.err")
      if (!is.null(derivs) ) {
        derivs.bloq <- derivs[is.bloq, , drop = FALSE]
        derivs <- derivs[!is.bloq, , drop = FALSE]
      }
      if (!is.null(derivs.err)) {
        derivs.err.bloq <- derivs.err[is.bloq, , drop = FALSE]
        derivs.err <- derivs.err[!is.bloq, , drop = FALSE]
      }
      mywrss__ <- dMod_init_empty_objlist(pars, deriv = deriv)
      if (!all(is.bloq))
        mywrss__ <- mywrss__ + dMod_nll_ALOQ(nout, derivs, derivs.err, opt.BLOQ = opt.BLOQ, opt.hessian = opt.hessian)
      if (any(is.bloq) && (!opt.BLOQ == "M1")){
        mydMod_wrss_BLOQ <- dMod_nll_BLOQ(nout.bloq, derivs.bloq, derivs.err.bloq, opt.BLOQ = opt.BLOQ, opt.hessian = opt.hessian)
        mywrss__ <- mywrss__ + mydMod_wrss_BLOQ
      }
      mywrss__ <- dMod_rename_objlist(mywrss__, cn__, est.grid)
      return(mywrss__)
    }, mc.cores = SIMOPT.cores)
    failed__ <- sapply(outlist__, is.character)
    if (all(!failed__)) {
      msg__ <- "OK: Evaluation of objective function successful for all IDs\n"
    } else if (all(failed__)) {
      msg__ <- "FAILED: Evaluation of objective function failed for all IDs\n"
    } else {
      msg__ <- paste0("FAILED: Objective function could not be evaluated for the following IDs: ", paste(conditions[failed__], collapse = ", "), "\n")
    }
    cat(msg__, file = "project_obj.log", append = TRUE)
    outlist__ <- outlist__[!failed__]
    if (length(outlist__) == 0)
      stopIQR("Objective function could not be evaluated for any of the conditions.")
    values__    <- lapply(outlist__, function(x__) x__[["value"]]+1e6*sum(failed__))
    gradients__ <- lapply(outlist__, function(x__) x__[["gradient"]])
    hessians__  <- lapply(outlist__, function(x__) x__[["hessian"]])
    out__ <- dMod_init_empty_objlist(pouter__, deriv = deriv)
    out__[["value"]] <- Reduce("+", values__)
    if (deriv) {
      for (grad in gradients__) out__$gradient[names(grad)] <- out__$gradient[names(grad)] + grad
      for (hes in hessians__)   out__$hessian[rownames(hes), colnames(hes)] <- out__$hessian[rownames(hes), colnames(hes)] + hes
    }
    nearPD2__ <- function (x, corr = FALSE){
      X__ <- 0.5*(x+t(x))
      e__ <- eigen(X__)
      eV__ <- e__$values
      if (min(eV__) > 0) return(X__)
      eV__[eV__<0] <- 0
      const__ <- length(eV__)
      Xout__ <- e__$vectors %*% diag(eV__) %*% (ginv(e__$vectors*const__)*const__)
      if (corr) diag(Xout__) <- 1
      return(Xout__)
    }
    if (opt.hessian["PD"] & deriv) {
      poshessian__ <- try(nearPD2__(out__$hessian), silent = TRUE)
      if (!inherits(poshessian__, "try-error")) {
        out__$hessian <- structure(nearPD2__(out__$hessian), dimnames = dimnames(out__$hessian))
      }
    }
    attr(out__, controls$attr.name) <- out__$value
    return(out__)
  }
  class(myfn__) <- c("objfn", "fn")
  attr(myfn__, "conditions") <- data.conditions__
  attr(myfn__, "parameters") <- attr(prd, "parameters")
  attr(myfn__, "modelname") <- modelname(prd, errmodel)
  return(myfn__)
}
dMod_PRD_indiv <- function(prd, fixed.grid, est.grid) {
  prd_conditions <- as.character(fixed.grid$ID)
  if (length(prd_conditions) == 0)
    stopIQR("fixed.grid must contain ID column for conditions")
  P2X_indiv__ <- function(..., fixed = NULL, deriv = FALSE, conditions = prd_conditions) {
    arglist__ <- list(...)
    arglist__ <- arglist__[match.fnargs(arglist__, c("times", "pars"))]
    times <- arglist__[[1]]
    pouter__ <- arglist__[[2]]
    fixedouter__ <- fixed
    if (!is.null(attr(pouter__, "deriv"))){
      pouter__ <- unclass(pouter__)
      attr(pouter__, "deriv") <- NULL
    }
    if (is.null(conditions))
      conditions <- prd_conditions
    if (!is.null(conditions) & !is.null(prd_conditions))
      conditions <- intersect(conditions, prd_conditions)
    prediction <- lapply(conditions, function(cn__) {
      fixed <- fixedouter__
      pars_from_grid__ <- dMod_make_pars(c(pouter__, fixed), cn__,est.grid, prd)
      fixed_from_grid__ <- dMod_make_fixed(cn__, fixed.grid, prd)
      pars <- pars_from_grid__[!(names(pars_from_grid__) %in% names(fixed))]
      fixed <- c(fixed_from_grid__, fixed)
      cn_prd__ <- intersect(cn__, getConditions(prd))
      if (length(cn_prd__) == 0 & !is.null(cn_prd__)) {
        cn_prd__ <- getConditions(prd)[1]
        warningIQR("Condition ", cn__, " not provided with prd. Used first condition of prd instead.")
      }
      pred_cn <- try(prd(times = times, pars = unclass(pars), fixed = fixed, deriv = deriv, conditions = cn_prd__)[[1]])
      if (inherits(pred_cn, "try-error")) warningIQR("\n\n********Problem encountered while simulating ID ", cn__ ,".********\n\n\n")
      pred_cn
    })
    prediction <- as.prdlist(prediction, names = conditions)
    return(prediction)
  }
  attr(P2X_indiv__, "modelname") <- modelname(prd)
  attr(P2X_indiv__, "parameters") <- getSymbols(unlist(est.grid[!names(est.grid)%in%c("ID", "CONDITION")]))
  attr(P2X_indiv__, "conditions") <- prd_conditions
  class(P2X_indiv__) <- c("prdfn", "fn")
  return(P2X_indiv__)
}
dMod_P_indiv <- function(p, fixed.grid, est.grid) {
  p_conditions__ <- as.character(fixed.grid$ID)
  if (length(p_conditions__) == 0)
    stopIQR("fixed.grid must contain ID column for conditions")
  P2P_indiv__ <- function(..., fixed = NULL, deriv = FALSE, conditions = p_conditions__) {
    arglist__ <- list(...)
    arglist__ <- arglist__[match.fnargs(arglist__, c("pars"))]
    pouter__ <- arglist__[[1]]
    fixedouter__ <- fixed
    if (!is.null(attr(pouter__, "deriv"))){
      pouter__ <- unclass(pouter__)
      attr(pouter__, "deriv") <- NULL
    }
    pinner__ <- NULL
    for (cn__ in conditions) {
      fixed <- fixedouter__
      pars_from_grid__ <- dMod_make_pars(c(pouter__, fixed), cn__, est.grid, p)
      fixed_from_grid__ <- dMod_make_fixed(cn__, fixed.grid, p)
      pars <- pars_from_grid__[!(names(pars_from_grid__) %in% names(fixed))]
      fixed <- c(fixed_from_grid__, fixed)
      cn_p__ <- NULL
      if (length(getConditions(p)) > 1) {
        warningIQR("p contains more than one condition, only the first is used")
        cn_p__ <- getConditions(p)[1]
      }
      pinner__ <- c(pinner__, try(stats::setNames(p(pars = pars, fixed = fixed, deriv = deriv, conditions = cn_p__),
                                                  nm = cn__)))
    }
    return(pinner__)
  }
  attr(P2P_indiv__, "parameters") <- getSymbols(unlist(est.grid[!names(est.grid)%in%c("ID", "CONDITION")]))
  attr(P2P_indiv__, "conditions") <- p_conditions__
  class(P2P_indiv__) <- c("parfn", "fn")
  return(P2P_indiv__)
}
dMod_build_LOC.grids <- function(myNlmeEst__, IDCOND.grid) {
  all_conditions <- unique(c(myNlmeEst__$modelSpec$CONDITIONS, IDCOND.grid$CONDITION))
  filled_LOC_fields__ <- dMod_fill_LOC_fields(myNlmeEst__)
  myNlmeEst__$modelSpec[names(filled_LOC_fields__)] <- filled_LOC_fields__
  LOCmodel__ <- myNlmeEst__$modelSpec$LOCmodel
  LOCvalues0 <- myNlmeEst__$modelSpec$LOCvalues0[names(LOCmodel__)]
  LOCestimate__ <- myNlmeEst__$modelSpec$LOCestimate[names(LOCmodel__)]
  LOCparameters__ <- myNlmeEst__$modelSpec$LOCparameters[names(LOCmodel__)]
  fixed.grid_LOC__ <- Reduce(merge, mapply(function(parameter, LV, LE, IDCOND.grid) {
    IDCOND.grid <- cbind(IDCOND.grid, LV[IDCOND.grid$CONDITION], stringsAsFactors = FALSE)
    names(IDCOND.grid)[3] <- parameter
    IDCOND.grid[[3]][LE[IDCOND.grid$CONDITION] == 1] <- NA
    return(IDCOND.grid)
  }, parameter = names(LOCmodel__), LV = LOCvalues0, LOCestimate__, MoreArgs = list(IDCOND.grid =IDCOND.grid), SIMPLIFY = FALSE))
  est.grid_LOC__ <- Reduce(merge, mapply(function(parameter, LP, LE, IDCOND.grid) {
    IDCOND.grid <- cbind(IDCOND.grid, LP[IDCOND.grid$CONDITION], stringsAsFactors = FALSE)
    names(IDCOND.grid)[3] <- parameter
    IDCOND.grid[[3]][LE[IDCOND.grid$CONDITION] == 0] <- NA
    return(IDCOND.grid)
  }, parameter = names(LOCmodel__), LP = LOCparameters__, LOCestimate__, MoreArgs = list(IDCOND.grid =IDCOND.grid), SIMPLIFY = FALSE))
  est.vec_LOC__ <- Reduce(c, mapply(function(LV, LP, LE) {
    stats::setNames(LV, LP)[LE == 1]
  }, LV = LOCvalues0, LP = LOCparameters__, LE = LOCestimate__, SIMPLIFY = FALSE))
  est.vec_LOC__ <- est.vec_LOC__[!duplicated(names(est.vec_LOC__))]
  out__ <- list(fixed.grid_LOC = fixed.grid_LOC__,
                est.grid_LOC   = est.grid_LOC__,
                est.vec_LOC    = est.vec_LOC__)
  return(out__)
}
dMod_expand_cat <- function(condition.grid, catName, catValues, ref) {
  if (any(grepl("[ /()+-]", as.character(catValues))))
    stopIQR(paste0("The levels", grep("[ /()]", as.character(catValues)), "of categorical variable", catName, "contains unallowed symbols"))
  catValues_wo_ref__ <- catValues[!catValues==ref]
  aux_pars__ <- paste0(catName, "_", catValues_wo_ref__)
  named_indices__ <- stats::setNames(seq_along(aux_pars__), aux_pars__)
  aux_cols <- lapply(named_indices__, function(i) {
    as.integer(condition.grid[[catName]] == catValues[!catValues == ref][i])
  })
  aux_cols <- do.call(cbind, aux_cols)
  out__ <- cbind(condition.grid[names(condition.grid) != catName], aux_cols)
  aux_cols_old__ <- attr(condition.grid, "aux_cols")
  aux_cols_attr__ <- c(attr(condition.grid, "aux_cols"), colnames(aux_cols))
  attr(out__, "aux_cols") <- c(aux_cols_old__, list(aux_cols_attr__))
  levels_mapping_old__ <- attr(condition.grid, "levels_mapping")
  levels_mapping <- do.call(c, lapply(as.list(as.data.frame(aux_cols)), function(.x) {condition.grid[[catName]][as.logical(.x)]}))
  attr(out__, "levels_mapping") <- c(levels_mapping_old__, list(levels_mapping))
  return(out__)
}
dMod_cov_multiplier <- function(cov, ref, to_which, scale = c("L", "N", "G")) {
  if (scale == "N")
    return(paste0("(", "log(", cov , " / ", ref, ") * beta_", to_which, "_", cov,")"))
  if (scale != "N")
    return(paste0("(", "log(", cov , " / ", ref, ") * beta_", to_which, "_", cov,")"))
}
dMod_cat_multiplier <- function(cat, catValues, ref, to_which, scale = c("L", "N", "G")) {
  catValues_wo_ref__ <- catValues[!catValues==ref]
  cov_pars__ <- paste0(cat, "_", catValues_wo_ref__)
  beta_pars__ <- paste0("beta", "_", to_which, "_", cov_pars__)
  if (scale == "N")
    return(paste(paste0("(", beta_pars__, " * ", cov_pars__, ")"), collapse = " + "))
  if (scale != "N")
    return(paste(paste0("(", beta_pars__, " * ", cov_pars__, ")"), collapse = " + "))
}
dMod_get_fixed_betas <- function(COVestimate, covNames, covariateModelValues, catNames, catValues, covariateCATreference) {
  do.call(c, lapply(seq_along(COVestimate), function(i) {
    is_fixed__ <- (COVestimate[[i]] == 0)
    if (sum(is_fixed__) == 0)
      return(NULL)
    to_which <- names(COVestimate)[i]
    fixed_covariates__ <- names(COVestimate[[i]])[is_fixed__]
    cov <- do.call(c, lapply(fixed_covariates__[fixed_covariates__%in%covNames], function(mycov) {
      cov_value__ <- covariateModelValues[[i]][mycov]
      names(cov_value__) <- paste0("beta_", to_which, "_", mycov)
      return(cov_value__) }))
    cat <- do.call(c, lapply(fixed_covariates__[fixed_covariates__%in%catNames], function(mycov) {
      cat_value__ <- covariateModelValues[[i]][mycov]
      cat_ref__ <- covariateCATreference[mycov]
      if (length(catValues[[mycov]])>2)
        stopIQR("Fixing betas of categorical variables with more than two categroies are not yet implemented") 
      names(cat_value__) <- paste0("beta_", to_which, "_", mycov, "_", setdiff(catValues[[mycov]], cat_ref__))
      return(cat_value__)}))
    return(c(cov, cat))
  }))
}
dMod_get_default_betas <- function(myNlmeEst__, cov_trafo) {
  fixed_betas__ <- attr(cov_trafo, "fixed")
  covdefaultsALL__ <- unlist(lapply(names(myNlmeEst__$modelSpec$covariateModelValues), function(n__) {
    values__ <- myNlmeEst__$modelSpec$covariateModelValues[[n__]]
    names(values__) <- paste("beta", n__, names(values__), sep = "_")
    return(values__)
  }))
  covdefaults__ <- covdefaultsALL__[!duplicated(names(covdefaultsALL__))]
  covdefaults__ <- covdefaults__[sapply(names(covdefaults__), function(n__) !any(grepl(paste0("^", n__), names(fixed_betas__))))]
  if (length(covdefaults__) == 0) return()
  possible_covpars_regex__ <- paste0("(", paste0(names(covdefaults__), collapse = "|"), "|", paste0(paste0(names(covdefaults__), "_[1-9]+$"), collapse = "|"), ")")
  covparnames__ <- getSymbols(cov_trafo)[grepl(possible_covpars_regex__, getSymbols(cov_trafo))]
  index__ <- match(sub("_[1-9]+$", "", covparnames__), names(covdefaults__))
  betas__ <- covdefaults__[index__]
  names(betas__) <- covparnames__
  return(betas__)
}
dMod_build_covcat_trafo <- function(myNlmeEst__) {
  covariateModel__        <- myNlmeEst__$modelSpec$covariateModel
  COVestimate             <- myNlmeEst__$modelSpec$COVestimate
  covariateModelValues    <- myNlmeEst__$modelSpec$covariateModelValues
  covNames                <- myNlmeEst__$data$covNames
  covariateMedianValues__ <- myNlmeEst__$data$covariateMedianValues
  covariateMedianValues__[intersect(covNames, names(myNlmeEst__$modelSpec$COVcentering))] <-
    myNlmeEst__$modelSpec$COVcentering[intersect(covNames, names(myNlmeEst__$modelSpec$COVcentering))]
  catNames                <- myNlmeEst__$data$catNames
  covariateCATreference__ <- myNlmeEst__$data$covariateCATreference
  covariateCATreference__[intersect(catNames, names(myNlmeEst__$modelSpec$COVcentering))] <-
    myNlmeEst__$modelSpec$COVcentering[intersect(catNames, names(myNlmeEst__$modelSpec$COVcentering))]
  catValues               <- myNlmeEst__$data$catValues
  cov_trafo <- vapply(names(covariateModel__), function(mypar) {
    scale <- myNlmeEst__$modelSpec$IIVdistribution[mypar]
    cov_expressions__ <- vapply(covariateModel__[[mypar]], function(mycov) {
      if(mycov %in% covNames)
        return(dMod_cov_multiplier(cov = mycov,
                                   ref = covariateMedianValues__[mycov],
                                   to_which = mypar,
                                   scale = scale))
      if (mycov %in% catNames) {
        return(dMod_cat_multiplier(cat = mycov,
                                   catValues = catValues[[mycov]],
                                   ref = covariateCATreference__[mycov],
                                   to_which = mypar,
                                   scale = scale))
      }
    }, FUN.VALUE = "")
    separator__ <- switch(scale, L = " + ", G = " + ", N = " + ")
    mytrafo__ <- paste(mypar, paste0(cov_expressions__, collapse = separator__), sep = separator__)
    if (scale == "N")
      mytrafo__ <- paste0("(", mytrafo__, ")")
    if (scale == "L")
      mytrafo__ <- paste0("exp(", mytrafo__, ")")
    if (scale == "G")
      mytrafo__ <- paste0("exp(", mytrafo__, ") / (1 + exp(", mytrafo__, "))")
    return(mytrafo__)
  }, FUN.VALUE = "")
  names(cov_trafo) <- names(covariateModel__)
  fixed_beta_pars__ <- dMod_get_fixed_betas(COVestimate, covNames, covariateModelValues, catNames, catValues, covariateCATreference__)
  attr(cov_trafo, "fixed") <- fixed_beta_pars__
  return(cov_trafo)
}
dMod_handle_default_options <- function(OPT, SIMOPT) {
  SIMOPT0__ <- list(
    SIMOPT.method    = "lsodes",
    SIMOPT.atol      = 1e-6,
    SIMOPT.rtol      = 1e-6,
    SIMOPT.hmin      = 0,
    SIMOPT.hmax      = 10000,
    SIMOPT.hini      = 0,
    SIMOPT.maxsteps  = 5000,
    SIMOPT.nauxtimes = 0,
    SIMOPT.cores     = 1
  )
  OPT0__ <- list(
    opt.method = "trust",
    opt.nfits = 10,
    opt.sd = 1,
    opt.rinit = 1,
    opt.rmax = 10,
    opt.iterlim = 100,
    opt.prior_sigma = 10,
    opt.parlower = -Inf,
    opt.parupper = Inf
  )
  if (length(c(setdiff(names(OPT), names(OPT0__)),setdiff(names(SIMOPT), names(SIMOPT0__)))))
    stopIQR("Unkown options: ", paste0(c(setdiff(names(OPT), names(OPT0__)),setdiff(names(SIMOPT), names(SIMOPT0__))), collapse = ", "),
         "\n Please add these to dMod_handle_default_options()")
  OPT0__[names(OPT)] <- OPT
  SIMOPT0__[names(SIMOPT)] <- SIMOPT
  return(list(OPT = OPT0__, SIMOPT = SIMOPT0__))
}
dMod_check_mstrust_results <- function(mymodel, opt.parlower, opt.parupper) {
  myparframe__ <- mymodel$parframes[[1]]
  mybestfit__  <- unclass(mymodel$bestfit[[1]])
  myparlower__ <- opt.parlower
  myparupper__ <- opt.parupper
  less_than_10_percent_converged__ <- sum(myparframe__$converged) < floor(0.1*nrow(myparframe__))
  is_converged_bestfit__ <- myparframe__$converged[1]
  on_lower_boundary_bestfit__ <- abs(myparlower__ - mybestfit__[names(myparlower__)]) < sqrt(.Machine$double.eps)
  on_lower_boundary_bestfit__ <- on_lower_boundary_bestfit__[!is.na(on_lower_boundary_bestfit__)]
  if (length(on_lower_boundary_bestfit__) == 0 || all(!on_lower_boundary_bestfit__)) on_lower_boundary_bestfit__ <- NULL
  on_upper_boundary_bestfit__ <- abs(myparupper__ - mybestfit__[names(myparupper__)]) < sqrt(.Machine$double.eps)
  on_upper_boundary_bestfit__ <- on_upper_boundary_bestfit__[!is.na(on_upper_boundary_bestfit__)]
  if (length(on_upper_boundary_bestfit__) == 0 || all(!on_upper_boundary_bestfit__)) on_upper_boundary_bestfit__ <- NULL
  checks__ <- list(less_than_10_percent_converged = less_than_10_percent_converged__,
                   is_converged_bestfit      = is_converged_bestfit__,
                   on_lower_boundary_bestfit = on_lower_boundary_bestfit__,
                   on_upper_boundary_bestfit = on_upper_boundary_bestfit__)
  return(checks__)
}
dMod_appendLowerOmega <- function(mymodel, opt.omega_min) {
  lower_omega__ <- with(mymodel[["parameters"]][[1]], {
    has_omega__ <- names(IIVestimate)[IIVestimate == 1]
    if (length(has_omega__) == 0 )
      return(NULL)
    out__ <- structure(rep(log(opt.omega_min), length(has_omega__)), names = has_omega__)
    names(out__) <- paste0("omega_", names(out__))
    return(out__)
  })
  mymodel$lower_omega <- list(lower_omega__)
  return(mymodel)
}
#'@export
dMod_nlmeEst2dModFrame <- function(est,
                                   algOpt.SEED = 12345,
                                   ...) {
  options__ <- c(list(...), list(algOpt.SEED = algOpt.SEED))
  SIMOPT__ <- options__[grepl("^SIMOPT\\.", names(options__))]
  OPT__ <- options__[grepl("^opt\\.", names(options__))]
  SIMOPT__ <- dMod_handle_default_options(OPT__, SIMOPT__)$SIMOPT
  OPT__ <- dMod_handle_default_options(OPT__, SIMOPT__)$OPT
  cat("Convert data to dMod ...... ")
  datanames__ <- stats::setNames(nm = c("datafile", "catNames", "covNames", "regressorNames"))
  data__ <- lapply(datanames__, function(i) est$data[[i]])
  data__[["inputs"]] <- max(1, length(est[["model"]][["inputs"]])) 
  data__$datafile <- file.path(est$data$relPathFromProject, est$data$fileName)
  my_dMod_data__ <- do.call(convert2dMod_IQRdata, data__)
  cat("done. \n")
  cat("Convert model to basic dMod model ..... ")
  FLAGderiv__ <- ifelse(OPT__[["opt.method"]] %in% "trust", TRUE, FALSE)
  basic_dMod_model__ <- convert2dMod_IQRmodel(est = est,
                                              my_dMod_data = my_dMod_data__,
                                              options = SIMOPT__,
                                              FLAGderiv = FLAGderiv__)
  cat("done. \n")
  cat("Link basic dMod model to data ...... ")
  mymodel <- combine_model_and_data(basic_dMod_model__,
                                    my_dMod_data__,
                                    est,
                                    SIMOPT.nauxtimes = SIMOPT__[["SIMOPT.nauxtimes"]],
                                    SIMOPT.cores = SIMOPT__[["SIMOPT.cores"]])
  cat("done. \n")
  mymodel <- dplyr::mutate(mymodel, constr_fit = list(NULL))
  if (!is.null(OPT__[["opt.prior_sigma"]])) {
    mu__ <- mymodel[["pars"]][[1]]
    mu__ <- mu__[!grepl("^(omega|ETA)", names(mu__))]
    mymodel <- dplyr::mutate(mymodel,
                             constr_fit = list(constraintL2(mu__, sigma = OPT__[["opt.prior_sigma"]])),
                             obj = list(obj + constr_fit))
  }
  startpars__ <- msParframe(mymodel$pars[[1]], n = OPT__[["opt.nfits"]], seed = algOpt.SEED, sd = OPT__[["opt.sd"]])
  mymodel <- dplyr::mutate(mymodel, startpars = list(startpars__))
  mymodel <- dplyr::mutate(mymodel, options = list(options__))
  .so__ <- .Platform$dynlib.ext
  modelnames__ <- Reduce(union, lapply(unlist(mymodel, FALSE), function(i) {if (inherits(i, "fn")) return(modelname(i))}))
  modelnames__ <- paste0(modelnames__, .so__)
  mymodel <- dplyr::mutate(mymodel, dllpaths = list(modelnames__), dllfolder = list(tempdirIQR()))
  args0.est__ <- attr(est, "args0")
  args0__ <- list()
  args0__[["Scenario"]] <- args0.est__[["Scenario"]]
  sysModelEst__ <- list()
  sysModelEst__[["model"]]              <- args0.est__[["model"]]
  sysModelEst__[["dosing"]]             <- args0.est__[["dosing"]]
  sysModelEst__[["data"]]               <- args0.est__[["data"]]
  sysModelEst__[["estSpec"]]            <- args0.est__[["estSpec"]]
  sysModelEst__[["modelSpec"]]          <- args0.est__[["modelSpec"]]
  sysModelEst__[["parsOfInterest"]]     <- args0.est__[["parsOfInterest"]]
  sysModelEst__[["data"]][["datafile"]] <- est$data$datafile
  sysModelEst__[["est"]]                <- est
  sysModelEst__[["IQRsysData"]]         <- import_IQRsysData(est$data$datafile)
  attr(mymodel, "args0")       <- args0__
  attr(mymodel, "sysModelEst") <- sysModelEst__
  class(mymodel) <- unique(c("IQRsysModel", class(mymodel)))
  return(mymodel)
}
#'@export
dMod_sysProject_computations <- function(mymodel, ncores, FLAGrequireConverged = TRUE, FLAGkeepFits = FALSE, FLAGchecks = TRUE, FLAGprofileLL = FALSE) {
  loadedPackages__ <- .packages()
  if (ncores > 1 & any(c("RevoUtils", "RevoUtilsMath") %in% loadedPackages__))
    stopIQR("Loaded packages RevoUtils/RevoUtilsMath can cause problems with IQRtools when running with ncores > 1. Please unload with\n",
         "    detach('package:RevoUtils', unload=TRUE)\n",
         "    detach('package:RevoUtilsMath', unload=TRUE)\n",
         "before continuing.")
  SIMOPT.cores <- mymodel[["options"]][[1]][["SIMOPT.cores"]]
  if (SIMOPT.cores > 1 & ncores > 1) {
    ncores <- 1
    warningIQR("When SIMOPT.cores > 1, fits cannot be parallelized. Argument ncores has been changed to 1.")
  }
  myattributes__ <- attributes(mymodel)
  partable__ <- mymodel[["IQRpartable"]][[1]]
  pars__ <- mymodel[["pars"]][[1]]
  opt.method <- mymodel[["options"]][[1]][["opt.method"]]
  opt.rinit <- mymodel[["options"]][[1]][["opt.rinit"]]
  opt.rmax <- mymodel[["options"]][[1]][["opt.rmax"]]
  opt.iterlim <- mymodel[["options"]][[1]][["opt.iterlim"]]
  opt.parlower <- mymodel[["options"]][[1]][["opt.parlower"]]
  opt.parupper <- mymodel[["options"]][[1]][["opt.parupper"]]
  if (length(opt.parlower) > 0) {
    names__ <- intersect(names(opt.parlower), names(pars__))
    if (length(names__) > 0) {
      opt.parlower <- sapply(names__, function(n__) {
        switch(partable__$trafo[partable__$parametername == n__],
               "N" = opt.parlower[n__],
               "L" = log(opt.parlower[n__]),
               "G" = logit(opt.parlower[n__]))
      })
      names(opt.parlower) <- names__
    } else opt.parlower <- NULL
  }
  if (length(opt.parupper) > 0) {
    names__ <- intersect(names(opt.parupper), names(pars__))
    if (length(names__) > 0) {
      opt.parupper <- sapply(names__, function(n__) {
        switch(partable__$trafo[partable__$parametername == n__],
               "N" = opt.parupper[n__],
               "L" = log(opt.parupper[n__]),
               "G" = logit(opt.parupper[n__]))
      })
      names(opt.parupper) <- names__
    } else opt.parupper <- NULL
  }
  if (FLAGchecks) {
    cat("\n----------------------------------------------------------------------------------------\n", file = "project_obj.log", append = TRUE)
    cat("Initial Checking of Objective Function\n", file = "project_obj.log", append = TRUE)
    cat("----------------------------------------------------------------------------------------\n\n", file = "project_obj.log", append = TRUE)
    testmodel__ <- lapply(mymodel, function(x) x[[1]])
    cat("Checking generated functions ")
    is_df <- opt.method %in% c("hjkb", "nmkb")
    if (is_df) cat("[     ]") else cat("[       ]")
    with(testmodel__, {
      is_inf.pars__ <- !is.finite(pars)
      if (any(is_inf.pars__)) stopIQR("Parameters (", paste(names(pars)[is_inf.pars__], collapse = ", "), ") were initialized with infinite values.")
      if (is_df) cat("\b\b\b\b\b\b\b[-    ]") else cat("\b\b\b\b\b\b\b\b\b[-      ]")
      dummy__ <- run_silent_IQR(try(p(pars), silent = TRUE))
      if (any(sapply(dummy__, function(d__) inherits(d__, "try-error"))))
        stopIQR("Evaluation of model parameterization yields error. Possible sources:\n",
             "  * Initial conditions in STATES section of IQR model file\n",
             "  * VARIABLES section of IQR model file\n",
             "  * INITIAL ASSIGNMENTS section of IQR model file\n",
             "  * IIVdistribution in model spec")
      if (is_df) cat("\b\b\b\b\b\b\b[--   ]") else cat("\b\b\b\b\b\b\b\b\b[--     ]")
      dummy__ <- run_silent_IQR(try(prd(times, pars, deriv = FALSE), silent = TRUE))
      if (inherits(dummy__, "try-error")) stopIQR("Simulation of model without derivatives failed. Possible sources:\n",
                                               "  * Bad parameter guesses or initial values\n",
                                               "  * Integration tolerances\n",
                                               "Try to simulate with sim_IQRsysModel() to find appropriate initial guesses and integrator settings.")
      else {
        infinits <- lapply(dummy__, function(d__) sapply(as.data.frame(d__), function(x__) any(is.infinite(x__))))
        inf_cond <- names(dummy__)[sapply(infinits, function(i__) any(i__))]
        inf_state <- Reduce(union, lapply(infinits, function(i__) names(i__)[i__]))
        if (length(inf_cond) > 0) stopIQR("Infinite prediction detected.\n",
                                          "Affected states: ", paste(inf_state, collapse = ", "), "\n",
                                          "Affected conditions: ", paste(inf_cond, collapse = ", "), "\n")
      }
      if (is_df) cat("\b\b\b\b\b\b\b[---  ]") else cat("\b\b\b\b\b\b\b\b\b[---    ]")
      dummy__ <- run_silent_IQR(try((e*prd)(times, pars, deriv = FALSE), silent = TRUE))
      if (hasError(dummy__)) stopIQR("Error model cannot be evaluated. Please check \"errorModel\" in your modelSpec.",
                                     getErrorMessage(dummy__))
      sigma__ <- as.data.frame(dummy__)
      is_inf.sigma__ <- !is.finite(sigma__[["value"]])
      if (any(is_inf.sigma__)) stopIQR("Error model cannot be evaluated for following outputs: ", paste(unique(sigma__[["name"]][is_inf.sigma__]), sep = ", "), ".\n",
                                    "Check the model predictions for these outputs.")
      is_neg.sigma__ <- (sigma__[["value"]] < 0)
      if (any(is_neg.sigma__)) stopIQR("Error model predicts negative values for the following outputs: ", paste(unique(sigma__[["name"]][is_neg.sigma__]), sep = ", "), ".\n",
                                    "Probably a relative error model is used and the predicted OUTPUT is negative.")
      is_zero.sigma__ <- (sigma__[["value"]] == 0)
      if (any(is_zero.sigma__)) stopIQR("Error model predicts 0 for the following outputs: ", paste(unique(sigma__[["name"]][is_zero.sigma__]), sep = ", "), ".\n",
                                     "Probably a relative error model is used and the predicted OUTPUT is 0.\n",
                                     "Please change error model to \"absrel\" or remove observation records from data set that ",
                                     "correspond to 0 predictions.")
      if (is_df) cat("\b\b\b\b\b\b\b[---- ]") else cat("\b\b\b\b\b\b\b\b\b[----   ]")
      dummy__ <- run_silent_IQR(try(obj(pars, deriv = FALSE), silent = TRUE))
      if (hasError(dummy__)) {
        stopIQR("Error in evaluating objective function.", toString(getErrorMessage(dummy__)))
      }
      if (!is.finite(dummy__[["value"]])) {
        stopIQR("Objective function cannot be evaluated to a finite value.")
      }
      if (is_df) cat("\b\b\b\b\b\b\b[-----]") else cat("\b\b\b\b\b\b\b\b\b[-----  ]")
      if (!is_df) {
        dummy__ <- run_silent_IQR(try(prd(times, pars, deriv = TRUE), silent = TRUE))
        if (any(sapply(dummy__, function(d__) inherits(d__, "try-error"))))
          stopIQR("Simulation of model sensitivities failed. Known sources:\n",
               "  * Typically estimation of hill parameters and exponents.\n",
               "  * Generally, estimation of parameters involved in expressions x^p (x is a state, p is the parameter to be estimated)\n",
               "The problem for the above cases occurs when x = 0. Conserider shiftig x by a small value eps -> (x+eps)^p in ",
               "your model file.")
        cat("\b\b\b\b\b\b\b\b\b[------ ]")
        dummy__ <- run_silent_IQR(try(obj(pars, deriv = TRUE), silent = TRUE))
        if (hasError(dummy__)) {
          stopIQR("Error in evaluating objective function with derivatives.", toString(getErrorMessage(dummy__)))
        }
        is_inf.grad__ <- !is.finite(dummy__[["gradient"]])
        if (any(is_inf.grad__)) stopIQR("Non-finite gradient of the objective function for the following parameters: ", paste(names(dummy__[["gradient"]])[is_inf.grad__]), collapse = ", ", ".\n",
                                     "Reason unknown.")
        cat("\b\b\b\b\b\b\b\b\b[-------]")
      }
    })
    cat(" ... done.\n")
  }
  cat("\n----------------------------------------------------------------------------------------\n", file = "project_obj.log", append = TRUE)
  cat("Parameter Estimation\n", file = "project_obj.log", append = TRUE)
  cat("----------------------------------------------------------------------------------------\n\n", file = "project_obj.log", append = TRUE)
  cat("Running fits ... ")
  fits__ <- mstrust(mymodel$obj[[1]],
                          mymodel$startpars[[1]],
                          rinit   = opt.rinit,
                          rmax    = opt.rmax,
                          iterlim = opt.iterlim,
                          cores = ncores,
                          optmethod = opt.method,
                          parlower = opt.parlower,
                          parupper = opt.parupper,
                          printIter = TRUE,
                          traceFile = "optTrace.csv")
  mymodel <- dplyr::mutate(mymodel, fits = list(fits__))
  cat("done.\n")
  cat("Augmenting result by derived quantities ... ")
  mymodel <- appendParframes(mymodel, keepFits = FLAGkeepFits)
  mymodel <- dplyr::mutate(mymodel,
                           bestfit = list(as.parvec(parframes)),
                           pars = list(as.parvec(parframes)),
                           selected = list(1))
  mstrustchecks__ <- dMod_check_mstrust_results(mymodel, opt.parlower, opt.parupper)
  if (mstrustchecks__$less_than_10_percent_converged)
    warningIQR("\nLess than 10% of fits converged. Try to run the project with more iterations.")
  if (!mstrustchecks__$is_converged_bestfit)
    warningIQR("\nBest fit is not converged. Try to run the project with more iterations.")
  if (!mstrustchecks__$is_converged_bestfit & FLAGprofileLL)
    warningIQR("\nProfiles are not going to be computed due to unconverged fit.")
  fixed_on_lower__ <- fixed_on_upper__ <- NULL
  if (!is.null(mstrustchecks__$on_lower_boundary_bestfit)) {
    message("\nSome parameters have reached their lower boundary in the best fit.")
    fixed_on_lower__ <- opt.parlower[mstrustchecks__$on_lower_boundary_bestfit]
  }
  if (!is.null(mstrustchecks__$on_upper_boundary_bestfit)) {
    message("\nSome parameters have reached their upper boundary in the best fit.")
    fixed_on_upper__ <- opt.parupper[mstrustchecks__$on_upper_boundary_bestfit]
  }
  fixed__ <- c(fixed_on_lower__, fixed_on_upper__)
  mymodel <- dplyr::mutate(mymodel,
                           fixed_on_lower = list(fixed_on_lower__),
                           fixed_on_upper = list(fixed_on_upper__))
  mymodel <- vcov_IQRsysModel(mymodel)
  cat("done.\n")
  saveRDS(mymodel, file = "project_result.sysfit")
  mymodel <- dplyr::mutate(mymodel, profiles = list(NULL))
  if (FLAGprofileLL & mstrustchecks__$is_converged_bestfit) {
    cat("\n----------------------------------------------------------------------------------------\n", file = "project_obj.log", append = TRUE)
    cat("Profile Likelihood\n", file = "project_obj.log", append = TRUE)
    cat("----------------------------------------------------------------------------------------\n\n", file = "project_obj.log", append = TRUE)
    cat("Running profile likelihood ... ")
    if (length(mymodel[["fixed_on_lower"]][[1]]) + length(mymodel[["fixed_on_upper"]][[1]]) > 0)
      message("\nEstimated parameters on bounds are fixed during profile likelihood computation.")
    mymodel <- dplyr::mutate(mymodel,
                             profiles = list(
                               structure(
                                 list(profile(obj,
                                                    bestfit, 
                                                    whichPar = names(bestfit)[!(grepl("^(omega|ETA|error_ADD|error_PROP)", names(bestfit))|names(bestfit)%in%names(c(fixed_on_lower, fixed_on_upper)))],
                                                    cores = ncores,
                                                    verbose = FALSE,
                                                    fixed = c(fixed_on_lower, fixed_on_upper))),
                                 names = "1" 
                               )))
    cat("done.\n")
  }
  attr(mymodel, "sysModelEst") <- myattributes__[["sysModelEst"]]
  attr(mymodel, "args0") <- myattributes__[["args0"]]
  class(mymodel) <- unique(c("IQRsysModel", class(mymodel)))
  mymodel$pars[[1]] <- structure(as.numeric(mymodel$bestfit[[1]]),
                                 names = names(mymodel$bestfit[[1]]))
  mymodel <- pred_IQRsysModel(mymodel)
  mymodel <- partable_IQRsysModel(mymodel)
  mymodel <- sim_IQRsysModel(mymodel)
  mymodel <- metrics_IQRsysModel(mymodel)
  return(mymodel)
}
genModelParInfo_SYSFIT <- function(est) {
  param_fixed__ <- names(est$modelSpec$POPestimate)[est$modelSpec$POPestimate==0]
  param_estimated__ <- names(est$modelSpec$POPestimate)[est$modelSpec$POPestimate==1]
  cov_param__ <- as.vector(unlist(sapply(names(est$modelSpec$covariateModel), function(x) {
    paste0("beta_",x,"_",est$modelSpec$covariateModel[[x]])
  })))
  cov_param_estimated__ <- cov_param__[unlist(sapply(names(est$modelSpec$covariateModel), function(x) {
    est$modelSpec$COVestimate[[x]]
  }))==1]
  cov_param_fixed__ <- setdiff(cov_param__,cov_param_estimated__)
  covariates__ <- unique(unlist(est$modelSpec$covariateModel))
  covariateValues__ <- as.vector(unlist(sapply(names(est$modelSpec$covariateModel), function(x) {
    est$modelSpec$covariateModelValues[[x]]
  })))
  names(covariateValues__) <- cov_param__
  output__ <- ""
  covParamFixedText <- sapply(cov_param_fixed__, function (x) {
    paste0("    ",x," <- ",covariateValues__[x])
  })
  if (length(covParamFixedText) > 0) {
    output__ <- paste0(output__,"# Fixed covariate coefficients")
    output__ <- paste0(output__,"\n",paste0(covParamFixedText,collapse="\n"))
    output__ <- paste0(output__,"\n\n")
  }
  paramTextEstimated <- sapply(param_estimated__, function (param__) {
    covModel <- ""
    if (!is.null(est$modelSpec$covariateModel[[param__]])) {
      cats__ <- intersect(est$data$catNames,est$modelSpec$covariateModel[[param__]])
      covs__ <- intersect(est$data$covNames,est$modelSpec$covariateModel[[param__]])
      catText__ <- sapply(cats__, function (cat) {
        paste0(" + beta_",param__,"_",cat,"*",cat)
      })
      if (length(catText__) > 0) {
        catText__ <- paste0(catText__,collapse="")
      } else {
        catText__ <- ""
      }
      covText__ <- sapply(covs__, function (cov) {
        covReference__ <- est$data$covariateMedianValues[cov] 
        paste0(" + beta_",param__,"_",cov,"*log(",cov,"/",covReference__,")")
      })
      if (length(covText__) > 0) {
        covText__ <- paste0(covText__,collapse="")
      } else {
        covText__ <- ""
      }
      covModel <- paste0(covText__,catText__)
    }
    if (est$modelSpec$IIVestimate[param__]!=0) {
      etaText__ <- paste0(" + ETA_",param__)
    } else {
      etaText__ <- ""
    }
    out__ <- paste0("    ",param__," <- ")
    if (est$modelSpec$IIVdistribution[param__]=="G") {
      x__ <- paste0("trans",param__,etaText__,covModel)
      out__ <- paste0(out__,"exp(",x__,")/(1+exp(",x__,"))")
    }
    if (est$modelSpec$IIVdistribution[param__]=="L") out__ <- paste0(out__,"exp(trans",param__,etaText__,covModel,")")
    if (est$modelSpec$IIVdistribution[param__]=="N") out__ <- paste0(out__,"trans",param__,etaText__,covModel)
    out__
  })
  output__ <- paste0(output__,"# Parameter transformations\n")
  output__ <- paste0(output__,paste0(paramTextEstimated,collapse="\n"))
  output__ <- paste0(output__,"\n\n")
  paramTextFixed__ <- sapply(param_fixed__, function (param__) {
    covModel <- ""
    if (!is.null(est$modelSpec$covariateModel[[param__]])) {
      cats__ <- intersect(est$data$catNames,est$modelSpec$covariateModel[[param__]])
      covs__ <- intersect(est$data$covNames,est$modelSpec$covariateModel[[param__]])
      catText__ <- sapply(cats__, function (cat) {
        paste0(" + beta_",param__,"_",cat,"*",cat)
      })
      if (length(catText__) > 0) {
        catText__ <- paste0(catText__,collapse="")
      } else {
        catText__ <- ""
      }
      covText__ <- sapply(covs__, function (cov) {
        covReference__ <- est$data$covariateMedianValues[cov] 
        paste0(" + beta_",param__,"_",cov,"*log(",cov,"/",covReference__,")")
      })
      if (length(covText__) > 0) {
        covText__ <- paste0(covText__,collapse="")
      } else {
        covText__ <- ""
      }
      covModel <- paste0(covText__,catText__)
    }
    value <- est$modelSpec$POPvalues[param__]
    out__ <- paste0("    ",param__," <- ")
    if (est$modelSpec$IIVdistribution[param__]=="G") out__ <- paste0(out__,"inv_logit(logit(",value,")",covModel,")")
    if (est$modelSpec$IIVdistribution[param__]=="L") out__ <- paste0(out__,"exp(log(",value,")",covModel,")")
    if (est$modelSpec$IIVdistribution[param__]=="N") out__ <- paste0(out__,value,covModel,param__)
    out__
  })
  if (length(paramTextFixed__) > 0) {
    output__ <- paste0(output__,"# Fixed model parameters (considered in modelSpec)")
    output__ <- paste0(output__,"\n",paste0(paramTextFixed__,collapse="\n"))
    output__ <- paste0(output__,"\n")
  }
  cov_param__ <- sapply(cov_param__, function (x) {
    x <- aux_strrep(x,"beta_","")
    x <- aux_strrep(x,"_","(")
    paste0("beta_",x,")")
  })
  cov_param_estimated__ <- sapply(cov_param_estimated__, function (x) {
    x <- aux_strrep(x,"beta_","")
    x <- aux_strrep(x,"_","(")
    paste0("beta_",x,")")
  })
  paramsAll__ <- c(names(est$modelSpec$POPestimate),
                   cov_param__)
  paramsEstimated__ <- c(est$modelSpec$POPestimate,
                         as.numeric(cov_param__ %in% cov_param_estimated__))
  paramsInit__ <- c(est$modelSpec$POPvalues0,
                    covariateValues__)
  if (!is.null(est$data$covNames)) {
    covParam__ <- cov_param__[sort(unique(unlist(sapply(est$data$covNames, function (x) {
      which(grepl(paste0("(",x),cov_param__,fixed=TRUE))
    }))))]
  } else {
    covParam__ <- NULL
  }
  if (!is.null(est$data$catNames)) {
    catParam__ <- cov_param__[sort(unique(unlist(sapply(est$data$catNames, function (x) {
      which(grepl(paste0("(",x),cov_param__,fixed=TRUE))
    }))))]
  } else {
    catParam__ <- NULL
  }
  covTrans__ <- sapply(covParam__, function (cov) {
    ix__ <- gregexpr("(",cov,fixed=TRUE)[[1]][1]
    cov <- substr(cov,ix__+1,nchar(cov)-1)
    covReference__ <- est$data$covariateMedianValues[cov]
    paste0("log(cov/",covReference__,")")
  })
  catRef__ <- rep(0,length(catParam__))
  names(catRef__) <- catParam__
  betacatcategories__ <- lapply(catParam__, function (x) {
    c(0,1)
  })
  names(betacatcategories__) <- catParam__
  return(list(output=output__,
              parameters = paramsAll__,
              paramsEstimated = paramsEstimated__,
              paramsInit = paramsInit__,
              covariatesused = covariates__,
              covParam = covParam__,
              covTrans = covTrans__,
              catParam = catParam__,
              catRef   = catRef__, 
              betacatcategories = betacatcategories__ 
  )
  )
}
dMod_process_bestfit <- function(mymodel) {
  bestfit__  <- unclass(mymodel$bestfit[[1]])
  attr(bestfit__, "deriv") <- NULL
  sigma__ <- sqrt(diag(mymodel[["vcov"]][[1]]))
  fixed.grid <- mymodel$fixed.grid[[1]]
  parameters <- mymodel$parameters[[1]]
  pars <- list()
  pars$ETA        <- bestfit__[grepl("^ETA_", names(bestfit__))]
  pars$omega      <- bestfit__[grepl("^omega_", names(bestfit__))]
  pars$beta       <- bestfit__[grepl("^beta_", names(bestfit__))]
  pars$error      <- bestfit__[grepl("^error", names(bestfit__))]
  pars$pop        <- bestfit__[!grepl("^(ETA|omega|beta|error)", names(bestfit__))]
  fixed <- list()
  fixed$ETA        <- NULL
  fixed$omega      <- unlist(fixed.grid[1, grepl("omega_", names(fixed.grid))])
  fixed$beta       <- NULL
  fixed$errors     <- NULL
  fixed$pop        <- unlist(fixed.grid[1,intersect(names(fixed.grid), names(parameters[[1]]))])
  pars <- do.call(rbind,lapply(seq_along(pars), function(.x) {
    if(length(pars[[.x]]) == 0)
      return(NULL)
    data.frame(parametername = names(pars[[.x]]),
               parametervalue = pars[[.x]],
               sigma = sigma__[names(pars[[.x]])],
               parametertask = names(pars)[.x],
               estimated = 1,
               stringsAsFactors = FALSE)
  }))
  fixed <- do.call(rbind,lapply(seq_along(fixed), function(.x) {
    if(length(fixed[[.x]]) == 0)
      return(NULL)
    data.frame(parametername = names(fixed[[.x]]),
               parametervalue = fixed[[.x]],
               sigma = NA,
               parametertask = names(fixed)[.x],
               estimated = 0,
               stringsAsFactors = FALSE)
  }))
  parameters_df <- rbind(pars, fixed)
  parameters_df$RSE <- abs(parameters_df$sigma / parameters_df$parametervalue) * 100
  belongs_to <- function(parametername, parameters) {
    gsub(paste0(".*(",paste0(names(parameters[[1]]), collapse = "|"), ").*"), "\\1", parametername)
  }
  parameters_df$belongs_to <- belongs_to(parameters_df$parametername, parameters)
  covariate_levels <- function(parametername, belongs_to) {
    out__ <- rep(NA, length(belongs_to))
    is_beta__ <- grepl("^beta", parametername)
    betas__ <- parametername[is_beta__]
    to_which <- unique(belongs_to[is_beta__])
    betas__ <- gsub(paste0("^beta_(",paste0(to_which, collapse = "|"), ")_"), "", betas__)
    out__[is_beta__] <- betas__
    return(out__)
  }
  parameters_df$covariate_levels <- covariate_levels(parameters_df$parametername, parameters_df$belongs_to)
  parameters_df$trafo <- parameters$IIVdistribution[parameters_df$belongs_to]
  parameters_df$trafo[parameters_df$parametertask %in% c("error")] <- "L"
  parameters_df$parametervalue_linear <-
    vapply(seq_len(nrow(parameters_df)), function(.x) switch(parameters_df$trafo[.x], N = parameters_df$parametervalue[.x], L = exp(parameters_df$parametervalue[.x]), G = inv_logit(parameters_df$parametervalue[.x]), `NA` = exp(parameters_df$parametervalue[.x])), FUN.VALUE = 1)
  dinv_logit__ <- function(x) (exp(x))/((1+exp(x))^2)
  parameters_df$sigma_linear <- vapply(seq_len(nrow(parameters_df)),
                                       function(.x) switch(parameters_df$trafo[.x],
                                                           N = parameters_df$sigma[.x],
                                                           L = sqrt((exp(parameters_df$parametervalue[.x])*parameters_df$sigma[.x])^2),
                                                           G = sqrt((dinv_logit__(parameters_df$parametervalue[.x])*parameters_df$sigma[.x])^2),
                                                           `NA` = sqrt((exp(parameters_df$parametervalue[.x])*parameters_df$sigma[.x])^2)),
                                       FUN.VALUE = 1)
  parameters_df$RSE_linear <- abs(parameters_df$sigma_linear / parameters_df$parametervalue_linear) * 100
  parameters_df$description_name <- vapply(seq_len(nrow(parameters_df)),
                                           function(.x) switch(parameters_df$trafo[.x],
                                                               N = parameters_df$parametername[.x],
                                                               L = paste0("log(",parameters_df$parametername[.x], ")"),
                                                               G = paste0("logit(",parameters_df$parametername[.x], ")"),
                                                               `NA` = parameters_df$parametername[.x]),
                                           FUN.VALUE = character(1L))
  printname <- function(parametertask, belongs_to, covariate_levels, parametername) {
    out__ <- paste0(parametertask, "(", belongs_to, ")")
    is_beta__ <- !is.na(covariate_levels)
    betas__ <- parametername[is_beta__]
    to_which <- unique(belongs_to[is_beta__])
    betas__ <- gsub(paste0("(beta_(",paste0(to_which, collapse = "|"), ")).*"), "\\1", betas__)
    betas__ <- paste0(betas__, "(", covariate_levels[is_beta__], ")")
    out__[is_beta__] <- betas__
    return(out__)
  }
  parameters_df$printname <- printname(parameters_df$parametertask, parameters_df$belongs_to, parameters_df$covariate_levels, parameters_df$parametername)
  parameters_df$printname[parameters_df$parametertask %in% c("pop", "error")] <- parameters_df$parametername[parameters_df$parametertask %in% c("pop", "error")]
  parameters_df$distribution_info <- vapply(parameters_df$trafo, function(i) {switch(i, N = "(psi)", L = "log(psi)", G = "logit(psi)")}, FUN.VALUE = "1")
  pops__ <- parameters_df[parameters_df$parametertask == "pop", "parametername", drop = TRUE]
  omegas__ <- parameters_df[parameters_df$parametertask == "omega", "belongs_to", drop = TRUE]
  noIIV__ <- setdiff(pops__, omegas__)
  est <- readRDS(file.path("project.est"))
  data <- IQRloadCSVdata(file.path(est$data$relPathFromProject, basename(est$data$datafile)))
  IDs__ <- unique(data$ID)
  df_eta__ <- df_omega__ <- NULL
  if (length(noIIV__) > 0) {
    df_eta__ <- data.frame(parametername = paste0("ETA_", outer(noIIV__, IDs__, paste, sep = "_")),
                           parametervalue = 0,
                           sigma = NA,
                           parametertask = "ETA",
                           estimated = 0,
                           RSE = NA,
                           belongs_to = rep(noIIV__, length(IDs__)),
                           covariate_levels = NA,
                           trafo = "x",
                           parametervalue_linear = 0,
                           sigma_linear = NA,
                           RSE_linear = NA,
                           description_name = paste0("ETA_", outer(noIIV__, IDs__, paste, sep = "_")),
                           printname = paste0("ETA(", noIIV__, ")"),
                           distribution_info = "x",
                           stringsAsFactors = FALSE
    )
    df_omega__ <- data.frame(parametername = paste0("omega_", noIIV__),
                             parametervalue = 0,
                             sigma = NA,
                             parametertask = "omega",
                             estimated = 0,
                             RSE = NA,
                             belongs_to = noIIV__,
                             covariate_levels = NA,
                             trafo = "x",
                             parametervalue_linear = 0,
                             sigma_linear = NA,
                             RSE_linear = NA,
                             description_name = paste0("omega_", noIIV__),
                             printname = paste0("omega(", noIIV__, ")"),
                             distribution_info = "x",
                             stringsAsFactors = FALSE
    )
  }
  parameters_df <- rbind(parameters_df, df_eta__, df_omega__)
  parameters_df <- parameters_df[order(parameters_df$parametername),]
  return(parameters_df)
}
dMod_rawParameterInfo <- function(parameters_df, parsOfInterest) {
  list(
    fixedEffects = with(parameters_df, {
      mynames__ <- intersect(parsOfInterest, parametername)
      index__ <- match(mynames__, parametername)
      out <- list()
      out[["names"]] <- mynames__
      out[["trans"]] <- rep("", length(mynames__))
      out[["invtrans"]] <- rep("", length(mynames__))
      out[["estimated"]] <- estimated[index__]
      out[["values"]] <- parametervalue_linear[index__]
      out[["stderr"]] <- sigma_linear[index__]
      out[["rse"]] <- 100*RSE_linear[index__]
      out[["distribution_info"]] <- as.character(c("L" = "log(psi)", "N" = "(psi)", "G" = "logit(psi)")[trafo[index__]])
      out
    }),
    fixedEffects_transformed = with(parameters_df, {
      mynames__ <- intersect(parsOfInterest, parametername)
      index__ <- match(mynames__, parametername)
      out <- list()
      out[["names"]] <- mynames__
      out[["trans"]] <- as.character(c("L" = "exp(phi)", "N" = "(phi)", "G" = "exp(phi)/(1+exp(phi))")[trafo[index__]])
      out[["invtrans"]] <- as.character(c("L" = "log(psi)", "N" = "(psi)", "G" = "logit(psi)")[trafo[index__]])
      out[["estimated"]] <- estimated[index__]
      out[["values"]] <- parametervalue[index__]
      out[["stderr"]] <- sigma[index__]
      out[["rse"]] <- 100*sigma[index__]/abs(parametervalue[index__])
      out[["distribution_info"]] <- as.character(c("L" = "log(psi)", "N" = "(psi)", "G" = "logit(psi)")[trafo[index__]])
      out
    }),
    randomEffects = with(parameters_df, {
      out <- list()
      out[["names"]] <- paste0("omega(", intersect(parsOfInterest, parametername), ")")
      out[["estimated"]] <- rep(0, length(out[["names"]]))
      out[["values"]] <- rep(0, length(out[["names"]]))
      out[["stderr"]] <- rep(NA, length(out[["names"]]))
      out[["rse"]] <- rep(NA, length(out[["names"]]))
      if (any("omega" %in% parametertask)) {
        index__ <- which(parametertask == "omega")
        out[["estimated"]][match(printname[index__], out[["names"]])] <- c(2, 1)[estimated[index__]+1]
        out[["values"]][match(printname[index__], out[["names"]])] <- parametervalue_linear[index__]
        out[["stderr"]][match(printname[index__], out[["names"]])] <- sigma_linear[index__]
        out[["rse"]] <- 100*out[["stderr"]]/abs(out[["values"]])
      }
      out
    }),
    correlation = list(
      names = character(0),
      stderr = logical(0),
      rse = logical(0)
    ),
    covariate = with(parameters_df, {
      index__ <- which(parametertask == "beta")
      out <- list()
      out[["names"]] <- printname[index__]
      out[["estimated"]] <- estimated[index__]
      out[["values"]] <- parametervalue_linear[index__]
      out[["stderr"]] <- sigma_linear[index__]
      out[["rse"]] <- 100*RSE_linear[index__]
      out
    }),
    errorParameter = with(parameters_df, {
      index__ <- which(parametertask == "error")
      out <- list()
      out[["names"]] <- printname[index__]
      out[["estimated"]] <- estimated[index__]
      out[["values"]] <- parametervalue_linear[index__]
      out[["stderr"]] <- sigma_linear[index__]
      out[["rse"]] <- 100*RSE_linear[index__]
      out
    })
  )
}
standardOutput_IQRsysModel <- function(mymodel,
                                       SIGDIG = 3, 
                                       FLAGreport = FALSE,
                                       projectPath = "."
) {
  pathInformation__ <- projectPath
  setwd(attr(projectPath, "absProjectPath"))
  projectPath <- "."
  parameters_df <- mymodel[["IQRpartable"]][[1]]
  parsOfInterest__ <- attr(mymodel, "sysModelEst")[["parsOfInterest"]]
  parsLOC__ <- parameters_df[["parametername"]][!is.na(parameters_df[["CONDITION"]]) & !parameters_df[["CONDITION"]] %in% "BASE"]
  if (length(parsOfInterest__) == 0)
    parsOfInterest__ <- unique(parameters_df[["parametername"]][parameters_df[["parametertask"]] == "pop"])
  else
    parsOfInterest__ <- intersect(parsOfInterest__, parameters_df[["parametername"]])
  parsOfInterestNoLOC__ <- setdiff(parsOfInterest__, parsLOC__)
  pred_df__ <- mymodel[["IQRpredtable"]][[1]]
  rawParameterInfo <- dMod_rawParameterInfo(parameters_df, parsOfInterest__)
  est <- readRDS(file.path(projectPath, "project.est"))
  data <- IQRloadCSVdata(file.path(projectPath, est$data$relPathFromProject, basename(est$data$datafile)))
  covariate_df__ <- data[c("ID", est$data$covNames, est$data$catNames, "USUBJID")]
  covariate_df__ <- do.call(rbind, lapply(split(covariate_df__, covariate_df__[["USUBJID"]]), function(d) d[1,]))
  atrcontents__ <- list()
  atrcontents__$paramNames <- parsOfInterest__
  atrcontents__$localNames <- intersect(parsLOC__, parsOfInterest__)
  atrcontents__$covariateNames <- c(est$data$covNames, est$data$catNames)
  atrcontents__$covNames <- est$data$covNames
  atrcontents__$catNames <- est$data$catNames
  atrcontents__$ALT_NAMES_USED <- c("XPRED", "XWRES", "IPRED", "IWRES")
  atrcontents__$ALT_NAMES_ORIG <- c("XPRED", "XWRES", "IPRED", "IWRES")
  IDs__ <- unique(data[["ID"]])
  ETAs__ <- c(list(IDs__), lapply(parsOfInterest__, function(x__) rep(0, length(IDs__))))
  names(ETAs__) <- c("ID", parsOfInterest__)
  ETAs__ <- as.data.frame(ETAs__)
  for (par__ in parsOfInterest__) {
    for (id__ in IDs__) {
      candidate__ <- paste("ETA", par__, id__, sep = "_")
      if (candidate__ %in% parameters_df[["parametername"]]) {
        ETAs__[match(id__, IDs__), par__] <- parameters_df[["parametervalue"]][match(candidate__, parameters_df[["parametername"]])]
      }
    }
  }
  names(ETAs__) <- c("ID", paste("ETA", parsOfInterest__, sep = "_"))
  ETAs__ <- merge(ETAs__, covariate_df__, by = "ID")
  attributes(ETAs__) <- c(attributes(ETAs__), atrcontents__)
  IQRsaveCSVdata(ETAs__, file.path(projectPath, "RESULTS/project_eta.csv"))
  myenv__ <- environment(mymodel$p[[1]])
  assign("prd_conditions", myenv__$p_conditions, pos = myenv__)
  pars_indiv__ <- with(unlist(mymodel,FALSE), {p(bestfit)})
  pars_indiv__ <- do.call(rbind, mapply(
    function(pars_i, nmpars_i) {as.data.frame(t(c(ID = nmpars_i, unclass(pars_i))))},
    pars_i = pars_indiv__, nmpars_i = as.numeric(names(pars_indiv__)), SIMPLIFY = FALSE))
  if (length(parsOfInterestNoLOC__) == 0) stopIQR("Check if you have defined POPvalues0 in the IQRsysModel call.\n")
  pars_indiv__ <- merge(pars_indiv__[, c("ID", parsOfInterestNoLOC__)], covariate_df__, by = "ID")
  attributes(pars_indiv__) <- c(attributes(pars_indiv__), atrcontents__)
  IQRsaveCSVdata(pars_indiv__, file.path(projectPath, "RESULTS/project_indiv.csv"))
  data_pred_df__ <- data[!is.na(data$YTYPE),
                         c("ID", est$data$covNames, est$data$catNames, "USUBJID",
                           "TIME", "TIMEPOS", "TAD", "YTYPE","MDV", "EVID", "CENS", "DV")]
  pred_pred_df__ <- dplyr::transmute(pred_df__,
                                     ID = ID,
                                     TIME = time,
                                     YTYPE = gsub("^OUTPUT", "", name),
                                     DV = value,
                                     IPRED = pred_indiv,
                                     IRES = res_indiv,
                                     IWRES = wres_indiv,
                                     XPRED = pred_pop,
                                     XRES = res_pop,
                                     XWRES = wres_pop,
                                     NPDE = NA)
  pred_pred_df__ <- merge(data_pred_df__, pred_pred_df__, by = c("ID", "TIME", "YTYPE", "DV"))
  pred_pred_df__ <- dplyr::rename(pred_pred_df__, TIME2 = TIMEPOS)
  attributes(pred_pred_df__) <- c(attributes(pred_pred_df__), atrcontents__)
  IQRsaveCSVdata(pred_pred_df__, file.path(projectPath, "RESULTS/project_pred.csv"))
  h__ <- parseSYSprojectHeader(projectPath)
  RESULT__ <- list()
  RESULT__$COMMENT                         <- h__$COMMENT
  RESULT__$TOOL                            <- "SYSFIT"
  RESULT__$model                           <- unclass(projectPath)
  RESULT__$OBJ                             <- mymodel[["metrics"]][[1]][["value"]][1]
  RESULT__$BIC                             <- mymodel[["metrics"]][[1]][["value"]][2]
  RESULT__$AIC                             <- mymodel[["metrics"]][[1]][["value"]][3]
  RESULT__$parameternames                  <- parameters_df$parametername
  RESULT__$parametervalues                 <- parameters_df$parametervalue
  RESULT__$stderrors                       <- parameters_df$sigma
  RESULT__$correlationmatrixRandomEffects  <- NULL 
  RESULT__$rawParameterInfo                <- rawParameterInfo
  RESULT__$projectHeader                   <- h__
  ATRinfo__ <- loadATRinfo_csvData(h__$DATA)
  parameters_noETAs_df__ <- dplyr::filter(parameters_df, parametertask != "ETA")
  vcov_noETAs__ <- mymodel$vcov[[1]]
  vcov_noETAs__ <- vcov_noETAs__[!grepl("ETA_",rownames(vcov_noETAs__)),!grepl("ETA_",colnames(vcov_noETAs__)), drop = FALSE]
  corr_noETAs__ <- vcov_noETAs__ / sqrt(abs(outer(diag(vcov_noETAs__), diag(vcov_noETAs__))))
  project_results__ <- list()
  project_results__$type <- RESULT__$TOOL
  project_results__$method <- "mstrust"
  project_results__$termination_info <- ""
  project_results__$path <- pathInformation__
  project_results__$parameters <- with(parameters_noETAs_df__, {
    index <- c(
      match(parsOfInterest__, parametername),
      which(parametertask == "beta"),
      which(parametertask == "error")
    )
    myparnames <- c(printname[index], paste0("omega(", parsOfInterest__,")"))
    myparflagestimated <- c(estimated[index], rep(0, length(parsOfInterest__)))
    myparvalues <- c(parametervalue[index], rep(0, length(parsOfInterest__)))
    mypartransformation <- as.character(c(
      c("N" = "(phi)", "L" = "exp(phi)", "G" = "exp(phi)/(1+exp(phi))")[trafo[index]],
      rep("", length(parsOfInterest__))
    ))
    mypartransformation[!myparnames %in% parsOfInterest__] <- "" 
    mystandarderrors <- c(sigma[index], rep(0, length(parsOfInterest__)))
    if (any(parametertask == "omega")) {
      omegaindex <- match(printname[parametertask == "omega"], myparnames)
      myparflagestimated[omegaindex] <- c(2, 1)[estimated[parametertask == "omega"]+1]
      myparvalues[omegaindex] <- parametervalue_linear[parametertask == "omega"]
      mystandarderrors[omegaindex] <- sigma[parametertask == "omega"]
    }
    myvcov <- mycor <- matrix(0, nrow = length(myparnames),
                              ncol = length(myparnames),
                              dimnames = list(myparnames, myparnames))
    for (n__ in rownames(vcov_noETAs__)) {
      vec__ <- vcov_noETAs__[n__, ]
      myvcov[printname[match(n__, parametername)],
             printname[match(rownames(vcov_noETAs__), parametername)]] <- vec__
      vec__ <- corr_noETAs__[n__, ]
      mycor[printname[match(n__, parametername)],
            printname[match(rownames(corr_noETAs__), parametername)]] <- vec__
    }
    mystandarderrors[is.na(mystandarderrors)] <- 0
    myvcov[is.na(myvcov)] <- 0
    mycor[is.na(mycor)] <- 0
    diag(mycor) <- 1
    list(
      note = "Parameters are given on the scale at which they are estimated, they are not transformed to linear scale",
      names = myparnames,
      FLAGestimated = myparflagestimated,
      transformation = mypartransformation,
      values = myparvalues,
      stderrors = mystandarderrors,
      correlationmatrix = mycor,
      covariancematrix = myvcov
    )
  })
  project_results__$objectivefunction <- stats::setNames(as.list(mymodel[["metrics"]][[1]][["value"]]),
                                                         mymodel[["metrics"]][[1]][["metric"]])
  project_results__$residualerrormodels <- as.character(do.call(c,lapply(est$modelSpec$errorModel, "[[", 1)))
  project_results__$inv_trans_randeffects <- as.character(
    c("L" = "log(psi)",
      "N" = "(psi)",
      "G" = "logit(psi)")[parameters_df$trafo[match(parsOfInterest__, parameters_df$parametername)]])
  project_results__$trans_randeffects <- as.character(
    c("L" = "exp(phi)",
      "N" = "(phi)",
      "G" = "exp(phi)/(1+exp(phi))")[parameters_df$trafo[match(parsOfInterest__, parameters_df$parametername)]])
  covNames                   <- RESULT__$projectHeader$COVNAMES
  covTransformation__          <- RESULT__$projectHeader$BETACOVTRANS
  catNames                   <- RESULT__$projectHeader$CATNAMES
  catReference__               <- RESULT__$projectHeader$BETACATREFERENCE
  catCategories__              <- RESULT__$projectHeader$BETACATREFERENCE
  project_results__$covariates <- list(
    covNames = covNames,
    covTransformation = covTransformation__,
    catNames = catNames,
    catReference = catReference__,
    catCategories = catCategories__
  )
  project_results__$PROJECTINFO <- RESULT__$projectHeader
  project_results__$rawParameterInfo <- rawParameterInfo
  IQRoutputFile(deparse(project_results__), file.path(projectPath, "RESULTS/project_results.x"))
}
dMod_approxHessian <- function(objfn, pars, h = 1e-4, diag = TRUE, ...) {
  if (!diag)
    stopIQR("Approximation of non-diagonal entries not implemented for sake of speed")
  nm__ <- names(pars)
  ln__ <- length(pars)
  fn__ <- function(x__) {
    args <- list(...)
    args[["pars"]] <- x__
    args[["deriv"]] <- FALSE
    do.call(objfn, args)[["value"]]
  }
  if (diag) {
    values__ <- lapply(seq_len(ln__), function(i__) {
      hvec__ <- rep(0, ln__)
      hvec__[i__] <- h
      (fn__(pars+hvec__) - 2*fn__(pars) + fn__(pars-hvec__))/h^2
    })
    values__ <- unlist(values__)
    hessian__ <- diag(values__)
  }
  if (!diag) {
    cat("Computing Hessian Matrix")
    hessian__ <- numDeriv::hessian(fn__, x = pars)
    hessian__ <- nearPD(hessian__)
  }
  rownames(hessian__) <- nm__
  colnames(hessian__) <- nm__
  return(hessian__)
}
convert2dMod_IQRmodel <- function(est, my_dMod_data = NULL, options = NULL, ..., FLAGonlyMeta = FALSE, FLAGderiv = TRUE) {
  mywd__ <- getwd()
  output__ <- try({
    dots__ <- list(...)
    quoted__ <- function(x) paste0("(", x, ")")
    is_number__ <- function(x) !is.na(suppressWarnings(as.numeric(x)))
    model <- est$model
    if (is_IQRmodel(model)) {
      model__ <- model
    } else if (aux_fileparts(model)[["fileext"]]==".xml") {
      model__ <- importSBML_IQRmodel(model)
    } else {
      model__ <- import_IQRmodel(model, FLAGtextIQRmodel=FALSE)
      checkNames_IQRmodel(model__)
    }
    setwd(tempdirIQR())
    states__ <- names(model__[["states"]])
    states.equations__ <- sapply(states__, function(s) model__[["states"]][[s]][["ODE"]])
    observables__ <- names(model__[["outputs"]])
    observables.equations__ <- sapply(observables__, function(s) model__[["outputs"]][[s]][["formula"]])
    symbols__ <- getSymbols(states.equations__)
    inputs__ <- symbols__[grepl("^INPUT", symbols__)]
    inputs__ <- inputs__[order(as.numeric(sub("INPUT", "", inputs__)))] 
    events__ <- eventpars__ <- NULL
    if (!is.null(my_dMod_data) & !is.null(model__[["inputs"]]) & !is.null(attr(my_dMod_data, "max_scheme")))
      ndoses__ <- attr(my_dMod_data, "max_scheme")
    else ndoses__ <- structure(rep(1, length(inputs__)), names = inputs__)
    if (length(inputs__) > 0) {
      diff__ <- setdiff(inputs__, paste0("INPUT", 1:length(inputs__)))
      if (length(diff__) > 0)
        stopIQR("Inputs must be defind in numeric order, e.g., INPUT1, INPUT2, INPUT3, ...")
      input_exists__ <- intersect(inputs__, states__)
      input_new__ <- setdiff(inputs__, states__)
      states__ <- union(states__, inputs__)
      if (length(input_exists__) > 0)
        states.equations__[input_exists__] <- paste(states.equations__[input_exists__], "0", sep = " + ")
      if (length(input_new__) > 0)
        states.equations__[input_new__] <- "0"
      events__ <- dMod_build_dosing_events(inputs__, ndoses__)
      eventpars__ <- getParameters(events__)
    }
    if (!is.null(model__[["events"]])) {
      eventsModel__ <- model__[["events"]]
      getArgs__ <- function(char__) trimws(strsplit(gsub("\\)$", "", gsub(".*\\(", "", char__)), ",", fixed = TRUE)[[1]])
      eventsdMod__ <- do.call(rbind, lapply(eventsModel__, function(myevent__) {
        myargs__ <- getArgs__(myevent__[["trigger"]])
        isTimeLike__ <- (myargs__[1] == "time")
        data.frame(
          var = myevent__[["assignment"]][[1]][["variable"]],
          time = ifelse(isTimeLike__, myargs__[2], paste0("time", myargs__[2])),
          value = myevent__[["assignment"]][[1]][["formula"]],
          root = ifelse(isTimeLike__, NA, paste0(myargs__[1], "-", myargs__[2])),
          method = "replace",
          stringsAsFactors = FALSE
        )
      }))
      eventState_exists__ <- intersect(eventsdMod__[["var"]], states__)
      eventStates_new__ <- setdiff(eventsdMod__[["var"]], states__)
      states__ <- union(states__, eventsdMod__[["var"]])
      if (length(eventStates_new__) > 0)
        states.equations__[eventStates_new__] <- "0"
      if (all(is.na(eventsdMod__[["root"]]))) eventsdMod__[["root"]] <- NULL
      events__ <- bind_rows(events__, eventsdMod__)
      eventpars__ <- union(eventpars__, getSymbols(c(eventsdMod__[["time"]],
                                                           eventsdMod__[["value"]],
                                                           eventsdMod__[["root"]]),
                                                         exclude = states__))
    }
    if (length(inputs__) > 0) {
      dosing.equations__ <- dMod_build_dosing_trafo(ndoses__)
    } else {
      dosing.equations__ <- NULL
    }
    variables__ <- names(model__[["variables"]])
    variables.equations__ <- sapply(variables__, function(s) model__[["variables"]][[s]][["formula"]])
    variables.equations__ <- resolveRecurrence(variables.equations__)
    forcings__ <- unique(attr(my_dMod_data, "time_varying_regressors")$name)
    is.timedependent__ <- sapply(variables.equations__, function(myeq) any(c("time", states__, forcings__) %in% getSymbols(myeq)))
    states.equations__ <- replaceSymbols(what = variables__[is.timedependent__],
                                               by   = quoted__(variables.equations__[is.timedependent__]),
                                               x    = states.equations__)
    observables.equations__ <- replaceSymbols(what = variables__[is.timedependent__],
                                                    by   = quoted__(variables.equations__[is.timedependent__]),
                                                    x    = observables.equations__)
    assignments__ <- names(model__[["initalAssignments"]])
    assignments.values__ <- sapply(assignments__, function(s) model__[["initalAssignments"]][[s]][["formula"]])
    is_state.assignment__ <- assignments__ %in% names(model__[["states"]])
    is_par.assignment__ <- !is_state.assignment__
    initials__ <- names(model__[["states"]])
    initials.values__ <- sapply(initials__, function(s) model__[["states"]][[s]][["IC"]])
    if (!is.null(assignments__)) {
      initials.values__[assignments__[is_state.assignment__]] <-
        assignments.values__[assignments__[is_state.assignment__]]
    }
    initials.values__ <- resolveRecurrence(initials.values__)
    initials.symbols__ <- getSymbols(initials.values__)
    is.states.contained__ <- sapply(c("time", initials__), function(x__) x__ %in% initials.symbols__)
    if (any(is.states.contained__)) {
      stopIQR(
        "The following symbols are states and are not allowed in initial conditions: ",
        paste(c("time", initials__)[is.states.contained__], collapse = ", ")
      )
    }
    variables.ic__ <- intersect(variables__, getSymbols(initials.values__))
    if (length(variables.ic__) > 0) {
      variables.equations.ic__ <- variables.equations__[variables.ic__]
      variables.equations.ic__ <- replaceSymbols(initials__, quoted__(initials.values__), variables.equations.ic__)
      variables.equations.ic__ <- resolveRecurrence(variables.equations.ic__)
      initials.values__ <- replaceSymbols(variables.ic__, variables.equations.ic__, initials.values__)
      if (any(c(variables__, initials__) %in% getSymbols(initials.values__)))
        stopIQR("Initial conditions could not be evaluated. If initial conditions contain variables or initial assignments, make sure that these are defined in the right order. Variables/initial assignments can only refer to other variables/initial assignments if **previously** defined.")
    }
    parameters.equations__ <- c(variables.equations__[!is.timedependent__],
                                initials.values__[!is_number__(initials.values__)])
    if (!is.null(assignments__) && any(is_par.assignment__)) {
      par.assignment.equations__ <- assignments.values__[is_par.assignment__]
      par.assignment.equations__ <- replaceSymbols(variables__, quoted__(variables.equations__), par.assignment.equations__)
      par.assignment.equations__ <- replaceSymbols(initials__, quoted__(initials.values__), par.assignment.equations__)
      parameters.equations__ <- c(par.assignment.equations__, parameters.equations__)
    }
    fluxes__ <- names(model__[["reactions"]])
    fluxes.equations__ <- sapply(fluxes__, function(s) model__[["reactions"]][[s]][["formula"]])
    fluxes.equations__ <- resolveRecurrence(fluxes.equations__)
    fluxes.equations__ <- replaceSymbols(what = variables__[is.timedependent__],
                                               by   = quoted__(variables.equations__[is.timedependent__]),
                                               x    = fluxes.equations__)
    states.equations__ <- replaceSymbols(what = fluxes__,
                                               by   = quoted__(fluxes.equations__),
                                               x    = states.equations__)
    sens__ <- names(est$modelSpec$POPestimate)[!(est$modelSpec$POPestimate == 0 & est$modelSpec$IIVestimate == 0)]
    sens__ <- union(sens__, names(dMod_build_covcat_trafo(est)))
    sens__ <- union(sens__, names(est$modelSpec$LOCestimate)[sapply(est$modelSpec$LOCestimate, function(val) any(val != 0))])
    detect_symbols__ <- function(equations, symbols) {
      vapply(equations, function(eqn) {
        any(getSymbols(eqn) %in% symbols)
      }, FUN.VALUE = TRUE)}
    pinner_of_sens__ <- parameters.equations__[detect_symbols__(parameters.equations__, sens__)]
    sens__ <- c(sens__, names(pinner_of_sens__))
    pinner_of_sens__ <- c(
      names(dosing.equations__[detect_symbols__(dosing.equations__, sens__)]),
      events__[["time"]][detect_symbols__(events__[["root"]], sens__)],
      events__[["var"]][detect_symbols__(events__[["root"]], sens__)]
    )
    if (is.null(pinner_of_sens__)) pinner_of_sens__ <- ""
    sens__ <- c(sens__, pinner_of_sens__)
    fix__ <- names(est$modelSpec$POPestimate)[est$modelSpec$POPestimate == 0 & est$modelSpec$IIVestimate == 0]
    if (!is.null(sens__))
      fix__ <- setdiff(getSymbols(c(names(states.equations__),
                                          states.equations__,
                                          parameters.equations__,
                                          eventpars__,
                                          dosing.equations__,
                                          observables.equations__
      ), exclude = "time"), sens__)
    if (!is.null(my_dMod_data)) {
      forcings <- unique(attr(my_dMod_data, "time_varying_regressors")$name)
    } else forcings <- NULL
    mymodelname__ <- paste0(gsub("\\W", "_", model__[["name"]]), paste0(sample(c(0:9,letters), 8), collapse = ""))
    if (!FLAGonlyMeta) {
      sens_in_eqs__ <- intersect(getSymbols(states.equations__), sens__)
      if (length(sens_in_eqs__) == 0) {
        sens_sens__ <- c(sens__, names(states.equations__)[1])
        fix_sens__ <- setdiff(fix__, names(states.equations__)[1])
      } else {
        sens_sens__ <- sens__
        fix_sens__ <- fix__
      }
      myodemodel__ <- odemodel(f= states.equations__,
                                     forcings = forcings,
                                     events = events__,
                                     fixed = fix_sens__,
                                     estimate = sens_sens__,
                                     modelname = mymodelname__,
                                     compile = FALSE,
                                     deriv = FLAGderiv
      )
    } else {
      myodemodel__ <- states.equations__
      attr(myodemodel__, "forcings") <- forcings
      attr(myodemodel__, "events") <- events__
    }
    solver__ <- "deSolve"
    if (!is.null(options)) {
      names(options) <- gsub("^SIMOPT\\.", "", names(options))
      optionsOde__ <- optionsSens__ <- options
    } else if (!is.null(events__) && !is.null(events__[["root"]])) {
      optionsOde__ <- optionsSens__ <- list(method = "lsoda")
    } else {
      optionsOde__ <- optionsSens__ <- list(method = "lsodes")
    }
    forcings_x__ <- NULL
    fcontrol__ <- NULL
    if (length(forcings) > 0 ) {
      forcings_x__ <- data.frame(name = forcings, value = vapply(model__$parameters[forcings], function(i) i$value, FUN.VALUE = 1.0), time = 0)
      fcontrol__ <- list(method = "constant", rule = 2)
    }
    if (!FLAGonlyMeta) {
      if (FLAGderiv)
        x__ <- Xs(odemodel = myodemodel__, forcings = forcings_x__, optionsOde = optionsOde__, optionsSens = optionsSens__, fcontrol = fcontrol__)
      else
        x__ <- Xf(odemodel = myodemodel__, forcings = forcings_x__, optionsOde = optionsSens__, fcontrol = fcontrol__)
    } else {
      x__ <- states.equations__
    }
    parameters__ <- unique(
      c(names(states.equations__),
        getSymbols(states.equations__, exclude = c(forcings, "time")),
        getSymbols(observables.equations__, exclude = c(forcings, "time")),
        getSymbols(events__$time),
        getSymbols(events__$value),
        getSymbols(events__$root)
      )
    )  
    sens_pars_g__ <- parameters__[!(parameters__ %in% c(fix__, names(states.equations__)))]
    if (!FLAGonlyMeta) {
      g__ <- Y(g = observables.equations__,
                     f = x__,
                     parameters = sens_pars_g__,
                     attach.input = FALSE,
                     deriv = FLAGderiv,
                     compile = FALSE, modelname = paste0("obs_", mymodelname__))
    } else {
      g__ <- observables.equations__
    }
    if (!FLAGonlyMeta) {
      g_aux__ <- Y(g = variables.equations__,
                         states = states__,
                         attach.input = FALSE, deriv = FALSE, compile = FALSE, modelname = paste0("obsaux_", mymodelname__))
    } else {
      g_aux__ <- variables.equations__
    }
    parameters__ <- union(
      parameters__,
      getSymbols(observables.equations__, exclude = c(forcings, names(states.equations__), "time"))
    ) 
    errorModel__ <- est$modelSpec$errorModel
    e__ <- NULL
    if (!is.null(errorModel__)) {
      errmodel__ <- dMod_convert2dMod_errorModel__(errorModel__)
      if (!FLAGonlyMeta) {
        e__ <- Y(errmodel__, f = g__, compile = FALSE, modelname = paste0("err_", mymodelname__),
                       attach.input = FALSE, deriv = FLAGderiv)
      } else {
        e__ <- errmodel__
      }
      errmodel.parameters__ <- getSymbols(errmodel__, exclude = c(observables__, "time", forcings))
      parameters__ <- union(parameters__, errmodel.parameters__)
    }
    transformation__ <- repar("x~x", x = parameters__)
    transformation__ <- repar("x~y", x = names(parameters.equations__), y = parameters.equations__, trafo = transformation__)
    if (length(inputs__) > 0) {
      transformation__ <- repar(expr = "x~y", trafo = transformation__, x = names(dosing.equations__), y = dosing.equations__, reset = TRUE)
    }
    if (!FLAGonlyMeta) {
      p__ <- P(transformation__, modelname = paste0("par_", mymodelname__), compile = FALSE)
    } else {
      p__ <- transformation__
    }
    if (!FLAGonlyMeta) {
      files__ <- c(
        list.files(pattern = utils::glob2rx(paste0(mymodelname__, "*.c*"))),
        list.files(pattern = utils::glob2rx(paste0("obs_", mymodelname__, "*.c*"))),
        list.files(pattern = utils::glob2rx(paste0("obsaux_", mymodelname__, "*.c*"))),
        list.files(pattern = utils::glob2rx(paste0("err_", mymodelname__, "*.c*"))),
        list.files(pattern = utils::glob2rx(paste0("par_", mymodelname__, "*.c*")))
      )
      files_deriv__ <- c(
        list.files(pattern = utils::glob2rx(paste0("obs_", mymodelname__, "_deriv*.c*"))),
        list.files(pattern = utils::glob2rx(paste0("obsaux_", mymodelname__, "_deriv*.c*"))),
        list.files(pattern = utils::glob2rx(paste0("err_", mymodelname__, "_deriv*.c*"))),
        list.files(pattern = utils::glob2rx(paste0("par_", mymodelname__, "_deriv*.c*")))
      )
      if (!FLAGderiv) files__ <- setdiff(files__, files_deriv__)
      timestamp__ <- format(Sys.time(), "%Y-%m-%d_%H-%M-%S")
      output__ <- paste0("IQRsysModel_", timestamp__)
      path__ <- gsub("\\", "/", tempdirIQR(), fixed = TRUE)
      .so__ <- .Platform[["dynlib.ext"]]
      clean_loadedDLLs("IQRsysModel") 
      info__ <- system(paste0(R.home(component = "bin"), "/R CMD SHLIB ", paste(files__, collapse = " "), " -o ", file.path(path__, output__), .so__, " >xxx"), intern = TRUE)
      tryCatch({
        dyn.load(paste0(file.path(path__, output__), .so__))
      }, error=function (err) {
        cat(paste0(info__,collapse = "\n"))
        stopIQR("Compilation of model failed. Consider the above message to track down the issue.")
      })
      modelname(p__) <- modelname(x__) <- modelname(g__) <- modelname(g_aux__)  <- output__
      if (!is.null(e__))
        modelname(e__)  <- output__
      unlink(paste0("*", mymodelname__, "*.o"))
      unlink("xxx")
    }
    parameters__ <- getSymbols(transformation__, exclude = c(forcings, "time")) 
    parameters.values__ <- structure(rep(0, length(parameters__)), names = parameters__)
    parameters.values__[grepl("TINF", parameters__)] <- 1
    parameters.values__[grepl("^error_", parameters__)] <- pi/10
    parameters__ <- intersect(names(model__[["parameters"]]), parameters__)
    parameters.values__[parameters__] <- sapply(parameters__, function(s) model__[["parameters"]][[s]][["value"]])
    parameters.values__[initials__[is_number__(initials.values__)]] <- as.numeric(initials.values__[is_number__(initials.values__)])
    fixed__ <- parameters.values__[intersect(getSymbols(transformation__), c(fix__, inputs__))]
    pars__ <- parameters.values__[setdiff(names(parameters.values__), c(fix__, inputs__))]
    list(g = g__,  g_aux = g_aux__, e = e__, x =  x__, p = p__, pars = pars__, fixed = fixed__, model = myodemodel__)
  }, silent = TRUE)
  setwd(mywd__)
  if (inherits(output__, "try-error"))
    stopIQR(as.character(output__))
  return(output__)
}
convert2dMod_IQRdata <- function(datafile = NULL,
                                 catNames = NULL,
                                 covNames = NULL,
                                 regressorNames = NULL,
                                 keep = "CONDITION",
                                 split.by = "ID",
                                 inputs = NULL) {
  mydata0__ <- IQRsysData(datafile, covNames, catNames, regressorNames)
  keep__ <- unique(c(catNames, covNames,  keep))
  keep__ <- intersect(keep__, names(mydata0__))
  mydata__ <- mydata0__
  forcings__ <- do.call(rbind, lapply(regressorNames, function(i) {
    data.frame(name = i,
               time = mydata__[["TIME"]],
               value = mydata__[[i]],
               ID = mydata__[["ID"]],
               stringsAsFactors = FALSE) 
  }))
  determine_constant_forcings__ <- function(forcings) {
    n_unique_values__ <- by(forcings, list(forcings$ID, forcings$name), function(i) {
      nforc__ <- length(unique(i$value))
    }, simplify = TRUE)
    apply(n_unique_values__, 2, function(j) {all(j == 1)})
  }
  is_constant_forcing__ <- determine_constant_forcings__(forcings__)
  constant_forcings__ <- constant_forcnames__ <- NULL
  if (any(is_constant_forcing__)) {
    constant_forcnames__ <- names(is_constant_forcing__)[is_constant_forcing__]
    constant_forcings__ <- unique(forcings__[forcings__$name %in% constant_forcnames__, names(forcings__) != "time"])
  }
  time_varying_forcings__ <- time_varying_forcnames__ <- NULL
  if (any(!is_constant_forcing__)) {
    time_varying_forcnames__ <- names(is_constant_forcing__)[!is_constant_forcing__]
    time_varying_forcings__ <- forcings__[forcings__$name %in% time_varying_forcnames__, ]
  }
  keep__ <- union(keep__, constant_forcnames__)
  mydata__ <- mydata0__
  if (nrow(mydata__) > 0) {
    if (is.null(mydata__$LLOQ))
      mydata__$LLOQ <- -Inf
    mydata__$LLOQ[is.na(mydata__$LLOQ)] <- -Inf
    mydata__$LLOQ[mydata__$CENS == 1] <- mydata__$DV[mydata__$CENS == 1]
    if (!is.null(mydata__$MDV))
      mydata__ <- mydata__[mydata__$MDV != 1 | (mydata__$MDV == 1 & (is.na(mydata__$YTYPE) | mydata__$YTYPE %in% 0)),]
    data <- with(mydata__, {
      YTYPE[is.na(YTYPE)] <- 0
      data.frame(
        name = paste0("OUTPUT", YTYPE)[seq_along(TIME)],
        time = TIME,
        value = DV,
        sigma = rep(NA, length(TIME)),
        lloq = LLOQ,
        ID = ID)
    })
    if (!is.null(keep__)) {
      data <- cbind(data, mydata__[, keep__, drop = FALSE])
    }
    data <- as.datalist(data, split.by = split.by, keep.covariates = keep__)
    condition.grid <- attr(data, "condition.grid")
    data <- as.datalist(lapply(data, function(d) d[d[["name"]] != "OUTPUT0",]),
                              names = names(data),
                              condition.grid = attr(data, "condition.grid"))
  }
  dosing_pars__ <- trafo__ <- max_scheme__ <- NULL
  mydosing__ <- mydata0__[is.na(mydata0__[["YTYPE"]]) | mydata0__[["YTYPE"]] %in% 0, unique(c("TIME", "ID", "AMT", "ADM", "TINF", keep__))]
  if (nrow(mydosing__) > 0) {
    dosing_pars__ <- dMod_build_dosing_parameters(mydata0__, inputs = inputs)
    max_scheme__ <- structure(
      attr(dosing_pars__, "max_nDoses_per_ADM")[["N"]],
      names = paste0("INPUT", attr(dosing_pars__, "max_nDoses_per_ADM")[["ADM"]])
    )
    trafo__ <- dMod_build_dosing_trafo(max_scheme__)
    dosing_pars__ <- dosing_pars__[, setdiff(names(dosing_pars__), "CONDITION")]
    all_IDs__ <- names(data)
    no_dosing_IDs__ <- setdiff(all_IDs__, as.character(dosing_pars__$ID))
    dosing_pars__ <- dosing_pars__[match(all_IDs__, dosing_pars__$ID),] 
  }
  output__ <- data
  attr(output__, "constant_regressors") <- constant_forcings__
  attr(output__, "time_varying_regressors") <- time_varying_forcings__
  attr(output__, "dosing_pars") <- dosing_pars__
  attr(output__, "dosing_trafo") <- trafo__
  attr(output__, "max_scheme") <- max_scheme__
  attr(output__, "catNames") <- catNames
  attr(output__, "covNames") <- covNames
  attr(output__, "regressorNames") <- regressorNames
  attr(output__, "keep") <- keep__
  return(output__)
}
combine_model_and_data <- function(basic_dMod_model__, my_dMod_data, myNlmeEst__,
                                   SIMOPT.nauxtimes, SIMOPT.auxtimes = NULL, SIMOPT.cores = 1,
                                   opt.method = "trust") {
  IDs__ <- stats::setNames(nm = names(my_dMod_data))
  parameters <- myNlmeEst__$modelSpec[c("POPvalues0", "POPestimate", "IIVdistribution", "IIVvalues0", "IIVestimate", "LOCmodel", "LOCvalues0", "LOCestimate")]
  IIVpars__ <- dMod_build_IIVpars(parameters = parameters, conditions = IDs__)
  forcings__ <- attr(my_dMod_data, "time_varying_regressors")
  x <- basic_dMod_model__$x
  if (!is.null(forcings__)) {
    x <- lapply(IDs__, function(C__) {
      mycontrols__ <- environment(environment(basic_dMod_model__$x)$mappings[[1]])$controls
      forcings_c__ <- forcings__[forcings__[["ID"]] == C__, ][, c("name", "time", "value")]
      forcings_c__ <- forcings_c__[order(forcings_c__[["time"]]),]
      forcings_c__ <- unique(forcings_c__)
      Xs(odemodel = basic_dMod_model__$model,
               forcings = forcings_c__,
               condition = C__,
               optionsOde = mycontrols__[["optionsOde"]],
               optionsSens = mycontrols__[["optionsSens"]],
               fcontrol = mycontrols__[["fcontrol"]]
      )
    })
    x <- Reduce("+", x)
    modelname(x) <- modelname(basic_dMod_model__$x)
  }
  indiv_objects__ <- dMod_build_indiv_grids(myNlmeEst__, my_dMod_data, basic_dMod_model__)
  fixed.grid__    <- indiv_objects__$fixed.grid
  est.grid__      <- indiv_objects__$est.grid
  est.vec__       <- indiv_objects__$est.vec
  trafo__ <- dMod_build_nlme_trafo(myNlmeEst__, IDs__, basic_dMod_model__)
  p__ <- dMod_build_nlme_p(trafo__)
  prd__ <- basic_dMod_model__[["g"]]*x*p__
  p_indiv__   <- dMod_P_indiv(p = p__, fixed.grid = fixed.grid__, est.grid = est.grid__)
  prd_indiv__ <- dMod_PRD_indiv(prd = prd__, fixed.grid = fixed.grid__, est.grid = est.grid__)
  obj__ <- obj_data__ <- NULL
  if (!is_IQRsysModelEst(myNlmeEst__)){
    obj__ <- obj_data__ <- dMod_normL2_indiv(data         = my_dMod_data,
                                             prd          = prd__,
                                             errmodel     = basic_dMod_model__[["e"]],
                                             fixed.grid   = fixed.grid__,
                                             est.grid     = est.grid__,
                                             SIMOPT.nauxtimes = SIMOPT.nauxtimes,
                                             SIMOPT.cores = SIMOPT.cores,
                                             opt.method   = opt.method)
    nlme.fix__ <- nlme.est__ <- nlme__ <- NULL
    if (length(IIVpars__$omegapars.est) > 0) {
      nlme.est__ <- constraintL2(mu = IIVpars__$ETA.est, sigma = unlist(IIVpars__$omegapars.est, use.names = FALSE), attr.name = "data")
      nlme__ <- nlme.est__
    }
    if (length(IIVpars__$omegapars.fix) > 0) {
      nlme.fix__ <- constraintL2(mu = IIVpars__$ETA.fix, sigma = exp(as.numeric(IIVpars__$omega.fix[unlist(IIVpars__$omegapars.fix, use.names = FALSE)])), attr.name = "data")
      nlme__ <- nlme.fix__
    }
    if (length(IIVpars__$omega.est) > 0 & length(IIVpars__$omega.fix) > 0)
      nlme__ <- nlme.est__ + nlme.fix__
    if (!is.null(nlme__))
      obj__ <- obj_data__ + nlme__
  }
  timerange__ <- suppressWarnings(range(as.data.frame(my_dMod_data)[["time"]]))
  if (!is.finite(timerange__[1])) timerange__[1] <- 0
  if (!is.finite(timerange__[2])) timerange__[2] <- 20
  times__     <- seq(min(0, timerange__[1]), timerange__[2], length.out = 200)
  times__     <- sort(unique(c(times__, SIMOPT.auxtimes)))
  covariateModel__        <- myNlmeEst__$modelSpec$covariateModel
  COVestimate__           <- myNlmeEst__$modelSpec$COVestimate
  covariateModelValues__  <- myNlmeEst__$modelSpec$covariateModelValues
  covNames                <- myNlmeEst__$data$covNames
  covariateMedianValues__ <- myNlmeEst__$data$covariateMedianValues
  covariateMedianValues__[intersect(covNames, names(myNlmeEst__$modelSpec$COVcentering))] <-
    myNlmeEst__$modelSpec$COVcentering[intersect(covNames, names(myNlmeEst__$modelSpec$COVcentering))]
  catNames                <- myNlmeEst__$data$catNames
  covariateCATreference__ <- myNlmeEst__$data$covariateCATreference
  covariateCATreference__[intersect(catNames, names(myNlmeEst__$modelSpec$COVcentering))] <-
    myNlmeEst__$modelSpec$COVcentering[intersect(catNames, names(myNlmeEst__$modelSpec$COVcentering))]
  parameters <- c(parameters, list(
    covariateModel = covariateModel__,
    covariateModelValues = covariateModelValues__,
    COVestimate = COVestimate__,
    COVcentering = c(covariateMedianValues__, covariateCATreference__)
  ))
  out__ <- dMod.frame(hypothesis = date(),
                            g = basic_dMod_model__[["g"]],
                            x = x,
                            p0 = list(p__),
                            p = p_indiv__,
                            data = my_dMod_data,
                            e = basic_dMod_model__[["e"]],
                            model = list(basic_dMod_model__[["model"]]))
  out__ <- appendObj(out__,
                           prd = list(prd_indiv__),
                           obj_data = list(obj_data__),
                           obj = list(obj__),
                           parameters = list(parameters),
                           pars = list(est.vec__),
                           est.grid = list(est.grid__),
                           fixed.grid = list(fixed.grid__),
                           times = list(times__),
                           ETA = list(c(IIVpars__$ETApars.est, IIVpars__$ETApars.fix)),
                           omega = list(IIVpars__$omegapars.est))
  class(out__) <- c("IQRsysModel", class(out__))
  attr(out__, "sysModelEst") <- list(
    model = myNlmeEst__$model,
    dosing = stats::setNames(
      object = lapply(seq_along(myNlmeEst__$dosingInfo[["INPUTnames"]]), function(i__) {
        c(type = myNlmeEst__$dosingInfo[["types"]][[i__]])
      }),
      nm = myNlmeEst__$dosingInfo[["INPUTnames"]]
    ),
    data = stats::setNames(
      object = myNlmeEst__$data[c("datafile", "covNames", "catNames", "regressorNames")],
      nm = c("datafile", "covNames", "catNames", "regressorNames")
    ),
    estSpec = myNlmeEst__$modelSpec,
    modelSpec = myNlmeEst__$modelSpec
  )
  out__ <- partable_IQRsysModel(out__)
  return(out__)
}
#'@export
modelSpec_IQRest <- function (
  POPvalues0,
  POPestimate = NULL,
  IIVdistribution = NULL,
  IIVvalues0 = NULL,
  IIVestimate = NULL,
  IOVvalues0 = NULL,
  IOVestimate = NULL,
  errorModel = NULL,
  covarianceModel = NULL,
  covariateModel = NULL,
  covariateModelValues = NULL,
  COVestimate = NULL,
  COVcentering = NULL,
  PriorVarPOP = NULL,
  PriorVarCovariateModelValues = NULL,
  PriorDFerrorModel = NULL,
  PriorIIV = NULL,
  PriorDFIIV = NULL
) {
  modelSpec <- list()
  modelSpec$POPvalues0 <- POPvalues0
  modelSpec$POPestimate <- POPestimate
  modelSpec$IIVdistribution <- IIVdistribution
  modelSpec$IIVvalues0 <- IIVvalues0
  modelSpec$IIVestimate <- IIVestimate
  modelSpec$IOVvalues0 <- IOVvalues0
  modelSpec$IOVestimate <- IOVestimate
  modelSpec$errorModel <- errorModel
  modelSpec$covarianceModel <- covarianceModel
  modelSpec$covariateModel <- covariateModel
  modelSpec$covariateModelValues <- covariateModelValues
  modelSpec$COVestimate <- COVestimate
  modelSpec$COVcentering <- COVcentering
  modelSpec$PriorVarPOP <- PriorVarPOP
  modelSpec$PriorVarCovariateModelValues <- PriorVarCovariateModelValues
  modelSpec$PriorDFerrorModel <- PriorDFerrorModel
  modelSpec$PriorIIV <- PriorIIV
  modelSpec$PriorDFIIV <- PriorDFIIV
  return(modelSpec)
}
#'@export
data_IQRest <- function (
  datafile,
  covNames = NULL,
  catNames = NULL,
  regressorNames = NULL
) {
  data <- list()
  data$datafile <- datafile
  data$covNames <- covNames
  data$catNames <- catNames
  data$regressorNames <- regressorNames
  return(data)
}
#'@export
dosing_IQRest <- function (...) {
  dots <- list(...)
  return(dots)
}
#'@export
addCovariateToModelSpec_IQRest <- function(
  modelSpec,
  covariateModel,
  covariateModelValues = NULL,
  COVestimate = NULL,
  COVcentering = NULL) {
  message("This function is deprecated. Please use addCov_modelSpec() instead.")
  modelSpec__ <- modelSpec
  if (class(covariateModel) != "list") stopIQR("covariateModel needs to be a list.")
  if (!is.null(COVestimate)) {
    if (class(COVestimate) != "list") stopIQR("COVestimate needs to be a list.")
    if (!setequal(names(COVestimate), names(covariateModel))) stopIQR("If given COVestimate needs contain entries for the same model parameters as covariateModel.")
    for (k__ in names(COVestimate))
      if (!setequal(names(COVestimate[[k__]]), covariateModel[[k__]])) stopIQR("If given COVestimate needs contain same covariate-parameter relationship as covariateModel.")
  }
  if (!is.null(covariateModelValues)) {
    if (class(covariateModelValues) != "list") stopIQR("covariateModelValues needs to be a list.")
    if (!setequal(names(covariateModelValues), names(covariateModel))) stopIQR("If given covariateModelValues needs contain entries for the same model parameters as covariateModel.")
    for (k__ in names(covariateModelValues))
      if (!setequal(names(covariateModelValues[[k__]]), covariateModel[[k__]])) stopIQR("If given covariateModelValues needs contain same covariate-parameter relationship as covariateModel.")
  }
  if ("COVcentering" %in% names(modelSpec__)) {
    check__ <- names(COVcentering) %in% names(modelSpec__$COVcentering)
    if (any(check__)) {
      warningIQR("Reference value for ", names(COVcentering)[check__], "already exists. Value will not be changed")
      COVcentering <- COVcentering[!check__]
    }
  }
  if (is.null(modelSpec__$covariateModel)) modelSpec__$covariateModel <- list()
  if (is.null(modelSpec__$covariateModelValues) & !is.null(covariateModelValues)) {
    modelSpec__$covariateModelValues <- list()
    for (kpar__ in names(modelSpec__$covariateModel)) {
      modelSpec__$covariateModelValues[[kpar__]] <- structure(rep(0.1, length(modelSpec__$covariateModel[[kpar__]])), names = modelSpec__$covariateModel[[kpar__]])
    }
  }
  if (is.null(modelSpec__$COVestimate) & !is.null(COVestimate)) {
    modelSpec__$COVestimate <- list()
    for (kpar__ in names(modelSpec__$covariateModel)) {
      modelSpec__$COVestimate[[kpar__]] <- structure(rep(1, length(modelSpec__$covariateModel[[kpar__]])), names = modelSpec__$covariateModel[[kpar__]])
    }
  }
  if (!is.null(modelSpec__$covariateModelValues) & is.null(covariateModelValues)) {
    covariateModelValues <- list()
    for (kpar__ in names(covariateModel)) {
      covariateModelValues[[kpar__]] <- structure(rep(0.1, length(covariateModel[[kpar__]])), names = covariateModel[[kpar__]])
    }
  }
  if (!is.null(modelSpec__$COVestimate) & is.null(COVestimate)) {
    COVestimate <- list()
    for (kpar__ in names(covariateModel)) {
      COVestimate[[kpar__]] <- structure(rep(1, length(covariateModel[[kpar__]])), names = covariateModel[[kpar__]])
    }
  }
  for (kpar__ in names(covariateModel)) {
    if (!is.null(modelSpec__$covariateModel[[kpar__]])) {
      check__ <- covariateModel[[kpar__]] %in% modelSpec__$covariateModel[[kpar__]]
      if (any(check__)) {
        warningIQR("Covariate relationship for ", covariateModel[[kpar__]][check__], " on ", kpar__, " already exists.")
        covariateModel[[kpar__]] <- covariateModel[[kpar__]][!check__]
        if (!is.null(covariateModelValues))
          covariateModelValues[[kpar__]] <- covariateModelValues[[kpar__]][names(covariateModelValues[[kpar__]])]
        if (!is.null(COVestimate))
          COVestimate[[kpar__]] <- COVestimate[[kpar__]][names(covariateModel[[kpar__]])]
      }
      if (length(covariateModel[[kpar__]]) > 0) {
        modelSpec__$covariateModel[[kpar__]] <- c(modelSpec__$covariateModel[[kpar__]], covariateModel[[kpar__]])
        if (!is.null(covariateModelValues))
          modelSpec__$covariateModelValues[[kpar__]] <- c(modelSpec__$covariateModelValues[[kpar__]], covariateModelValues[[kpar__]])
        if (!is.null(COVestimate))
          modelSpec__$COVestimate[[kpar__]] <- c(modelSpec__$COVestimate[[kpar__]], COVestimate[[kpar__]])
      } else {
        covariateModel[[kpar__]] <- NULL
      }
    } else {
      modelSpec__$covariateModel[[kpar__]] <- covariateModel[[kpar__]]
      if (!is.null(covariateModelValues))
        modelSpec__$covariateModelValues[[kpar__]] <- covariateModelValues[[kpar__]]
      if (!is.null(COVestimate))
        modelSpec__$COVestimate[[kpar__]] <- COVestimate[[kpar__]]
    }
  }
  if (!(is.null(COVcentering) | length(COVcentering) == 0)) {
    if (is.null(modelSpec__$COVcentering)) {
      modelSpec__$COVcentering <- COVcentering
    } else {
      modelSpec__$COVcentering <- c(modelSpec__$COVcentering, COVcentering)
    }
  }
  if (length(covariateModel) > 0) {
    messtext__ <- "\nThe following covariate relationships were added to the model specification:\n"
    for (k__ in seq_along(covariateModel)) {
      messtext__ <- paste0(messtext__,paste0(" - ", covariateModel[[k__]], " on ", names(covariateModel)[[k__]], "\n"))
    }
  } else {
    messtext__ <- "\nAll covariate relationships already in model specification.\n"
  }
  message(messtext__)
  modelSpec__
}
#'@export
addPar_modelSpec <- function(modelSpec, parname, value, estimate = NULL, distribution = NULL, IIVvalue = NULL, IIVestimate = NULL) {
  modelSpec[["POPvalues0"]][parname] <- value
  if (!is.null(estimate)) modelSpec[["POPestimate"]][parname] <- estimate
  if (!is.null(distribution)) modelSpec[["IIVdistribution"]][parname] <- distribution
  if (!is.null(IIVvalue)) modelSpec[["IIVvalues0"]][parname] <- IIVvalue
  if (!is.null(IIVestimate)) modelSpec[["IIVestimate"]][parname] <- IIVestimate
  return(modelSpec)
}
#'@export
addCov_modelSpec <- function(modelSpec, parname, covname, value = NULL, estimate = NULL, center = NULL) {
  if (is.null(modelSpec[["covariateModel"]])) {
    modelSpec[["covariateModel"]] <- structure(list(covname), names = parname)
  } else {
    modelSpec[["covariateModel"]][[parname]] <- union(modelSpec[["covariateModel"]][[parname]], covname)
  }
  if (!is.null(value)) {
    if (is.null(modelSpec[["covariateModelValues"]])) {
      modelSpec[["covariateModelValues"]] <- structure(list(structure(value, names = covname)), names = parname)
    } else {
      modelSpec[["covariateModelValues"]][[parname]][covname] <- value
    }
  }
  if (!is.null(estimate)) {
    if (is.null(modelSpec[["COVestimate"]])) {
      modelSpec[["COVestimate"]] <- structure(list(structure(estimate, names = covname)), names = parname)
    } else {
      modelSpec[["COVestimate"]][[parname]][covname] <- estimate
    }
  }
  if (!is.null(center)) {
    modelSpec[["COVcentering"]][[covname]] <- center
  }
  return(modelSpec)
}
#'@export
removePar_modelSpec <- function(modelSpec, parname) {
  fields__ <- c("POPvalues0", "POPestimate", "IIVdistribution",
                "IIVvalues0", "IIVestimate", "covariateModel",
                "covariateModelValues", "COVestimate", "COVcentering")
  for (n__ in fields__) {
    index__ <- which(names(modelSpec[[n__]]) %in% parname)
    if (length(index__) > 0 & length(modelSpec[[n__]]) > 0)
      modelSpec[[n__]] <- modelSpec[[n__]][-index__]
  }
  return(modelSpec)
}
#'@export
removeCov_modelSpec <- function(modelSpec, parname, covname) {
  newCovModelPar <- setdiff(modelSpec$covariateModel[[parname]], covname)
  if (length(newCovModelPar) == 0) newCovModelPar <- NULL
  modelSpec$covariateModel[[parname]] <- newCovModelPar
  fields__ <- c("covariateModelValues", "COVestimate")
  for (n__ in fields__) {
    newentry__ <- modelSpec[[n__]][[parname]][setdiff(names(modelSpec[[n__]][[parname]]), covname)]
    if (length(newentry__) == 0) newentry__ <- NULL
    modelSpec[[n__]][[parname]] <- newentry__
  }
  all_covariates__ <- Reduce(union, modelSpec[["covariateModel"]])
  if (length(all_covariates__) > 0)
    modelSpec[["COVcentering"]] <- modelSpec[["COVcentering"]][intersect(names(modelSpec[["COVcentering"]]), all_covariates__)]
  else
    modelSpec[["COVcentering"]] <- NULL
  return(modelSpec)
}
#'@export
print_modelSpec <- function(modelSpec, pop = TRUE, cov = TRUE, error = TRUE, prior = FALSE, loc = FALSE) {
  if (prior) warningIQR("Printing of prior information not yet supported.")
  if (loc)   warningIQR("Printing of local parameter information not yet supported.")
  fields.par <- c("POPvalues0", "POPestimate", "IIVdistribution", "IIVvalues0", "IIVestimate")
  fields.cov <- c("covariateModel", "covariateModelValues", "COVestimate")
  if (pop) {
    parameters <- Reduce(union, lapply(fields.par, function(n) names(modelSpec[[n]])))
    table <- lapply(fields.par, function(myfield) {
      structure(tibble(x = parameters, y = "."), names = c("Parameter", myfield))
    })
    table <- Reduce(function(x, y) left_join(x, y, by = "Parameter"), table)
    for (f in intersect(fields.par, names(modelSpec))) {
      values <- modelSpec[[f]][table$Parameter]
      if (is.numeric(values)) values <- signif(values, digits = 3)
      values <- as.character(values)
      values[is.na(values)] <- "."
      if (grepl("estimate", f)) {
        values[values == "0"] <- ""
        values[values == "1"] <- "+"
        values[values == "2"] <- "/"
      }
      table[[f]] <- values
    }
    cat("Parameter set-up:\n\n")
    print(as_IQRtable(table))
    cat("\n\n")
  }
  if (cov) {
    parameters <- Reduce(union, lapply(fields.cov, function(n) names(modelSpec[[n]])))
    covariates <- Reduce(union, lapply(modelSpec$covariateModel, identity))
    if (length(covariates) > 0) {
      table <- lapply(covariates, function(myfield) {
        structure(tibble(x = parameters, y = "."), names = c("Parameter", myfield))
      })
      table <- Reduce(function(x, y) left_join(x, y, by = "Parameter"), table)
      for (f in covariates) {
        if (is.null(modelSpec$covariateModelValues)) {
          values <- structure(rep(".", length(parameters)), names = parameters)
        } else {
          values <- modelSpec$covariateModelValues[intersect(names(modelSpec$covariateModelValues), parameters)]
          values <- structure(sapply(values, function(v) v[f]), names = names(values))
          values <- signif(values, 3)
          values <- sapply(values, as.character)
          values[is.na(values)] <- "."
        }
        if (is.null(modelSpec$COVestimate)) {
          estimate <- structure(rep("", length(parameters)), names = parameters)
        } else {
          estimate <- modelSpec$COVestimate[intersect(names(modelSpec$COVestimate), parameters)]
          estimate <- structure(sapply(estimate, function(v) v[f]), names = names(estimate))
          estimate <- sapply(estimate, as.character)
          estimate[is.na(estimate)] <- "."
          estimate[estimate == "."] <- ""
          estimate[estimate == "1"] <- "(+)"
          estimate[estimate == "0"] <- "(-)"
        }
        valest <- rep(".", length(parameters))
        valest[match(names(values), parameters)] <- values
        valest[match(names(estimate), parameters)] <- paste(valest[match(names(estimate), parameters)], estimate)
        table[[f]] <- valest
        centering <- modelSpec$COVcentering[[f]]
        if (!is.null(centering)) names(table)[match(f, names(table))] <- paste0(f, " (", centering, ")")
      }
      cat("Covariate set-up:\n\n")
      print(as_IQRtable(table))
      cat("\n\n")
    }
  }
  if (error) {
    outputs <- modelSpec$errorModel
    if (length(outputs) > 0) {
      table <- matrix(".", nrow = length(outputs)+1, ncol = 3)
      table[1,] <- c("Output", "abs", "rel")
      for (i in seq_along(outputs)) {
        table[i + 1, 1] <- names(outputs)[i]
        values <- dplyr::case_when(outputs[[i]][1] == "abs" ~ c(outputs[[i]][2], ""),
                                   outputs[[i]][1] == "rel" ~ c("", outputs[[i]][2]),
                                   outputs[[i]][1] == "absrel" ~ outputs[[i]][2:3])
        values[is.na(values)] <- ""
        table[i + 1, 2:3] <- values
      }
      cat("Error model set-up:\n\n")
      print(as_IQRtable(table))
      cat("\n\n")
    }
  }
  invisible()
}
#'@export
create_IQReventTable <- function(dosing, indivData, regression = NULL, abs0inputs=NULL, abs0Tk0param=NULL) {
  if (!is.data.frame(indivData)) stopIQR("indivData argument is not a data.frame")
  eData__ <- create_IQReventData(dosing, indivData)
  if (is.null(regression)) regressNames__ <- setdiff(names(indivData), c("ID", "USUBJID")) else regressNames__ <- regression
  eTable__ <- IQReventTable(
    eData__,
    regression = regressNames__,
    abs0inputs=abs0inputs, abs0Tk0param=abs0Tk0param
  )
  eTable__
}
#'@export
create_IQReventData <- function(dosing, indivData) {
  if (!(is_IQRdosing(dosing))) {
    if ("list" %in% class(dosing)) {
      if (!all(sapply(dosing, is_IQRdosing))) stopIQR("List of dosings does not exclusively contain IQRdosing objects.")
    } else {
      stopIQR("'dosing'is not an IQRdosing object.")
    }
  }
  if (!("ID" %in% names(indivData))) stopIQR("'indivData' needs to contain ID column.")
  indivData$ID <- as.character(indivData$ID)
  IDs <- unique(indivData$ID)
  if ("list" %in% class(dosing)) {
    if (is.null(names(dosing))) {
      if (length(dosing) != length(unique(indivData$ID)))
        stopIQR("Number of dosings in list does not match number of individuals in indivData.")
      warningIQR("List of dosings unnamed. Individuals in indivData are match by order of occurence.")
      names(dosing) <- unique(indivData$ID)
    } else {
      if (!(all(names(dosing) %in% as.character(unique(indivData$ID))) &
            all(as.character(unique(indivData$ID)) %in% names(dosing))))
        stopIQR("Names of dosing list is not equal to IDs in indivData.")
    }
  } else {
    dosing <- plyr::alply(IDs, 1, function(x) dosing)
    names(dosing) <- IDs
  }
  eventData <- plyr::adply(IDs, 1, function(x) {
    dosi__ <- dosing[[x]]
    dati__ <- dplyr::filter(indivData, ID == x)
    dosi__$ID <- x
    bycol__ <- intersect(names(dosi__), names(dati__))
    out__ <- dplyr::full_join(dosi__, dati__, by = bycol__)
    out__ <- dplyr::arrange(out__,TIME)
  }, .id = "ID")
  eventData$ID <- as.numeric(eventData$ID)
  eventData
}
#'@export
extract_IQRdosing <- function(data, FLAGunique = FALSE, TIMEcol = "TIME") {
  data__ <- data
  if (!(TIMEcol %in% names(data__))) stopIQR("Time column not available in data. Check also 'TIMEcol' input.")
  data__$TIME <- data__[[TIMEcol]]
  reqCol__ <- c("ID", "TIME", "EVID", "ADM", "AMT")
  if (!all(reqCol__ %in% names(data__)))  {
    miss__ <- setdiff(reqCol__, names(data__))
    stopIQR(paste0(paste0(miss__, collapse = ", ")," missing in input dataset."))
  }
  data__ <- dplyr::filter(data__, EVID == 1)
  if ("ADDL" %in% names(data__)) {
    data__$ADDL[is.na(data__$ADDL)] <- 0
    flagADDL__ <- data__$ADDL > 0
    idxADDL__ <- which(flagADDL__)
    if (length(idxADDL__) > 0) {
      if (!("II" %in% names(data__))) stopIQR("For some dosing records ADDL is positive, but II column is missing.")
      data__$II[is.na(data__$II)] <- 0
      idxII__ <- which(data__$II > 0)
      if (!all(idxADDL__ %in% idxII__)) stopIQR("For some dosing records ADDL is positive, but II entry not.")
      dataADDL__ <- data__[idxADDL__,]
      dataExp__ <- plyr::adply(dataADDL__, 1, function(x__) {
        out__ <- x__[rep(1,x__$ADDL+1),]
        out__$TIME <- seq(x__$TIME, length.out = x__$ADDL+1, by = x__$II)
        out__$ADDL <- 0
        out__
      })
      data__ <- rbind(data__[!flagADDL__,], dataExp__)
    }
  }
  if ("RATE" %in% names(data__)) {
    data__$RATE[is.na(data__$RATE)] <- 0
    flagRATE__ <- data__$RATE > 0
  } else {
    flagRATE__ <- NULL
  }
  if ("TINF" %in% names(data__)) {
    data__$TINF[is.na(data__$TINF)] <- 0
    flagTINF__ <- data__$TINF > 0
  } else {
    flagTINF__ <- NULL
    data__$TINF <- 0
  }
  if (any(flagTINF__ & flagRATE__)) stopIQR("TINF>0 and RATE>0 defined for dosing record.")
  if (!is.null(flagRATE__)) data__$TINF[flagRATE__] <- data__$AMT[flagRATE__] / data__$RATE[flagRATE__]
  data__$TINF[data__$TINF == 0] <- 1e-4
  data__ <- data__[,c("ID", "TIME", "ADM", "AMT", "TINF")]
  out__ <- plyr::dlply(data__, ~ID, function(x) {
    xx__ <- x
    xx__$ID <- NULL
    class(xx__) <- c("IQRdosing","data.frame")
    xx__
  })
  attr(out__,"split_type") <- NULL
  attr(out__,"split_labels") <- NULL
  if (FLAGunique) {
    idxUNIQUE <- !duplicated(out__)
    out__ <- out__[idxUNIQUE]
    names(out__) <- NULL
  }
  return(out__)
}
hasError <- function(object, FLAGrecursive = TRUE) {
  if(inherits(object, "try-error")) {
    TRUE
  } else if(is.vector(object) && FLAGrecursive) {
    any(sapply(object, inherits, "try-error"))
  } else {
    FALSE
  }
}
getErrorMessage <- function(object, FLAGrecursive = TRUE) {
  if(hasError(object)) {
    if(inherits(object, "try-error")) {
      toString(object)
    } else if(is.vector(object) && FLAGrecursive){
      errorMessages <- ""
      for(o__ in object) {
        if(inherits(o__, "try-error")) {
          errorMessages <- paste0(errorMessages, toString(o__), "\n")
        }
      }
      errorMessages
    } else {
      ""
    }
  }
}
aux_getFileGitRevision <- function (filename,revision,outputfile) {
  if (nchar(revision) < 5) stop
  if (!file.exists(filename)) stopIQR("File chosen with filename does not exist. Note: use relative paths from the current working directory.")
  if (file.exists(outputfile)) stopIQR("Output file exists and will not be overwritten. Delete yourself if desired.")
  command <- paste0("git show ",revision,":./",filename,"> ",outputfile)
  content <- suppressWarnings(shell(command))
  if (file.size(outputfile)==0) {
    unlink(outputfile)
    stopIQR("Chosen filename either did not exist in the selected revision - or revision number is wrong.")
  }
}
#'@export
tempdirIQR <- function(check=FALSE){
  out <- tempdir(check=check)
  out <- gsub("\\","/",out,fixed=TRUE)
  out
}
#'@export
tempfileIQR <- function(pattern = "file", tmpdir = tempdirIQR(), fileext = ""){
  out <- tempfile(pattern = pattern, tmpdir = tmpdir, fileext = fileext)
  out <- gsub("\\","/",out,fixed=TRUE)
  out
}
#'@export
stopIQR <- function(..., call.=FALSE,domain=NULL){
  stop(..., call.=call., domain=domain)
}
#'@export
warningIQR <- function(..., call.=FALSE,domain=NULL){
  warning(..., call.=call., domain=domain)
}
aux_getOS <- function(){
  i <- Sys.info()[["sysname"]]
  if (i=="Windows") return("windows")
  if (i=="Darwin") return("mac")
  if (i=="Linux") return("unix")
  stopIQR("Unknown operating system")
}
aux_closePDFs <- function() {
  tryCatch({
    mydevs <- grDevices::dev.list()
    dummy <- sapply(mydevs[names(mydevs) %in% c("pdf")], function (x) {
      grDevices::dev.off(x)
    })
  },error=function(x){})
  if (1==1) {a=1}
}
aux_closePNGs <- function() {
  if (aux_getOS()=="mac") {
    grDevices::graphics.off()
    return(invisible(NULL))
  }
  tryCatch({
    mydevs <- grDevices::dev.list()
    dummy <- sapply(mydevs[names(mydevs) %in% c("png")], function (x) {
      grDevices::dev.off(x)
    })
  },error=function(x){})
  return(invisible(NULL))
}
aux_closeDevice <- function(device) {
  if (grepl("pdf", device, ignore.case = TRUE)) aux_closePDFs()
  if (grepl("png", device, ignore.case = TRUE)) aux_closePNGs()
}
#'@export
aux_version <- function(pkgName="IQRtools", IQdesktop=NULL, exactVersion=NULL, minVersion=NULL,Rversion=NULL,isRopen=NULL,OS=NULL) {
  curVersion__ <- tryCatch(
    utils::packageVersion(pkgName),
    error=function (err) return ("No version present")
    )
  if (is.null(curVersion__)) return (NULL) 
  if (is.null(minVersion) & is.null(exactVersion) & is.null(IQdesktop)) {
    return(curVersion__)
  }
  if (!is.null(IQdesktop)) {
    if (!isIQdesktop()) stopIQR("You are not using IQdesktop (might not be a problem if everything else is well set up)")
    currentIQdesktopVersion <- getIQdesktopversion()
    if (currentIQdesktopVersion!=IQdesktop) stopIQR(sprintf("IQdesktop version %s required. You are using version %s",IQdesktop,currentIQdesktopVersion))
  }
  if (!is.null(minVersion)) {
    if (curVersion__ < minVersion) {
      stopIQR(sprintf("Package %s version is %s - but at least %s is required", pkgName, curVersion__, minVersion))
    }
  }
  if (!is.null(exactVersion)) {
    if (curVersion__ != exactVersion) {
      stopIQR(sprintf("Package %s version is %s - but version %s is required", pkgName, curVersion__, exactVersion))
    }
  }
  if (!is.null(Rversion)) {
    currentVersion <- paste0(version$major,".",version$minor)
    if (currentVersion != Rversion) {
      stopIQR(paste0("Your current R version (",currentVersion,") does not match the version the analysis was written for (",Rversion,").\n  You can on your own risk remove the 'Rversion' argument in the aux_version() function and run this script.\n  Or use the indicated version. We need to do this in order to ensure 100% reproducibility at all times."))
    }
  }
  if (!is.null(isRopen)) {
    if (!is.logical(isRopen)) stopIQR("isRopen needs to be TRUE or FALSE.")
    instPack <- utils::installed.packages()[,1]
    currentIsRopen <- "MicrosoftR" %in% instPack
    if (isRopen == TRUE & currentIsRopen == FALSE) stopIQR("You are using R, but the script was written for R open.\n  You can on your own risk remove the 'isRopen' argument in the aux_version() function and run this script.\n  Or use R Open instead of R. We need to do this in order to ensure 100% reproducibility at all times.")
    if (isRopen == FALSE & currentIsRopen == TRUE) stopIQR("You are using R open, but the script was written for R.\n  You can on your own risk remove the 'isRopen' argument in the aux_version() function and run this script.\n  Or use R instead of R Open. We need to do this in order to ensure 100% reproducibility at all times.")
  }
  if (!is.null(OS)) {
    if (OS != .Platform$OS.type) {
      stopIQR(paste0("Your current operating system (",.Platform$OS.type,") does not match the OS the analysis was written for (",OS,").\n  You can on your own risk remove the 'OS' argument in the aux_version() function and run this script.\n  Or use the indicated OS. We need to do this in order to ensure 100% reproducibility at all times."))
    }
  }
  return(TRUE)
}
#'@export
gen_aux_version <- function(pkgName="IQRtools", automode = TRUE, exactVersion=TRUE, IQdesktop=TRUE, Rversion=TRUE,isRopen=TRUE,OS=TRUE) {
  args <- list(
    pkgName = pkgName,
    exactVersion = tryCatch(as.character(utils::packageVersion(pkgName)),
                            error = function (err) return ("No version present")),
    IQdesktop = getIQdesktopversion(),
    Rversion = paste0(version$major,".",version$minor),
    isRopen = {
      instPack <- utils::installed.packages()[,1]
      "MicrosoftR" %in% instPack
    },
    OS = .Platform$OS.type
  )
  if (automode) {
    if (isIQdesktop()) {
      IQdesktop <- TRUE
      exactVersion <- Rversion <- isRopen <- OS <- FALSE
    } else {
      IQdesktop <- FALSE
      exactVersion <- Rversion <- isRopen <- OS <- TRUE
    }
  }
  if (!exactVersion) args[["exactVersion"]] <- NULL
  if (!IQdesktop | !isIQdesktop()) args[["IQdesktop"]] <- NULL
  if (!Rversion) args[["Rversion"]] <- NULL
  if (!isRopen) args[["isRopen"]] <- NULL
  if (!OS) args[["OS"]] <- NULL
  args <- paste(names(args), "=", sapply(args, function(a) ifelse(is.character(a), paste0("\"", a, "\""), a)))
  args <- paste(args, collapse = ", ")
  args <- paste0("aux_version(", args, ")")
  args <- sub("pkgName = ", "", args)
  return(args)
}
isIQdesktop <- function () {
  if (!file.exists("/IQDESKTOP/.version")) return (FALSE)
  return(TRUE)
}
getIQdesktopversion <- function () {
  if (!isIQdesktop()) return (NULL)
  aux_fileread("/IQDESKTOP/.version")
}
#'@export
aux_quantilenumber <- function(x, probs=c(0.25,0.5,0.75), na.rm=TRUE) {
  q <- c(min(x,na.rm = TRUE), stats::quantile(x = x,probs = probs,na.rm=TRUE),Inf)
  Qx <- rep(NA,length(x))
  lapply(1:(length(q)-1), function (k__) {
    Qx[x>=q[k__] & x<q[k__+1]] <<- k__
  })
  return(list(quantilenumbers=Qx,quantiles=q))
}
#'@export
aux_unlevel <- function(x) {
  if (!is.null(levels(x))) {
    x <- levels(x)[as.numeric(x)]
  }
  return(x)
}
#'@export
logit <- function (x) {
  if (any(x<=0 | x>=1)) stopIQR("Argument not between 0 and 1")
  log(x/(1-x))
}
#'@export
inv_logit <- function (x) {
  1/(1+exp(-x))
}
#'@export
aux_na_locf <- function(x,T=NULL) {
  v <- !is.na(x)
  y <- c(NA, x[v])[cumsum(v)+1]
  if (!is.null(T)) {
    naTindex <- which(is.na(T))
    T[is.na(T)] <- 999999999+naTindex 
    z <- data.frame(T=T,y=y)
    sZ <- split(z,z$T)
    z2 <- do.call(rbind,lapply(sZ,function (d) {
      d$y <- d$y[nrow(d)]
      d
    }))
    y <- z2$y
  }
  y
}
#'@export
aux_strtrim <- function(input) {
  return(gsub("^\\s+|\\s+$", "", input))
}
#'@export
aux_strrep <- function(origstr,oldsubstr,newsubstr) {
  return(gsub(oldsubstr, newsubstr, origstr, fixed="TRUE"))
}
aux_removeWhiteSpace <- function(inputText) {
  return(gsub("\\s+|\\s+", "", inputText))
}
aux_strmatch <- function(inputVec,searchString) {
  x <- which(inputVec==searchString)
  if (length(x)==0) return (NULL)
  return(unname(x))
}
#'@export
aux_explode <- function(input,separator=",") {
  return(unlist(strsplit(input,separator)))
}
#'@export
aux_explodePC <- function(input,separator=",",group="round") {
  if (group=="round") {
    groupStart__ <- "("
    groupEnd__   <- ")"
  }
  if (group=="square") {
    groupStart__ <- "["
    groupEnd__   <- "]"
  }
  if (group=="curly") {
    groupStart__ <- "{"
    groupEnd__   <- "}"
  }
  if (group!="round" & group!="square" & group!="curly") stopIQR("wrong group definition")
  elements        <- c()
  openParenthesis <- 0
  lastIndex       <- 1
  elementIndex    <- 1
  for (k2 in 1:nchar(input)) {
    if (substr(input,k2,k2) == groupStart__) {
      openParenthesis <- openParenthesis + 1
    } else {
      if (substr(input,k2,k2) == groupEnd__) {
        openParenthesis <- openParenthesis - 1;
      } else {
        if ((substr(input,k2,k2) == separator) & (openParenthesis == 0)) {
          elements[elementIndex] <- aux_strtrim(substr(input,lastIndex,k2-1))
          elementIndex           <- elementIndex + 1
          lastIndex              <- k2+1
        }
      }
    }
  }
  elements[elementIndex] <- aux_strtrim(substr(input,lastIndex,nchar(input)))
  return(elements)
}
#'@export
aux_strFindAll <- function(input,searchString) {
  x      <- gregexpr(pattern=searchString,input,fixed=TRUE)
  start  <- unlist(x)
  end <- start+attr(x[[1]],"match.length")-1
  if (length(start)==1 && start==-1)
    return(list(start=NULL,end=NULL))
  else
    return(list(start=start,end=end))
}
#'@export
aux_fileparts <- function(filename.with.path){
  pathname <- dirname(filename.with.path)
  filename <- basename(filename.with.path)
  fileext <- gsub(".*(\\.[^\\.]*)$","\\1",filename)
  filename <- gsub("(.*)(\\.[^\\.]*)$","\\1",filename)
  for (k in seq_along(filename)) {
    if(fileext[k]==filename[k]) fileext[k] <- ""
  }
  return(list(pathname=pathname,filename=filename,fileext=fileext))
}
#'@export
aux_filewrite <- function(text,filename) {
  if (is.null(filename)) return(0)
  fid <- aux_fopen(filename, mode="w")
  write(text, fid)
  aux_fclose(fid)
}
#'@export
aux_fileread <- function(filename,collapserows=TRUE) {
  fid <- aux_fopen(filename, mode="r")
  text <- readLines(fid)
  aux_fclose(fid)
  if (collapserows) {
    text <- paste(text,collapse="\n")
  }
  return(text)
}
#'@export
aux_mkdir <- function(pathdir) {
  suppressWarnings(if (!file.exists(pathdir)) dir.create(pathdir,recursive='TRUE'))
}
#'@export
aux_rmdir <- function(pathdir) {
  unlink(pathdir,recursive = 'TRUE')
}
aux_fopen <- function(filename,mode="w") {
  if (mode=="w") aux_mkdir(aux_fileparts(filename)$pathname)
  fid <- file(filename,open=mode)
  return(fid)
}
aux_fclose <- function(fid) {
  close(fid)
}
aux_fwrite <- function(fid,text) {
  write(text,fid)
}
aux_isnumericVector <- function(input) {
  return (!(NA %in% suppressWarnings(as.numeric(as.character(input)))))
}
#'@export
aux_preFillChar <- function(value2prefill,lengthString,fillChar) {
  if (nchar(value2prefill) >= lengthString) {
    lengthString <- nchar(value2prefill)
  }
  result <- paste0(c(paste0(rep(fillChar,lengthString-nchar(as.character(value2prefill))),collapse=""),
                     as.character(value2prefill)),collapse="")
  return(result)
}
#'@export
aux_postFillChar <- function(value2postfill,lengthString,fillChar) {
  if (nchar(value2postfill) >= lengthString) {
    lengthString <- nchar(value2postfill)
  }
  result <- tryCatch({
    paste0(c(as.character(value2postfill)),
                   paste0(rep(fillChar,lengthString-nchar(as.character(value2postfill))),collapse=""),
                   collapse="")
  }, error = function (msg) {
    result
  })
  return(result)
}
#'@export
aux_splitVectorEqualPieces <- function(x,n) {
  if (n>=length(x)) return(list(x))
  n_pieces_same_length <- round(length(x)/n)
  out   <- list()
  for (k in 1:n_pieces_same_length)
    out[[k]] <- x[seq(1+(k-1)*n,n+(k-1)*n)]
  if (n_pieces_same_length*n<length(x)) {
    k <- length(out)+1
    out[[length(out)+1]] <- x[seq(1+(k-1)*n,length(x))]
  }
  return(out)
}
aux_repStringElements <- function(string,old,new) {
  for (k in seq_along(old))
    string <- gsub(x = string,pattern = paste0("\\b",old[k],"\\b"),replacement = new[k])
  return(string)
}
aux_wrapText <- function(text,ncol,npre) {
  textwork__            <- text
  wraptext__            <- ""
  while (nchar(textwork__) > ncol) {
    ixSpace__ <- which(charToRaw(textwork__)==32)
    ixSpaceAbove__ <- which(ixSpace__>ncol)
    if (length(ixSpaceAbove__) > 0) {
      ixSpaceLimit__ <- ixSpace__[ixSpaceAbove__[1]-1]
    } else {
      ixSpaceLimit__ <- ixSpace__[length(ixSpace__)]
    }
    wraptext__ <- sprintf('%s%s\n',wraptext__,substr(textwork__,1,ixSpaceLimit__-1))
    textwork__ <- paste0(paste0(rep(" ",npre),collapse=""), substr(textwork__,ixSpaceLimit__+1,nchar(textwork__)))
  }
  wraptext__ = aux_strtrim(sprintf('%s%s\n',wraptext__,textwork__))
  return(wraptext__)
}
#'@export
aux_getRelPath <- function(fromFolder,toFolder) {
  if (fromFolder==toFolder) return("./")
  toFolder_vec__    <- aux_explode(toFolder,"/")
  fromFolder_vec__ <- aux_explode(fromFolder,"/")
  if (toFolder_vec__[1] != fromFolder_vec__[1])
    stopIQR("Absolute path of fromFolder and toFolder do not share the same root")
  maxLength__ <- min(length(toFolder_vec__),length(fromFolder_vec__))
  foundDIFF__ <- FALSE
  for (k in 1:maxLength__) {
    if (toFolder_vec__[k] != fromFolder_vec__[k]) {
      diff_elements_toFolder__ <- toFolder_vec__[k:length(toFolder_vec__)]
      diff_elements_fromFolder__ <- fromFolder_vec__[k:length(fromFolder_vec__)]
      foundDIFF__ <- TRUE
      break()
    }
  }
  if (!foundDIFF__) {
    diff_elements_toFolder__ <- toFolder_vec__[maxLength__:length(toFolder_vec__)]
    diff_elements_fromFolder__ <- fromFolder_vec__[maxLength__:length(fromFolder_vec__)]
  }
  returnFrom__ <- c(rep("..",length(diff_elements_fromFolder__)))
  gotTo__      <- diff_elements_toFolder__
  fromTo__     <- c(returnFrom__,gotTo__)
  relPath__ <- paste0(fromTo__,collapse="/")
  return(relPath__)
}
#'@export
aux_simplifypath <- function(path) {
  tmp0 <- aux_explode(path,"/")
  tmp0 <- tmp0[grep("^[.]$", tmp0, invert = TRUE)]
  tmp <- tmp0
  idxnodots <- c(grep("..",tmp, fixed = TRUE, invert = TRUE),length(tmp)+1)
  step <- diff(idxnodots)
  while (any(step>1)) {
    idx0 <- which(step>1)[1]
    tmp <- tmp[-(idxnodots[idx0]+c(0,1))]
    idxnodots <- c(grep("..",tmp, fixed = TRUE, invert = TRUE),length(tmp)+1)
    step <- diff(idxnodots)
  }
  paste0(tmp,collapse = "/")
}
#'@export
geomean <- function (x, na.rm = FALSE)
{
  if (!is.vector(x, mode = "numeric") || is.factor(x))
    stopIQR("'x' must be a numeric vector")
  wna <- which(is.na(x))
  if (length(wna)) {
    if (na.rm)
      x <- x[-wna]
    else return(NA)
  }
  if (any(x <= 0)) {
    warningIQR("Non-positive values in 'x'")
    return(NA)
  }
  else return(exp(mean(log(x[x>0]))))
}
#'@export
geosd <- function (x, na.rm = FALSE, sqrt.unbiased = TRUE)
{
  if (!is.vector(x, mode = "numeric") || is.factor(x))
    stopIQR("'x' must be a numeric vector")
  wna <- which(is.na(x))
  if (length(wna)) {
    if (na.rm)
      x <- x[-wna]
    else return(NA)
  }
  if (any(x <= 0)) {
    warningIQR("Non-positive values in 'x'")
    return(NA)
  }
  else {
    sd.log <- sd(log(x))
    if (!sqrt.unbiased) {
      n <- length(x)
      sd.log <- sqrt((n - 1)/n) * sd.log
    }
  }
  exp(sd.log)
}
#'@export
geocv <- function (x, na.rm = FALSE)
{
  sqrt(exp(stats::sd(log(x), na.rm = na.rm)^2) - 1) * 100
}
getSymbols <- function(char, exclude = NULL) {
  char <- char[char!="0"]
  out <- parse(text=char, keep.source = TRUE)
  out <- utils::getParseData(out)
  names <- unique(out$text[out$token == "SYMBOL"])
  if(!is.null(exclude)) names <- names[!names%in%exclude]
  return(names)
}
replaceSymbols <- function(what, by, x) {
  xOrig <- x
  is.not.zero <- which(x!="0")
  x <- x[is.not.zero]
  mynames <- names(x)
  x.parsed <- parse(text = x, keep.source = TRUE)
  data <- utils::getParseData(x.parsed)
  by <- rep(by, length.out=length(what))
  names(by) <- what
  data$text[data$text%in%what] <- by[data$text[data$text%in%what]]
  data <- data[data$token!="expr",]
  breaks <- c(0, which(diff(data$line1) == 1), length(data$line1))
  out <- lapply(1:(length(breaks)-1), function(i) {
    paste(data$text[(breaks[i]+1):(breaks[i+1])], collapse="")
  })
  names(out) <- mynames
  out <- unlist(out)
  xOrig[is.not.zero] <- out
  return(xOrig)
}
#'@export
#'@importFrom stats median
#'@importFrom utils tail
clusterX <- function(x, y = NULL, groupsize = 5, resolution = 0.1, lambda = 1, iterlim = 100, log = FALSE) {
  n_inner <- groupsize
  n_iter <- iterlim
  n_min <- 1 
  alpha <- 0 
  if (log & any(x <= 0))
    stopIQR("When argument log = TRUE, x values must be strictly positive.")
  if (is.null(y)) y <- rep(1, length(x))
  if (!is.null(y) & length(y) != length(x))
    stopIQR("x and y must have the same length.")
  x <- cbind.data.frame(TIME = x, VALUE = y)
  x <- x[order(x[[1]]),]
  is_finite <- Reduce("&", lapply(x, is.finite))
  if (all(!is_finite))
    stopIQR("x contains only NA/NaN/Inf values.")
  if (any(!is_finite)) {
    x <- x[is_finite,]
    warningIQR("x or y contained NA/NaN/Inf values. These were removed befor applying the clustering algorithm.")
  }
  if (log) x[[1]] <- log(x[[1]])
  getMu <- function(x) {
    do.call(rbind, lapply(split(x, x[["block"]]), function(d) {
      c(mu1 = median(d[[1]]),
        mu2 = median(d[[2]]))
    }))
  }
  getB <- function(x) {
    do.call(rbind, lapply(split(x, x[["block"]]), function(d) {
      c(b1 = max(c(sum(abs(d[[1]] - median(d[[1]])))/length(d[[1]]), 1e-16)),
        b2 = max(c(sum(abs(d[[2]] - median(d[[2]])))/length(d[[2]]), 1e-16)))
    }))
  }
  getBlocks <- function(d) {
    d <- d[!is.na(d)]
    q <- structure(as.numeric(names(d)), names = d)
    cl <- list()
    if (length(d) > 0) {
      for (i in 1:length(d)) {
        cl[[i]] <- c(as.numeric(q[1]), as.numeric(d[1]))
        for (j in 1:length(d)) {
          cl_new <- unique(c(cl[[i]], d[names(d) %in% as.character(cl[[i]])], q[names(q) %in% as.character(cl[[i]])]))
          if (length(setdiff(cl_new, cl[[i]])) == 0) break else cl[[i]] <- cl_new
        }
        d <- d[setdiff(names(d), cl[[i]])]
        q <- structure(as.numeric(names(d)), names = d)
        if (length(d) == 0) break
      }
    }
    return(cl)
  }
  x[["block"]] <- ceiling(seq_along(x[[1]])/n_inner)
  counts <- table(x[["block"]])
  if (tail(counts, 1) < n_min) x[["block"]][x[["block"]] == length(counts)] <- length(counts) - 1
  mu <- getMu(x)
  d <- outer(mu[, 1], mu[, 1], function(x, y) abs(x - y)/resolution); diag(d) <- Inf
  d <- apply(d, 1, function(x) which(x <= 1)[1])
  blocks <- getBlocks(d)
  for (b in blocks) x[["block"]][x[["block"]] %in% b] <- b[1]
  blocks <- unique(x[["block"]])
  x[["block"]] <- match(x[["block"]], blocks)
  for (i in 1:n_iter) {
    mu <- getMu(x)
    b <- getB(x)
    d1 <- t(t(outer(x[, 1], mu[, 1], function(x, y)  abs(x - y)))/b[,1] + lambda*log(b[,1]^2))
    d2 <- t(t(outer(x[, 2], mu[, 2], function(x, y)  abs(x - y)))/b[,2] + lambda*log(b[,2]^2))
    d <- cos(alpha)*d1 + sin(alpha)*d2
    block_old <- x[["block"]]
    block_new <- apply(d, 1, which.min)
    counts <- table(block_new)
    x[["block"]] <- block_new
    if (any(counts < n_min)) {
      small_blocks <- counts[counts < n_min]
      k <- 1
      while (k <= length(small_blocks)) {
        block_nr <- names(small_blocks)[k]
        block_counts <- small_blocks[[k]]
        while (block_counts < n_min) {
          block_nr_next <- as.character(as.numeric(block_nr[length(block_nr)]) + 1)
          block_nr <- c(block_nr, block_nr_next)
          block_counts <- block_counts + counts[block_nr_next]
        }
        index <- x[["block"]] %in% block_nr
        x[["block"]][index] <- block_nr[1]
        available <- which(names(small_blocks) %in% as.character(x[["block"]]))
        if (any(available > k)) {
          k <- seq_along(small_blocks)[available[available > k]][1]
        } else break
      }
    }
    x <- x[order(x[["block"]], x[[1]]),]
    blocks <- unique(x[["block"]])
    x[["block"]] <- match(x[["block"]], blocks)
    if (all(block_new == block_old) & all(counts >= n_min)) {
      break
    }
  }
  if (i == n_iter) warningIQR("Algorithm did not converge.")
  if (log) x[[1]] <- exp(x[[1]])
  x[["block"]] <- factor(as.character(x[["block"]]), levels = as.character(sort(unique(x[["block"]]))))
  return(x)
}
#'@export
#'@importFrom stats median quantile
statXY <- function(x, y = NULL, ..., quantiles = c(0.05, 0.95)) {
  clout <- clusterX(x = x, y = y, ...)
  if (any(y <= 0))
    warningIQR("NA values returned for GEOMETRICAL MEAN or SD due to y-values <= 0.")
  out <- do.call(rbind, lapply(split(clout, clout[[3]]), function(d) {
    t <- d[[1]]
    y <- d[[2]]
    group <- as.numeric(as.character(d[[3]]))
    d <- data.frame(
      GROUP = group[1],
      TIME = mean(t, na.rm = TRUE),
      MEAN.VALUE = mean(y, na.rm = TRUE),
      MEDIAN.VALUE = median(y, na.rm = TRUE),
      SD.VALUE = sd(y, na.rm = TRUE),
      SE.VALUE = sd(y, na.rm = TRUE)/sqrt(length(y)),
      GEOMMEAN.VALUE = suppressWarnings(exp(mean(log(y)))),
      GEOMSD.VALUE = suppressWarnings(exp(sd(log(y))))
    )
    quantile_names <- paste0("P", round(100*quantiles), ".VALUE")
    quantile_data <- lapply(quantiles, function(q) as.numeric(stats::quantile(y, probs = q, na.rm = TRUE)))
    names(quantile_data) <- quantile_names
    quantile_data <- as.data.frame(quantile_data)
    cbind(d, quantile_data)
  }))
  attr(out, "clusterOut") <- clout
  return(out)
}
#'@export
ginv <- function(X, tol = sqrt(.Machine$double.eps)) {
  if(length(dim(X)) > 2L || !(is.numeric(X) || is.complex(X)))
    stopIQR("'X' must be a numeric or complex matrix")
  if(!is.matrix(X)) X <- as.matrix(X)
  Xsvd <- svd(X)
  if(is.complex(X)) Xsvd$u <- Conj(Xsvd$u)
  Positive <- Xsvd$d > max(tol * Xsvd$d[1L], 0)
  if (all(Positive)) Xsvd$v %*% (1/Xsvd$d * t(Xsvd$u))
  else if(!any(Positive)) array(0, dim(X)[2L:1L])
  else Xsvd$v[, Positive, drop=FALSE] %*% ((1/Xsvd$d[Positive]) * t(Xsvd$u[, Positive, drop=FALSE]))
}
#'@export
mvrnorm <- function(n = 1, mu, Sigma, tol=1e-6, empirical = FALSE) {
  p <- length(mu)
  if(!all(dim(Sigma) == c(p,p))) stopIQR("incompatible arguments")
  eS <- eigen(Sigma, symmetric = TRUE)
  ev <- eS$values
  if(!all(ev >= -tol*abs(ev[1L]))) stopIQR("'Sigma' is not positive definite")
  X <- matrix(stats::rnorm(p * n), n)
  if(empirical) {
    X <- scale(X, TRUE, FALSE) 
    X <- X %*% svd(X, nu = 0)$v 
    X <- scale(X, FALSE, TRUE) 
  }
  X <- drop(mu) + eS$vectors %*% diag(sqrt(pmax(ev, 0)), p) %*% t(X)
  nm <- names(mu)
  if(is.null(nm) && !is.null(dn <- dimnames(Sigma))) nm <- dn[[1L]]
  dimnames(X) <- list(nm, NULL)
  if(n == 1) drop(X) else t(X)
}
#'@export
calcAICBIC <- function(OFV,nData,nParam, nSubj = NULL, nParamF = NULL, nParamR = NULL) {
  AIC <- as.numeric(OFV) + 2*as.numeric(nParam)
  BIC <- as.numeric(OFV) + log(as.numeric(nData))*as.numeric(nParam)
  BICc <- NA_real_
  if (!is.null(nSubj) & !is.null(nParamF) & !is.null(nParamR))
    BICc <- as.numeric(OFV) + log(as.numeric(nData))*as.numeric(nParamF) + log(as.numeric(nSubj))*as.numeric(nParamR)
  list(AIC=AIC,BIC=BIC, BICc = BICc)
}
#'@export
format_GUM <- function(value, se = NULL, digits = 2, justify = c("decimal", "left", "right", "centre"), na.string = "--", ...) {
  x <- utils::type.convert(as.character(value))
  if (!all(is.na(x)) && !is.numeric(x))
    stopIQR("value cannot be type-converted to numeric")
  sigma_x <- NULL
  if (!is.null(se)) {
    sigma_x <- utils::type.convert(as.character(se))
    if (!is.numeric(sigma_x)) {
      rel_x <- utils::type.convert(gsub("%", "", as.character(se), fixed = TRUE))
      if (!all(is.na(rel_x)) && !is.numeric(rel_x)) {
        stopIQR("se/rse cannot be type-converted to numeric")
      } else {
        sigma_x <- abs(x * rel_x / 100)
      }
    }
    tol__ <- sqrt(.Machine$double.eps)
    sigma_x <- sign(sigma_x)*sigma_x
    sigma_x[sigma_x < tol__] <- NA
  }
  N <- length(x)
  magnitude.x <- floor(log10(abs(x)))
  justify <- match.arg(justify)
  if (is.null(sigma_x)) {
    y <- sapply(1:N, function(i) {
      if (is.infinite(magnitude.x[i])) return(format(x[i]))
      nsmall <- max(0, -magnitude.x[i] + digits - 1, na.rm = TRUE)
      nsmall <- min(nsmall,20) 
      format(round(x[i], -magnitude.x[i] + digits - 1),
             nsmall = nsmall)
    })
  } else {
    magnitude.sigma_x <- floor(log10(sigma_x))
    y <- sapply(1:N, function(i) {
      if (is.na(sigma_x[i]) | is.infinite(magnitude.sigma_x[i])) {
        z <- format(x[i])
      } else {
        nsmall <- max(0, -magnitude.sigma_x[i] + digits - 1, na.rm = TRUE)
        nsmall <- min(nsmall,20) 
        z <- format(round(x[i], -magnitude.sigma_x[i] + digits - 1),
                    nsmall = nsmall)
      }
      return(z)
    })
  }
  y[grepl("NA", y)] <- na.string
  digits.y <- sapply(strsplit(y, ".", fixed = TRUE), function(v) {
    out <- nchar(v[2])
    if (is.na(out)) out <- -1
    return(out)
  })
  if (justify == "decimal") {
    y <- format(
      x = sapply(1:N, function(i) {
        paste0(y[i], paste(rep(" ", max(digits.y, na.rm = TRUE) - digits.y[i]), collapse = ""))
      }),
      justify = "right", ...
    )
  } else {
    y <- format(y, justify = justify, ...)
  }
  return(y)
}
#'@export
aux_extractObjects <- function(mylist, myclass = "ggplot") {
  sublist <- mylist
  output <- list()
  for (i in 1:5000) {
    is.object <- sapply(sublist, function(element) inherits(element, myclass))
    is.list <- sapply(sublist, is.list)
    if (!any(is.list)) break
    output <- c(output, sublist[is.object])
    sublist <- do.call(c, sublist[!is.object & is.list])
  }
  return(output)
}
alphnumsort <- function(x) {
  data__ <- dplyr::bind_rows(lapply(x, function(myx__) {
    contents__ <- sapply(seq_len(nchar(myx__)), function(i__) is.numeric(utils::type.convert(substr(myx__, i__, i__))))
    change__ <- c(1, abs(diff(contents__)))
    start__ <- which(change__ == 1)
    stop__ <- c((which(change__ == 1) - 1)[-1], nchar(myx__))
    split__ <- as.data.frame(lapply(seq_along(start__), function(i__) substr(myx__, start__[i__], stop__[i__])), stringsAsFactors = FALSE)
    colnames(split__) <- paste0("X", seq_len(ncol(split__)))
    return(split__)
  }))
  datanum__ <- lapply(data__, function(col__) utils::type.convert(col__))
  order__ <- do.call(order, datanum__)
  x[order__]
}
#'@export
run_silent_IQR <- function(expr, filename = tempfileIQR(), report = FALSE) {
  zz <- file(filename, open = "wt")
  sink(zz)
  sink(zz, type = "message")
  out <- suppressWarnings(suppressMessages(expr))
  sink(type = "message")
  sink()
  con <- file(filename)
  message <- readLines(con)
  close.connection(con)
  suppressWarnings(file.remove(filename))
  if (report && length(message) > 0) attr(out, "message") <- message
  return(out)
}
progressBar <- function(percentage, size = 50, number = TRUE) {
  if(percentage < 0) percentage <- 0
  if(percentage > 100) percentage <- 100
  out <- paste("\r|", paste(rep("=", round(size*percentage/100)), collapse=""), paste(rep(" ", size-round(size*percentage/100)), collapse=""), "|", sep="")
  cat(out)
  if(number) cat(format(paste(" ", round(percentage), "%", sep=""), width=5))
}
#'@export
rbind_IQRdosing <- function(...) {
  dots <- list(...)
  x <- do.call(rbind,dots)
  x <- dplyr::arrange(x,TIME,ADM)
  class(x) <- c("IQRdosing", class(x))
  x
}
#'@export
is_IQRdosing <- function(input) {
  methods::is(input,"IQRdosing")
}
#'@export
print.IQRdosing <- function(x, ...) {
  print.data.frame(x)
  cat("\nIQRdosing object")
  cat("\n  Number of inputs: ",numberInputs_IQRdosing(x),sep="")
}
#'@export
IQRdosing <- function(TIME, ADM, AMT,
                      TINF  = NULL,
                      RATE  = NULL,
                      ADDL  = NULL,
                      II    = NULL) {
  if (!is.null(ADDL)) ADDL[is.na(ADDL)] <- 0
  if (!is.null(II)) II[is.na(II)] <- 0
  if (!aux_isnumericVector(TIME) | !aux_isnumericVector(ADM) |
      !aux_isnumericVector(AMT) | !aux_isnumericVector(TINF) |
      !aux_isnumericVector(RATE) | !aux_isnumericVector(ADDL) | !aux_isnumericVector(II))
    stopIQR("All input arguments need to be numeric")
  if (length(ADM)==1) ADM <- rep(ADM,length(TIME))
  if (length(AMT)==1) AMT <- rep(AMT,length(TIME))
  if (!is.null(TINF) & length(TINF)==1) TINF <- rep(TINF,length(TIME))
  if (!is.null(RATE) & length(RATE)==1) RATE <- rep(RATE,length(TIME))
  if (!is.null(ADDL) & length(ADDL)==1) ADDL <- rep(ADDL,length(TIME))
  if (!is.null(II) & length(II)==1)     II   <- rep(II,length(TIME))
  if (length(TIME)!=length(ADM) | length(TIME)!=length(AMT))
    stopIQR("TIME, ADM, and AMT need to have same length")
  if (!is.null(TINF) & !is.null(RATE))
    stopIQR("RATE and TINF not allowed to be defined at the same time")
  if (!is.null(RATE)) {
    if (length(RATE) != length(AMT))
      stopIQR("RATE needs to have same length as TIME, ADM, AMT")
    TINF <- AMT/RATE
    TINF[RATE==0] <- 0
  }
  if (is.null(TINF)) TINF <- rep(0,length(TIME))
  if (length(TINF) != length(TIME))
    stopIQR("TINF needs to have same length as TIME, ADM, AMT")
  TINF[TINF<.Machine$double.eps] <- 0.0001
  if (is.null(ADDL) & !is.null(II))
    stopIQR("If II is defined also ADDL needs to be defined")
  if (!is.null(ADDL) & is.null(II))
    stopIQR("If ADDL is defined also II needs to be defined")
  if (is.null(ADDL) & length(TIME) > 0) ADDL <- rep(0,length(TIME))
  if (is.null(II) & length(TIME) > 0) II <- rep(0,length(TIME))
  dosingTable__ <- data.frame(TIME=as.numeric(TIME),ADM=as.numeric(ADM),
                            AMT=as.numeric(AMT),TINF=as.numeric(TINF),
                            ADDL=ADDL, II=II,
                            stringsAsFactors=FALSE)
  if (nrow(dosingTable__) > 0) {
    dosingTable__ <- do.call(rbind,lapply(1:nrow(dosingTable__), function (x) {
      if (dosingTable__$ADDL[x] == 0) {
        return(dosingTable__[x,])
      } else {
        row__ <- dosingTable__[x,]
        dtx__ <- row__[rep(seq(nrow(row__)), row__$ADDL+1),]
        dtx__$TIME <- seq(dtx__$TIME[1],
                          dtx__$TIME[1]+dtx__$ADDL[1]*dtx__$II[1],
                          dtx__$II[1])
        return(dtx__)
      }
    }))
  }
  dosingTable__$ADDL <- NULL
  dosingTable__$II   <- NULL
  dosingTable__ <- dplyr::arrange(dosingTable__,TIME,ADM)
  attr(dosingTable__,"class") <- c("IQRdosing", "data.frame")
  return(dosingTable__)
}
numberInputs_IQRdosing <- function(x) {
  if (!is_IQRdosing(x))
    stopIQR("Input is not an IQRdosing object")
  return(length(unique(x$ADM)))
}
#'@export
is_IQReventTable <- function(input) {
  methods::is(input,"IQReventTable")
}
#'@export
print.IQReventTable <- function(x, ...) {
  print.data.frame(x)
  cat("\nIQReventTable object")
  cat("\n")
  cat("\n")
  cat(paste0("  Nr subjects: ",length(unique(x$ID))))
  cat("\n")
  cat("\n")
  adm__ <- unique(x$ADM[!is.na(x$ADM)])
  if (length(adm__) > 0) {
    cat("  Dose records present for: ")
    cat(paste0("INPUT",adm__,collapse=", "))
    cat("\n")
    cat("\n")
  }
  regParam__ <- setdiff(names(x),c("ID","TIME","ADM","AMT","TINF"))
  if (length(regParam__) > 0) {
    cat("  Regression parameters: ")
    cat(paste0(regParam__, collapse=", "))
    cat("\n")
    cat("\n")
  }
}
#'@export
#'@importFrom data.table data.table setorderv copy rbindlist :=
IQReventTable <- function(data, regression=NULL, abs0inputs=NULL, abs0Tk0param=NULL,FLAGfixDoseOverlap=FALSE) {
  if (!is.data.frame(data))
    stopIQR("Input argument 'data' is not a data.frame object")
  if (!("TIME" %in% names(data)))
    stopIQR("TIME column not present in the 'data' input argument")
  if (!is.null(abs0Tk0param)) {
    if (!all(abs0Tk0param %in% regression)) {
      stopIQR("Not all parameters in 'abs0Tk0param' provided as 'regression' parameters")
    }
  }
  if (length(abs0inputs) != length(abs0Tk0param)) {
    stopIQR("Number of elements in arguments 'abs0inputs' and 'abs0Tk0param' need to match")
  }
  if (!("ID" %in% names(data)))
    data <- cbind(ID=1,data)
  if (!("ADM" %in% names(data)))
    data <- cbind(ADM=NA,data)
  if (!("AMT" %in% names(data)))
    data <- cbind(AMT=NA,data)
  if (!("ADDL" %in% names(data)))
    data <- cbind(ADDL=0,data)
  if (!("II" %in% names(data)))
    if (all(data$ADDL[data$ADM != 0 & !is.na(data$ADM)] == 0)) {
      data <- cbind(II=0,data)
    } else {
      stopIQR("If additional doses are defined, the dosing intervals needs to be given.")
    }
  if (!(any(c("TINF","RATE") %in% names(data))))
    data <- cbind(data,TINF=0)
  if (!"TINF" %in% names(data)) {
    if ("RATE" %in% names(data)) {
      TINF__ <- data$AMT/data$RATE
      TINF__[data$RATE==0] <- 0
      TINF__[data$RATE==-2] <- 0  
      data$TINF <- TINF__
    }
  }
  if (any(is.na(data$TINF) & !(is.na(data$ADM) | data$ADM == 0))){
    warningIQR("There are NA entries for TINF for dosings. A bolus dose will be assumed.")
    data$TINF[is.na(data$TINF) & !(is.na(data$ADM) | data$ADM == 0)] <- 0
  }
  if (!is.null(regression)) {
    if (!all(regression %in% names(data))) {
      stopIQR("Not all defined regression names are present in the dataset")
    }
    if (any(sapply(regression, function(.r) any(is.na(data[[.r]]))))) {
      check__ <- regression[sapply(regression, function(.r) any(is.na(data[[.r]])))]
      stopIQR(paste0("Regression columns are not allowed to contain NAs.\nCheck ", paste0(check__, collapse = ", "), " for NAs."))
    }
  }
  dataWork__ <- data[,c("ID","TIME","ADM","AMT","TINF","ADDL","II",regression)]
  `:=` <- data.table::`:=`
  if (nrow(dataWork__) > 0) {
    dataWork__$ADDL[is.na(dataWork__$ADDL)] <- 0
    dW__ <- split(dataWork__, dataWork__$ADDL > 0)
    if (!is.null(dW__$`TRUE`)){
      dWADDL__ <- data.table::data.table(dW__$`TRUE`)
      dWADDL__[,ROWID := 1:.N]
      dWADDL2__ <- data.table::copy(dWADDL__)[,list(TIME, ADDL, II, ROWID)]
      dWADDL2__ <- dWADDL2__[,list(TIME = TIME + II * seq(0,ADDL)), by = ROWID]
      dWADDL__[,`:=`(TIME = NULL)]
      dWADDL__ <- merge(dWADDL2__, dWADDL__,all = TRUE)
      dWADDL__[,`:=`(ROWID = NULL)]
      dW__$`TRUE` <- dWADDL__
    }
    dataWork__ <- data.table::rbindlist(dW__, use.names = TRUE)
  }
  dataWork__$ADDL <- NULL
  dataWork__$II   <- NULL
  dataWork__ <- data.table::as.data.table(dataWork__)
  dataWork__[ADM == 0,   `:=`(ADM = NA)]
  dataWork__[is.na(ADM), `:=`(TINF = NA, AMT = NA)]
  data.table::setorderv(dataWork__,c("ID","TIME","ADM"), na.last = TRUE)
  dataWork__ <- data.table::data.table(dataWork__)
  dataWork__[.N > 1, dummy__ := 1, by = c("TIME", "ID") ]
  if (length(regression))
    dataWork__[,
               {if (any(vapply(.SD, function(x) length(unique(x)) > 1, FALSE)))
                 stopIQR("There are regression parameters at same TIME that have different values")},
               by = c("TIME", "ID"), .SDcols = regression]
  dataWork__[, dummy__ := NULL]
  dummy__ <- sapply(seq_along(abs0inputs), function (kx__) {
    input__ <- abs0inputs[kx__]
    dataWork__$TINF[dataWork__$ADM==input__ & !is.na(dataWork__$ADM)] <<- dataWork__[[abs0Tk0param[kx__]]][dataWork__$ADM==input__ & !is.na(dataWork__$ADM)]
  })
  dataWork__$TINF[dataWork__$TINF<.Machine$double.eps] <- 0.0001
  dfCheck__ <- dataWork__
  lagNames <- grep("Tlag[[:digit:]]", names(dfCheck__), value = TRUE)
  lagNo    <- as.numeric(gsub("Tlag","",lagNames))
  if (any(is.na(lagNo))) stopIQR("For ", paste0(lagNames[is.na(lagNo)], collapse = ", "), " the corresponding input (ADM) number could not be determined.\nLag time names must be of the form 'TlagX' with X being the corresponding ADM.")
  dfCheck__$TIMEtinfStart <- dfCheck__$TIME
  for (kk__ in seq_along(lagNo)) {
    ixk__ <- dfCheck__$ADM == lagNo[[kk__]] & !is.na(dfCheck__$ADM)
    dfCheck__$TIMEtinfStart[ixk__] <- dfCheck__$TIME[ixk__] + dfCheck__[[lagNames[kk__]]][ixk__]
  }
  dfCheck__ <- dplyr::mutate(dfCheck__, TIMEtinfEnd = TIMEtinfStart + TINF)
  dfCheck__ <- dplyr::arrange(dfCheck__, ID, ADM, TIMEtinfStart)
  check2 <- check1 <- data.frame()
  for (admk__ in unique(dfCheck__$ADM)) {
    x__ <- filter(dfCheck__, ADM == admk__ & !is.na(ADM) & ADM != 0)
    for (idk__ in unique(x__$ID)) {
      xx__ <- dplyr::filter(x__, ID == idk__)
      ix_dupl__ <- duplicated(xx__$TIME, fromLast = TRUE)
      if (any(ix_dupl__))
        check1 <- rbind(check1,unique(xx__[ix_dupl__, c("ID", "ADM", "TIME")]))
      ix_longInf__ <- c(diff(xx__$TIMEtinfStart) <= xx__$TINF[-length(xx__$TINF)], FALSE)
      if (any(ix_longInf__ & !ix_dupl__))
        check2 <- rbind(check2,
                        unique(xx__[ix_longInf__ & !ix_dupl__, c("ID", "ADM", "TIME", "TINF")]))
    }
  }
  if (nrow(check1)>0 | nrow(check2)>0) {
    msg <- paste0("Dosing event times are duplicated or infusions last longer than next dose given.\n",
                  "(Note that for bolus doses, infusion time of 1e-4 is assumed and potential lag times are taken into account.):\n")
    if (nrow(check1)>0) {
      check1tab <- dplyr::bind_rows(structure(names(check1), names = names(check1)),
                                 dplyr::mutate_all(check1, as.character))
      check1tab <- as.data.frame(lapply(check1tab, format, justify = "right"), stringsAsFactors = FALSE)
      msg <- paste0(msg, "Multiple dosing events at same time points for:\n")
      for (kk in 1:nrow(check1tab)) {
        msg <- paste0(msg, check1tab$ID[kk], " | ", check1tab$ADM[kk], " | ", check1tab$TIME[kk], "\n")
      }
    }
    if (nrow(check2)>0) {
      check2tab <- bind_rows(structure(names(check2), names = names(check2)),
                             dplyr::mutate_all(check2, as.character))
      check2tab <- as.data.frame(lapply(check2tab, format, justify = "right"), stringsAsFactors = FALSE)
      msg <- paste0(msg, "Dosing events for which infusion end times are at or after next dosing time:\n")
      for (kk in 1:nrow(check2tab)) {
        msg <- paste0(msg, check2tab$ID[kk], " | ", check2tab$ADM[kk], " | ", check2tab$TIME[kk], " | ", check2tab$TINF[kk], "\n")
      }
    }
    if (!FLAGfixDoseOverlap) {
      msg <- paste0("!!! Please handle as simulation would fail !!!\n", msg)
      stopIQR(msg)
    } else {
      msg <- paste0("Event table for each ID/ADM instance is manipulated by introducing new non-overlapping dosing events.\n\n", msg)
      warningIQR(msg)
      id_adm_corr <- unique(check2[,c("ID", "ADM")])
      for (k in 1:nrow(id_adm_corr)) {
        et_k <- dplyr::inner_join(dataWork__, id_adm_corr[k,], by = c("ID", "ADM"))
        etnew_k <- remove_input_overlap(et_k)
        dataWork__ <- dplyr::anti_join(dataWork__, id_adm_corr[k,], by = c("ID", "ADM"))
        dataWork__ <- rbind(dataWork__, etnew_k)
      }
      dataWork__ <- data.table::data.table(dataWork__)
      data.table::setorderv(dataWork__,c("ID","TIME","ADM"), na.last = TRUE)
    }
  }
  dataWork__ <- data.table::data.table(dataWork__)
  if (length(regression))
    dataWork__[, c(regression) := lapply(.SD, function(.x) replace(.x, c(1, diff(.x)) == 0, NA)), by = "ID", .SDcols = regression]
  dataWork__ <- as.data.frame(dataWork__)
  dataWork__ <- as.data.frame(dataWork__)
  xx__ <- dataWork__[c("ADM","AMT","TINF",regression)]
  NR_NA__ <- rowSums(is.na(xx__))
  ix_ROWS_NOT_ALL_NA__ <- which(NR_NA__ != length(c("ADM","AMT","TINF",regression)))
  dataWork__ <- dataWork__[ix_ROWS_NOT_ALL_NA__,]
  dataWork__ <- dataWork__[,c("ID","TIME","ADM","AMT","TINF",regression)]
  attr(dataWork__,"class") <- c("IQReventTable", "data.frame")
  return(dataWork__)
}
genSim_IQReventTable <- function (eventTable,model,simtime,parametersSim) {
  if (!is_IQReventTable(eventTable))
    stopIQR("The 'eventTable' argument is not an IQReventTable object")
  regressionParam__ <- setdiff(names(eventTable),c("ID", "TIME", "ADM", "AMT", "TINF"))
  lagTimeParam__ <- names(parametersSim)[grepl("\\<Tlag[0-9]+\\>",names(parametersSim))]
  lagTimeRegre__ <- regressionParam__[grepl("\\<Tlag[0-9]+\\>",regressionParam__)]
  addeventTable__ <- setdiff(lagTimeParam__,lagTimeRegre__)
  dummy__ <- sapply(addeventTable__, function (xxx__) {
    eventTable[[xxx__]] <<- parametersSim[xxx__]
  })
  if (!all(c("ADM", "AMT", "TINF") %in% names(eventTable)))
    stopIQR("Event table needs to contain ADM, AMT, and TINF columns.")
  if (length(setdiff(regressionParam__,names(model$parameters))) > 0)
    stopIQR("eventTable seems to contain column names that are neither parameters in the model or ID, TIME, ADM, AMT, TINF: \n",
         paste0(setdiff(regressionParam__,names(model$parameters)), collapse = ", "))
  eventTable$LAGTIMECOL <- NA
  allADM__ <- unique(eventTable$ADM[!is.na(eventTable$ADM)])
  dummy__ <- sapply(allADM__, function (xxx__) {
    tryCatch({
      eventTable$LAGTIMECOL[eventTable$ADM==xxx__ & !is.na(eventTable$ADM) & eventTable$ADM != 0] <<- aux_na_locf(eventTable[[paste0("Tlag",xxx__)]])[eventTable$ADM==xxx__ & !is.na(eventTable$ADM)  & eventTable$ADM != 0]
    }, error=function(err) {
      eventTable$LAGTIMECOL[eventTable$ADM==xxx__ & !is.na(eventTable$ADM) & eventTable$ADM != 0] <<- 0
    })
    eventTable$LAGTIMECOL[is.na(eventTable$ADM) | eventTable$ADM==0] <<- NA
  })
  ADM_data__ <- unique(eventTable$ADM[!is.na(eventTable$ADM)])
  if (length(ADM_data__) > 0) {
    INPUTS_data__ <- paste0("INPUT",ADM_data__)
    INPUTS_model__ <- names(model$inputs)
    if (length(setdiff(INPUTS_data__,INPUTS_model__)) > 0)
      stopIQR("There are input definitions in the eventTable (ADM) for INPUTs that are not present in the model")
  }
  if (!is.list(simtime)) {
    eventTable__ <- eventTable[eventTable$TIME<=max(simtime),]
  } else {
    eventTable__ <- eventTable
  }
  x__ <- tidyr::gather(eventTable__,"NAME","VALUE", dplyr::one_of("AMT",regressionParam__))
  x__ <- x__[!is.na(x__$VALUE),]
  x__ <- x__[!(is.na(x__$ADM) & x__$NAME %in% c("AMT","TINF","TIME")),]
  x__ <- x__[!(x__$ADM==0 & x__$NAME %in% c("AMT","TINF","TIME")),]
  x__$PARAMNAME[!is.na(x__$ADM)] <- paste0("INPUT",x__$ADM[!is.na(x__$ADM)])
  x__$PARAMNAME[x__$NAME %in% regressionParam__] <- x__$NAME[x__$NAME %in% regressionParam__]
  x__$VALUE[x__$NAME=="AMT"] <- x__$VALUE[x__$NAME=="AMT"]/x__$TINF[x__$NAME=="AMT"]
  x__$LAGTIMECOL[x__$NAME!="AMT"] <- 0
  x__$TIME[!is.na(x__$ADM)] <- x__$TIME[!is.na(x__$ADM)] + x__$LAGTIMECOL[!is.na(x__$ADM)]
  x__$LAGTIMECOL <- NULL
  y__ <- x__[x__$NAME=="AMT",]
  if (nrow(y__) > 0) {
    y__$TIME <- y__$TIME+y__$TINF
    y__$VALUE <- 0
  }
  x__ <- dplyr::arrange(rbind(x__,y__),ID,TIME,PARAMNAME)
  if (length(model$inputs)==0) {
    x__ <- x__[!grepl("INPUT[0-9]+",x__$PARAMNAME),]
  }
  xSplitID__ <- split(x__,x__$ID)
  eventTableICs__ <- list()
  eventTableSim__ <- data.frame(do.call(rbind,lapply(xSplitID__, function (xID__) {
    TIME__ <- unique(xID__$TIME)
    if (!is.list(simtime)) {
      TIMEeventTable__ <- sort(unique(c(min(simtime), TIME__ ,max(simtime))))
    } else {
      TIMEeventTable__ <- sort(unique(c(min(simtime[[as.character(xID__$ID[1])]]), TIME__ ,max(simtime[[as.character(xID__$ID[1])]]))))
    }
    NrowsEventTable__ <- length(TIMEeventTable__)
    eventTableSimID__ <- rbind(parametersSim,
                               matrix(rep(NA,length(parametersSim)*(NrowsEventTable__-1)),ncol=length(parametersSim)))
    dummy__ <- sapply(split(xID__,xID__$PARAMNAME), function (xx__) {
      ix_row__   <- match(TIMEeventTable__,xx__$TIME)
      ix_row__   <- which(!is.na(ix_row__))
      if (length(ix_row__) != nrow(xx__)) {
        stopIQR(paste0("Event table input argument seems to have same type of event happening at an identical time point in ID=",xID__$ID[1]))
      }
      eventTableSimID__[ix_row__,xx__$PARAMNAME[1]] <<- xx__$VALUE
    })
    eventTableSimID__ <- cbind(ID=xID__$ID[1],TIME=TIMEeventTable__,eventTableSimID__)
    rownames(eventTableSimID__) <- NULL
    eventTableICs__ <<- rbind(eventTableICs__,calcNNic(model,eventTableSimID__[1,c(-1,-2)])$ICs)
    eventTableSimID__
  })),stringsAsFactors=FALSE)
  output__ <- list(eventTableSim=eventTableSim__,eventTableICs=eventTableICs__)
}
#'@export
remove_input_overlap <- function(et) {
  if (length(unique(et$ID)) != 1) {
    stopIQR("input needs to be from one individual")
  }
  if (length(unique(et$ADM)) != 1) {
    stopIQR("input needs to be from one input/ADM")
  }
  lagName <- paste0("Tlag", et$ADM[1])
  if (lagName %in% names(et)) {
    et$TIME <- et$TIME + et[[lagName]]
  }
  et$TEND <- et$TIME + et$TINF
  evtT <- sort(c(et$TIME, et$TEND))
  nD <- nrow(et)
  nE <- length(evtT)-1
  mat <- matrix(NA, nrow = nE, ncol = nD)
  for (k in 1:nD) {
    mat[,k] <- evtT[1:nE] >= et$TIME[k] & evtT[1:nE] < et$TEND[k]
  }
  etnew <- data.frame(
    ID   = et$ID[1],
    TIME = evtT[1:nE],
    ADM  = et$ADM[1],
    RATE = mat %*% matrix(et$AMT/et$TINF, ncol = 1),
    TINF = diff(evtT)
  )
  etnew$AMT <- etnew$RATE * etnew$TINF
  etnew$RATE <- NULL
  etnew <- etnew[etnew$AMT != 0,]
  etnew <- dplyr::left_join(etnew,
                            select(et, -AMT, -TINF, -TEND),
                            by = c("ID", "ADM", "TIME"))
  if (lagName %in% names(et)){
    etnew <- dplyr::left_join(etnew,
                              select(et, c("ID", "ADM", "TEND", lagName)) %>% rename(TIME=TEND),
                              by = c("ID", "ADM", "TIME"),
                              suffix = c("", "end"))
    etnew$shift <- ifelse(is.na(etnew[[lagName]]), etnew[[paste0(lagName,"end")]], etnew[[lagName]])
    etnew$TIME <- etnew$TIME - etnew$shift
    etnew$shift <- NULL
    etnew[[paste0(lagName,"end")]] <- NULL
  }
  etnew$TINF[etnew$TINF>1e-9] <- etnew$TINF[etnew$TINF>1e-9] - 1e-9
  etnew
}
handleVectorSyntaxR_IQRmodel <- function(model) {
  for (k in seq_along(model$states)) {
    if (!is.null(aux_strFindAll(model$states[[k]]$ODE,"[")$start)) {
      model$states[[k]]$ODE <- aux_strrep(aux_strrep(aux_removeWhiteSpace(model$states[[k]]$ODE),"[","c("),"]",")")
    }
  }
  for (k in seq_along(model$variables)) {
    if (!is.null(aux_strFindAll(model$variables[[k]]$formula,"[")$start)) {
      model$variables[[k]]$formula <- aux_strrep(aux_strrep(aux_removeWhiteSpace(model$variables[[k]]$formula),"[","c("),"]",")")
    }
  }
  for (k in seq_along(model$reactions)) {
    if (!is.null(aux_strFindAll(model$reactions[[k]]$formula,"[")$start)) {
      model$reactions[[k]]$formula <- aux_strrep(aux_strrep(aux_removeWhiteSpace(model$reactions[[k]]$formula),"[","c("),"]",")")
    }
  }
  return(model)
}
nonNumICsFct_IQRmodel <- function (model__) {
  varInfo__   <- variablesInfo_IQRmodel(model__)
  for (k in seq_along(names(model__$variables))) {
    if (k+1 <= length(names(model__$variables))) {
      for (k2__ in (k+1):length(names(model__$variables)))
        varInfo__$varformulas[k2__] <- gsub(pattern = paste0("\\<",names(model__$variables)[k],"\\>"),
                                          replacement = paste0("(",varInfo__$varformulas[k],")"),
                                          x = varInfo__$varformulas[k2__])
    }
  }
  reacInfo__  <- reactionsInfo_IQRmodel(model__)
  for (k in seq_along(names(model__$reactions))) {
    if (k+1 <= length(names(model__$reactions))) {
      for (k2__ in (k+1):length(names(model__$reactions)))
        reacInfo__$reacformulas[k2__] <- gsub(pattern = paste0("\\<",names(model__$reactions)[k],"\\>"),
                                            replacement = paste0("(",reacInfo__$reacformulas[k],")"),
                                            x = reacInfo__$reacformulas[k2__])
    }
  }
  stateInfo__ <- statesInfo_IQRmodel(model__)
  for (k in seq_along(names(model__$states))) {
    for (k2__ in seq_along(names(model__$reactions))) {
      updatedIC__ <- gsub(pattern = paste0("\\<",names(model__$reactions)[k2__],"\\>"),
                          replacement = paste0("(",reacInfo__$reacformulas[k2__],")"),
                          x = stateInfo__$stateICs[k])
      stateInfo__$stateICs[k] <- updatedIC__
    }
  }
  for (k in seq_along(names(model__$states))) {
    for (k2__ in seq_along(names(model__$variables))) {
      updatedIC__ <- gsub(pattern = paste0("\\<",names(model__$variables)[k2__],"\\>"),
                          replacement = paste0("(",varInfo__$varformulas[k2__],")"),
                          x = stateInfo__$stateICs[k])
      stateInfo__$stateICs[k] <- updatedIC__
    }
  }
  IAinfo__ <- list(
    paramnames = names(model__$initalAssignments),
    formulas = sapply(model__$initalAssignments, function (x) x$formula)
  )
  ix__ <- which(!IAinfo__$paramnames %in% names(model__$states))
  IAinfo__$paramnames <- IAinfo__$paramnames[ix__]
  IAinfo__$formulas <- IAinfo__$formulas[ix__]
  for (k in seq_along(names(model__$initalAssignments))) {
    for (k2__ in seq_along(names(model__$reactions))) {
      updatedIA__ <- gsub(pattern = paste0("\\<",names(model__$reactions)[k2__],"\\>"),
                          replacement = paste0("(",reacInfo__$reacformulas[k2__],")"),
                          x = IAinfo__$formulas[k])
      IAinfo__$formulas[k] <- updatedIA__
    }
  }
  for (k in seq_along(IAinfo__$paramnames)) {
    for (k2__ in seq_along(names(model__$variables))) {
      updatedIA__ <- gsub(pattern = paste0("\\<",names(model__$variables)[k2__],"\\>"),
                          replacement = paste0("(",varInfo__$varformulas[k2__],")"),
                          x = IAinfo__$formulas[k])
      IAinfo__$formulas[k] <- updatedIA__
    }
  }
  time <- 0
  for (k in seq_along(model__$functions)) {
    text <- paste(names(model__$functions)[k]," <- function(",model__$functions[[k]]$arguments,") { ",model__$functions[[k]]$formula," }")
    eval(parse(text=text))
  }
  for (k in seq_along(names(model__$states))) {
    text <- paste(names(model__$states)[k],"= NA")
    eval(parse(text=text))
  }
  paramInfo__ <- parametersInfo_IQRmodel(model__)
  for (k in seq_along(paramInfo__$paramnames)) {
    text <- paste(paramInfo__$paramnames[k],"=",paramInfo__$paramvalues[k])
    eval(parse(text=text))
  }
  for (k in seq_along(names(model__$states))) {
    text <- paste(names(model__$states)[k],"=",stateInfo__$stateICs[k])
    eval(parse(text=text))
  }
  test <- c()
  for (k in seq_along(names(model__$states))) {
    text <- paste("test[k] <- ",names(model__$states)[k])
    eval(parse(text=text))
  }
  if (sum(as.double(is.na(test))) > 0) stopIQR("Non-numerical initial conditions are wrongly defined and non-evaluable.")
  text__ <- "function (parameters,intialConditions,time) {\n"
  for (k in seq_along(model__$functions)) text__ <- paste0(text__,"  ",names(model__$functions)[k]," <- function(",model__$functions[[k]]$arguments,") { ",model__$functions[[k]]$formula," }\n")
  for (k in seq_along(names(model__$states))) text__ <- paste0(text__,"  ",names(model__$states)[k]," <- NA\n")
  for (k in seq_along(paramInfo__$paramnames)) text__ <- paste0(text__,"  ",paramInfo__$paramnames[k]," <- parameters[",k,"]\n")
  for (k in seq_along(names(model__$states))) {
    test__ <- suppressWarnings(as.numeric(stateInfo__$stateICs[k]))
    if (is.na(test__)) {
      text__ <- paste0(text__,"  ",names(model__$states)[k]," <- ",stateInfo__$stateICs[k],"\n")
    } else {
      text__ <- paste0(text__,"  ",names(model__$states)[k]," <- as.numeric(intialConditions[",k,"])\n")
    }
  }
  for (k in seq_along(IAinfo__$paramnames)) text__ <- paste0(text__,"  ",IAinfo__$paramnames[k]," <- ",IAinfo__$formulas[k],"\n")
  text__ <- paste0(text__,"  ICs <- c()\n")
  for (k in seq_along(names(model__$states))) text__ <- paste0(text__,'  ICs["',names(model__$states)[k],'"] <- ',names(model__$states)[k],"\n")
  text__ <- paste0(text__,"  IAs <- c()\n")
  IAparams__ <- intersect(names(model__$initalAssignments),names(model__$parameters))
  for (k in seq_along(IAparams__)) text__ <- paste0(text__,'  IAs["',IAparams__[k],'"] <- ',IAparams__[k],"\n")
  text__ <- paste0(text__,"  if (sum(as.double(is.na(ICs))) > 0) stopIQR('Non-numerical initial conditions are wrongly defined and non-evaluable.')\n")
  text__ <- paste0(text__,"  if (sum(as.double(is.na(IAs))) > 0) stopIQR('Initial parameter assignments are wrongly defined and non-evaluable.')\n")
  text__ <- paste0(text__,"  return(list(ICs=ICs,IAs=IAs))\n")
  text__ <- paste0(text__,"}\n")
  return(eval(parse(text=text__)))
}
nonNumICsSensFct_IQRmodel <- function (model,sensParams) {
  stateInfo__ <- statesInfo_IQRmodel(model)
  paramInfo__ <- parametersInfo_IQRmodel(model)
  varInfo__   <- variablesInfo_IQRmodel(model)
  reacInfo__  <- reactionsInfo_IQRmodel(model)
  if (is.null(sensParams)) sensParams <- paramInfo__$paramnames
  for (k in seq_along(varInfo__$varnames)) {
    if (k+1 <= length(varInfo__$varnames)) {
      for (k2__ in (k+1):length(varInfo__$varnames)) {
        varInfo__$varformulas[k2__] <- gsub(pattern = paste0("\\<",varInfo__$varnames[k],"\\>"),replacement = paste0("(",varInfo__$varformulas[k],")"),x = varInfo__$varformulas[k2__])
      }
    }
  }
  for (k in seq_along(reacInfo__$reacnames)) {
    if (k+1 <= length(reacInfo__$reacnames)) {
      for (k2__ in (k+1):length(reacInfo__$reacnames)) {
        reacInfo__$reacformulas[k2__] <- gsub(pattern = paste0("\\<",reacInfo__$reacnames[k],"\\>"),replacement = paste0("(",reacInfo__$reacformulas[k],")"),x = reacInfo__$reacformulas[k2__])
      }
    }
  }
  for (k in seq_along(stateInfo__$statenames)) {
    for (k2__ in seq_along(reacInfo__$reacnames)) {
      updatedIC__ <- gsub(pattern = paste0("\\<",reacInfo__$reacnames[k2__],"\\>"),replacement = paste0("(",reacInfo__$reacformulas[k2__],")"),x = stateInfo__$stateICs[k])
      stateInfo__$stateICs[k] <- updatedIC__
    }
  }
  for (k in seq_along(stateInfo__$statenames)) {
    for (k2__ in seq_along(varInfo__$varnames)) {
      updatedIC__ <- gsub(pattern = paste0("\\<",varInfo__$varnames[k2__],"\\>"),replacement = paste0("(",varInfo__$varformulas[k2__],")"),x = stateInfo__$stateICs[k])
      stateInfo__$stateICs[k] <- updatedIC__
    }
  }
  allICs__ <- stateInfo__$stateICs
  allDerivICs__ <- matrix(NA,ncol=length(sensParams),nrow=length(allICs__))
  for (kstate__ in seq_along(allICs__)) {
    for (kpar__ in seq_along(sensParams)) {
      x__ <- eval(parse(text=paste0("expression(",aux_removeWhiteSpace(allICs__[kstate__]),")")))
      res__ <- paste0(deparse(stats::D(x__,aux_removeWhiteSpace(sensParams[kpar__]))),collapse="")
      allDerivICs__[kstate__,kpar__] <- res__
    }
  }
  text__ <- "function (parameters,time) {\n"
  for (k in seq_along(model$functions)) text__ <- paste0(text__,"  ",names(model$functions)[k]," <- function(",model$functions[[k]]$arguments,") { ",model$functions[[k]]$formula," }\n")
  for (k in seq_along(stateInfo__$statenames)) text__ <- paste0(text__,"  ",stateInfo__$statenames[k]," <- NA\n")
  for (k in seq_along(paramInfo__$paramnames)) text__ <- paste0(text__,"  ",paramInfo__$paramnames[k]," <- parameters[",k,"]\n")
  for (k in seq_along(stateInfo__$statenames)) text__ <- paste0(text__,"  ",stateInfo__$statenames[k]," <- ",stateInfo__$stateICs[k],"\n")
  for (kstate__ in seq_along(stateInfo__$statenames)) {
    for (kpar__ in seq_along(sensParams)) {
      text__ <- paste0(text__,"  ",stateInfo__$statenames[kstate__],"_",sensParams[kpar__]," <- ",allDerivICs__[kstate__,kpar__],"\n")
    }
  }
  text__ <- paste0(text__,"  out <- c()\n")
  for (kstate__ in seq_along(stateInfo__$statenames)) {
    for (kpar__ in seq_along(sensParams)) {
      text__ <- paste0(text__,'  out["',stateInfo__$statenames[kstate__],"_",sensParams[kpar__],'"] <- ',stateInfo__$statenames[kstate__],"_",sensParams[kpar__],"\n")
    }
  }
  text__ <- paste0(text__,"  if (sum(as.double(is.na(out))) > 0) stopIQR('Non-numerical sensitivity initial conditions are wrongly defined and non-evaluable.')\n")
  text__ <- paste0(text__,"  return(out)\n")
  text__ <- paste0(text__,"}\n")
  return(eval(parse(text=text__)))
}
exchangeInterp0 <- function (text) {
  if (is.null(aux_strFindAll(text,"interp0(")$start)) return(text)
  if (length(aux_strFindAll(text,"interp0(")$start) > 1)
    stopIQR("The interp0 function is only allowed to be present once in each formula.")
  textnew__ <- text
  indexstart__ <- aux_strFindAll(text,"interp0(")$end+1
  pc__ <- 1
  cstart__ <- indexstart__
  cend__ <- cstart__
  while (pc__ != 0) {
    cend__ <- cend__ + 1
    if (substr(textnew__,cend__,cend__) == '(') {
      pc__ <- pc__+1
    } else {
      if (substr(textnew__,cend__,cend__) == ')') {
        pc__ <- pc__-1
      }
    }
  }
  indexend__ <- cend__-1
  indexafter__ <- indexend__+1
  textinside__ <- substr(textnew__,indexstart__,indexend__)
  terms__ <- aux_explodePC(textinside__,separator=",",group="square")
  xtermstring__ <- aux_strtrim(terms__[1])
  ytermstring__ <- aux_strtrim(terms__[2])
  xtermstring__ = substr(xtermstring__,2,nchar(xtermstring__)-1)
  ytermstring__ = substr(ytermstring__,2,nchar(ytermstring__)-1)
  xtermelements__ = aux_explodePC(xtermstring__)
  ytermelements__ = aux_explodePC(ytermstring__)
  if (length(xtermelements__) < 3) {
    stopIQR('The interp0 function requires at least 3 points on the x and y axis.')
  }
  if (length(xtermelements__) != length(ytermelements__)) {
    stopIQR('x and y arguments for interp0 function do not have same number of elements.');
  }
  pwText__ <- paste0(ytermelements__[1],",lt(",terms__[3],",",xtermelements__[1],"),")
  for (k in 2:length(xtermelements__)-1) {
    pwText__ <- paste0(pwText__,"(",ytermelements__[k],")")
    if (k<length(xtermelements__)-1) {
      pwText__ <- paste0(pwText__,",andIQR(lt(",terms__[3],",",xtermelements__[k+1],"),ge(",terms__[3],",",xtermelements__[k],")),")
    }
  }
  pwText__ <- paste0(pwText__,",andIQR(lt(",terms__[3],",",xtermelements__[length(xtermelements__)],"),ge(",terms__[3],",",xtermelements__[length(xtermelements__)-1],")),(",ytermelements__[length(ytermelements__)],")")
  textnew__ <- paste(substr(text,1,indexstart__-1), pwText__, substr(text,indexend__+1,nchar(text)))
  textnew__ <- aux_strrep(textnew__,'interp0','piecewiseIQR')
  return(textnew__)
}
exchangeInterp1 <- function (text) {
  if (is.null(aux_strFindAll(text,"interp1(")$start)) return(text)
  if (length(aux_strFindAll(text,"interp1(")$start) > 1)
    stopIQR("The interp1 function is only allowed to be present once in each formula.")
  textnew__ <- text
  indexstart__ <- aux_strFindAll(text,"interp1(")$end+1
  pc__ <- 1
  cstart__ <- indexstart__
  cend__ <- cstart__
  while (pc__ != 0) {
    cend__ <- cend__ + 1
    if (substr(textnew__,cend__,cend__) == '(') {
      pc__ <- pc__+1
    } else {
      if (substr(textnew__,cend__,cend__) == ')') {
        pc__ <- pc__-1
      }
    }
  }
  indexend__ <- cend__-1
  indexafter__ <- indexend__+1
  textinside__ <- substr(textnew__,indexstart__,indexend__)
  terms__ <- aux_explodePC(textinside__,separator=",",group="square")
  xtermstring__ <- aux_strtrim(terms__[1])
  ytermstring__ <- aux_strtrim(terms__[2])
  xtermstring__ = substr(xtermstring__,2,nchar(xtermstring__)-1)
  ytermstring__ = substr(ytermstring__,2,nchar(ytermstring__)-1)
  xtermelements__ = aux_explodePC(xtermstring__)
  ytermelements__ = aux_explodePC(ytermstring__)
  if (length(xtermelements__) < 3) {
    stopIQR('The interp1 function requires at least 3 points on the x and y axis.')
  }
  if (length(xtermelements__) != length(ytermelements__)) {
    stopIQR('x and y arguments for interp1 function do not have same number of elements.');
  }
  pwText__ <- paste0(ytermelements__[1],",lt(",terms__[3],",",xtermelements__[1],"),")
  for (k in 2:length(xtermelements__)-1) {
    pwText__ <- paste0(pwText__,"(",ytermelements__[k+1],"-(",ytermelements__[k],"))/(",xtermelements__[k+1],"-(",xtermelements__[k],"))*(",terms__[3],"-(",xtermelements__[k],"))+(",ytermelements__[k],")")
    if (k<length(xtermelements__)-1) {
      pwText__ <- paste0(pwText__,",andIQR(lt(",terms__[3],",",xtermelements__[k+1],"),ge(",terms__[3],",",xtermelements__[k],")),")
    }
  }
  pwText__ <- paste0(pwText__,",andIQR(lt(",terms__[3],",",xtermelements__[length(xtermelements__)],"),ge(",terms__[3],",",xtermelements__[length(xtermelements__)-1],")),(",ytermelements__[length(ytermelements__)],")")
  textnew__ <- paste(substr(text,1,indexstart__-1), pwText__, substr(text,indexend__+1,nchar(text)))
  textnew__ <- aux_strrep(textnew__,'interp1','piecewiseIQR')
  return(textnew__)
}
exchangeInterpcs <- function (text) {
  if (is.null(aux_strFindAll(text,"interpcsIQR(")$start)) return(text)
  if (length(aux_strFindAll(text,"interpcsIQR(")$start) > 1)
    stopIQR("The interpcs function is only allowed to be present once in each formula.")
  textnew__ <- text
  indexstart__ <- aux_strFindAll(text,"interpcsIQR(")$end+1
  pc__ <- 1
  cstart__ <- indexstart__
  cend__ <- cstart__
  while (pc__ != 0) {
    cend__ <- cend__ + 1
    if (substr(textnew__,cend__,cend__) == '(') {
      pc__ <- pc__+1
    } else {
      if (substr(textnew__,cend__,cend__) == ')') {
        pc__ <- pc__-1
      }
    }
  }
  indexend__ <- cend__-1
  indexafter__ <- indexend__+1
  textinside__ <- substr(textnew__,indexstart__,indexend__)
  terms__ <- aux_explodePC(textinside__,separator=",",group="square")
  xtermstring__ <- aux_strtrim(terms__[1])
  ytermstring__ <- aux_strtrim(terms__[2])
  xtermstring__ = substr(xtermstring__,2,nchar(xtermstring__)-1)
  ytermstring__ = substr(ytermstring__,2,nchar(ytermstring__)-1)
  xtermelements__ = aux_explodePC(xtermstring__)
  ytermelements__ = aux_explodePC(ytermstring__)
  if (length(xtermelements__) < 3) {
    stopIQR('The interpcs function requires at least 3 points on the x and y axis.')
  }
  if (length(xtermelements__) != length(ytermelements__)) {
    stopIQR('x and y arguments for interpcs function do not have same number of elements.');
  }
  newexpr <- paste0(length(xtermelements__),",",terms__[3])
  newexpr <- paste0(newexpr,',',xtermstring__,',',ytermstring__)
  textnew__ <- paste0(substr(text,1,indexstart__-1), newexpr, substr(text,indexend__+1,nchar(text)))
  return(textnew__)
}
clean_loadedDLLs <- function(basename = "IQRmodel") {
  loadSetupOptions_IQRtools()
  x__ <- unclass(getLoadedDLLs())
  ix_IQRmodel__ <- which(grepl(paste0("^", basename, "_"), names(x__)))
  if (length(ix_IQRmodel__) >= .MAX_NUMBER_IQRMODEL_DLLS_LOADED) {
    y__ <- unclass(x__[[ix_IQRmodel__[1]]])
    DLLpath__ <- y__$path
    dyn.unload(DLLpath__)
  }
}
compile_IQRmodel <- function(model) {
  loadSetupOptions_IQRtools()
  x__ <- unclass(getLoadedDLLs())
  ix_IQRmodel__ <- which(grepl("IQRmodel_",names(x__)))
  if (length(ix_IQRmodel__) >= .MAX_NUMBER_IQRMODEL_DLLS_LOADED) {
    y__ <- unclass(x__[[ix_IQRmodel__[1]]])
    DLLpath__ <- y__$path
    dyn.unload(DLLpath__)
  }
  tempFilePath__   <- tempfileIQR()
  xxx__            <- aux_fileparts(tempFilePath__)
  tempFilePath__   <- paste0(xxx__$pathname,"/","IQRmodel_",xxx__$filename,xxx__$fileext)
  tempFilename__   <- aux_fileparts(tempFilePath__)$filename
  oldpath__        <- getwd()
  setwd(aux_fileparts(tempFilePath__)$pathname)
  exportC_IQRmodel(model,tempFilename__)
  includesPaths__  <- .libPaths()
  if (.LIBPATHS_FIRSTONLY) {
    includesPaths__ <- includesPaths__[1]
  }
  includesLocDef__ <- paste0('PKG_CPPFLAGS =')
  for (k in seq_along(includesPaths__)) includesLocDef__ <- paste0(includesLocDef__,' -I"',includesPaths__[k],'/IQRtools/solver/include/"')
  includesLocDef__ <- paste0(includesLocDef__,' -w')
  includesLocDef__ <- paste0(includesLocDef__,'\nPKG_LIBS = -lm')
  aux_filewrite(text=includesLocDef__,filename="Makevars")
  system(paste0("R CMD SHLIB ",tempFilename__,".c >xxx"))
  tryCatch({
    if (.Platform$OS.type=="unix") {
      dyn.load(paste0(tempFilename__,".so"))
    } else {
      dyn.load(tempFilename__)
    }
  }, error = function(err) {
    setwd(oldpath__)
    stopIQR("Compilation of model led to an error. Please check the above output and correct the model.")
  })
  setwd(oldpath__)
  model_func_ptr__ <- getNativeSymbolInfo("model",PACKAGE=tempFilename__)$address
  attr(model,"DLLpath.IQRmodel") <- tempFilePath__
  attr(model,"DLLname.IQRmodel") <- tempFilename__
  attr(model,"address.IQRmodel") <- model_func_ptr__
  return(model)
}
dealFormulas <- function (formulaArray__) {
  oldElements__ = c('\\bnthroot\\b','\\band\\b','\\bor\\b','\\babs\\b','\\bindexmax\\b','\\bmin\\b','\\bmax\\b','\\bpiecewise\\b','\\binterpcs\\b')
  newElements__ = c('nthrootIQR','andIQR','orIQR','absIQR','indexmaxIQR','minIQR','maxIQR','piecewiseIQR','interpcsIQR')
  for (k in seq_along(oldElements__)) formulaArray__ <- gsub(oldElements__[k],newElements__[k],formulaArray__)
  formulaArray__ <- gsub('\\<power\\(','pow(',formulaArray__)
  for (k in seq_along(formulaArray__)) {
    formula <- exchangeInterp0(formulaArray__[k])
    formula <- exchangeInterp1(formula)
    formula <- exchangeInterpcs(formula)
    formula <- convertPowerOperator(formula)
    formula <- gsub("(\\b[0-9.]+)","\\1.0",formula)
    formula <- gsub("\\.0\\.",".",formula)
    formula <- gsub("(\\.[0-9]+)\\.0","\\1",formula)
    formula <- gsub("(E\\.0)","E",formula)
    formula <- gsub("([0-9]E-\\d*)\\.0","\\1",formula)
    formula <- gsub("([0-9]E\\+\\d*)\\.0","\\1",formula)
    formula <- gsub("([0-9]E\\d*)\\.0","\\1",formula)
    formula <- gsub("(e\\.0)","e",formula)
    formula <- gsub("([0-9]e-\\d*)\\.0","\\1",formula)
    formula <- gsub("([0-9]e\\+\\d*)\\.0","\\1",formula)
    formula <- gsub("([0-9]e\\d*)\\.0","\\1",formula)
    fixElements = c('\\<indexmaxIQR\\>','\\<minIQR\\>','\\<maxIQR\\>','\\<andIQR\\>','\\<orIQR\\>','\\<piecewiseIQR\\>','\\<interpcsIQR\\>')
    for (k1__ in 1:length(fixElements)) {
      index__ <- unlist(gregexpr(pattern=fixElements[k1__],formula))
      for (k2__ in seq_along(index__)) {
        if (index__[k2__] != -1) {
          ixStart <- index__[k2__]+nchar(fixElements[k1__])-4
          ixEnd <- ixStart
          parOpen <- 1
          while (parOpen != 0) {
            ixEnd <- ixEnd + 1
            if (substr(formula,ixEnd,ixEnd) == '(') {
              parOpen <- parOpen + 1
            } else {
              if (substr(formula,ixEnd,ixEnd) == ')') {
                parOpen <- parOpen - 1
              }
            }
          }
          command <- fixElements[k1__]
          oldarguments <- substr(formula,ixStart+1,ixEnd-1)
          oldargumentsReplace <- oldarguments
          if (command %in% c("\\<interpcsIQR\\>")) {
            oldarguments <- sub("([0-9]+).0","\\1",oldarguments)
          }
          newargstring <- paste0(length(aux_explodePC(oldarguments)),",",oldarguments)
          oldrep  <- paste0(substr(command,3,nchar(command)-2), '(', oldargumentsReplace, ')')
          newrep <- paste0(substr(command,3,nchar(command)-2), '(', newargstring, ')')
          formula <- aux_strrep(formula,oldrep,newrep)
          index__ <- index__ + nchar(newargstring)-nchar(oldarguments)
        }
      }
    }
    formulaArray__[k] <- formula
  }
  return(formulaArray__)
}
outputDeclarationData <- function(ALLCONTENT__,data) {
  if (length(data)==0) return(ALLCONTENT__)
  nrperrow__ <- 0
  text__ <- ""
  for (k in seq_along(data)) {
    if (nrperrow__==0) text__ <- paste0(text__,'    double ')
    if (k<length(data) & nrperrow__<20-1) {
      text__ <- paste0(text__,data[k],",")
    } else {
      text__ <- paste0(text__,data[k],";")
    }
    nrperrow__ <- nrperrow__ + 1
    if (nrperrow__ == 20) {
      text__ <- paste0(text__,"\n")
      nrperrow__ <- 0
    }
  }
  ALLCONTENT__ <- paste0(ALLCONTENT__,text__,"\n")
  return(ALLCONTENT__)
}
gettriggerPiecewise <- function(input) {
  trigger__ <- c()
  index__ <- aux_strFindAll(input,'piecewise')$start
  if (is.null(index__)) return(trigger__)
  for (k in seq_along(index__)) {
    work__       <- input
    work__       <- substr(work__,index__[k]+nchar('piecewise')+1,nchar(work__))
    popen      <- 1
    offset     <- 1
    while (popen != 0) {
      if (substr(work__,offset,offset) == '(') popen <- popen + 1
      if (substr(work__,offset,offset) == ')') popen <- popen - 1
      offset   <- offset + 1
    }
    work__ <- substr(work__,1,offset-2)
    terms__ <- aux_explodePC(work__)
    trigger__ <- c(trigger__, terms__[seq(2,length(terms__),2)])
  }
  return(unique(trigger__))
}
convertPowerOperator <- function (formula) {
  formula <- aux_removeWhiteSpace(formula)
  indices__ <- aux_strFindAll(formula,'^')$start
  while (!is.null(indices__)) {
    index__ <- indices__[1]
    formula1 <- substr(formula,1,index__-1)
    formula2 <- substr(formula,index__+1,nchar(formula))
    pc__ <- 0
    cend__ <- nchar(formula1)
    cstart__ <- cend__
    run <- TRUE
    while (run) {
      if (pc__==0) {
        if (substr(formula1,cstart__,cstart__) %in% c("+","-","*","/")) { cstart__ <- cstart__+1; break }
        if (substr(formula1,cstart__,cstart__) == "(") {
          if (cstart__ == 1) { cstart__ <- cstart__+1; break }
          if (substr(formula1,cstart__-1,cstart__-1) %in% c("+","-","*","/","(")) { cstart__ <- cstart__+1; break }
        }
      }
      if (substr(formula1,cstart__,cstart__) == ')') pc__ <- pc__+1
      if (substr(formula1,cstart__,cstart__) == '(') pc__ <- pc__-1
      if (cstart__<=1) break
      cstart__ <- cstart__ - 1
    }
    firstargument <- substr(formula1,cstart__,cend__)
    cendfirst <- cstart__
    pc__ <- 0
    cstart__ <- 1
    cend__ <- cstart__
    run <- TRUE
    while (run) {
      if (cend__ > 1 & pc__==0 & substr(formula2,cend__,cend__) %in% c("+","-","*","/",")","^")) { cend__ <- cend__-1; break }
      if (cend__>=nchar(formula2)) break
      if (substr(formula2,cend__,cend__) == ')') pc__ <- pc__+1
      if (substr(formula2,cend__,cend__) == '(') pc__ <- pc__-1
      cend__ <- cend__ + 1
    }
    secondargument <- substr(formula2,cstart__,cend__)
    cstartsecond <- cend__
    powerexp <- paste0("pow(",firstargument,",",secondargument,")")
    formula <- paste0(substr(formula1,1,cendfirst-1), powerexp, substr(formula2,cstartsecond+1,nchar(formula2)))
    indices__ <- aux_strFindAll(formula,'^')$start
  }
  return(formula)
}
addPiecewiseEvents_IQRmodel <- function(model) {
  triggers__ <- c()
  for (k in seq_along(model$states))
    triggers__    <- c(triggers__, gettriggerPiecewise(model$states[[k]]$ODE))
  for (k in seq_along(model$variables))
    triggers__    <- c(triggers__, gettriggerPiecewise(model$variables[[k]]$formula))
  for (k in seq_along(model$reactions))
    triggers__    <- c(triggers__, gettriggerPiecewise(model$reactions[[k]]$formula))
  triggers__      <- unique(triggers__)
  triggers__ <- handlePulsePiecewiseExpressions(triggers__,'and<ge<time,(.*)>,lt<time,(.*)>>')
  triggers__ <- handlePulsePiecewiseExpressions(triggers__,'and<ge<time,(.*)>,le<time,(.*)>>')
  triggers__ <- handlePulsePiecewiseExpressions(triggers__,'and<gt<time,(.*)>,lt<time,(.*)>>')
  triggers__ <- handlePulsePiecewiseExpressions(triggers__,'and<gt<time,(.*)>,le<time,(.*)>>')
  triggers__ <- handlePulsePiecewiseExpressions(triggers__,'and<lt<time,(.*)>,ge<time,(.*)>>')
  triggers__ <- handlePulsePiecewiseExpressions(triggers__,'and<lt<time,(.*)>,gt<time,(.*)>>')
  triggers__ <- handlePulsePiecewiseExpressions(triggers__,'and<le<time,(.*)>,ge<time,(.*)>>')
  triggers__ <- handlePulsePiecewiseExpressions(triggers__,'and<le<time,(.*)>,gt<time,(.*)>>')
  presentModelEvents__ <- eventsInfo_IQRmodel(model)$evetriggers
  presentModelEvents2__ <- presentModelEvents__
  presentModelEvents2__ <- gsub(x=presentModelEvents2__,pattern="\\<gt\\(","ge(")
  presentModelEvents2__ <- gsub(x=presentModelEvents2__,pattern="\\<lt\\(","le(")
  presentModelEvents3__ <- presentModelEvents__
  presentModelEvents3__ <- gsub(x=presentModelEvents3__,pattern="\\<ge\\(","gt(")
  presentModelEvents3__ <- gsub(x=presentModelEvents3__,pattern="\\<le\\(","lt(")
  triggers__ <- setdiff(triggers__,c(presentModelEvents__,presentModelEvents2__,presentModelEvents3__))
  if (length(triggers__) > 0) {
    sn <- names(model$states)[1]
    for (k in seq_along(triggers__)) {
      eventName <- paste0("piecewise_event_",k)
      model <- addEvent_IQRmodel(model,name=eventName,trigger=triggers__[k],notes='Just a dummy assignment for correct piecewise timing')
      model <- addEventAssignment_IQRmodel(model,eventname=eventName,variable=sn,formula=sn)
    }
  }
  return(model)
}
handlePulsePiecewiseExpressions <- function(triggers__,syntax) {
  usetriggers__ <- c()
  for (k in seq_along(triggers__)) {
    trigger__ <- aux_removeWhiteSpace(triggers__[k])
    x <- aux_strrep(trigger__,'(','<')
    x <- aux_strrep(x,')','>')
    y <- regexpr(text=x,pattern=syntax,perl=TRUE)
    if (y[1] != -1) {
      found_start__  <- attr(y,"capture.start")
      found_length__ <- attr(y,"capture.length")
      trigger1 <- substr(trigger__,found_start__[1],found_start__[1]+found_length__[1]-1)
      trigger2 <- substr(trigger__,found_start__[2],found_start__[2]+found_length__[2]-1)
      usetriggers__ <- c(usetriggers__, paste0("ge(time,",trigger1,")"))
      usetriggers__ <- c(usetriggers__, paste0("ge(time,",trigger2,")"))
    } else {
      usetriggers__ <- c(usetriggers__, trigger__)
    }
  }
  triggers__ <- usetriggers__
  return(triggers__)
}
#'@export
export_IQRmodel <- function (model, filename=NULL, FLAGbc=FALSE) {
  if (FLAGbc) {
    message("For export in BC notation the underlying assumptions are:")
    message("  * All reaction rates are defined in amount/time units")
    message("  * Species ideally in amount and ODEs defined by sum of reaction rates")
    message("    * Stoichiometric factors can be numeric or parameters and need to be define in front of reaction names")
    message("      Example: d/dt(speciesAmount) = 2*reaction1 - reaction2 - 1*reaction3")
  }
  if (!is_IQRmodel(model)) stopIQR("Input argument is not an IQRmodel")
  if (!is.null(filename)) filename <- paste0(aux_strrep(filename,".txt",""), ".txt")
  stoichiometry         <- stoichiometry_IQRmodel(model,raw=FALSE)
  stoichiometricMatrix  <- stoichiometry$N
  stateNamesBiochemical <- stoichiometry$statenames
  stateNamesAll__       <- names(model$states)
  stateNamesODE__       <- setdiff(stateNamesAll__,stateNamesBiochemical)
  ALLCONTENT__ <- ""
  ALLCONTENT__ <- paste0(ALLCONTENT__,"********** MODEL NAME\n\n",model$name,"\n\n")
  ALLCONTENT__ <- paste0(ALLCONTENT__,"********** MODEL NOTES\n\n",model$notes,"\n\n")
  if (!FLAGbc) {
    ALLCONTENT__ <- addStatesODE_IQRmodel(ALLCONTENT__,model)
  } else {
    ALLCONTENT__ <- addStatesBC_IQRmodel(ALLCONTENT__,model,stateNamesODE__)
  }
  ALLCONTENT__ <- addParameters_IQRmodel(ALLCONTENT__,model)
  ALLCONTENT__ <- addVariables_IQRmodel(ALLCONTENT__,model)
  if (!FLAGbc) {
    ALLCONTENT__ <- addReactionsODE_IQRmodel(ALLCONTENT__,model)
  } else {
    ALLCONTENT__ <- addReactionsBC_IQRmodel(ALLCONTENT__,model,stateNamesBiochemical,stoichiometricMatrix)
  }
  ALLCONTENT__ <- addFunctions_IQRmodel(ALLCONTENT__,model)
  ALLCONTENT__ <- addEvents_IQRmodel(ALLCONTENT__,model)
  ALLCONTENT__ <- addCfunctions_IQRmodel(ALLCONTENT__,model)
  ALLCONTENT__ <- addInitialAssignments_IQRmodel(ALLCONTENT__,model)
  aux_filewrite(ALLCONTENT__,filename)
  if (is.null(filename)) return(ALLCONTENT__)
}
addStatesODE_IQRmodel <- function (ALLCONTENT__,model__) {
  ALLCONTENT__ <- paste0(ALLCONTENT__,"********** MODEL STATES\n\n")
  for (k in seq_along(model__$states)) {
    text__ <- paste0("d/dt(",names(model__$states)[k],") = ",model__$states[[k]]$ODE)
    text__ <- addSBMLinfo_IQRmodel(text__,model__$states,k)
    text__ <- addNotes_IQRmodel(text__,model__$states,k)
    ALLCONTENT__ <- paste0(ALLCONTENT__,text__,"\n")
  }
  ALLCONTENT__ <- paste0(ALLCONTENT__," \n")
  for (k in seq_along(model__$states)) {
    ALLCONTENT__ <- paste0(ALLCONTENT__,names(model__$states)[k],"(0) = ",model__$states[[k]]$IC,"\n")
  }
  ALLCONTENT__ <- paste0(ALLCONTENT__," \n")
}
addStatesBC_IQRmodel <- function (ALLCONTENT__,model__,stateNamesODE__) {
  ALLCONTENT__ <- paste0(ALLCONTENT__,"********** MODEL STATE INFORMATION\n\n")
  for (k in seq_along(stateNamesODE__)) {
    index        <- aux_strmatch(names(model__$states),stateNamesODE__[k])
    text__       <- paste0("d/dt(",names(model__$states)[index],") = ",model__$states[[index]]$ODE)
    text__       <- addSBMLinfo_IQRmodel(text__,model__$states,index)
    text__       <- addNotes_IQRmodel(text__,model__$states,index)
    ALLCONTENT__ <- paste0(ALLCONTENT__,text__,"\n")
  }
  ALLCONTENT__   <- paste0(ALLCONTENT__," \n")
  for (k in seq_along(model__$states)) {
    text__ <- paste0(names(model__$states)[k],"(0) = ",model__$states[[k]]$IC)
    if (!(names(model__$states)[k] %in% stateNamesODE__)) {
      text__       <- addSBMLinfo_IQRmodel(text__,model__$states,k)
      text__       <- addNotes_IQRmodel(text__,model__$states,k)
    }
    ALLCONTENT__ <- paste0(ALLCONTENT__,text__,"\n")
  }
  ALLCONTENT__ <- paste0(ALLCONTENT__," \n")
}
addParameters_IQRmodel <- function (ALLCONTENT__,model__) {
  ALLCONTENT__   <- paste0(ALLCONTENT__,"********** MODEL PARAMETERS\n\n")
  for (k in seq_along(model__$parameters)) {
    text__       <- paste0(names(model__$parameters)[k]," = ",model__$parameters[[k]]$value)
    text__       <- addSBMLinfo_IQRmodel(text__,model__$parameters,k)
    text__       <- addNotes_IQRmodel(text__,model__$parameters,k)
    ALLCONTENT__ <- paste0(ALLCONTENT__,text__,"\n")
  }
  ALLCONTENT__   <- paste0(ALLCONTENT__," \n")
  return(ALLCONTENT__)
}
addVariables_IQRmodel <- function (ALLCONTENT__,model__) {
  ALLCONTENT__   <- paste0(ALLCONTENT__,"********** MODEL VARIABLES\n\n")
  for (k in seq_along(model__$variables)) {
    text__       <- paste0(names(model__$variables)[k]," = ",model__$variables[[k]]$formula)
    text__       <- addSBMLinfo_IQRmodel(text__,model__$variables,k)
    text__       <- addNotes_IQRmodel(text__,model__$variables,k)
    ALLCONTENT__ <- paste0(ALLCONTENT__,text__,"\n")
  }
  ALLCONTENT__   <- paste0(ALLCONTENT__," \n")
  return(ALLCONTENT__)
}
addReactionsODE_IQRmodel <- function (ALLCONTENT__,model__) {
  ALLCONTENT__   <- paste0(ALLCONTENT__,"********** MODEL REACTIONS\n\n")
  for (k in seq_along(model__$reactions)) {
    text__       <- paste0(names(model__$reactions)[k]," = ",model__$reactions[[k]]$formula)
    if (model__$reactions[[k]]$reversible) text__ <- paste(text__,"{reversible}")
    if (model__$reactions[[k]]$fast) text__ <- paste(text__,"{fast}")
    text__       <- addNotes_IQRmodel(text__,model__$reactions,k)
    ALLCONTENT__ <- paste0(ALLCONTENT__,text__,"\n")
  }
  ALLCONTENT__   <- paste0(ALLCONTENT__," \n")
  return(ALLCONTENT__)
}
addReactionsBC_IQRmodel <- function (ALLCONTENT__,model__,stateNamesBiochemical,stoichiometricMatrix) {
  ALLCONTENT__ <- paste0(ALLCONTENT__,"********** MODEL REACTIONS\n\n")
  reacInfo__                     <- reactionsInfo_IQRmodel(model__)
  if (!is.null(stoichiometricMatrix)) {
    for (k1 in 1:dim(stoichiometricMatrix)[2]) {
      Ncol                       <- stoichiometricMatrix[,k1]
      substrateIndices           <- unname(which(Ncol < 0))
      productIndices             <- unname(which(Ncol > 0))
      substrateNames__           <- stateNamesBiochemical[substrateIndices]
      productNames__             <- stateNamesBiochemical[productIndices]
      substrateStoichiometries__ <- abs(Ncol[substrateIndices])
      productStoichiometries__   <- abs(Ncol[productIndices])
      if (reacInfo__$reacreversible[k1]) {
        irreversibleRates__      <- aux_explodePC(reacInfo__$reacformulas[k1],'-')
        if (length(irreversibleRates__) != 2) {
          reacInfo__$reacreversible[k1]      <- FALSE
        } else {
          reactionForward        <- irreversibleRates__[1]
          reactionReverse        <- irreversibleRates__[2]
        }
      }
      text__ <- ""
      if (length(substrateNames__) > 0) {
        if (substrateStoichiometries__[1] != 1) {
          text__             <- paste0(text__,substrateStoichiometries__[1],"*",substrateNames__[1])
        } else {
          text__             <- paste0(text__,substrateNames__[1])
        }
      }
      if (length(substrateNames__) > 1) {
        for (k2 in 2:length(substrateNames__)) {
          if (substrateStoichiometries__[k2] != 1) {
            text__           <- paste0(text__,"+",substrateStoichiometries__[k2],"*",substrateNames__[k2])
          } else {
            text__           <- paste0(text__,"+",substrateNames__[k2])
          }
        }
      }
      if (reacInfo__$reacreversible[k1]) {
        text__               <- paste0(text__," <=> ")
      } else {
        text__               <- paste0(text__," => ")
      }
      if (length(productNames__) > 0) {
        if (productStoichiometries__[1] != 1) {
          text__             <- paste0(text__,productStoichiometries__[1],"*",productNames__[1])
        } else {
          text__             <- paste0(text__,productNames__[1])
        }
      }
      if (length(productNames__) > 1) {
        for (k2 in 2:length(productNames__)) {
          if (productStoichiometries__[k2] != 1) {
            text__           <- paste0(text__,"+",productStoichiometries__[k2],"*",productNames__[k2])
          } else {
            text__           <- paste0(text__,"+",productNames__[k2])
          }
        }
      }
      text__                 <- paste0(text__," : ",reacInfo__$reacnames[k1])
      if (reacInfo__$reacfast[k1]) text__ <- paste0(text__," {fast}")
      if (!is.null(model__$reactions[[k1]]$notes)) text__ <- paste0(text__," # ",model__$reactions[[k1]]$notes)
      text__                 <- paste0(text__,"\n")
      if (!reacInfo__$reacreversible[k1]) {
        text__               <- paste0(text__,"\tvf = ",reacInfo__$reacformulas[k1],"\n")
      } else {
        text__               <- paste0(text__,"\tvf = ",reactionForward,"\n\tvr = ",reactionReverse,"\n")
      }
      ALLCONTENT__               <- paste0(ALLCONTENT__,text__,"\n")
    }
  } else {
    ALLCONTENT__ <- paste0(ALLCONTENT__," \n")
  }
  return(ALLCONTENT__)
}
addFunctions_IQRmodel <- function(ALLCONTENT__,model__) {
  ALLCONTENT__   <- paste0(ALLCONTENT__,"********** MODEL FUNCTIONS\n\n")
  for (k in seq_along(model__$functions)) {
    text__       <- paste0(names(model__$functions)[k],"(",model__$functions[[k]]$arguments,") = ",model__$functions[[k]]$formula)
    text__       <- addNotes_IQRmodel(text__,model__$functions,k)
    ALLCONTENT__ <- paste0(ALLCONTENT__,text__,"\n")
  }
  ALLCONTENT__   <- paste0(ALLCONTENT__," \n")
  return(ALLCONTENT__)
}
addEvents_IQRmodel <- function(ALLCONTENT__,model__) {
  ALLCONTENT__   <- paste0(ALLCONTENT__,"********** MODEL EVENTS\n\n")
  for (k in seq_along(model__$events)) {
    text__       <- paste0(names(model__$events)[k]," = ",model__$events[[k]]$trigger)
    for (k2 in seq_along(model__$events[[k]]$assignment)) {
      text__ <- paste0(text__,",",model__$events[[k]]$assignment[[k2]]$variable,",",model__$events[[k]]$assignment[[k2]]$formula)
    }
    text__       <- addNotes_IQRmodel(text__,model__$events,k)
    ALLCONTENT__ <- paste0(ALLCONTENT__,text__,"\n")
  }
  ALLCONTENT__ <- paste0(ALLCONTENT__," \n")
  return(ALLCONTENT__)
}
addCfunctions_IQRmodel <- function(ALLCONTENT__,model__) {
  if (!is.null(model__$Cfunctions)) {
    if (nchar(aux_strtrim(model__$Cfunctions)) > 0) {
      ALLCONTENT__ <- paste0(ALLCONTENT__,"********** MODEL C FUNCTIONS\n\n")
      ALLCONTENT__ <- paste0(ALLCONTENT__,model__$Cfunctions,"\n ")
    }
  }
  return(ALLCONTENT__)
}
addInitialAssignments_IQRmodel <- function(ALLCONTENT__,model__) {
  ALLCONTENT__   <- paste0(ALLCONTENT__,"********** MODEL INITIAL ASSIGNMENTS\n\n")
  for (k in seq_along(model__$initalAssignments)) {
    text__       <- paste0(names(model__$initalAssignments)[k]," = ",model__$initalAssignments[[k]]$formula)
    text__       <- addNotes_IQRmodel(text__,model__$initalAssignments,k)
    ALLCONTENT__ <- paste0(ALLCONTENT__,text__,"\n")
  }
  ALLCONTENT__   <- paste0(ALLCONTENT__," \n")
  return(ALLCONTENT__)
}
addSBMLinfo_IQRmodel <- function(text__,modelElement__,k) {
  type        <- modelElement__[[k]]$type
  compartment <- modelElement__[[k]]$compartment
  unittype    <- modelElement__[[k]]$unittype
  SBMLinfo__ <- ""
  if (!is.null(type) | !is.null(compartment) | !is.null(unittype)) {
    if (type=="isSpecie" & !is.null(compartment) && (unittype=="amount" | unittype=="concentration"))
      SBMLinfo__ <- paste0(" {",type,":",compartment,":",unittype,"}")
    if (type=="isParameter" & is.null(compartment) & is.null(unittype))
      SBMLinfo__ <- paste0(" {",type,"}")
    if (type=="isCompartment" & is.null(unittype))
      SBMLinfo__ <- paste0(" {",type,":",compartment,"}")
    if (SBMLinfo__=="") {
      stopIQR(paste0("Type information for ",names(modelElement__)[k]," seems to be wrong."))
    }
  }
  text__ <- aux_strtrim(paste0(text__,SBMLinfo__))
  return(text__)
}
addNotes_IQRmodel <- function(text__,modelElement__,k) {
  if (!is.null(modelElement__[[k]]$notes)) {
    text__ <- aux_strtrim(paste(text__,"#",modelElement__[[k]]$notes,sep=" "))
  }
  return(text__)
}
import_IQRmodel <- function(input,FLAGtextIQRmodel=FALSE) {
  if (FLAGtextIQRmodel) {
    modelText__ <- input
  } else {
    filename__ <- input
    suppressWarnings(modelText__ <- aux_fileread(filename__,collapserows=FALSE))
  }
  modelText__ <- gsub("^\\s*%.*$", "", modelText__)
  modelText__ <- gsub("^\\s*#.*$", "", modelText__)
  modelText__ <- gsub("^\\s+$", "", modelText__)
  modelText__ <- modelText__[modelText__!=""]
  if (!any(grepl("********** MODEL NAME",modelText__,fixed = TRUE))) stopIQR("The '********** MODEL NAME' identifier is not present in the model")
  if (!any(grepl("********** MODEL NOTES",modelText__,fixed = TRUE))) stopIQR("The '********** MODEL NOTES' identifier is not present in the model")
  if (!any(grepl("********** MODEL PARAMETERS",modelText__,fixed = TRUE))) stopIQR("The '********** MODEL PARAMETERS' identifier is not present in the model")
  if (!any(grepl("********** MODEL VARIABLES",modelText__,fixed = TRUE))) stopIQR("The '********** MODEL VARIABLES' identifier is not present in the model")
  if (!any(grepl("********** MODEL REACTIONS",modelText__,fixed = TRUE))) stopIQR("The '********** MODEL REACTIONS' identifier is not present in the model")
  if (!any(grepl("********** MODEL FUNCTIONS",modelText__,fixed = TRUE))) stopIQR("The '********** MODEL FUNCTIONS' identifier is not present in the model")
  if (!any(grepl("********** MODEL EVENTS",modelText__,fixed = TRUE))) stopIQR("The '********** MODEL EVENTS' identifier is not present in the model")
  if (!any(grepl("********** MODEL STATES",modelText__,fixed = TRUE))
      &
      !any(grepl("********** MODEL STATE INFORMATION",modelText__,fixed = TRUE)))
    stopIQR("Neither the '********** MODEL STATES' nor the '********** MODEL STATE INFORMATION' identifier is present in the model (one of them is needed)")
  if (any(grepl("********** MODEL STATES",modelText__,fixed = TRUE))
      &
      any(grepl("********** MODEL STATE INFORMATION",modelText__,fixed = TRUE)))
    stopIQR("Both the '********** MODEL STATES' and the '********** MODEL STATE INFORMATION' identifier is present in the model (only one is allowed)")
  if (any(grepl("********** MODEL MATLAB FUNCTIONS",modelText__,fixed = TRUE)))
      stopIQR("'MODEL MATLAB FUNCTIONS' identifier present in the model.\nThis is not allowed - please take it out")
  sectionStarts__ <- which(grepl("********** MODEL",modelText__,fixed = TRUE))
  sectionLimits__ <- c(sectionStarts__, length(modelText__)+1)
  sections__ <- lapply(1:(length(sectionLimits__)-1), function (k__) {
    modelText__[sectionLimits__[k__]:(sectionLimits__[k__+1]-1)]
  })
  namesSections__ <- sapply(sections__,function (s__) s__[1])
  names(sections__) <- namesSections__
  model_name__        <- sections__$`********** MODEL NAME`
  model_notes__       <- sections__$`********** MODEL NOTES`
  if ("********** MODEL STATES" %in% namesSections__) {
    model_states__    <- sections__$`********** MODEL STATES`
    FLAGodeModel      <- TRUE
  } else {
    model_states__    <- sections__$`********** MODEL STATE INFORMATION`
    FLAGodeModel      <- FALSE
  }
  model_parameters__  <- sections__$`********** MODEL PARAMETERS`
  model_variables__   <- sections__$`********** MODEL VARIABLES`
  model_reactions__   <- sections__$`********** MODEL REACTIONS`
  model_functions__   <- sections__$`********** MODEL FUNCTIONS`
  model_events__      <- sections__$`********** MODEL EVENTS`
  if ("********** MODEL C FUNCTIONS" %in% namesSections__) {
    model_Cfunctions__ <- sections__$`********** MODEL C FUNCTIONS`
  } else {
    model_Cfunctions__ <- "********** MODEL C FUNCTIONS"
  }
  if ("********** MODEL INITIAL ASSIGNMENTS" %in% namesSections__) {
    model_initialassignments__ <- sections__$`********** MODEL INITIAL ASSIGNMENTS`
  } else {
    model_initialassignments__ <- "********** MODEL INITIAL ASSIGNMENTS"
  }
  if (length(model_name__) == 1) {
    model_name__ <- "Please provide a model name in one line"
  } else {
    model_name__ <- model_name__[2:length(model_name__)]
  }
  if (length(model_notes__) == 1) {
    model_notes__ <- "Please provide some model information\nMultiple lines possible"
  } else {
    model_notes__ <- model_notes__[2:length(model_notes__)]
  }
  if (length(model_states__) == 1) {
    model_states__ <- NULL
  } else {
    model_states__ <- model_states__[2:length(model_states__)]
  }
  if (length(model_parameters__) == 1) {
    model_parameters__ <- NULL
  } else {
    model_parameters__ <- model_parameters__[2:length(model_parameters__)]
  }
  if (length(model_variables__) == 1) {
    model_variables__ <- NULL
  } else {
    model_variables__ <- model_variables__[2:length(model_variables__)]
  }
  if (length(model_reactions__) == 1) {
    model_reactions__ <- NULL
  } else {
    model_reactions__ <- model_reactions__[2:length(model_reactions__)]
  }
  if (length(model_functions__) == 1) {
    model_functions__ <- NULL
  } else {
    model_functions__ <- model_functions__[2:length(model_functions__)]
  }
  if (length(model_events__) == 1) {
    model_events__ <- NULL
  } else {
    model_events__ <- model_events__[2:length(model_events__)]
  }
  if (length(model_Cfunctions__) == 1) {
    model_Cfunctions__ <- NULL
  } else {
    model_Cfunctions__ <- model_Cfunctions__[2:length(model_Cfunctions__)]
    model_Cfunctions__ <- paste0(aux_strtrim(model_Cfunctions__),collapse="\n")
  }
  if (length(model_initialassignments__) == 1) {
    model_initialassignments__ <- NULL
  } else {
    model_initialassignments__ <- model_initialassignments__[2:length(model_initialassignments__)]
  }
  model       <- init_IQRmodel()
  model$name  <- paste0(aux_strtrim(model_name__),collapse=" ")
  model$notes <- paste0(aux_strtrim(model_notes__),collapse="\n")
  model       <- parseParameters_IQRmodelText(model,model_parameters__)
  model       <- parseVariables_IQRmodelText(model,model_variables__)
  model       <- parseFunctions_IQRmodelText(model,model_functions__)
  model       <- parseEvents_IQRmodelText(model,model_events__)
  if (FLAGodeModel) {
    model              <- parseStatesODE_IQRmodelText(model,model_states__)
    model              <- parseReactionsODE_IQRmodelText(model,model_reactions__)
  } else {
    info__             <- parseReactionsBC_IQRmodelText(model,model_reactions__)
    model              <- info__$model
    model_states__     <- parseStatesBC_IQRmodelText(info__,model_states__)
    model              <- parseStatesODE_IQRmodelText(model,model_states__)
  }
  model       <- parseOutputs_IQRmodelText(model)
  model       <- parseInputs_IQRmodelText(model)
  model$Cfunctions <- model_Cfunctions__
  model       <- parseInitialAssigments_IQRmodelText(model,model_initialassignments__)
  return(model)
}
parseParameters_IQRmodelText <- function(model,model_parameters__) {
  for (k in seq_along(model_parameters__)) {
    parameterString   <- aux_strtrim(model_parameters__[k])
    commentInfo__     <- parseNotes_IQRmodelText(parameterString)
    parameterString   <- commentInfo__$main
    notesk__          <- commentInfo__$comment
    SBMLinfo__        <- parseSBMLinfo_IQRmodelText(parameterString,"parameter")
    typek__           <- SBMLinfo__$type
    compartmentk__    <- SBMLinfo__$compartment
    unittypek__       <- SBMLinfo__$unittype
    parameterString   <- SBMLinfo__$textString__
    temp__            <- regexpr("=", parameterString,fixed=TRUE)
    test__            <- aux_strtrim(substr(parameterString,1,(temp__[1]-1)))
    if (nchar(test__) == 0) stopIQR("At least one parameter name not given:\n", parameterString)
    namek__           <- aux_removeWhiteSpace(test__)
    valuek__          <- aux_strtrim(substr(parameterString,(temp__+1),nchar(parameterString)))
    if (nchar(valuek__) == 0) stopIQR("At least one parameter definition not given:\n", parameterString)
    model             <- addParameter_IQRmodel(model,
                                               name=namek__,
                                               value=as.numeric(valuek__),
                                               notes=notesk__,
                                               type=typek__,
                                               compartment=compartmentk__,
                                               unittype=unittypek__)
  }
  return(model)
}
parseVariables_IQRmodelText <- function(model,model_variables__) {
  for (k in seq_along(model_variables__)) {
    variableString    <- aux_strtrim(model_variables__[k])
    commentInfo__     <- parseNotes_IQRmodelText(variableString)
    variableString    <- commentInfo__$main
    notesk__          <- commentInfo__$comment
    SBMLinfo__        <- parseSBMLinfo_IQRmodelText(variableString,"variable")
    typek__           <- SBMLinfo__$type
    compartmentk__    <- SBMLinfo__$compartment
    unittypek__       <- SBMLinfo__$unittype
    variableString    <- SBMLinfo__$textString__
    temp__            <- regexpr("=", variableString,fixed=TRUE)
    test__            <- aux_strtrim(substr(variableString,1,(temp__[1]-1)))
    if (nchar(test__) == 0) stopIQR("At least one variable name not given")
    namek__           <- aux_removeWhiteSpace(test__)
    formulak__        <- aux_strtrim(substr(variableString,(temp__+1),nchar(variableString)))
    if (nchar(formulak__) == 0) stopIQR("At least one variable definition not given")
    model             <- addVariable_IQRmodel(model,
                                              name=namek__,
                                              formula=formulak__,
                                              notes=notesk__,
                                              type=typek__,
                                              compartment=compartmentk__,
                                              unittype=unittypek__)
  }
  return(model)
}
parseInitialAssigments_IQRmodelText <- function(model,model_initialassignments__) {
  for (k in seq_along(model_initialassignments__)) {
    variableString    <- aux_strtrim(model_initialassignments__[k])
    commentInfo__     <- parseNotes_IQRmodelText(variableString)
    elementString     <- commentInfo__$main
    notesk__          <- commentInfo__$comment
    temp__            <- regexpr("=", elementString,fixed=TRUE)
    test__            <- aux_strtrim(substr(elementString,1,(temp__[1]-1)))
    if (nchar(test__) == 0) stopIQR("At least one element name for initial assignments not given")
    namek__           <- aux_removeWhiteSpace(test__)
    formulak__        <- aux_strtrim(substr(elementString,(temp__+1),nchar(variableString)))
    if (nchar(formulak__) == 0) stopIQR("At least one element definition for initial assignments not given")
    model             <- addInitialAssignment_IQRmodel(model,
                                              name=namek__,
                                              formula=formulak__,
                                              notes=notesk__)
  }
  return(model)
}
parseFunctions_IQRmodelText <- function(model,model_functions__) {
  for (k in seq_along(model_functions__)) {
    functionString    <- aux_strtrim(model_functions__[k])
    commentInfo__     <- parseNotes_IQRmodelText(functionString)
    functionString    <- commentInfo__$main
    notesk__          <- commentInfo__$comment
    temp__            <- regexpr("(", functionString,fixed=TRUE)
    namek__           <- aux_strtrim(substr(functionString,1,(temp__[1]-1)))
    if (nchar(namek__) == 0) stopIQR("Check if all function names provided")
    namek__           <- aux_removeWhiteSpace(namek__)
    temp2__           <- regexpr(")", functionString,fixed=TRUE)
    test__            <- aux_strtrim(substr(functionString,(temp__[1]+1),(temp2__[1]-1)))
    if (nchar(test__) == 0)
      stopIQR("Check if all functions have arguments")
    argumentsk__      <- aux_removeWhiteSpace(test__)
    temp3__           <- regexpr("=", functionString)
    formulak__        <- aux_strtrim(substr(functionString,(temp3__[1]+1),nchar(functionString)))
    if(nchar(formulak__) == 0) stopIQR("Check if all functions have formulas")
    model             <- addFunction_IQRmodel(model,
                                              name=namek__,
                                              arguments=argumentsk__,
                                              formula=formulak__,
                                              notes=notesk__)
  }
  return(model)
}
parseEvents_IQRmodelText <- function(model,model_events__) {
  for (k in seq_along(model_events__)) {
    eventString__ <- aux_strtrim(model_events__[k])
    commentInfo__ <- parseNotes_IQRmodelText(eventString__)
    eventString__ <- commentInfo__$main
    notesk__      <- commentInfo__$comment
    temp__        <- regexpr("=", eventString__,fixed=TRUE)
    namek__       <- aux_strtrim(substr(eventString__,1,(temp__[1]-1)))
    if (nchar(namek__) == 0) stopIQR("At least one event name not given")
    eventRHS      <- aux_strtrim(substr(eventString__,temp__[1]+1,nchar(eventString__)))
    elementsRHS__ <- aux_explodePC(eventRHS)
    if ((length(elementsRHS__) < 3) | ((length(elementsRHS__) %% 2) == 0)) stopIQR("At least one event has no full information given")
    triggerk__    <- aux_removeWhiteSpace(elementsRHS__[1])
    model         <- addEvent_IQRmodel(model,
                                       name=namek__,
                                       trigger=aux_removeWhiteSpace(triggerk__),
                                       notes=notesk__)
    for (k2 in seq(2,length(elementsRHS__),2)) model <- addEventAssignment_IQRmodel(model,
                                                                                    eventname=namek__,
                                                                                    variable=aux_removeWhiteSpace(elementsRHS__[k2]),
                                                                                    formula=aux_removeWhiteSpace(elementsRHS__[k2+1]))
  }
  return(model)
}
parseStatesODE_IQRmodelText <- function(model,model_states__) {
  ODEtest__ <- grep("d/dt(", model_states__, fixed=TRUE)
  ICtest__ <- grep("(0)", model_states__, fixed=TRUE)
  if (length(ODEtest__)==0) stopIQR('The model does not contain any states')
  if (length(ICtest__) != 0) {
    if (max(ODEtest__) > min(ICtest__)) stopIQR('Initial conditions have to be defined after the definition of the ODEs')
  }
  for (k__ in seq_along(ODEtest__)) {
    stateString__  <- aux_strtrim(model_states__[ODEtest__[k__]])
    commentInfo__  <- parseNotes_IQRmodelText(stateString__)
    notesk__       <- commentInfo__$comment
    stateString__  <- commentInfo__$main
    SBMLinfo__     <- parseSBMLinfo_IQRmodelText(stateString__,"state")
    compartmentk__ <- SBMLinfo__$compartment
    typek__        <- SBMLinfo__$type
    unittypek__    <- SBMLinfo__$unittype
    stateString__  <- SBMLinfo__$textString__
    temp__         <- regexpr(")", stateString__, fixed=TRUE)
    test__         <- substr(stateString__,6,(temp__[1]-1))
    if (nchar(test__) == 0) stopIQR("At least on state name in ODE definition is not given")
    namek__        <- aux_removeWhiteSpace(test__)
    temp__         <- regexpr("=", stateString__, fixed=TRUE)
    test__         <- substr(stateString__,temp__[1]+1,nchar(stateString__))
    if (nchar(test__) == 0) stopIQR("At least one RHS of an ODE is not given")
    ODEk__         <- aux_strtrim(test__)
    if (substr(ODEk__,1,1) == "+") {
      ODEk__ <- aux_strtrim(substr(ODEk__,2,nchar(ODEk__)))
    }
    model          <- addState_IQRmodel(model,
                                        name=namek__,
                                        IC=0,
                                        ODE=ODEk__,
                                        type=typek__,
                                        compartment=compartmentk__,
                                        unittype=unittypek__,
                                        notes=notesk__)
  }
  for (k__ in seq_along(ICtest__)) {
    ICString__     <- aux_removeWhiteSpace(model_states__[ICtest__[k__]])
    temp__         <- regexpr("(0)", ICString__,fixed=TRUE)
    stateName__    <- aux_strtrim(substr(ICString__,1,temp__[1]-1))
    temp__         <- regexpr("=", ICString__,fixed=TRUE)
    stateIC__      <- aux_strtrim(substr(ICString__,temp__[1]+1,nchar(ICString__)))
    found__        <- FALSE
    ix__           <- unname(which(statesInfo_IQRmodel(model)$statenames==stateName__))
    if (length(ix__) != 0) {
      model$states[[stateName__]]$IC <- stateIC__
      found__     <- TRUE
    }
    if (!found__) stopIQR("An initial condition ( ", ICString__," ) is defined for a state that is not present in the model ( ", stateName__, " )")
  }
  return(model)
}
parseReactionsODE_IQRmodelText <- function(model,model_reactions__) {
  for (k in seq_along(model_reactions__)) {
    reactionString__ <- aux_strtrim(model_reactions__[k])
    commentInfo__    <- parseNotes_IQRmodelText(reactionString__)
    reactionString__ <- commentInfo__$main
    notesk__         <- commentInfo__$comment
    temp__           <- regexpr("=", reactionString__,fixed=TRUE)
    test__           <- aux_strtrim(substr(reactionString__,1,(temp__[1]-1)))
    if (nchar(test__) == 0) stopIQR("At least one reaction name not given")
    namek__          <- aux_removeWhiteSpace(test__)
    formulak__       <- aux_strtrim(substr(reactionString__,(temp__+1),nchar(reactionString__)))
    flagInfo__       <- parseReactionFlags_IQRmodelText(formulak__,"{fast}")
    formulak__       <- flagInfo__$textString__
    fastFlag         <- flagInfo__$flagPresent__
    flagInfo__       <- parseReactionFlags_IQRmodelText(formulak__,"{reversible}")
    formulak__       <- flagInfo__$textString__
    reversibleFlag   <- flagInfo__$flagPresent__
    if (nchar(formulak__) == 0) stopIQR("At least one reaction definition not given")
    model <- addReaction_IQRmodel(model,
                                  name=namek__,
                                  formula=formulak__,
                                  notes=notesk__,
                                  reversible=reversibleFlag,
                                  fast=fastFlag)
  }
  return(model)
}
parseReactionsBC_IQRmodelText <- function(model,model_reactions__) {
  reactionsList__   <- list()
  allSpecies__      <- c()
  k__               <- 1
  nReac__           <- 0
  while (k__ < length(model_reactions__)) {
    rowText__ = model_reactions__[k__]
    if (!is.null(aux_strFindAll(rowText__,":")$start)) {
      nReac__       <- nReac__+1
      reacInfo__    <- parseNotes_IQRmodelText(rowText__)
      reacDef__     <- aux_removeWhiteSpace(reacInfo__$main)
      reacNotes__   <- reacInfo__$comment
      flagCheck__   <- parseReactionFlags_IQRmodelText(reacDef__,"{fast}")
      reacFast      <- flagCheck__$flagPresent__
      reacDef__     <- flagCheck__$textString__
      if (!is.null(aux_strFindAll(reacDef__,"<=>")$start)) {
        reacReversible__   <- TRUE
        reacDef__          <- aux_strrep(reacDef__,"<=>","xyxyxyxy")
      } else {
        if (!is.null(aux_strFindAll(reacDef__,"=>")$start)) {
          reacReversible__ <- FALSE
          reacDef__        <- aux_strrep(reacDef__,"=>","xyxyxyxy")
        } else {
          stopIQR("Wrong reaction expression")
        }
      }
      terms              <- aux_explode(reacDef__,":")
      reacName__         <- terms[2]
      reacDef__          <- terms[1]
      terms              <- aux_explode(paste0(" ",reacDef__," "),"xyxyxyxy")
      reacLHS__          <- aux_strtrim(terms[1])
      reacRHS__          <- aux_strtrim(terms[2])
      k__                <- k__+1
      if (k__>length(model_reactions__)) stopIQR("Error in reaction expression")
      rowKineticsVF__    <- aux_removeWhiteSpace(model_reactions__[k__])
      if (is.null(aux_strFindAll(rowKineticsVF__,"vf=")$start)) stopIQR("Error in reaction expression")
      rowKineticsVF__    <- aux_strrep(rowKineticsVF__,"vf=","")
      if (reacReversible__) {
        k__              <- k__+1
        if (k__>length(model_reactions__)) stopIQR("error in reaction expression")
        rowKineticsVR__  <- aux_removeWhiteSpace(model_reactions__[k__])
        addParentheses__ <- FALSE
        termsplus__ <- aux_explodePC(rowKineticsVR__,"+")
        termsminus__ <- aux_explodePC(rowKineticsVR__,"-")
        if (length(termsplus__) > 1) addParentheses__ <- TRUE
        if (length(termsminus__) > 1) addParentheses__ <- TRUE
        if (addParentheses__) rowKineticsVR__ <- paste0("(",rowKineticsVR__,")")
        if (is.null(aux_strFindAll(rowKineticsVR__,"vr=")$start)) stopIQR("error in reaction expression")
        rowKineticsVR__  <- aux_strrep(rowKineticsVR__,"vr=","")
        reacFormula__    <- paste0(rowKineticsVF__,"-",rowKineticsVR__)
      } else {
        rowKineticsVR__  <- NULL
        reacFormula__    <- rowKineticsVF__
      }
    }
    model <- addReaction_IQRmodel(model,
                                  name=reacName__,
                                  formula=reacFormula__,
                                  notes=reacNotes__,
                                  reversible=reacReversible__,
                                  fast=reacFast)
    substrateInfo__      <- parseReactionTermsBC_IQRmodelText(reacLHS__)
    productInfo__        <- parseReactionTermsBC_IQRmodelText(reacRHS__)
    if (!is.null(substrateInfo__$names)) allSpecies__ <- unique(c(allSpecies__, substrateInfo__$names))
    if (!is.null(productInfo__$names))   allSpecies__ <- unique(c(allSpecies__, productInfo__$names))
    reactionsList__[[nReac__]] <- list(name=reacName__,
                                       substrateNames=substrateInfo__$names,
                                       substrateFactors=substrateInfo__$factors,
                                       productNames=productInfo__$names,
                                       productFactors=productInfo__$factors)
    k__ <- k__+1
  }
  return(list(model=model,allSpecies__=allSpecies__,reactionsList__=reactionsList__))
}
parseStatesBC_IQRmodelText <- function(info__,model_states__) {
  model                <- info__$model
  allSpecies__         <- info__$allSpecies__
  reactionsList__      <- info__$reactionsList__
  allSpeciesStates     <- c()
  allParNames          <- parametersInfo_IQRmodel(model)$paramnames
  allVarNames          <- variablesInfo_IQRmodel(model)$varnames
  for (k in seq_along(allSpecies__)) {
    parameterIndex     <- aux_strmatch(allSpecies__[k],allParNames)
    variableIndex      <- aux_strmatch(allSpecies__[k],allVarNames)
    if (is.null(parameterIndex) & is.null(variableIndex)) allSpeciesStates <- c(allSpeciesStates, allSpecies__[k])
  }
  for (k__ in seq_along(allSpeciesStates)) {
    stateName__        <- allSpeciesStates[k__]
    stateODE           <- ""
    for (k2__ in seq_along(reactionsList__)) {
      reacName__       <- reactionsList__[[k2__]]$name
      ix__             <- aux_strmatch(stateName__,reactionsList__[[k2__]]$substrateNames)
      if (!is.null(ix__))
        stateODE       <- paste0(stateODE,"-",reactionsList__[[k2__]]$substrateFactors[ix__],"*",reacName__)
      ix__ <- aux_strmatch(stateName__,reactionsList__[[k2__]]$productNames)
      if (!is.null(ix__))
        stateODE       <- paste0(stateODE,"+",reactionsList__[[k2__]]$productFactors[ix__],"*",reacName__)
    }
    ODEtext            <- paste0("d/dt(",stateName__,") = ",stateODE)
    model_states__     <- c(ODEtext,model_states__)
  }
  ix_ICs__             <- which(grepl("(0)",model_states__,fixed=TRUE))
  for (k__ in seq_along(ix_ICs__)) {
    xx__ <- model_states__[ix_ICs__[k__]]
    ixCB__ <- aux_strFindAll(xx__,"{")$start
    ixC1__ <- aux_strFindAll(xx__,"%")$start
    ixC2__ <- aux_strFindAll(xx__,"#")$start
    xxxx__ <- c(ixCB__,ixC1__,ixC2__)
    if (!is.null(xxxx__)) {
      annotation__ <- aux_strtrim(substr(xx__,min(xxxx__),nchar(xx__)))
      new_ICtext__ <- aux_strtrim(aux_strrep(xx__,annotation__,""))
      ix0__  <- aux_strFindAll(xx__,"(0)")$start
      stateName__ <- aux_removeWhiteSpace(substr(xx__,1,ix0__-1))
      model_states__[ix_ICs__[k__]] <- new_ICtext__
      ixState__ <- which(grepl(paste0("d/dt(",stateName__,")"),aux_removeWhiteSpace(model_states__),fixed=TRUE))
      model_states__[ixState__] <- paste0(model_states__[ixState__]," ",annotation__)
    }
  }
  return(model_states__)
}
parseNotes_IQRmodelText <- function(textString__) {
  startNotesMATLAB__ <- regexpr("%",textString__)
  startNotesR__      <- regexpr("#",textString__)
  if (startNotesMATLAB__ != -1 & startNotesR__ != -1)
    stopIQR("Both MATLAB and R-type comment signs used in the comment of a model element.\nPlease note that 'hashtag' and % are not allowed to be used in comments.")
  startNotes__       <- startNotesMATLAB__
  if (startNotesR__ != -1)
    startNotes__     <- startNotesR__
  notesk__           <- NULL
  if (startNotes__[1] != -1) {
    notesk__         <- aux_strtrim(substr(textString__,startNotes__[1]+1,nchar(textString__)))
    textString__     <- aux_strtrim(substr(textString__,1,startNotes__[1]-1))
    if (nchar(notesk__)==0)
      notesk__       <- NULL
  }
  return(list(main=textString__,comment=notesk__))
}
parseSBMLinfo_IQRmodelText <- function(textString__,elementname) {
  infoStart__         <- aux_strFindAll(textString__,"{")
  infoEnd__           <- aux_strFindAll(textString__,"}")
  informationText__   <- ""
  if ((length(infoStart__$start)+length(infoEnd__$start))>2)
    stopIQR(paste0("To many curly parentheses in a ",elementname," definition"))
  if (length(infoStart__$start) != length(infoEnd__$start))
    stopIQR(paste0("At least one ",elementname," information not properly defined"))
  if (!is.null(infoStart__$start)) {
    informationText__ <- aux_strtrim(substr(textString__,infoStart__$start+1,infoEnd__$start-1))
    textString__      <- aux_strtrim(substr(textString__,1,infoStart__$start-1))
  }
  type                <- NULL
  compartment         <- NULL
  unittype            <- NULL
  if(nchar(informationText__)>0) {
    terms             <- aux_explode(informationText__,':')
    found__           <- FALSE
    if (tolower(aux_strtrim(terms[1]))=="isparameter") {
      type            <- "isParameter"
      found__         <- TRUE
    }
    if (tolower(aux_strtrim(terms[1]))=="iscompartment") {
      type            <- "isCompartment"
      if (length(terms)==1) terms[2] = ""
      compartment     <- aux_strtrim(terms[2])
      found__         <- TRUE
    }
    if (tolower(aux_strtrim(terms[1]))=="isspecie") {
      type            <- "isSpecie"
      if (length(terms)!=3)
        stopIQR(paste0("Error in ",elementname," isSpecie SBML information"))
      compartment     <- aux_strtrim(terms[2])
      unittype        <- aux_strtrim(terms[3])
      found__         <- TRUE
    }
    if (!found__)
      stopIQR(paste0("Error in ",elementname," SBML information"))
  }
  return(list(textString__=textString__,type=type,compartment=compartment,unittype=unittype))
}
parseReactionFlags_IQRmodelText <- function(textString__,flagString) {
  if (!is.null(aux_strFindAll(textString__,flagString)$start)) {
    textString__  <- aux_strtrim(aux_strrep(textString__,flagString,""))
    flagPresent__ <- TRUE
  } else {
    flagPresent__ <- FALSE
  }
  return(list(textString__=textString__,flagPresent__=flagPresent__))
}
parseReactionTermsBC_IQRmodelText <- function(reactionEquation) {
  if (nchar(reactionEquation)==0) return(list(names=NULL, factors=NULL))
  allTerms__             <- aux_explode(reactionEquation,"\\+")
  termsNames__           <- c()
  termsFactors__         <- c()
  for (k__ in seq_along(allTerms__)) {
    checkTerms__         <- aux_explode(allTerms__[k__],"\\*")
    if (length(checkTerms__) == 1) {
      termsNames__       <- c(termsNames__, checkTerms__[1])
      termsFactors__     <- c(termsFactors__, 1)
    } else {
      if (length(checkTerms__) == 2) {
        termsNames__     <- c(termsNames__, checkTerms__[2])
        termsFactors__   <- c(termsFactors__, checkTerms__[1])
      } else {
        stopIQR("Error in a reaction equation")
      }
    }
  }
  return(list(names=termsNames__, factors=termsFactors__))
}
parseOutputs_IQRmodelText <- function(model) {
  if (length(grep("OUTPUT",names(model$states)))>0) stopIQR("'OUTPUT' present in a state name")
  if (length(grep("OUTPUT",names(model$parameters)))>0) stopIQR("'OUTPUT' present in a parameter name")
  if (length(grep("OUTPUT",names(model$reactions)))>0) stopIQR("'OUTPUT' present in a reaction name")
  Noutputs__ <- length(grep("OUTPUT",names(model$variables)))
  if (Noutputs__==0) return(model)
  for (k__ in 1:Noutputs__) {
    name__     <- paste0("OUTPUT",k__)
    varIndex__ <- grep(paste0("\\<",name__,"\\>"),names(model$variables))
    if (length(varIndex__)==0) stopIQR("OUTPUTs need to be defined in order 1,2,3,...N")
    formula__  <- model$variables[[varIndex__]]$formula
    notes__    <- model$variables[[varIndex__]]$notes
    outputInfo__ <- list(formula=formula__, notes=notes__, varindex=varIndex__)
    model$outputs[[name__]] <- outputInfo__
    test__ <- cbind(unname(which(formula__==names(model$states))),unname(which(formula__==names(model$variables))))
    if (length(test__)==0) warningIQR("An OUTPUT is defined by an expression. It is better to assign a variable or a state to an output (for MONOLIX export)")
  }
  return(model)
}
parseInputs_IQRmodelText <- function(model) {
  reacNamesInput__ <- names(model$reactions)[grep("INPUT",reactionsInfo_IQRmodel(model)$reacformulas)]
  for (k in seq_along(reacNamesInput__)) {
    reacName__    <- reacNamesInput__[k]
    reacFormula__ <- model$reactions[[reacName__]]$formula
    if (!is.null(aux_strFindAll(reacFormula__,"(")$start))  stopIQR("Model contains reaction with INPUT and parentheses in formula. Parentheses not allowed in this case!")
    if (!is.null(aux_strFindAll(reacFormula__,"+")$start)) stopIQR("Model contains a reaction with INPUT and a '+' sign. The '+' is not allowed. Reaction needs to be defined only be the input")
    if (!is.null(aux_strFindAll(reacFormula__,"-")$start)) stopIQR("Model contains a reaction with INPUT and a '-' sign. The '-' is not allowed. Reaction needs to be defined only be the input")
    for (k2 in seq_along(model$states))
      model$states[[k2]]$ODE <- gsub(pattern=paste0("\\<",reacName__,"\\>"),replacement=reacFormula__,x=model$states[[k2]]$ODE)
    for (k2 in 1:length(model$reactions))
      if (length(grep(paste0("\\b",reacName__,"\\b"),model$reactions[[k2]]$formula[k2]))>0)
        stopIQR("A reaction with an INPUT is present on the RHS of another reaction. This is not allowed!")
    model$reactions[[reacName__]] <- NULL
  }
  if (length(grep("\\bINPUT[0-9]+\\b",names(model$variables)))>0) stopIQR("Model variable name contains INPUT")
  if (length(grep("\\bINPUT[0-9]+\\b",names(model$reactions)))>0) stopIQR("Model reaction name contains INPUT")
  if (length(grep("\\bINPUT[0-9]+\\b",variablesInfo_IQRmodel(model)$varformulas))>0) stopIQR("Model variable formula contains INPUT")
  if (length(grep("\\bINPUT[0-9]+\\b",reactionsInfo_IQRmodel(model)$reacformulas))>0) stopIQR("Model variable formula contains INPUT")
  m         <- gregexpr("INPUT[0-9]+",statesInfo_IQRmodel(model)$stateODEs,perl=TRUE)
  y         <- as.numeric(aux_strrep(unique(unlist(regmatches(statesInfo_IQRmodel(model)$stateODEs,m))),"INPUT",""))
  NINPUTS__ <- length(y)
  if (NINPUTS__==0) return(model)
  if (min(y) != 1 | max(y) != NINPUTS__) stopIQR("INPUTs need to be ordered sequntially, starting from 1 until N=number of INPUTs")
  states__ <- statesInfo_IQRmodel(model)
  for (k in 1:NINPUTS__) {
    inputName__ <- paste0("INPUT",k)
    inputStateindex__ <- grep(paste0("\\b",inputName__,"\\b"),states__$stateODEs)
    parameters__ <- parametersInfo_IQRmodel(model)
    inputParindex__ <- grep(paste0("\\b",inputName__,"\\b"),parameters__$paramnames)
    if (length(inputParindex__)==0) {
      model <- addParameter_IQRmodel(model,name=inputName__,value=0)
      inputParindex__ <- length(model$parameters)
    }
    TlaginputParindex__ <- grep(paste0("\\bTlag",k,"\\b"),parameters__$paramnames)
    if (length(TlaginputParindex__)==0) {
      model <- addParameter_IQRmodel(model,name=paste0("Tlag",k),value=0)
    }
    inputFactors__ <- c()
    inputTerms__ <- c()
    for (k2 in inputStateindex__) {
      ODE__          <- aux_removeWhiteSpace(states__$stateODEs[[k2]])
      results__      <- parseInputFactorsTerms_IQRmodel(model,inputName__,ODE__)
      inputFactors__ <- cbind(inputFactors__,results__$inputFactor__)
      inputTerms__   <- cbind(inputTerms__,results__$inputTerm__)
    }
    model$inputs[[inputName__]] <- list(name=inputName__,
                                        factors=inputFactors__,
                                        terms=inputTerms__,
                                        stateindex=inputStateindex__,
                                        parindex=inputParindex__)
  }
  return(model)
}
parseInputFactorsTerms_IQRmodel <- function(model,inputName__,ODE__) {
  ix__ <- aux_strFindAll(ODE__,inputName__)
  if (length(ix__$start)>1) stopIQR("Same INPUT more than once on an ODE")
  if (ix__$start==1) {
    ODEpre__ <- ""
  } else {
    ODEpre__ <- aux_strtrim(substr(ODE__,1,ix__$start-1))
  }
  ODEpost__ <- aux_strtrim(substr(ODE__,ix__$end+1,nchar(ODE__)))
  if (nchar(ODEpost__) > 0) {
    if (substr(ODEpost__,1,1) != "+" & substr(ODEpost__,1,1) != "-") {
      stopIQR("The INPUT* identifier must be the last element in the input term")
    }
  }
  npo__ <- length(aux_strFindAll(ODEpost__,'(')$start)
  npc__ <- length(aux_strFindAll(ODEpost__,')')$start)
  if (npo__ != npc__) stopIQR("The INPUT* identifier is not allowed to be inside a parentheses")
  if (nchar(ODEpre__) > 0) {
    if (substr(ODEpre__,nchar(ODEpre__),nchar(ODEpre__)) != '+' &
        substr(ODEpre__,nchar(ODEpre__),nchar(ODEpre__)) != '-' &
        substr(ODEpre__,nchar(ODEpre__),nchar(ODEpre__)) != '*') {
      stopIQR("The INPUT term can have a multiplicative pre-term and the whole term needs to be additive")
    }
  }
  inputFactor__ <- NULL
  inputTerm__   <- NULL
  if (nchar(ODEpre__)==0) {
    inputFactor__ <- "1"
    inputTerm__ <- inputName__
    return(list(inputFactor__=inputFactor__, inputTerm__=inputTerm__))
  }
  if (substr(ODEpre__,nchar(ODEpre__),nchar(ODEpre__)) == "+") {
    inputFactor__ <- "1"
    inputTerm__ <- paste0("+",inputName__)
    return(list(inputFactor__=inputFactor__, inputTerm__=inputTerm__))
  }
  if (substr(ODEpre__,nchar(ODEpre__),nchar(ODEpre__)) == "-") {
    inputFactor__ <- "-1"
    inputTerm__ <- paste0("-",inputName__)
    return(list(inputFactor__=inputFactor__, inputTerm__=inputTerm__))
  }
  po <- 0
  for (k in nchar(ODEpre__):1) {
    if (substr(ODEpre__,k,k) == '(') po <- po+1
    if (substr(ODEpre__,k,k) == ')') po <- po-1
    if (substr(ODEpre__,k,k) == "+" & po==0) break
    if (substr(ODEpre__,k,k) == "-" & po==0) break
  }
  inputFactor__ <- substr(ODEpre__,k,nchar(ODEpre__)-1)
  inputTerm__ <- paste0(inputFactor__,"*",inputName__)
  testNames__ <- c(names(model$states),names(model$variables),names(model$reactions))
  for (k in seq_along(testNames__)) {
    test__ <- grep(paste0("\\<",testNames__[k],"\\>"),inputFactor__)
    if (length(test__)!=0)
      warningIQR("IMPORTANT (Will not work for NONMEM conversion!): Pre-factors of INPUT* terms are not allowed to depend on states, variables, and reactions")
  }
  return(list(inputFactor__=inputFactor__, inputTerm__=inputTerm__))
}
#'@export
new_IQRmodel <- function(filename="newmodel.txt",FLAGbc=FALSE) {
  if (is.null(filename)) stopIQR("Please provide a filename")
  filename <- paste0(aux_strrep(filename,".txt",""),".txt")
  model__ <- IQRmodel()
  if (FLAGbc) {
    export_IQRmodel(model__,filename=filename,FLAGbc=TRUE)
  } else {
    export_IQRmodel(model__,filename=filename)
  }
  file.edit(filename)
}
#'@export
is_IQRmodel <- function(input) {
  methods::is(input,"IQRmodel")
}
#'@export
print.IQRmodel <- function(x, ...) {
  cat("\tIQRmodel\n\t========\n")
  cat("\tName:                      ", x$name,"\n")
  cat("\tNumber States:             ", length(x$states),"\n")
  cat("\tNumber Parameters:         ", length(x$parameters),"\n")
  cat("\tNumber Variables:          ", length(x$variables),"\n")
  cat("\tNumber Reactions:          ", length(x$reactions),"\n")
  cat("\tNumber Functions:          ", length(x$functions),"\n")
  cat("\tNumber Events:             ", length(x$events),"\n")
  cat("\tNumber Inputs:             ", length(x$inputs),"\n")
  cat("\tNumber Outputs:            ", length(x$outputs),"\n")
  if (!hasOnlyNumericICs_IQRmodel(x)) {
    cat("\tNon-numeric initial conditions are present in the model.\n")
  }
  if (hasCcodeFunctions_IQRmodel(x)) {
    cat("\tC-code functions are present in the model.\n")
  }
  if (hasInitialAssignments_IQRmodel(x)) {
    cat("\tInitial assignments are present in the model.\n")
  }
}
#'@export
IQRmodel <- function (input=NULL,FLAGsim=TRUE,FLAGsym=FALSE,sensParams=NULL) {
  if (is.null(input)) return(init_IQRmodel())
  if (!file.exists(input)) stopIQR("Provided input argument does not point to a file on the filesystem.")
  if (aux_fileparts(input)$fileext==".xml") {
    model__ <- importSBML_IQRmodel(input)
  } else {
    model__ <- import_IQRmodel(input,FLAGtextIQRmodel=FALSE)
    checkNames_IQRmodel(model__)
  }
  model__ <- regenerate_IQRmodel(model = model__,FLAGsim=FLAGsim,FLAGsym=FLAGsym,sensParams=sensParams)
  checkOrderVarReacDefinition(model__)
  class(model__) <- "IQRmodel"
  return(model__)
}
hasOnlyNumericICs_IQRmodel <- function(model__) {
  test <- suppressWarnings(as.numeric(sapply(model__$states, function (x) { x$IC })))
  return (all(!is.na(test)))
}
hasFastReactions_IQRmodel <- function(model__) {
  if (!is_IQRmodel(model__))
    stopIQR("Input argument is not an IQRmodel")
  return(any(sapply(model__$reactions,function (x) x$fast)==TRUE))
}
#'@export
exportSBML_IQRmodel <- function(model,filename) {
  message("For export in SBML the following should be considered")
  message("  * All reaction rates are defined in amount/time units")
  message("  * Species ideally in amount and ODEs defined by sum of reaction rates")
  message("    * Stoichiometric factors can be numeric or parameters and need to be define in front of reaction names")
  message("      Example: d/dt(speciesAmount) = 2*reaction1 - reaction2 - 1*reaction3")
  message("  * Species can also be defined in concentration units. In this case the following needs to be done:")
  message("    * The volume of the compartment in which the species is located needs to be added to the ODE as follows:")
  message("      Example: d/dt(speciesConcentration) = (2*reaction1 - reaction2 - 1*reaction3)/volumeOfCompartment")
  loadSetupOptions_IQRtools()
  if (!file.exists(.PATH_IQRsbmlOut))
    stopIQR("The IQRsbmlOut executable has not been installed. Currently it is only available on IQdesktop (https://iqdesktop.intiquan.com)")
  if (!is_IQRmodel(model))
    stopIQR("model argument is not an IQRmodel")
  pathModel <- paste0(tempfileIQR(),".txt")
  export_IQRmodel(model = model,filename = pathModel)
  xxx__ <- aux_fileparts(pathModel)
  oldpath__ <- getwd()
  setwd(xxx__$pathname)
  absModelPath__ <- paste0(getwd(),"/",xxx__$filename,xxx__$fileext)
  setwd(oldpath__)
  xxx__ <- aux_fileparts(filename)
  oldpath__ <- getwd()
  setwd(xxx__$pathname)
  absOutputPath__ <- paste0(getwd(),"/",xxx__$filename,xxx__$fileext)
  setwd(oldpath__)
  aux_mkdir(xxx__$pathname)
  syscall__ <- paste0(.PATH_IQRsbmlOut, " \"",absModelPath__, "\" \"",absOutputPath__,"\"")
  system(syscall__)
  return(invisible(NULL))
}
#'@export
importSBML_IQRmodel <- function(input,FLAGexportBC=FALSE,FLAGcheckComplete=FALSE,FLAGuseSBMLnames=FALSE,FLAGremoveSBMLinfo=FALSE,filename=NULL,FLAGchangeINPUT=FALSE) {
  loadSetupOptions_IQRtools()
  if (!file.exists(.PATH_IQRsbml))
    stopIQR("The IQRsbml executable has not been installed. Please obtain it from http://www.intiquan.com/iqrsbml for Windows or use IQdesktop (https://iqdesktop.intiquan.com)")
  if (!file.exists(input))
    stopIQR("SBML file not found")
  tempfile <- input
  if (FLAGchangeINPUT) {
    content <- aux_fileread(input)
    content <- gsub("\\<IN_PUT([1-9]+)\\>", "INPUT\\1", content)
    tempfile <- paste0(tempfileIQR(),".xml")
    aux_filewrite(content,filename = tempfile)
  }
  xxx__ <- aux_fileparts(tempfile)
  oldpath__ <- getwd()
  setwd(xxx__$pathname)
  absModelPath__ <- paste0(getwd(),"/",xxx__$filename,xxx__$fileext)
  setwd(oldpath__)
  outPath <- tempfileIQR()
  FLAGexportBC <- as.numeric(FLAGexportBC)
  FLAGcheckComplete <- as.numeric(FLAGcheckComplete)
  FLAGuseSBMLnames <- as.numeric(FLAGuseSBMLnames)
  FLAGremoveSBMLinfo <- as.numeric(FLAGremoveSBMLinfo)
  syscall__ <- paste0(.PATH_IQRsbml, " \"",absModelPath__, "\" \"",outPath,"\""," ",FLAGexportBC," ",FLAGcheckComplete," ",FLAGuseSBMLnames," ",FLAGremoveSBMLinfo)
  system(syscall__)
  content <- aux_fileread(paste0(outPath,".txt"),collapserows = FALSE)
  suppressWarnings(
    if (any(grepl("default =|\\(default\\)",content))) {
      warning("'default' present as component name in SBML model. All occurrence of 'default' changed to 'def_ault'")
      content <- gsub("\\<default\\>","def_ault",content)
    }
  )
  if (is.null(filename)) {
    model__ <- suppressWarnings(import_IQRmodel(content,FLAGtextIQRmodel=TRUE))
    return(model__)
  } else {
    aux_filewrite(content,paste0(gsub(".txt","",filename),".txt"))
  }
  return(invisible(NULL))
}
init_IQRmodel <- function () {
  model__        <- list()
  model__$name   <- "Provide Model Name"
  model__$notes  <- "Provide Model Information"
  class(model__) <- "IQRmodel"
  return(model__)
}
checkNames_IQRmodel <- function(model) {
  loadSetupOptions_IQRtools()
  stateNames__ <- toupper(statesInfo_IQRmodel(model)$statenames)
  paramNames__ <- toupper(parametersInfo_IQRmodel(model)$paramnames)
  varNames__   <- toupper(variablesInfo_IQRmodel(model)$varnames)
  reacNames__  <- toupper(reactionsInfo_IQRmodel(model)$reacnames)
  if (!.ALLOW_UNDERSCORES_IN_PARAMETER_NAMES) {
    if (any(grepl("_",paramNames__)))
      stopIQR("At least one parameter name contains an '_'.\nThis is not allowed mainly for NLME model and covariate purposes.\nThis check can be switched off in the setup_options_IQRtools.R file. Run setup_IQRtools() if you want to change the file.")
  }
  if (length(which(nchar(stateNames__) > .MODEL_MAX_DESIRED_STATENAME_LENGTH)) > 0)
    warningIQR(paste0("Some state names have more than ",.MODEL_MAX_DESIRED_STATENAME_LENGTH," characters.\nIt makes sense to not have them too long (for good old NONMEM)\nYou can set warning thresholds in the setup_options_IQRtools.R file. Run setup_IQRtools() if you want to change the file."))
  if (length(which(nchar(paramNames__) > .MODEL_MAX_DESIRED_PARAMETERNAME_LENGTH)) > 0)
    warningIQR(paste0("Some parameter names have more than ",.MODEL_MAX_DESIRED_PARAMETERNAME_LENGTH," characters.\nIt makes sense to use a max length of 8 (for good old requirements in XPT files for the FDA)\nYou can set warning thresholds in the setup_options_IQRtools.R file. Run setup_IQRtools() if you want to change the file."))
  if (length(which(nchar(varNames__) > .MODEL_MAX_DESIRED_VARIABLENAME_LENGTH)) > 0)
    warningIQR(paste0("Some variable names have more than ",.MODEL_MAX_DESIRED_VARIABLENAME_LENGTH," characters.\nIt makes sense to not have them too long (for good old NONMEM)\nYou can set warning thresholds in the setup_options_IQRtools.R file. Run setup_IQRtools() if you want to change the file."))
  if (length(which(nchar(reacNames__) > .MODEL_MAX_DESIRED_REACTIONNAME_LENGTH)) > 0)
    warningIQR(paste0("Some reaction names have more than ",.MODEL_MAX_DESIRED_REACTIONNAME_LENGTH," characters.\nIt makes sense to not have them too long (for good old NONMEM)\nYou can set warning thresholds in the setup_options_IQRtools.R file. Run setup_IQRtools() if you want to change the file."))
  reservedWords__ <- toupper(.RESERVED_WORD_IQRMODELS)
  if (length(intersect(stateNames__,reservedWords__)) > 0) {
    text <- paste0("Model contains the following states that are reserved words: ",intersect(stateNames__,reservedWords__))
    text <- paste0(text,"\nYou can set the reserved words in the setup_options_IQRtools.R file. Run setup_IQRtools() if you want to change the file.")
    stopIQR(text)
  }
  if (length(intersect(paramNames__,reservedWords__)) > 0) {
    text <- paste0("Model contains the following parameters that are reserved words: ",intersect(paramNames__,reservedWords__))
    text <- paste0(text,"\nYou can set the reserved words in the setup_options_IQRtools.R file. Run setup_IQRtools() if you want to change the file.")
    stopIQR(text)
  }
  if (length(intersect(varNames__,reservedWords__)) > 0) {
    text <- paste0("Model contains the following variables that are reserved words: ",intersect(varNames__,reservedWords__))
    text <- paste0(text,"\nYou can set the reserved words in the setup_options_IQRtools.R file. Run setup_IQRtools() if you want to change the file.")
    stopIQR(text)
  }
  if (length(intersect(reacNames__,reservedWords__)) > 0) {
    text <- paste0("Model contains the following reactions that are reserved words: ",intersect(reacNames__,reservedWords__))
    text <- paste0(text,"\nYou can set the reserved words in the setup_options_IQRtools.R file. Run setup_IQRtools() if you want to change the file.")
    stopIQR(text)
  }
  if (any(grepl("\\<TLAG[0-9]*\\>",stateNames__)))
    stopIQR("A state name contains Tlag* (case insensitive). This is not allowed")
  if (any(grepl("\\<TLAG[0-9]*\\>",varNames__)))
    stopIQR("A variable name contains Tlag* (case insensitive). This is not allowed")
  if (any(grepl("\\<TLAG[0-9]*\\>",reacNames__)))
    stopIQR("A reaction name contains Tlag* (case insensitive). This is not allowed")
  inputindices <- unique(as.numeric(aux_strrep(paramNames__[grepl("\\<TLAG[0-9]*\\>",paramNames__)],"TLAG","")))
  if (length(inputindices) != length(model$inputs))
    stopIQR("Model contains a non match between Tlag* parameters and INPUT* definitions")
  if (length(inputindices) > 0) {
    if (min(inputindices) != 1 & max(inputindices) != length(model$inputs))
      stopIQR("Model contains a non match between Tlag* parameters and INPUT* definitions")
  }
}
#'@export
regenerate_IQRmodel <- function(model,FLAGsim=TRUE,FLAGsym=TRUE,sensParams=NULL) {
  regenmodel__                           <- model
  if (!is.null(sensParams)) {
    if (length(setdiff(sensParams,parametersInfo_IQRmodel(regenmodel__)$paramnames)) > 0)
      stopIQR("Provided sensitivity parameters not all available in the model")
  } else {
    sensParams <- parametersInfo_IQRmodel(regenmodel__)$paramnames
    sensParams <- setdiff(sensParams,sensParams[grep(x=sensParams,pattern = "\\<INPUT[0-9]+\\>")])
  }
  attr(regenmodel__,"sensParams.IQRmodel") <- sensParams
  IA__ <- regenmodel__$initalAssignments
  IAstates__ <- intersect(names(IA__),names(regenmodel__$states))
  adummy__ <- sapply(IAstates__, function (ias__) {
    regenmodel__$states[[ias__]]$IC <<- IA__[[ias__]]$formula
  })
  modelVectorSyntaxR <- handleVectorSyntaxR_IQRmodel(regenmodel__)
  attr(regenmodel__,"nonNumICs.IQRmodel") <- nonNumICsFct_IQRmodel(modelVectorSyntaxR)
  if (FLAGsym) {
    attr(regenmodel__,"nonNumICsSens.IQRmodel") <- nonNumICsSensFct_IQRmodel(modelVectorSyntaxR,sensParams)
    attr(regenmodel__,"dfdx.IQRmodel") <- symStateJacobian_IQRmodel(regenmodel__)
    attr(regenmodel__,"dfdp.IQRmodel") <- symStateGradient_IQRmodel(regenmodel__,paramnames = sensParams)
    if (length(regenmodel__$outputs) > 0) {
      attr(regenmodel__,"dgdx.IQRmodel") <- symOutputJacobian_IQRmodel(regenmodel__)
      attr(regenmodel__,"dgdp.IQRmodel") <- symOutputGradient_IQRmodel(regenmodel__,paramnames = sensParams)
    } else {
      attr(regenmodel__,"dgdx.IQRmodel") <- NULL
      attr(regenmodel__,"dgdp.IQRmodel") <- NULL
    }
  }
  if (length(regenmodel__$states) < 50) {
    attr(regenmodel__,"dfdx.IQRmodel") <- tryCatch({symStateJacobian_IQRmodel(regenmodel__)}, error=function(err) NULL)
  }
  if (FLAGsim) regenmodel__ <- compile_IQRmodel(model = regenmodel__)
  return(regenmodel__)
}
dynLoadModelDLL_IQRmodel <- function(model__) {
  if (!is_IQRmodel(model__)) stopIQR("Please provide a model as input argument")
  DLLfile__ <- attr(model__,"DLLpath.IQRmodel")
  if (.Platform$OS.type=="unix") {
    DLLfile__ <- paste0(DLLfile__,".so")
  }
  dyn.load(DLLfile__)
}
#'@export
reload_DLLIQRmodel <- function(model){
  .so__ <- switch(Sys.info()["sysname"], "Linux" = ".so", "Windows" = "")
  dyn.load(paste0(attr(model, "DLLpath.IQRmodel"), .so__))
  ptr__ <- getNativeSymbolInfo("model",PACKAGE=attr(model,"DLLname.IQRmodel"))$address
  attr(model,"address.IQRmodel") <- ptr__
  model
}
#'@export
strReplace_IQRmodel <- function(model,old,new,regenerateModel=FALSE) {
  text__ <- export_IQRmodel(model)
  for (k in seq_along(old)) {
    text__ <- gsub(x = text__,pattern = paste0("\\b",old[k],"\\b"),replacement = new[k])
  }
  modelnew <- import_IQRmodel(input=aux_explode(text__,"\n"),FLAGtextIQRmodel=TRUE)
  if (regenerateModel) modelnew <- regenerate_IQRmodel(modelnew,FLAGsim = TRUE,FLAGsym = FALSE,sensParams = NULL)
  return(modelnew)
}
#'@export
hasCcodeFunctions_IQRmodel <- function(model) {
  if (!is_IQRmodel(model))
    stopIQR("input argument is not an IQRmodel")
  if (is.null(model$Cfunctions)) return(FALSE)
  if (nchar(model$Cfunctions)==0) return(FALSE)
  return(TRUE)
}
#'@export
hasInitialAssignments_IQRmodel <- function(model) {
  if (!is_IQRmodel(model))
    stopIQR("input argument is not an IQRmodel")
  if (is.null(model$initalAssignments)) return(FALSE)
  return(TRUE)
}
addState_IQRmodel <- function(model,
                              name,
                              IC,
                              ODE,
                              type = NULL,
                              compartment = NULL,
                              unittype = NULL,
                              notes = NULL) {
  if (name %in% names(model$states))
    stopIQR("Provided state name already exists in the model")
  if (!is.null(type)) {
    if (!(type %in% c("isSpecie", "isCompartment", "isParameter"))) {
      stopIQR("Wrong definition of 'type'. Needs to be 'isSpecie', 'isCompartment', or 'isParameter'")
    }
  }
  if (!is.null(unittype)) {
    if (!(unittype %in% c("amount", "concentration"))) {
      stopIQR("Wrong definition of 'unittype'. Needs to be 'amount' or 'concentration'")
    }
  }
  model$states[[name]] <- list(IC          = IC,
                               ODE         = ODE,
                               type        = type,
                               compartment = compartment,
                               unittype    = unittype,
                               notes       = notes)
  return(model)
}
addParameter_IQRmodel <- function(model,
                                  name,
                                  value,
                                  type = NULL,
                                  compartment = NULL,
                                  unittype = NULL,
                                  notes = NULL) {
  if (name %in% names(model$parameters))
    stopIQR(paste0("Provided parameter name (", name, ") already exists in the model"))
  if (!is.null(type)) {
    if (!(type %in% c("isSpecie", "isCompartment", "isParameter"))) {
      stopIQR("Wrong definition of 'type'. Needs to be 'isSpecie', 'isCompartment', or 'isParameter'")
    }
  }
  if (!is.null(unittype)) {
    if (!(unittype %in% c("amount", "concentration"))) {
      stopIQR("Wrong definition of 'unittype'. Needs to be 'amount' or 'concentration'")
    }
  }
  model$parameters[[name]] <- list(value       = value,
                                   type        = type,
                                   compartment = compartment,
                                   unittype    = unittype,
                                   notes       = notes)
  return(model)
}
#'@export
setParameters_IQRmodel <- function(model,parameters) {
  if (!is_IQRmodel(model))
    stopIQR("model input argument is not an IQRmodel")
  if (is.null(names(parameters)))
    stopIQR("parameters input argument needs to be a vector with named elements")
  if (any(!(names(parameters) %in% names(model$parameters))))
    stopIQR("At least one provided parameter is not available in the model: ",
            paste0(setdiff(names(model$parameters), names(parameters)), collapse = ", "))
  if (!is.numeric(parameters))
    stopIQR("Parameters are only allowed to be numeric values")
  sapply(names(parameters), function (pname) {
    model$parameters[[pname]]$value <<- unname(parameters[pname])
  })
  return(model)
}
addVariable_IQRmodel <- function(model,
                                 name,
                                 formula,
                                 type = NULL,
                                 compartment = NULL,
                                 unittype = NULL,
                                 notes = NULL) {
  if (name %in% names(model$variables))
    stopIQR("Provided variable name already exists in the model: ", name)
  if (!is.null(type)) {
    if (!(type %in% c("isSpecie", "isCompartment", "isParameter"))) {
      stopIQR("In variable ", name, ", type ", type,":\n",
              "Wrong definition of 'type'. Needs to be 'isSpecie', 'isCompartment', or 'isParameter'")
    }
  }
  if (!is.null(unittype)) {
    if (!(unittype %in% c("amount", "concentration"))) {
      stopIQR("In variable ", name, ", type ", unittype,":\n",
              "Wrong definition of 'unittype'. Needs to be 'amount' or 'concentration'")
    }
  }
  model$variables[[name]] <- list(formula     = formula,
                                  type        = type,
                                  compartment = compartment,
                                  unittype    = unittype,
                                  notes       = notes)
  return(model)
}
addInitialAssignment_IQRmodel <- function(model,
                                          name,
                                          formula,
                                          notes = NULL) {
  if (name %in% names(model$initalAssignments))
    stopIQR("Provided initial assignment element name already exists in the model: ", name)
  model$initalAssignments[[name]] <- list(formula     = formula,
                                          notes       = notes)
  return(model)
}
addReaction_IQRmodel <- function(model,
                                 name,
                                 formula,
                                 notes = NULL,
                                 reversible = FALSE,
                                 fast = FALSE) {
  if (name %in% names(model$reactions))
    stopIQR("Provided reaction name already exists in the model: ", name)
  model$reactions[[name]] <- list(formula    = formula,
                                  notes      = notes,
                                  reversible = reversible,
                                  fast       = fast)
  return(model)
}
addFunction_IQRmodel <- function(model,
                                 name,
                                 arguments,
                                 formula,
                                 notes = NULL) {
  if (name %in% names(model$functions))
    stopIQR("Provided function name already exists in the model: ", name)
  model$functions[[name]] <- list(arguments = arguments,
                                  formula   = formula,
                                  notes     = notes)
  return(model)
}
addEvent_IQRmodel <- function(model,
                              name,
                              trigger,
                              notes = NULL) {
  if (name %in% names(model$events))
    stopIQR("Provided event name already exists in the model: ", name)
  model$events[[name]] <- list(name       = name,
                               trigger    = trigger,
                               assignment = NULL,
                               notes      = notes)
  return(model)
}
addEventAssignment_IQRmodel <- function(model,
                                        eventname,
                                        variable,
                                        formula) {
  model$events[[eventname]]$assignment[[length(model$events[[eventname]]$assignment)+1]] <- list(variable=variable, formula=formula)
  return(model)
}
delInput_IQRmodel <- function(model, inputname) {
  si <- model$inputs[[inputname]]$stateindex
  for (k in seq_along(si)) {
    model$states[[si[k]]]$ODE <- aux_strrep(aux_removeWhiteSpace(model$states[[si[k]]]$ODE),model$inputs[[inputname]]$terms[[k]],"")
  }
  model$inputs[[inputname]] <- NULL
  model$parameters[[inputname]] <- NULL
  return(model)
}
#'@export
gt <- function (x,y) {
  return(as.numeric(x>y))
}
#'@export
ge <- function (x,y) {
  return(as.numeric(x>=y))
}
#'@export
lt <- function (x,y) {
  return(as.numeric(x<y))
}
#'@export
le <- function (x,y) {
  return(as.numeric(x<=y))
}
#'@export
mod <- function (x,y) {
  return(x %% y)
}
#'@export
and <- function (...) {
  varargin <- unlist(list(...))
  return(as.numeric(all(varargin==1)))
}
#'@export
or <- function (...) {
  varargin <- unlist(list(...))
  return(as.numeric(any(varargin==1)))
}
#'@export
piecewise <- function (...) {
  varargin <- unlist(list(...))
  nargin <- length(varargin)
  result <- NULL
  oddnumber = mod(nargin,2)
  for (k in seq(1,nargin-oddnumber,2)) {
    if (varargin[k+1] != 0) {
      result <- varargin[k]
      return(result)
    }
  }
  if (is.null(result)) {
    if (oddnumber==1) {
      result <- varargin[nargin]
    } else {
      stopIQR('Piecewise statement is wrongly defined - missing (but needed) default value');
    }
  }
  return(result)
}
#'@export
interp0 <- function (x,y,xi) {
  if (xi >= x[length(x)]) return(y[length(y)])
  if (xi <= x[1]) return(y[1])
  return(stats::approx(x,y,xi,method="const")$y)
}
#'@export
interp1 <- function (x,y,xi) {
  if (xi >= x[length(x)]) return(y[length(y)])
  if (xi <= x[1]) return(y[1])
  return(stats::approx(x,y,xi,method="linear")$y)
}
#'@export
interpcs <- function (x,y,xi) {
  if (xi >= x[length(x)]) return(y[length(y)])
  if (xi <= x[1]) return(y[1])
  return(stats::spline(x=x,y=y,xout=xi,method="natural")$y)
}
statesInfo_IQRmodel <- function(model__) {
  if (length(model__$states)==0)
    return(list(statenames=NULL,stateICs=NULL,stateODEs=NULL))
  statenames__ <- names(model__$states)
  stateICs__   <- c()
  stateODEs__  <- c()
  dummy__ <- sapply(model__$states, function (x) {
    stateICs__ <<- c(stateICs__, x$IC)
    stateODEs__ <<- c(stateODEs__, x$ODE)
  })
  names(statenames__) <- statenames__
  names(stateICs__) <- statenames__
  names(stateODEs__) <- statenames__
  return(list(statenames=statenames__,stateICs=stateICs__,stateODEs=stateODEs__))
}
parametersInfo_IQRmodel <- function(model__) {
  if (length(model__$parameters)==0)
    return(list(paramnames=NULL,paramvalues=NULL))
  paramnames__ <- names(model__$parameters)
  paramvalues__ <- sapply(model__$parameters, function (x) {
    x$value
  })
  names(paramnames__) <- paramnames__
  return(list(paramnames=paramnames__,paramvalues=paramvalues__))
}
variablesInfo_IQRmodel <- function(model__) {
  if (length(model__$variables)==0)
    return(list(varnames=NULL,varformulas=NULL))
  varnames__ <- names(model__$variables)
  varformulas__ <- sapply(model__$variables, function (x) {
    x$formula
  })
  names(varnames__) <- varnames__
  return(list(varnames=varnames__,varformulas=varformulas__))
}
reactionsInfo_IQRmodel <- function(model__) {
  if (length(model__$reactions)==0)
    return(list(reacnames=NULL,reacformulas=NULL,reacfast=NULL,reacreversible=NULL))
  reacnames__ <- names(model__$reactions)
  reacformulas__ <- c()
  reacfast__ <- c()
  reacreversible__ <- c()
  dummy__ <- sapply(model__$reactions, function (x) {
    reacformulas__ <<- c(reacformulas__, x$formula)
    reacfast__ <<- c(reacfast__, x$fast)
    reacreversible__ <<- c(reacreversible__, x$reversible)
  })
  names(reacnames__) <- reacnames__
  names(reacformulas__) <- reacnames__
  names(reacfast__) <- reacnames__
  names(reacreversible__) <- reacnames__
  return(list(reacnames=reacnames__,reacformulas=reacformulas__,reacfast=reacfast__,reacreversible=reacreversible__))
}
functionsInfo_IQRmodel <- function(model__) {
  if (length(model__$functions)==0)
    return(list(funcnames=NULL,funcformulas=NULL,funcarguments=NULL))
  funcnames__ <- names(model__$functions)
  funcformulas__ <- c()
  funcarguments__ <- c()
  dummy__ <- sapply(model__$functions, function (x) {
    funcformulas__ <<- c(funcformulas__, x$formula)
    funcarguments__ <<- c(funcarguments__, x$arguments)
  })
  names(funcnames__) <- funcnames__
  names(funcformulas__) <- funcnames__
  names(funcarguments__) <- funcnames__
  return(list(funcnames=funcnames__,funcformulas=funcformulas__,funcarguments=funcarguments__))
}
eventsInfo_IQRmodel <- function(model__) {
  if (length(model__$events)==0)
    return(list(evenames=NULL,evetriggers=NULL,evevariables=NULL,eveformulas=NULL))
  evenames__ <- names(model__$events)
  evetriggers__ <- c()
  evevariables__ <- c()
  eveformulas__ <- c()
  dummy__ <- sapply(model__$events, function (x) {
    evetriggers__ <<- c(evetriggers__, x$trigger)
    assignmentInfo__ <- unname(unlist(x$assignment))
    evevariables__ <<- c(evevariables__, list(assignmentInfo__[seq(1,length(assignmentInfo__),2)]))
    eveformulas__ <<- c(eveformulas__, list(assignmentInfo__[seq(2,length(assignmentInfo__),2)]))
  })
  names(evenames__) <- evenames__
  names(evetriggers__) <- evenames__
  names(evevariables__) <- evenames__
  names(eveformulas__) <- evenames__
  return(list(evenames=evenames__,evetriggers=evetriggers__,evevariables=evevariables__,eveformulas=eveformulas__))
}
outputInfo_IQRmodel <- function(model__) {
  if (length(model__$outputs)==0)
    return(list(outnames=NULL,outformulas=NULL,outvarindices=NULL))
  outnames__      <- names(model__$outputs)
  outformulas__   <- c()
  outvarindices__ <- c()
  dummy__ <- sapply(model__$outputs, function (x) {
    outformulas__ <<- c(outformulas__, x$formula)
    outvarindices__ <<- c(outvarindices__, x$varindex)
  })
  names(outnames__)      <- outnames__
  names(outformulas__)   <- outnames__
  names(outvarindices__) <- outnames__
  return(list(outnames=outnames__,outformulas=outformulas__,outvarindices=outvarindices__))
}
checkOrderVarReacDefinition <- function (model__) {
  X <- tryCatch({
    param__ <- sapply(model__$parameters, function (x__) x__$value)
    ICs__ <- sapply(model__$states, function (x__) x__$IC)
    states__ <- attributes(model__)$nonNumICs.IQRmodel(param__,ICs__,0)$ICs
    vars__ <- sapply(model__$variables, function (x__) x__$formula)
    reac__ <- sapply(model__$reactions, function (x__) x__$formula)
    time <- 0
    if (length(model__$variables) > 0) eval(parse(text=paste0(names(vars__),"<-NA")))
    if (length(model__$reactions) > 0) eval(parse(text=paste0(names(reac__),"<-NA")))
    eval(parse(text=paste0(names(states__),"<-",states__)))
    eval(parse(text=paste0(names(param__),"<-",param__)))
    if (length(model__$variables) > 0) eval(parse(text=paste0(names(vars__),"<-",vars__)))
    if (length(model__$reactions) > 0) eval(parse(text=paste0(names(reac__),"<-",reac__)))
    if (length(model__$variables) > 0) testVars__ <- sapply(names(vars__), function (x__) eval(parse(text=paste0("test<-",x__))))
    if (length(model__$reactions) > 0) testReac__ <- sapply(names(reac__), function (x__) eval(parse(text=paste0("test<-",x__))))
    "OK"
  }, error = function(err) {
    NULL
  })
  if (!is.null(X)) {
    if (length(model__$variables) > 0)  {
      ix__ <- which(is.na(testVars__))
      if (length(ix__) > 0) {
        stopIQR("The following variables are wrongly defined\nThe reason could be incorrect order of assignment or a divison by zero:\n",
                paste0(names(ix__),collapse=", "))
      }
    }
    if (length(model__$reactions) > 0) {
      ix__ <- which(is.na(testReac__))
      if (length(ix__) > 0) {
        stopIQR("The following reactions are wrongly defined\nThe reason could be incorrect order of assignment or a divison by zero:\n",
                paste0(names(ix__),collapse=", "))
      }
    }
  }
}
obfuscate_IQRmodel <- function(model, filename = NULL) {
  foldername <- tempdirIQR()
  modelname <- model
  if (is_IQRmodel(model)) {
    modelname <- file.path(foldername, "tmp.txt")
    export_IQRmodel(model, filename = modelname)
  }
  con <- file(modelname)
  script <- readLines(con)
  close.connection(con)
  is_eq <- sapply(script, function(s) !inherits(try(parse(text = s), silent = TRUE), "try-error") & grepl("=", s, fixed = TRUE))
  script[is_eq] <- sub("d/dt", "diffOp__", script[is_eq])
  symbols <- getSymbols(script[is_eq], exclude = "diffOp__")
  symbols <- symbols[!grepl("^INPUT[1-9]", symbols) & !grepl("^OUTPUT[1-9]", symbols)]
  nsymbols <- log10(length(symbols))
  newsymbols <- paste0("x", formatC(1:length(symbols), flag = "0", digits = ceiling(nsymbols)))
  script[is_eq] <- replaceSymbols(symbols, newsymbols, script[is_eq])
  script[is_eq] <- sub("diffOp__", "d/dt", script[is_eq])
  con <- file(file.path(foldername, "tmp.txt"))
  writeLines(script, con, sep = "\n")
  close.connection(con)
  m <- IQRmodel(file.path(foldername, "tmp.txt"), FLAGsim = FALSE)
  m$parameters <- lapply(m$parameters, function(mypar) {
    mypar$value <- signif(mypar$value*exp(stats::rnorm(1, 0, 1)), 3)
    return(mypar)
  })
  getNumbers <- function (char, exclude = NULL) {
    if (is.null(char))
      return(NULL)
    char <- char[char != "0"]
    out <- parse(text = char, keep.source = TRUE)
    out <- utils::getParseData(out)
    names <- unique(out$text[out$token == "NUM_CONST"])
    if (!is.null(exclude))
      names <- names[!names %in% exclude]
    return(names)
  }
  m$states <- lapply(m$states, function(mypar) {
    numbers <- getNumbers(mypar$IC)
    newnumbers <- signif(as.numeric(numbers)*exp(stats::rnorm(length(numbers), 0, 1)), 3)
    mypar$IC <- replaceSymbols(numbers, newnumbers, mypar$IC)
    return(mypar)
  })
  m$notes <- ""
  elements <- c("parameters", "variables", "states", "reactions", "outputs", "inputs", "initalAssignments")
  for (el in elements) {
    m[[el]] <- lapply(m[[el]], function(myel) {
      myel$notes <- NULL
      return(myel)
    })
  }
  m$name <- "Model"
  if (is.null(filename)) return(m)
  export_IQRmodel(m, filename = filename)
}
#'@export
is_IQRsimres <- function(input) {
  methods::is(input,"IQRsimres")
}
#'@export
print.IQRsimres <- function(x, ..., digits=3) {
  print.data.frame(x,digits=digits)
  cat("\nIQRsimres object")
  if (containsSensitivityInfoIQRsimres(x))
    cat('\n  Simulation results contain sensitivity information')
  if (hasIDcolumnIQRsimres(x)) cat('\n  Number of individual simulations: ',getNumberOfIndividualsIQRsimres(x),sep='')
}
hasIDcolumnIQRsimres <- function(x) {
  return("ID" %in% names(x))
}
hasCONDITIONcolumnIQRsimres <- function(x) {
  return("CONDITION" %in% names(x))
}
getNumberOfIndividualsIQRsimres <- function(x) {
  if (!is_IQRsimres(x))
    stopIQR("Input argument is not an IQRsimres object")
  if (!"ID" %in% names(x)) return(1)
  return(length(unique(x$ID)))
}
containsSensitivityInfoIQRsimres <- function(x) {
  if (!is_IQRsimres(x))
    stopIQR("Input argument is not an IQRsimres object")
  return(!is.null(attr(x,"sensitivity")))
}
#'@export
plot.IQRsimres <- function(x, ..., scales="free", facet="wrap", legend=TRUE) {
  xxx__ <- list(...)
  if (length(xxx__) > 0) {
    addIQMsimresIX__ <- which(unlist(lapply(xxx__, function(x) "IQRsimres" %in% class(x)))==TRUE)
  } else {
    addIQMsimresIX__ <- NULL
  }
  simNames__ <- setdiff(names(x),c("TIME","ID","CONDITION"))
  min__ <- match(simNames__[1],names(x))
  max__ <- match(simNames__[length(simNames__)],names(x))
  x.long__        <- tidyr::gather(x, "NAME", "VALUE", dplyr::one_of(simNames__))
  x.long.nar__    <- x.long__[!is.na(x.long__$VALUE),]
  if (!"ID" %in% names(x.long.nar__)) x.long.nar__$ID <- 1
  x.long.nar__$ID <- as.factor(x.long.nar__$ID)
  if (!"CONDITION" %in% names(x.long.nar__)) {
    x.long.nar__$CONDITION <- 1
    legend <- FALSE 
  }
  x.long.nar__$CONDITION <- as.factor(x.long.nar__$CONDITION)
  if (facet == "wrap") {
     p__ <- IQRggplot(x.long.nar__, aes_string(x = "TIME", y = "VALUE", group="ID", color="CONDITION")) +
      facet_wrap(~NAME, scales = scales) +
      scale_color_IQRtools() +
      geom_line(size=1)
  } else {
    p__ <- IQRggplot(x.long.nar__, aes_string(x = "TIME", y = "VALUE", color="ID", group="ID")) +
      facet_grid(NAME ~ CONDITION, scales = scales) +
      scale_color_IQRtools() +
      geom_line(size=1)
  }
  if (!legend) {
    p__ <- p__ + theme(legend.position="none")
  } else {
    p__ <- p__ + theme(legend.position="bottom",
                       legend.background=element_rect(linetype="solid",color="black"))
  }
  print(p__)
  p__
}
#'@export
is_IQRsimresMulti <- function(input) {
  methods::is(input,"IQRsimresMulti")
}
#'@export
print.IQRsimresMulti <- function(x, ..., digits=3) {
  print.data.frame(x,digits=digits)
  cat("\nIQRsimresMulti object")
  cat('\n  Number of individual simulations: ',length(unique(x$ID)),sep='')
  if (!is.null(attr(x,"sensitivity")))
    cat('\n  Simulation results contain sensitivity information')
}
#'@export
plot.IQRsimresMulti <- function(x, ..., type="quantiles",quantiles=c(0.05, 0.5, 0.95)) {
  if (type=="quantiles") {
    x$ID <- NULL
    data <- do.call(rbind,lapply(quantiles, function(qkkk) {
      a <- as.data.frame(do.call(rbind,lapply(split(x,x$TIME), function (yyy) {
        apply(yyy,2,stats::quantile,qkkk)
      })))
      a$QUANTILE <- paste0(qkkk*100,"th Quantile")
      a
    }))
    simNames__ <- setdiff(names(data),c("TIME","ID","CONDITION"))
    gather_cols <- setdiff(simNames__,"QUANTILE")
    x.long__        <- tidyr::gather(data, "NAME", "VALUE", dplyr::one_of(gather_cols))
    x.long.nar__    <- x.long__[!is.na(x.long__$VALUE),]
    x.long.nar__$QUANTILE <- as.factor(x.long.nar__$QUANTILE)
    p__ <- IQRggplot(x.long.nar__, aes_string(x = "TIME", y = "VALUE", group="NAME", color="QUANTILE")) +
      facet_wrap(~NAME, scales="free") +
      scale_color_IQRtools() +
      geom_line(size=1, aes_string(group="QUANTILE")) +
      theme(legend.position="bottom",
            legend.background=element_rect(linetype="solid",color="black"))
    print(p__)
  }
  if (type=="individual") {
    simNames__ <- setdiff(names(x),c("TIME","ID","CONDITION"))
    x.long__        <- tidyr::gather(x, "NAME", "VALUE", dplyr::one_of(simNames__))
    x.long.nar__    <- x.long__[!is.na(x.long__$VALUE),]
    x.long.nar__$ID <- as.factor(x.long.nar__$ID)
    p__ <- IQRggplot(x.long.nar__, aes_string(x = "TIME", y = "VALUE", group="NAME")) +
      facet_wrap(~NAME, scales="free") +
      scale_color_IQRtools() +
      geom_line(size=0.5,aes_string(group="ID"),alpha=0.1)
    print(p__)
  }
}
#'@export
#'@import numDeriv
fit_EmaxModel <- function(data, Emax = NULL, EC50 = NULL, Hill = NULL, y0 = 0, errmodel = "abs", log10Data = "") {
  stopifnot(
    is.null(Emax) || (is.numeric(Emax) && Emax > 0),
    is.null(EC50) || (is.numeric(EC50) && EC50 > 0),
    is.null(Hill) || (is.numeric(Hill) && Hill > 0),
    is.null(y0) || (is.numeric(y0)),
    is.character(errmodel),
    is.character(log10Data)
  )
  errmodel <- match.arg(errmodel, c("abs", "rel", "absrel"))
  if (log10Data != "") log10Data <- match.arg(log10Data, c("x", "y", "xy"))
  x <- data[, 1]
  y <- data[, 2]
  if (grepl("x", log10Data)) x <- 10^x
  natpars <- c("y0", "sigma_abs", "sigma_rel")
  logpars <- c("EC50", "Emax", "Hill")
  to_natScale <- function(p) {
    logpars <- setdiff(names(p), natpars)
    natpars <- intersect(names(p), natpars)
    if (length(logpars) > 0) p[logpars] <- exp(p[logpars])
    p
  }
  D_to_natScale <- function(p) {
    natpars <- intersect(names(p), natpars)
    logpars <- setdiff(names(p), natpars)
    if (length(natpars) > 0) p[natpars] <- 1
    if (length(logpars) > 0) p[logpars] <- exp(p[logpars])
    p
  }
  to_logScale <- function(p) {
    logpars <- setdiff(names(p), natpars)
    if (length(logpars) > 0) p[logpars] <- log(p[logpars])
    p
  }
  p.fixed <- to_logScale(
    c(Emax = Emax,
      EC50 = EC50,
      Hill = Hill,
      y0 = y0,
      sigma_abs = switch(errmodel, "abs" = NULL, "rel" = 0, "absrel" = NULL),
      sigma_rel = switch(errmodel, "abs" = 0, "rel" = NULL, "absrel" = NULL))
  )
  parameters <- c(logpars, natpars)
  parameters.fixed <- names(p.fixed)
  parameters.est <- setdiff(parameters, parameters.fixed)
  p.est.0 <- to_logScale(
    c(Emax = max(y),
      EC50 = 0.5*max(x),
      Hill = 1,
      y0 = min(y),
      sigma_abs = 0.05*max(y),
      sigma_rel = 0.05)
  )[parameters.est]
  prd <- function(p) {
    p["y0"] + p["Emax"]*x^p["Hill"]/(p["EC50"]^p["Hill"] + x^p["Hill"])
  }
  var.prd <- function(p) {
    p["sigma_abs"]^2 + p["sigma_rel"]^2 * prd(p)^2
  }
  ll <- function(p) {
    p <- to_natScale(p)
    sum(
      (prd(p) - y)^2/var.prd(p) + log(2*pi*var.prd(p))
    )
  }
  obj <- function(p) {
    p.full <- c(p, p.fixed)
    idx <- match(parameters.est, names(p.full))
    list(
      value = ll(p.full),
      gradient = structure(
        numDeriv::jacobian(ll, p.full, method = "complex")[1, idx],
        names = parameters.est),
      hessian = structure(
        numDeriv::hessian(ll, p.full, method = "complex")[idx, idx, drop = FALSE],
        dimnames = list(parameters.est, parameters.est))
    )
  }
  myfit <- trust(obj, p.est.0, rinit = 1, rmax = 10)
  myfit.pars <- c(myfit$argument, p.fixed)[parameters]
  myfit.cov <- structure(MASS::ginv(myfit$hessian), dimnames = list(parameters.est, parameters.est))
  eigen__ <- eigen(myfit$hessian)
  tol__ <- 1e-8
  V__ <- eigen__$vectors[, abs(eigen__$values) < tol__, drop = FALSE]
  identifiable__ <- apply(V__, 1, function(v) all(abs(v) < tol__))
  diag(myfit.cov)[!identifiable__] <- Inf
  myfit.se <- c(sqrt(diag(myfit.cov)),
                structure(rep(NA, length(p.fixed)), names = parameters.fixed))[parameters]
  myparameters <- data.frame(
    name = parameters,
    value = abs(to_natScale(myfit.pars)),
    se = abs(myfit.se*D_to_natScale(myfit.pars)),
    fixed = parameters %in% parameters.fixed,
    row.names = NULL,
    stringsAsFactors = FALSE
  )
  myprd <- function(x) {
    if (grepl("x", log10Data)) x <- 10^x
    p <- to_natScale(myfit.pars)
    y <- p["y0"] + p["Emax"]*x^p["Hill"]/(p["EC50"]^p["Hill"] + x^p["Hill"])
    sigma <- sqrt(p["sigma_abs"]^2 + p["sigma_rel"]^2 * y^2)
    out <- data.frame(x = x, y = y, lower = y - sigma, upper = y + sigma)
    if (grepl("x", log10Data)) out[["x"]] <- log10(out[["x"]])
    if (grepl("y", log10Data)) for (n in c("y", "lower", "upper")) out[[n]] <- log10(out[[n]])
    names(out)[1:2] <- names(data)[1:2]
    out
  }
  myprediction <- myprd(
    if (grepl("x", log10Data))
      log10(x)
    else
      x
  )
  myprediction.long <- myprd(
    if (grepl("x", log10Data))
      seq(min(log10(x)), max(log10(x)), length.out = 100)
    else
      seq(min(x), max(x), length.out = 100)
  )
  myplot <- IQRggplot(myprediction.long, aes_string(x = names(myprediction)[1],
                                                    names(myprediction)[2])) +
    geom_ribbon(aes_string(ymin = "lower", ymax = "upper"), alpha = .3) +
    geom_line() +
    geom_point(data = data)
  mytable <- IQRtable(myparameters,
                      stat = statSE(value = value, se = se),
                      Name = "name",
                      Value = "value",
                      SE = "se",
                      RSE  = "rse%",
                      Fixed = "fixed")
  list(
    objval = myfit[["value"]],
    converged = myfit[["converged"]],
    iterations = myfit[["iterations"]],
    parameters = myparameters,
    prd = myprd,
    prediction = myprediction,
    plot = function() myplot,
    table = mytable
  )
}
calcNNic <- function(model,parametersSim__,time) {
  if (hasOnlyNumericICs_IQRmodel(model) & !hasInitialAssignments_IQRmodel(model)) {
    return(list(ICs=statesInfo_IQRmodel(model)$stateICs,params=parametersSim__))
  }
  ICs__ <- sapply(model$states, function (x__) x__$IC)
  res__ <- attr(model,"nonNumICs.IQRmodel")(parametersSim__,ICs__,time)
  calcIC__ <- res__$ICs
  IAs__ <- res__$IAs
  parametersSim__[names(IAs__)] <- IAs__
  return(list(ICs=calcIC__,param=parametersSim__))
}
#'@export
stoichiometry_IQRmodel <- function (model,raw=TRUE) {
  if (!is_IQRmodel(model)) stopIQR("Model argument is not an IQRmodel")
  if (length(model$reactions)==0) return(list(N=NULL, statenames=NULL, reacnames=NULL, reacreversible=NULL))
  N              <- c()
  statenames     <- c()
  for (k in seq_along(model$states)) {
    Nrow__       <- parseStoichiometryODE_IQRmodel(aux_removeWhiteSpace(model$states[[k]]$ODE),model,raw)
    if (!is.null(Nrow__) & !(NA %in% Nrow__)) {
      N          <- rbind(N,Nrow__)
      statenames <- c(statenames,names(model$states)[k])
    }
  }
  return(list(N=N,
              statenames=statenames,
              reacnames=names(model$reactions),
              reacreversible=reactionsInfo_IQRmodel(model)$reacreversible))
}
parseStoichiometryODE_IQRmodel <- function(ODE,model,raw) {
  paramInfo__ <- parametersInfo_IQRmodel(model)
  reacInfo__  <- reactionsInfo_IQRmodel(model)
  nrOpenParentheses__   <- length(aux_strFindAll(ODE,"(")$start)
  nrClosedParentheses__ <- length(aux_strFindAll(ODE,")")$start)
  compartmentSize__     <- 1
  if (nrOpenParentheses__ != nrClosedParentheses__) stopIQR("Parentheses not in pairs")
  if (nrOpenParentheses__ > 1) return(NULL) 
  if (nrOpenParentheses__==1) {
    if (substr(ODE,1,1) != "(") return(NULL) 
    closePar__          <- aux_strFindAll(ODE,")")
    ODEinpar__          <- substr(ODE,2,closePar__$start-1)
    rest__              <- substr(ODE,closePar__$start+1,nchar(ODE))
    if (substr(rest__,1,1) != "/") return(NULL) 
    rest__              <- substr(rest__,2,nchar(rest__))
    index__             <- aux_strmatch(paramInfo__$paramnames,rest__)
    if (is.null(index__)) return(NULL) 
    compartmentSize__ = paramInfo__$paramvalues[index__]
    ODE <- ODEinpar__
  }
  ODE <- paste0(ODE,"+")
  terms__               <- c()
  termIndex__           <- 1
  if (substr(ODE,1,1)=="-") {
    signCurrent__ <- -1
    lastIndex__ <- 2
  } else {
    if (substr(ODE,1,1)=="+") {
      signCurrent__ <- +1
      lastIndex__ <- 2
    } else {
      signCurrent__ = +1
      lastIndex__ = 1
    }
  }
  Nrow__ <- as.vector(matrix(0,1,length(reacInfo__$reacnames)))
  startk__ <- lastIndex__
  for (k in startk__:nchar(ODE)) {
    if (substr(ODE,k,k) == '+' | substr(ODE,k,k) == '-') {
      element__ <- substr(ODE,lastIndex__,k-1)
      multIndex__ <- aux_strFindAll(element__,"*")$start
      if (is.null(multIndex__)) {
        stoichiometry__ <- signCurrent__*1
        reactionterm__ <- element__
      } else {
        if (length(multIndex__) > 1) return(NULL) 
        suppressWarnings(absStoichiometry <- as.numeric(substr(element__,1,multIndex__-1)))
        stoichiometry__ <- signCurrent__*absStoichiometry
        reactionterm__ <- substr(element__,multIndex__+1,nchar(element__))
      }
      indexReaction__ <- aux_strmatch(reacInfo__$reacnames,reactionterm__)
      if (is.null(indexReaction__)) return(NULL)
      if(is.na(stoichiometry__)) return(NULL)
      Nrow__[indexReaction__] <- Nrow__[indexReaction__] + stoichiometry__
      termIndex__ <- termIndex__ + 1
      lastIndex__ <- k+1
      if (substr(ODE,k,k) == "+")
        signCurrent__ <- +1
      else
        signCurrent__ <- -1
    }
  }
  if (!raw) Nrow__ <- Nrow__ / compartmentSize__
  return(Nrow__)
}
symStateGradient_IQRmodel <- function (model,paramnames=NULL) {
  if (!is_IQRmodel(model))
    stopIQR("model argument is not an IQRmodel")
  result__    <- prepareIQRmodelODEs4symbolic(model)
  stateInfo__ <- result__$stateInfo
  varInfo__   <- result__$varInfo
  paramInfo__ <- parametersInfo_IQRmodel(model)
  if (is.null(paramInfo__$paramnames)) {
    warningIQR("No parameters in model. No gradient derived.")
    return(NULL)
  }
  if (!is_differentiable_expression(model,stateInfo__$stateODEs)) return(NULL)
  if (is.null(paramnames)) {
    paramnames <- paramInfo__$paramnames
    isNotINPUTparam__ <- unlist(gregexpr(pattern="\\<INPUT[0-9]+",text=paramnames)) == -1
    paramnames <- paramnames[isNotINPUTparam__]
  }
  test__ <- setdiff(paramnames,paramInfo__$paramnames)
  if (length(test__) > 0)
    stopIQR("One or more of the provided paramnames are not present in the IQRmodel.")
  gradient__ <- matrix(nrow=length(stateInfo__$statenames),ncol=length(paramnames))
  for (k in seq_along(stateInfo__$statenames)) {
    for (k2 in seq_along(paramnames)) {
      x <- eval(parse(text=paste0("expression(",aux_removeWhiteSpace(stateInfo__$stateODEs[k]),")")))
      res__ <- paste0(deparse(stats::D(x,aux_removeWhiteSpace(paramnames[k2]))),collapse="")
      gradient__[k,k2] <- res__
    }
  }
  rownames(gradient__) <- stateInfo__$statenames
  colnames(gradient__) <- paramnames
  output <- list(gradient=gradient__, statenames=stateInfo__$statenames, paramnames=paramnames)
  return(output)
}
symOutputGradient_IQRmodel <- function (model,paramnames=NULL) {
  if (!is_IQRmodel(model))
    stopIQR("model argument is not an IQRmodel")
  result__    <- prepareIQRmodelODEs4symbolic(model)
  stateInfo__ <- result__$stateInfo
  varInfo__   <- result__$varInfo
  paramInfo__ <- parametersInfo_IQRmodel(model)
  if (is.null(paramInfo__$paramnames))
    stopIQR("No parameters in model. Derivation of gradient does not make sense.")
  outInfo__   <- outputInfo_IQRmodel(model)
  outInfo__$outformulas <- varInfo__$varformulas[outInfo__$outvarindices]
  if (!is_differentiable_expression(model,stateInfo__$stateODEs)) return(NULL)
  if (!is_differentiable_expression(model,outInfo__$outformulas)) return(NULL)
  if (is.null(paramnames)) {
    paramnames <- paramInfo__$paramnames
    isNotINPUTparam__ <- unlist(gregexpr(pattern="\\<INPUT[0-9]+",text=paramnames)) == -1
    paramnames <- paramnames[isNotINPUTparam__]
  }
  test__ <- setdiff(paramnames,paramInfo__$paramnames)
  if (length(test__) > 0)
    stopIQR("One or more of the provided paramnames are not present in the IQRmodel.")
  dgdp__ <- matrix(nrow=length(outInfo__$outnames),ncol=length(paramnames))
  for (k in seq_along(outInfo__$outnames)) {
    for (k2 in seq_along(paramnames)) {
      x <- eval(parse(text=paste0("expression(",aux_removeWhiteSpace(outInfo__$outformulas[k]),")")))
      res__ <- paste0(deparse(stats::D(x,aux_removeWhiteSpace(paramnames[k2]))),collapse="")
      dgdp__[k,k2] <- res__
    }
  }
  rownames(dgdp__) <- outInfo__$outnames
  colnames(dgdp__) <- paramnames
  output <- list(dgdp=dgdp__, outnames=outInfo__$outnames, outformulas=outInfo__$outformulas, paramnames=paramnames)
  return(output)
}
symStateJacobian_IQRmodel <- function (model) {
  if (!is_IQRmodel(model))
    stopIQR("model argument is not an IQRmodel")
  result__    <- prepareIQRmodelODEs4symbolic(model)
  stateInfo__ <- result__$stateInfo
  varInfo__   <- result__$varInfo
  paramInfo__ <- parametersInfo_IQRmodel(model)
  if (!is_differentiable_expression(model,stateInfo__$stateODEs)) return(NULL)
  jacobian__ <- matrix(nrow=length(stateInfo__$statenames),ncol=length(stateInfo__$statenames))
  for (k in seq_along(stateInfo__$statenames)) {
    for (k2 in seq_along(stateInfo__$statenames)) {
      x <- eval(parse(text=paste0("expression(",aux_removeWhiteSpace(stateInfo__$stateODEs[k]),")")))
      res__ <- paste0(deparse(stats::D(x,aux_removeWhiteSpace(stateInfo__$statenames[k2]))),collapse="")
      jacobian__[k,k2] <- res__
    }
  }
  rownames(jacobian__) <- stateInfo__$statenames
  colnames(jacobian__) <- stateInfo__$statenames
  output <- list(jacobian=jacobian__, statenames=stateInfo__$statenames)
  return(output)
}
symOutputJacobian_IQRmodel <- function (model) {
  if (!is_IQRmodel(model))
    stopIQR("model argument is not an IQRmodel")
  result__    <- prepareIQRmodelODEs4symbolic(model)
  stateInfo__ <- result__$stateInfo
  varInfo__   <- result__$varInfo
  paramInfo__ <- parametersInfo_IQRmodel(model)
  outInfo__   <- outputInfo_IQRmodel(model)
  outInfo__$outformulas <- varInfo__$varformulas[outInfo__$outvarindices]
  if (!is_differentiable_expression(model,stateInfo__$stateODEs)) return(NULL)
  if (!is_differentiable_expression(model,outInfo__$outformulas)) return(NULL)
  dgdx__ <- matrix(nrow=length(outInfo__$outnames),ncol=length(stateInfo__$statenames))
  for (k in seq_along(outInfo__$outnames)) {
    for (k2 in seq_along(stateInfo__$statenames)) {
      x <- eval(parse(text=paste0("expression(",aux_removeWhiteSpace(outInfo__$outformulas[k]),")")))
      res__ <- paste0(deparse(stats::D(x,aux_removeWhiteSpace(stateInfo__$statenames[k2]))),collapse="")
      dgdx__[k,k2] <- res__
    }
  }
  rownames(dgdx__) <- outInfo__$outnames
  colnames(dgdx__) <- stateInfo__$statenames
  output <- list(dgdx=dgdx__, outnames=outInfo__$outnames, outformulas=outInfo__$outformulas, statenames=stateInfo__$statenames)
  return(output)
}
prepareIQRmodelODEs4symbolic <- function(model) {
  stateInfo__ <- statesInfo_IQRmodel(model)
  paramInfo__ <- parametersInfo_IQRmodel(model)
  varInfo__   <- variablesInfo_IQRmodel(model)
  reacInfo__  <- reactionsInfo_IQRmodel(model)
  if (length(varInfo__$varnames) > 0) {
    for (k in 1:length(varInfo__$varnames)) {
      if (k+1 <= length(varInfo__$varnames)) {
        for (k2 in (k+1):length(varInfo__$varnames)) {
          varInfo__$varformulas[k2] <- gsub(pattern = paste0("\\<",varInfo__$varnames[k],"\\>"),replacement = paste0("(",varInfo__$varformulas[k],")"),x = varInfo__$varformulas[k2])
        }
      }
    }
  }
  if (length(reacInfo__$reacnames) > 0) {
    for (k in 1:length(reacInfo__$reacnames)) {
      if (k+1 <= length(reacInfo__$reacnames)) {
        for (k2 in (k+1):length(reacInfo__$reacnames)) {
          reacInfo__$reacformulas[k2] <- gsub(pattern = paste0("\\<",reacInfo__$reacnames[k],"\\>"),replacement = paste0("(",reacInfo__$reacformulas[k],")"),x = reacInfo__$reacformulas[k2])
        }
      }
    }
  }
  if (length(stateInfo__$statenames) > 0) {
    for (k in 1:length(stateInfo__$statenames)) {
      if (length(reacInfo__$reacnames) > 0) {
        for (k2 in 1:length(reacInfo__$reacnames)) {
          updatedODE__ <- gsub(pattern = paste0("\\<",reacInfo__$reacnames[k2],"\\>"),replacement = paste0("(",reacInfo__$reacformulas[k2],")"),x = stateInfo__$stateODEs[k])
          stateInfo__$stateODEs[k] <- updatedODE__
        }
      }
    }
  }
  if (length(stateInfo__$statenames) > 0) {
    for (k in 1:length(stateInfo__$statenames)) {
      if (length(varInfo__$varnames) > 0) {
        for (k2 in 1:length(varInfo__$varnames)) {
          updatedODE__ <- gsub(pattern = paste0("\\<",varInfo__$varnames[k2],"\\>"),replacement = paste0("(",varInfo__$varformulas[k2],")"),x = stateInfo__$stateODEs[k])
          stateInfo__$stateODEs[k] <- updatedODE__
        }
      }
    }
  }
  return(list(stateInfo=stateInfo__,varInfo=varInfo__))
}
is_differentiable_expression <- function(model,checkTextVector) {
  if (hasCcodeFunctions_IQRmodel(model)) {
    return(FALSE)
  }
  if (length(model$functions)>0) {
    return(FALSE)
  }
  if (hasFastReactions_IQRmodel(model)) {
    return(FALSE)
  }
  for (k in seq_along(checkTextVector)) {
    if (regexpr(pattern="\\<piecewise",text=checkTextVector[k]) != -1) {
      return(FALSE)
    }
  }
  for (k in seq_along(checkTextVector)) {
    if (regexpr(pattern="\\<interp",text=checkTextVector[k]) != -1) {
      return(FALSE)
    }
  }
  for (k in seq_along(checkTextVector)) {
    if (regexpr(pattern="\\<min\\(",text=checkTextVector[k]) != -1) {
      return(FALSE)
    }
    if (regexpr(pattern="\\<max\\(",text=checkTextVector[k]) != -1) {
      return(FALSE)
    }
  }
  return(TRUE)
}
#'@export
geom_uperrorbar <- function(mapping = NULL, data = NULL,
                            stat = "identity", position = "identity",
                            ...,
                            na.rm = FALSE,
                            show.legend = NA,
                            inherit.aes = TRUE) {
  layer(
    data = data,
    mapping = mapping,
    stat = stat,
    geom = GeomUperrorbar,
    position = position,
    show.legend = show.legend,
    inherit.aes = inherit.aes,
    params = list(
      na.rm = na.rm,
      ...
    )
  )
}
GeomUperrorbar <- ggproto("GeomUperrorbar", Geom,
                          default_aes = aes(colour = "black", size = 0.5, linetype = 1, width = 0.5,
                                            alpha = NA),
                          draw_key = draw_key_path,
                          required_aes = c("x", "y", "ymax"),
                          setup_data = function(data, params) {
                            data$width <- data$width %II%
                              params$width %II% (resolution(data$x, FALSE) * 0.9)
                            transform(data,
                                      xmin = x - width / 2, xmax = x + width / 2, width = NULL
                            )
                          },
                          draw_panel = function(data, panel_scales, coord, width = NULL) {
                            GeomPath$draw_panel(data.frame(
                              x = as.vector(rbind(data$xmin, data$xmax, NA, data$x,   data$x)),
                              y = as.vector(rbind(data$ymax, data$ymax, NA, data$ymax, data$y)),
                              colour = rep(data$colour, each = 5),
                              alpha = rep(data$alpha, each = 5),
                              size = rep(data$size, each = 5),
                              linetype = rep(data$linetype, each = 5),
                              group = rep(1:(nrow(data)), each = 5),
                              stringsAsFactors = FALSE,
                              row.names = 1:(nrow(data) * 5)
                            ), panel_scales, coord)
                          }
)
"%II%" <- function(a, b) {
  if (!is.null(a)) a else b
}
mybreaks <- function(n_major, n_minor, allowAddMinor = TRUE, allowReduceMajor = TRUE) {
  function(limits) {
    upper <- log10(limits[2])
    lower <- log10(limits[1])
    n <- ceiling(upper) - floor(lower)
    step <- 1
    logbreaks <- seq(floor(lower), ceiling(upper), step)
    nombreaks <- 10^logbreaks
    nombreaks.inrange <- nombreaks[nombreaks > limits[1] & nombreaks < limits[2]]
    if (allowAddMinor & length(nombreaks.inrange) < n_major & n_minor > 0) {
      minbreaks <- do.call("c", lapply(seq_len(length(logbreaks) - 1), function(i) {
        allminbreaks <- seq(10^logbreaks[i], 10^logbreaks[i+1], length.out = 10)
        allminbreaks[seq(1, 10, length.out = n_minor + 2)][-c(1, n_minor + 2)]
      }))
      minbreaks.inrange <- unique(minbreaks[minbreaks > limits[1] & minbreaks < limits[2]])
      nombreaks <- sort(union(nombreaks, minbreaks.inrange))
    }
    if (allowReduceMajor & length(nombreaks.inrange) > n_major) {
      nombreaks <- nombreaks.inrange[seq(1, length(nombreaks.inrange), by = floor(length(nombreaks.inrange)/n_major))]
    }
    nombreaks
  }
}
myminorbreaks <- function(n_major, n_minor) {
  n_minor <- 10
  function(limits) {
    logbreaks <- log10(mybreaks(n_major, n_minor, allowAddMinor = FALSE, allowReduceMajor = FALSE)(limits))
    minbreaks <- do.call("c", lapply(seq_len(length(logbreaks) - 1), function(i) {
      seq(10^logbreaks[i], 10^logbreaks[i+1], length.out = 10)
    }))
    return(minbreaks)
  }
}
mylabels <- function(labeltype = "natural") {
  function(breaks) {
    if (labeltype == "standard") {
      labels <- format(breaks)
    }
    if (labeltype == "scientific") {
      logbreaks <- log10(breaks)
      labels <- parse(text = paste0("10^", logbreaks))
    }
    if (labeltype == "natural") {
      labels <- format(breaks, scientific = FALSE, drop0trailing = TRUE, trim = TRUE)
    }
    if (labeltype == "comma") {
      labels <- format(breaks, scientific = FALSE, drop0trailing = TRUE, trim = TRUE, big.mark = ",")
    }
    return(labels)
  }
}
#'@export
scale_y_log10_IQRtools <- function(labeltype = c("natural", "comma", "scientific", "standard"), n_major = 4, n_minor = 0, ...) {
  labeltype <- match.arg(labeltype)
  args <- list(...)
  if (n_major < 1) stopIQR("scale_y_log10_IQRtools() requires n_major to be > 0.")
  if (n_minor < 0) stopIQR("scale_y_log10_IQRtools() requires n_minor to be >= 0.")
  if (length(args) > 0 & is.null(names(args)) | any(names(args) %in% ""))
    stopIQR("scale_y_log10_IQRtools() requires that arguments passed via ... are named.")
  args <- c(args, list(breaks = mybreaks(n_major, n_minor),
                       minor_breaks = myminorbreaks(n_major, n_minor),
                       labels = mylabels(labeltype = labeltype)))
  args <- args[!duplicated(names(args))]
  do.call(scale_y_log10, args)
}
#'@export
scale_x_log10_IQRtools <- function(labeltype = c("natural", "comma", "scientific", "standard"), n_major = 4, n_minor = 0, ...) {
  labeltype <- match.arg(labeltype)
  args <- list(...)
  if (n_major < 1) stopIQR("scale_x_log10_IQRtools() requires n_major to be > 0.")
  if (n_minor < 0) stopIQR("scale_x_log10_IQRtools() requires n_minor to be >= 0.")
  if (length(args) > 0  & is.null(names(args)) | any(names(args) %in% ""))
    stopIQR("scale_x_log10_IQRtools() requires that arguments passed via ... are named.")
  args <- c(args, list(breaks = mybreaks(n_major, n_minor),
                       minor_breaks = myminorbreaks(n_major, n_minor),
                       labels = mylabels(labeltype = labeltype)))
  args <- args[!duplicated(names(args))]
  do.call(scale_x_log10, args)
}
#'@export
printGrid <- function (plotList,nrow=4,ncol=4) {
  if (length(plotList)==0) return(invisible(NULL))
  x <- which(!sapply(plotList, is.null))
  plotList <- plotList[x]
  pieces__ <- aux_splitVectorEqualPieces(x = 1:length(plotList), nrow*ncol)
  for (k__ in seq_along(pieces__)) {
    pO__ <- cowplot::plot_grid(plotlist=plotList[pieces__[[k__]]],nrow=nrow,ncol=ncol)
    print(pO__)
  }
}
plot_slides <- function(plotlist, nrow = 3, ncol = 3, legend = NULL, legend.width = 0.2) {
  plots__ <- plotlist
  attr_out__ <- attr(plotlist, "plotData")
  plotsPerSlide__ <- nrow*ncol
  nPlots__ <- length(plots__)
  nSlides__ <- ceiling(nPlots__/plotsPerSlide__)
  slides__ <- lapply(seq_len(nSlides__), function(i__) {
    range__ <- plotsPerSlide__*(i__ - 1) + 1:plotsPerSlide__
    myplots__ <- vector("list", plotsPerSlide__)
    for (j__ in seq_len(plotsPerSlide__)) {
      if (range__[j__] > length(plots__)) {
        myplots__[[j__]] <- ggplot() + theme_classic()
      } else {
        myplots__[[j__]] <- plots__[[range__[j__]]]
      }
    }
    myplots__
  })
  output__ <- lapply(slides__, function(myslide__) {
    out__ <- suppressWarnings(cowplot::plot_grid(plotlist = myslide__, nrow = nrow, ncol = ncol)) 
    if (!is.null(legend))
      out__ <- cowplot::plot_grid(out__, legend, ncol = 2, rel_widths = c(1-legend.width, legend.width))
    return(out__)
  })
  attr(output__, "plotData") <- attr_out__
  class(output__) <- "IQRslideplot"
  return(output__)
}
#'@export
print.IQRslideplot <- function(x, ...) {
  if (length(x) > 1) cat(length(x), "page output has been printed.\n")
  for (n__ in x) print(n__)
}
plotListObjects_ggplot <- function (myList) {
  plots <- aux_extractObjects(myList, "ggplot")
  for (p in plots) print(p)
}
get_timelabelIQR <- function(data) paste0("Time (",tolower(unique(data$TIMEUNIT)),")")
get_obslabelIQR <- function(data) paste0(unique(data$NAME), " (", unique(data$UNIT), ")")
scale_color_IQRblloq <- scale_color_manual("BLOQ", values = c("yes" = '#F15A60', "no" = '#737373'), drop = FALSE)
scale_shape_IQRblloq <- scale_shape_manual("BLOQ", values = c("yes" = 4, "no" = 19), drop = FALSE)
handle_obsScalesIQR <- function(scale, varNames, default = "log"){
  sc__ <- scale
  vn__ <- varNames
  if (is.null(sc__)) sc__ <- default
  if (!all(sc__ %in% c("log","linear")))
    stopIQR("Unknown scale defined. Needs to be 'linear' or 'log'.")
  if ( is.null(names(sc__)) ){
    if ( length(sc__) == 1 ){
      out__ <- data.frame(
        NAME = vn__,
        scale = sc__,
        stringsAsFactors = FALSE
      )
    } else {
      stopIQR("If given scale unnamed, provide only 'linear' or 'log' or name by observation.")
    }
  } else {
    if ( all(names(sc__) %in% vn__) ) {
      miss.scale__ <- setdiff(vn__,names(sc__))
      for (missk in miss.scale__) sc__ <- eval(parse(text=paste0("c(sc__, \"",missk,"\" = \"",default,"\")")))
      out__ <- data.frame(
        NAME = names(sc__),
        scale = sc__,
        stringsAsFactors = FALSE
      )
    } else {
      stopIQR("Scale defined for non-existing observation.")
    }
  }
  return(out__)
}
scale_y_apply <- function(scaletype, ...){
  if (scaletype == "log") {
    scale_y_log10(...)
  } else {
    scale_y_continuous(...)
  }
}
scale_x_apply <- function(scaletype, ...){
  if (scaletype == "log") {
    scale_x_log10(...)
  } else {
    scale_x_continuous(...)
  }
}
median90range <- function(x) {
  return(
    data.frame(
      y    = stats::median(x, na.rm=TRUE),
      ymin = stats::quantile(x, 0.05, na.rm=TRUE),
      ymax = stats::quantile(x, 0.95, na.rm=TRUE)
    )
  )
}
samplesize  <- function(x) {
  N__ = sum(!is.na(x))
  return(c(y=N__,label=N__))
}
handle_stratificationIQR <- function(x, stratify) {
  data__ <- x
  strat__ <- stratify
  if (!is.null(attr(data__,"covInfo")))
    covInfo0__ <- subset(attr(data__,"covInfo"), !TIME.VARYING)
  else
    covInfo0__ <- data.frame()
  if (!is.null(attr(data__,"catInfo")))
    catInfo0__ <- subset(attr(data__,"catInfo"), !TIME.VARYING)
  else
    catInfo0__ <- data.frame()
  missingstrat__ <- setdiff(stratify, c(covInfo0__$COLNAME, catInfo0__$COLNAME))
  if (length(missingstrat__) != 0){
    warningIQR('Following stratifier(s) are no time-independent covariates in the dataset: ',paste0(missingstrat__, collapse = ", "))
    strat__ = intersect(strat__,c(covInfo0__$COLNAME, catInfo0__$COLNAME))
  }
  stratcont__ <- intersect(strat__, covInfo0__$COLNAME)
  for (k__ in seq_along(stratcont__)) {
    strk__ <- stratcont__[k__]
      strmed__ <- stats::median(unique(as.data.frame(data__)[,c("USUBJID",strk__)])[[strk__]], na.rm = TRUE)
      strknew__ <- paste0(strk__,"CAT")
      data__[[strknew__]] <- (data__[[strk__]] > strmed__)+1
      covInfo0k__ <- subset(covInfo0__, COLNAME == strk__)
      catInfo0__ <- rbind(catInfo0__,
                          data.frame(COLNAME = strknew__, NAME = covInfo0k__$NAME, UNIT = covInfo0k__$UNIT, VALUES = "1,2",
                                     VALUETXT = paste0("< ",strmed__,covInfo0k__$UNIT,",",">= ",strmed__,covInfo0k__$UNIT),
                                     TIME.VARYING = FALSE)
      )
      strat__[strat__ == strk__] <- strknew__
  }
  return(list(data__, strat__, catInfo0__))
}
get_xposDosing <- function(xx__, tmin, tmax) {
  nd__ <- length(unique(xx__$NAME))
  if (nd__ == 1) xx__$TIMEdos <- xx__$TIME else {
    xx__$DNo <- as.numeric(factor(xx__$NAME))
    mar <- 0.005 * (tmax-tmin)  
    a = 2*mar / (nd__-1)
    b = - a - mar
    xx__$TIMEdos <- xx__$TIME + a*xx__$DNo+b
  }
  out <- xx__
  out
}
get_yposDosing <- function(xx__, ymin, ymax, sc__) {
  if (ymin == ymax) {
    if (sc__ == "linear"){
      ymin <- ymin-0.5
      ymax <- ymax
    } else {
      ymin <- 10^(log10(ymin)-0.5)
      ymax <- ymax
    }
  }
  dmax <- max(xx__$VALUE, na.rm = TRUE)
  xx__$ystart <- ymin
  if (dmax == 0) { 
    xx__$yend = xx__$ystart
  } else {
    if (sc__ == "linear"){
      xx__$yend   <- ymin + 0.5*(ymax-ymin)*xx__$VALUE/dmax
    } else {
      xx__$yend   <- exp(log(ymin)+0.5*(log(ymax)-log(ymin))*xx__$VALUE/dmax)
    }
  }
  out <- xx__
  out
}
get_labelDosing <- function(xx__) {
  xx__$labelDos <- ifelse(
    xx__$ADDL == 0 | is.na(xx__$ADDL),
    xx__$VALUE,
    paste0(xx__$ADDL+1, "x ", xx__$VALUE, " every ", round(xx__$II)," ",  xx__$TIMEUNIT)
  )
  if (dim(xx__)[1] > 1) {
    xx__ <- xx__[order(xx__$NAME,xx__$TIME),]
    for (k in seq(dim(xx__)[1],2,-1) )
      if (xx__$ADDL[k] == 0 | is.na(xx__$ADDL[k])) {
        xx__$labelDos[k] <- ifelse(
          xx__$labelDos[k] == xx__$labelDos[k-1] & xx__$NAME[k] == xx__$NAME[k-1],
          "",
          xx__$labelDos[k]
        )
      }
  }
  out <- xx__
  out
}
add_LayerDosingSingle <- function(plobj__, dInfo__, ymin, ymax, tmin, tmax, sc__) {
  dInfo__ <- get_yposDosing(dInfo__, ymin, ymax, sc__)
  dInfo__ <- get_xposDosing(dInfo__, tmin, tmax)
  dInfo__ <- get_labelDosing(dInfo__)
  out__ <- plobj__ +
  geom_segment(data=dInfo__, mapping = aes_string(x="TIMEdos", xend = "TIMEdos", y = "ystart", yend = "yend", color = "NAME"), size = 0.5, linetype = 2) +
    geom_text(data=dInfo__, mapping = aes_string(x="TIMEdos", y="yend", label = "labelDos", color = "NAME"), angle = 90, size = 2.5, hjust = 0, show.legend = FALSE) +
    scale_color_manual("", values=IQRtoolsColors[2:20])
  out__
}
add_LayerDosingMulti <- function(plobj__, dInfo__, ymin, ymax, tmin, tmax, sc__) {
  dInfoS__ <- subset(dInfo__, ADDL == 0)
  if ("NT" %in% names(dInfo__)) {
    dInfoS__ <- dInfoS__[order(dInfoS__$NT),]
  } else {
    dInfoS__ <- dInfoS__[order(dInfoS__$TIME),]
  }
  diffT <- diff(dInfoS__$TIME)
  medianDiffT <- stats::median(diffT)
  diffdiffT <- abs(diff(diffT))
  idxBreak1 <- c(TRUE, FALSE, diffdiffT/diffT[1:(length(diffT)-1)] > 0.3)
  idxBreak2 <- c(TRUE, diff(dInfoS__$VALUE) > 0)
  idxBreak <- c(which(idxBreak1 | idxBreak2), dim(dInfoS__)[1]+1)
  dInfoSM__ <- data.frame(NAME = rep(dInfoS__$NAME[1], length(idxBreak)-1), TIME=NA,VALUE=NA,ADDL=NA,II=NA)
  for (k in 1:(length(idxBreak)-1)) {
    dInfoSM__$TIME[k]  <- dInfoS__$TIME[idxBreak[k]]
    dInfoSM__$VALUE[k] <- dInfoS__$VALUE[idxBreak[k]]
    dInfoSM__$ADDL[k]  <- idxBreak[k+1]-idxBreak[k]-1
    if (dInfoSM__$ADDL[k] == 0) {
      dInfoSM__$II[k]    <- medianDiffT
    } else {
      dInfoSM__$II[k]    <- mean(c(diffT,diffT[length(diffT)])[idxBreak[k]:(idxBreak[k+1]-2)])
    }
  }
  dInfoM__ <- subset(dInfo__, ADDL >  0)
  dInfoAll__ <- rbind(
    within(dInfoSM__, {FLAGautoMerge = TRUE}),
    within(dInfoM__[,c("NAME","TIME","VALUE","ADDL","II")], {FLAGautoMerge = FALSE})
  )
  dInfoAll__ <- get_yposDosing(dInfoAll__, ymin, ymax, sc__)
  dInfoAll__ <- get_labelDosing(dInfoAll__)
  out__ <- plobj__ +
    geom_rect(data=dInfoAll__,
              mapping = aes_string(
                xmin="TIME", xmax = "TIME+(ADDL+1)*II",
                ymin = "ystart", ymax = "yend",
                fill="NAME"),
              color = "transparent", alpha=0.5) +
    geom_rect(data=subset(dInfoAll__, FLAGautoMerge),
              mapping = aes_string(
                xmin="TIME", xmax = "TIME+(ADDL+1)*II",
                ymin = "ystart", ymax = "yend"),
              color = "grey20", fill = NA, size = 0.5, linetype = 3) +
    geom_text(data=dInfoAll__, mapping = aes_string(x="TIME", y="yend", label = "labelDos", color="NAME"), angle = 90, size = 2.5, hjust = 0, show.legend = FALSE) +
    scale_color_manual("", values=IQRtoolsColors[2:20]) +
    scale_fill_manual("", values=IQRtoolsColors[2:20])
  out__
}
handle_MDVBLQplot <- function(x, FLAGremoveMDV = TRUE) {
  out__ <- x[!is.na(x$VALUE),]
  if (FLAGremoveMDV) {
    out__ <- x[x$MDV==0,]
  } else {
    out__$MDVann <- factor(out__$MDV, levels = c(0,1), labels = c("no", "yes"))
  }
  BLOQ <- as.numeric(out__$VALUE < out__$LLOQ)
  BLOQ[is.na(BLOQ)] <- 0
  out__$BLOQ <- BLOQ
  out__$BLOQ <- factor(out__$BLOQ, levels = c(0,1), labels = c("no", "yes"))
  out__
}
handle_duplicatedLevels <- function(catInfo__) {
  for (k in seq_along(catInfo__$COLNAME)) {
    vals__ = aux_explode(catInfo__$VALUES[k])
    txts__ = aux_explode(catInfo__$VALUETXT[k])
    if (any(duplicated(txts__))) {
      warningIQR("Non-unique text values in", catInfo__$COLNAME[k])
      utxts__ <- unique(txts__)
      for (txtk__ in utxts__) {
        idx__ <- txts__ %in% txtk__
        if (sum(idx__) > 1) {
          txts__[idx__] <- paste0(txts__[idx__],".",vals__[idx__])
        }
      }
      catInfo__$VALUETXT[k] <- paste0(txts__, collapse = ",")
    }
  }
  catInfo__
}
#'@export
aux_plotlayout <- function(nplots, nrow = NULL, ncol = NULL, npage = NULL) {
  if (is.null(nrow) & is.null(ncol)) {
    if (is.null(npage)) npage <- nplots
    nPerPage <- ceiling(nplots / npage)
    nrow <- floor(sqrt(4/3*nPerPage))
    ncol <- ceiling(nPerPage/nrow)
    nPerPage <- ncol*nrow
  } else {
    if (is.null(ncol)){
      if (is.null(npage)) {
        ncol <- 1
        npage <- ceiling(nplots/nrow)
      } else {
        nPerPage <- ceiling(nplots / npage)
        ncol <- ceiling(nPerPage/nrow)
      }
    }
    if (is.null(nrow)){
      if (is.null(npage)) {
        nrow <- 1
        npage <- ceiling(nplots/ncol)
      } else {
        nPerPage <- ceiling(nplots / npage)
        nrow <- ceiling(nPerPage/ncol)
      }
    }
  }
  nPerPage <- nrow*ncol
  npage <-  ceiling(nplots / nPerPage)
  return(list(nrow=nrow, ncol=ncol, npage=npage))
}
is_plot_object <- function(x) {
  ggplot2::is.ggplot(x) | gtable::is.gtable(x)
}
remove_legend <- function(x) {
  if (ggplot2::is.ggplot(x)) x <- x + theme(legend.position = "none")
  return(x)
}
#'@export
createPages_IQRoutputFigure <- function(x,
                                  nrow = NULL, ncol = NULL, npage = NULL,
                                  legend.option = c("as.is", "remove", "common"),
                                  legend.object = NULL, legend.position = "right", legend.relsize = 0.2,
                                  title.relheight = 0.05, subtitle.relheight = 0.05, footer.relheight = 0.05) {
  draft <- x$draft
  if (!is.null(x$opt.layout)) {
    for (opt in names(x$opt.layout)) assign(opt, x$opt.layout[[opt]])
  }
  inputoptions <- as.list(match.call(expand.dots = TRUE))
  inputoptions <- inputoptions[!names(inputoptions) %in% c("", "x")]
  for (opt in names(inputoptions)) assign(opt, inputoptions[[opt]])
  if (!is.character(legend.option)) stopIQR("legend.option needs to be character ('as.is', 'remove', or 'common')")
  legend.option <- match.arg(legend.option)
  x <- purrr::compact(x)
  if (is_plot_object(x$content)) x$content <- list(x$content)
  if (!legend.position %in% c("right","left","bottom","top")) stopIQR("Legend position needs to be either right, left, bottom, or top.")
  nplots <- length(x$content)
  layout  <- aux_plotlayout(nplots, nrow, ncol, npage)
  nrow__  <- layout$nrow
  ncol__  <- layout$ncol
  npages__ <- layout$npage
  nPerPage <- nrow__ * ncol__
  pageIndex__ <- rep(1:npages__, each=nPerPage)[1:nplots]
  if (legend.option == "as.is") {
    legend__ <- list(NULL)[rep(1,npages__)]
    if (!is.null(legend.object)) warningIQR("Provided legend object ignored.\nIt is only considered as common legend when setting legend.option = 'common'. ")
  } else if (legend.option == "remove"){
    x$content <- lapply(x$content, remove_legend)
    legend__ <- list(NULL)[rep(1,npages__)]
  } else if (legend.option == "common") {
    x$content <- lapply(x$content, remove_legend)
    if (!is.null(legend.object)) {
      legend__ <- list(legend.object)[rep(1, npages__)]
    } else {
      legend__ <- lapply(which(!duplicated(pageIndex__)), function(ii) {
              ll__ <- tryCatch(cowplot::get_legend(x$content[[ii]] + theme(legend.position=legend.position)), error = function(e) cat("First figure of page has no legend."))
              if ("try-error" %in% class(ll__)) ll__ <- NULL
              ll__
      })
    }
    relsizes__ <- c(1-legend.relsize, legend.relsize)
    addlegendfun__ <- switch(legend.position,
                             top    = function(pc, legend) cowplot::plot_grid(legend, pc, ncol = 1, rel_heights = rev(relsizes__)),
                             bottom = function(pc, legend) cowplot::plot_grid(pc, legend, ncol = 1, rel_heights = relsizes__),
                             left   = function(pc, legend) cowplot::plot_grid(legend, pc, nrow = 1, rel_widths  = rev(relsizes__)),
                             right  = function(pc, legend) cowplot::plot_grid(pc, legend, nrow = 1, rel_widths  = relsizes__)
    )
  }
  plot_content <- lapply(1:npages__, function(p__) {
    oo__ <- cowplot::plot_grid(plotlist = x$content[pageIndex__ == p__],
                               nrow = nrow__, ncol = ncol__)
    if (legend.option == "common" & !is.null(legend__[[p__]])) {
      oo__ <- addlegendfun__(oo__, legend__[[p__]])
    }
    oo__
  })
  relheights__ <- 1
  plot_subtitle <- NULL
  if ("subtitle" %in% names(x)){
    plot_subtitle <- cowplot::ggdraw() + cowplot::draw_label(x$subtitle, fontface = "plain", x=0, hjust=0)
    relheights__ <- c(subtitle.relheight,relheights__)
  }
  plot_title <- NULL
  if ("title" %in% names(x)) {
    plot_title <- cowplot::ggdraw() + cowplot::draw_label(x$title, fontface = "bold", x=0, hjust=0)
    relheights__ <- c(title.relheight,relheights__)
  }
  plot_footer <- NULL
  if ("footer" %in% names(x)) {
    plot_footer <- cowplot::ggdraw() + cowplot::draw_label(x$footer, fontface = "plain", x=0, hjust=0, size = 10)
    relheights__ <- c(relheights__, footer.relheight)
  }
  relheights__[relheights__==1] <- 2-sum(relheights__)
  plot_pages__ <- lapply(1:npages__, function(p__) {
    plist <- c(list(plot_title, plot_subtitle), plot_content[p__], list(plot_footer))
    oo__ <- cowplot::plot_grid(
      plotlist = plist[!sapply(plist, is.null)],
      ncol = 1,
      rel_heights = relheights__
    )
    if (draft) {
      file__ <- system.file("images", "Preliminary.png", package = "IQRtools")
      oo__ <- oo__ + cowplot::draw_image(file__,
                                         hjust = 0.5, vjust = 0.5, y = 0, x = 0, scale = 0.8)
    }
    oo__
  })
  if (length(plot_pages__) == 1) plot_pages__ <- plot_pages__[[1]]
  return(plot_pages__)
}
#'@export
themeIQRtools <- function(base_size = 12, base_family = "") {
  colors <- list(
    medium = c(gray = '#737373', red = '#F15A60', green = '#7AC36A', blue = '#5A9BD4', orange = '#FAA75B', purple = '#9E67AB', maroon = '#CE7058', magenta = '#D77FB4'),
    dark = c(black = '#010202', red = '#EE2E2F', green = '#008C48', blue = '#185AA9', orange = '#F47D23', purple = '#662C91', maroon = '#A21D21', magenta = '#B43894'),
    light = c(gray = '#CCCCCC', red = '#F2AFAD', green = '#D9E4AA', blue = '#B8D2EC', orange = '#F3D1B0', purple = '#D5B2D4', maroon = '#DDB9A9', magenta = '#EBC0DA')
  )
  gray <- colors$medium["gray"]
  black <- colors$dark["black"]
  theme_bw(base_size = base_size, base_family = base_family) +
    theme(line = element_line(colour = "black"),
          rect = element_rect(fill = "white", colour = NA),
          text = element_text(colour = "black"),
          axis.text = element_text(size = rel(1.0), colour = "black"),
          axis.text.x = element_text(margin=unit(c(4, 4, 0, 4), "mm")),
          axis.text.y = element_text(margin=unit(c(4, 4, 4, 0), "mm")),
          axis.ticks = element_line(colour = "black"),
          axis.ticks.length = unit(-2, "mm"),
          legend.key = element_rect(colour = NA),
          panel.border = element_rect(colour = "black"),
          strip.background = element_rect(fill = "white", colour = NA),
          strip.text = element_text(size = rel(1.0)))
}
#'@export
IQRtoolsColors <- rep_len(c("#000000", "#C5000B", "#0084D1",
                            "#579D1C", "#FF950E", "#4B1F6F",
                            "#1B9E77", "#D95F02", "#7570B3"), length.out = 5000)
#'@export
scale_color_IQRtools <- function(...) {
  scale_color_manual(..., values = IQRtoolsColors)
}
#'@export
scale_fill_IQRtools <- function(...) {
  scale_fill_manual(..., values = IQRtoolsColors)
}
#'@export
IQRggplot <- function(..., fontsize = 12) {
  p__ <- ggplot(...) + themeIQRtools(base_size = fontsize)
  return(p__)
}
#'@export
simple_IQRlogisticRegression <- function (
  data,
  VARcol,
  PREDcol,
  title    = NULL,
  xlab     = NULL,
  ylab     = NULL,
  SIGNIF   = 4
) {
  checkData_IQRlogisticRegression(data, VARcol, PREDcol)
  call <- paste0("stats::glm(",VARcol,"~",PREDcol,", data=data, family=binomial)")
  fit <- eval(parse(text=call))
  newdat <- eval(parse(text=paste0("data.frame(",PREDcol,"=seq(min(data[[PREDcol]]), max(data[[PREDcol]]), len=100))")))
  prediction <- stats::predict(fit, newdata=newdat, type="link", se.fit = TRUE)
  dataPlot1 <- tidyr::gather(
    data.frame(
      x = newdat[[PREDcol]],
      value = fit$family$linkinv(prediction$fit),
      upper = fit$family$linkinv(prediction$fit+1.96*prediction$se.fit),
      lower = fit$family$linkinv(prediction$fit-1.96*prediction$se.fit)
    ),
    NAME,VALUE,-x
  )
  dataPlot1$NAME[dataPlot1$NAME=="value"] <- "Prediction"
  dataPlot1$NAME[dataPlot1$NAME=="lower"] <- "Lower 95% CI"
  dataPlot1$NAME[dataPlot1$NAME=="upper"] <- "Upper 95% CI"
  dataPlot1$NAME <- factor(dataPlot1$NAME,levels = c("Prediction","Lower 95% CI","Upper 95% CI"))
  dataPlot2 <- data.frame(
    x = data[[PREDcol]],
    NAME = "Observations",
    VALUE = data[[VARcol]]
  )
  if (is.null(xlab)) xlab <- PREDcol
  if (is.null(ylab)) ylab <- "Probability of event"
  pVal_PREDcol <- signif(stats::coef(summary(fit))[,4][PREDcol],SIGNIF)
  p <- IQRggplot() +
    geom_line(data=dataPlot1,aes_string(x="x",y="VALUE",group="NAME",linetype="NAME",color="NAME"),size=2) +
    geom_jitter(data=dataPlot2,aes_string(x="x",y="VALUE",group="NAME"),height=0.01,width=0,size=3,alpha=0.5) +
    scale_linetype_manual("",values=c("solid","dashed","dashed")) +
    scale_color_manual("",values = c("black","red","red")) +
    ggtitle(title,subtitle = paste0("p-Value for predictor: ",pVal_PREDcol)) +
    xlab(xlab) +
    ylab(ylab) +
    theme(legend.position="bottom")
  attr(p,"dataPlot1") <- dataPlot1
  attr(p,"dataPlot2") <- dataPlot2
  attr(p,"fit") <- fit
  attr(p,"prediction") <- prediction
  return(p)
}
#'@export
IQRlogisticRegression <- function (
  data,
  VARcol,
  PREDcol,
  IDcol           = "ID",
  PREDinteraction = NULL,
  PREDval         = NULL,
  FLAGintercept   = TRUE,
  formula         = NULL,
  ci.level        = 0.95,
  FLAGfirth       = FALSE,
  refValuesPlot   = NULL,
  xlab            = NULL,
  ylab            = NULL,
  pathname        = NULL,
  FLAGreport      = TRUE,
  SIGNIF          = 4
) {
  data__ <- data
  data__$Intercept <- 1
  if (!is.null(formula)) {
    if (!("formula" %in% class(formula))) {
      formula <- stats::as.formula(formula)
    }
    VARcol  <- all.vars(formula[[2]])
    PREDcol <- all.vars(formula[[3]])
    PREDinteractionTerms__ <- setdiff(attr(stats::terms(formula), "term.labels"), PREDcol)
  }
  checkData_IQRlogisticRegression(data__, VARcol, PREDcol)
  PREDcolCAT <- PREDcol[sapply(data__[,PREDcol, drop = FALSE], class) %in% c("factor","character")]
  CATval__ <- do.call(rbind,lapply(PREDcolCAT, function(xx__) {
    out__ <- data.frame(
      PREDcol = xx__,
      category = levels(factor(data__[[xx__]])),
      stringsAsFactors = FALSE
    )
    out__ <- within(out__, {
      label0 <- paste0(PREDcol,category)
      label1 <- paste0(PREDcol,"=",category,"")
    })
    out__
  }))
  if (is.null(formula)) {
    if (!is.null(PREDinteraction)) {
      PREDinteraction <- lapply(as.list(PREDinteraction), function(x) trimws(aux_explode(x, separator = ",")))
      if (!all(unlist(PREDinteraction) %in% PREDcol)) stopIQR("Interaction given for unknown predictors.")
      PREDinteractionTerms__ <- c(); lfd <- 0
      for (k__ in seq_along(PREDinteraction)) {
        nk__ <- length(PREDinteraction[[k__]])
        for (kk__ in 1:(nk__-1)) {
          for (kkk__ in (kk__+1):nk__) {
            lfd <- lfd+1
            PREDinteractionTerms__[lfd] <- paste0(PREDinteraction[[k__]][kk__], ":" , PREDinteraction[[k__]][kkk__])
          }
        }
      }
    } else {
      PREDinteractionTerms__ <- NULL
    }
  }
  if (!IDcol %in% names(data__)) {
    data__$ID <- 1:nrow(data__)
    IDcol <- "ID"
  }
  if (!is.null(PREDval)) {
    names(PREDval) <- gsub(",",":",names(PREDval), fixed = TRUE)
    idxInvalid__ <- !(names(PREDval) %in% c(PREDcol, PREDinteractionTerms__, "Intercept"))
    if (any(idxInvalid__)) {
      warningIQR(paste0("'",names(PREDval)[idxInvalid__], "'", collapse = ", "), " are no valid predictor terms. Input will be ignored.\nIn case values for interaction terms should be fixed, they need to be given in the same order as in PREDinteraction or in the given formula.")
      PREDval <- PREDval[!idxInvalid__]
    }
  }
  if (!is.null(xlab)) {
    if (length(xlab) != length(PREDcol))
      stopIQR("Number of given x-axis labels need to correspond to number of predictor variables.")
    names(xlab) <- PREDcol
  } else {
    xlab <- structure(PREDcol, names = PREDcol)
  }
  if (is.null(ylab)) ylab <- paste0("Probability of event (",VARcol,")")
  if (ci.level <= 0 | ci.level >= 1) { stopIQR("Confidence levels needs to be between 0 and 1.")
  } else {
    CIlabel <- paste0("CI",c("lb", "ub"),ci.level*100)
    CIrangeLabel <- paste0(ci.level*100, "% CI")
    CIfact <- stats::qnorm(1-(1-ci.level)/2)
  }
  if (!is.numeric(SIGNIF)) {warningIQR("Given number of siginificant digits (SIGNIF) not numerical. Default will be used (4)"); SIGNIF = 4}
  if (is.null(formula) | !is.null(PREDval)) {
    RHSterms0__ <- c(PREDcol, PREDinteractionTerms__)
    RHSterms__ <- RHSterms0__
    if (!is.null(PREDval)){
      for (kfix in names(PREDval)) {
        if (kfix == "Intercept") {
          RHSterms__ <- c(RHSterms__, paste0("offset(", PREDval[[kfix]], "*Intercept)"))
        } else {
          idxFixed <- RHSterms__ == kfix
          RHSterms__[idxFixed] <- paste0("offset(", PREDval[[kfix]], "*", gsub(":","*",RHSterms__[idxFixed], fixed = TRUE), ")")
        }
      }
    }
    RHS0__ <- paste0(RHSterms0__, collapse = "+")
    RHS__ <- paste0(RHSterms__, collapse = "+")
    if (!FLAGintercept | "Intercept" %in% names(PREDval))
      { RHS0__ <- paste0(RHS0__, "-1"); RHS__ <- paste0(RHS__, "-1") }
    formula0__ <- paste0(VARcol,"~",RHS0__)
    formula__ <- paste0(VARcol,"~",RHS__)
  } else {
    formula0__ <- deparse(formula)
    formula__ <- formula0__
  }
  fitMethod__ <- ifelse(FLAGfirth, "brglm2::brglmFit", "glm.fit")
  funCall__ <- paste0("fit <- glm(",formula__,", data=data__, family=binomial, method = ",fitMethod__,")")
  suppressWarnings(eval(parse(text=funCall__)))
  fitsummary__ <- summary(fit)
  conf__       <-
    try(
      matrix(
        suppressMessages(stats::confint(fit, level = ci.level)),
        nrow = length(fit$coefficients)
      ),
      silent = TRUE)
  if ("try-error" %in% class(conf__) ) {
    warningIQR("Confidence intervals for coefficients could not be determined.")
    conf__ <- matrix(NA, nrow = length(fit$coefficients), ncol = 2)
  }
  estimates__ <- data.frame(
    Estimate = names(fit$coefficients),
    Value     = fit$coefficients,
    CI.lower = conf__[,1],
    CI.upper = conf__[,2],
    Pvalue   = fitsummary__$coefficients[,4],
    stringsAsFactors = FALSE
  )
  if (!(is.null(PREDval)|length(PREDval)==0)) {
    fixed__ <- data.frame(
      Estimate = names(PREDval),
      Value    = PREDval,
      CI.lower = NA,
      CI.upper = NA,
      Pvalue   = NA,
      stringsAsFactors = FALSE
    )
    estimates__ <- rbind(estimates__, fixed__)
  }
  for (k in seq_along(CATval__$label0)) {
    estimates__$Estimate <- gsub(CATval__$label0[k],CATval__$label1[k],estimates__$Estimate)
  }
  names(estimates__) <- c("Parameter", "Value", CIlabel, "p-value")
  estimates__$Parameter <- sub("(Intercept)","Intercept", estimates__$Parameter, fixed = TRUE)
  N <- dim(data__)[1]
  K <- dim(estimates__)[1]
  objval__ <- data.frame(Parameter = c("OBJ", "BIC", "AIC"), Value = fit$aic+c(-2*K,-2*K+log(N)*K,0), stringsAsFactors = FALSE)
  estimates__ <- dplyr::bind_rows(estimates__, objval__)
  indivprob__ <- data__[,c(IDcol, VARcol, PREDcol)]
  indivprob__$Probability <- NA; indivprob__$Probability <- fit$fitted.values
  indivprob__$Residual <- NA; indivprob__$Residual <- stats::residuals(fit, type = "pearson")
  plotList__ <- plot_IQRlogistRegressFit(
    fit,
    refValues = refValuesPlot,
    IDcol = IDcol,
    xlab = xlab,
    ylab = ylab,
    ci.level = ci.level,
    SIGNIF = SIGNIF,
    filename = NULL
  )
  esttable__ <- estimates__ 
  esttable__ <- dplyr::mutate_if(esttable__, is.numeric, function(x) signif(x, SIGNIF))
  esttable__ <- format(data.frame(lapply(esttable__,function (x) as.character(x)),stringsAsFactors = FALSE),justify="left")
  esttable__ <- data.frame(lapply(esttable__, function(x) {x[grepl("^NA$", trimws(x))] <- "-"; x} ))
  colLB__ <- grep("CIlb", names(esttable__))
  colUB__ <- grep("CIub", names(esttable__))
  CIrange <- paste0("[", esttable__[[colLB__]],", ", esttable__[[colUB__]], "]")
  CIrange[esttable__[[colLB__]] == "-"] <- "-"
  esttable__[[colLB__]] <- CIrange
  names(esttable__)[colLB__] <- CIrangeLabel
  esttable__[[colUB__]] <- NULL
  xtitle__ <- paste0("Estimates for logistic regression")
  xfooter__ <- paste0("Model: ",formula0__, "\nImplemented as: ", funCall__)
  for (k in PREDcolCAT) {
    refCatk__ <- levels(factor(data__[[k]]))[1]
    xfooter__ <- paste0(xfooter__, paste0("\nReference category for ", k, ": ", refCatk__))
  }
  if (FLAGfirth)
    xfooter__ <- paste0(xfooter__, "\nFirth penalization of log-likelihood.")
  xfooter__ <- paste0(xfooter__, "\nValues rounded to ", SIGNIF, " significant digits.")
  names(esttable__)[names(esttable__)=="p.value"] <- "p-value"
  table__ <- IQRoutputTable(esttable__, xtitle = xtitle__, xfooter = xfooter__, filename = NULL, report = FLAGreport)
  out__ <- table__
  attr(out__, "estimates") <- estimates__
  attr(out__, "indivProb") <- indivprob__
  attr(out__, "fit") <- fit
  attr(out__, "formula") <- formula0__
  attr(out__, "plots") <- plotList__
  class(out__) <- c("IQRlogisticFit", class(out__))
  if (!is.null(pathname)) {
    export_IQRlogisticFit(out__, pathname, FLAGreport = FLAGreport)
  }
  out__
}
checkData_IQRlogisticRegression <- function(data, VARcol, PREDcol) {
  if(!is.data.frame(data)) {
    stopIQR("The data object is not a data.frame.")
  }
  if (!VARcol %in% names(data)) stopIQR("The VARcol column is not present in the data.")
  if (!all(PREDcol %in% names(data))) stopIQR("One or more PREDcol columns are not present in the data.")
  if ("Intercept" %in% c(PREDcol,VARcol)) stopIQR("'Intercept' is not allowed to be used as predictor or dependent variable name.")
  errorMessage <- ""
  for(name in c(VARcol, PREDcol)) {
    idxNAvar <- is.na(data[[name]])
    if (any(idxNAvar)) { 
      errorMessage <- paste0(
        errorMessage,
        sum(idxNAvar), " subjects have NA values for ", name, ".\n")
    }
  }
  for(name in c(VARcol, PREDcol)) {
    idxNAvar <- is.na(data[[name]])
    if (length(unique(stats::na.omit(data[[name]]))) <= 1L ) {
      errorMessage <- paste0(
        errorMessage,
        "The varaible ", name, " is constant or NA for all subjects.\n")
    }
  }
  if (!all(unique(stats::na.omit(data[[VARcol]])) %in% c(0,1))) {
    errorMessage <- paste0(errorMessage, "The VARcol column does not contain only 0s and 1s.\n")
  }
  if(errorMessage != "") stopIQR(errorMessage)
}
#'@export
summary_IQRlogisticRegression <- function(x,
                                          order       = NULL,
                                          filename    = NULL,
                                          SIGNIF      = 4,
                                          FLAGreport  =TRUE,
                                          FLAGformula = FALSE,
                                          title       = NULL,
                                          footerAdd   = NULL) {
  idxFolder__ <- !sapply(lapply(x, class), function(yy) "IQRlogisticFit" %in% yy)
  if (any(idxFolder__)) {
    idxFolder__ <- which(idxFolder__)
    for (k in idxFolder__) {
      if (!is.character(x[[k]]) | length(x[[k]]) != 1) stopIQR("For elements not being an IQRlogisticFit object, path to a project folder needs to be given.")
      x[[k]] <- import_IQRlogisticFit(x[[k]])
    }
  }
  esttables__ <- lapply(x, function(x__) attr(x__, "estimates"))
  modelNames__ <- names(x)
  if (is.null(modelNames__)) modelNames__ <- paste0("Model_", sprintf("%.2d",seq_along(x)))
  ci.level <- sapply(x, function(x__) gsub("% CI","",grep("CI", names(x__$xtable), value = TRUE), fixed = TRUE))
  if (length(unique(ci.level)) != 1) {
    warningIQR("Confidence level for models are not same.")
    ci.level <- NA
  } else {
    ci.level <- ci.level[1]
  }
  reformat <- function(x__) {
    val__ <- paste0(signif(x__[,"Value"], SIGNIF), " (",
                    signif(x__[,grep("^CIlb",names(x__))], SIGNIF), ",",
                    signif(x__[,grep("^CIub",names(x__))], SIGNIF),")")
    val__ <- gsub(" (NA,NA)","",val__, fixed = TRUE)
    pval__ <- x__[,"p-value"]; pval__[is.na(pval__)] <- 1
    pars__ <- x__[,"Parameter"]
    idxSIG1 <- pval__ < 0.05; val__ <- ifelse(idxSIG1, paste0(val__, "*"), val__)
    idxSIG2 <- pval__ < 0.01; val__ <- ifelse(idxSIG2, paste0(val__, "*"), val__)
    idxSIG3 <- pval__ < 0.001; val__ <- ifelse(idxSIG3, paste0(val__, "*"), val__)
    y__ <- data.frame(t(val__), stringsAsFactors = FALSE); names(y__) <- pars__
    y__
  }
  table__ <- do.call(dplyr::bind_rows, lapply(esttables__, reformat))
  table__$Model <- modelNames__
  table__[is.na(table__)] <- "-"
  if (!is.null(order)) {
    if (!(order %in% c("OBJ","BIC","AIC"))) stopIQR("Order column needs to be BIC, AIC, or OBJ.")
    table__ <- table__[order(table__[[order]]),]
    idxOBJ__ <- which(names(table__) == order)
  } else {
    idxOBJ__ <- which(names(table__) == "OBJ")
  }
  idxModel__ <- which(names(table__) == "Model")
  idxCore__ <- which(!names(table__) %in% c("Model","OBJ","BIC","AIC"))
  table__ <- table__[,c(idxModel__, idxOBJ__, idxCore__)]
  if (FLAGformula)
    table__$Formula <- sapply(x, function(x__) attr(x__,"formula"))
  if (is.null(title)) {
    title__ <- "Comparison of logisic regression models"
  } else {
    title__ <- title
  }
  footer__ <- paste0("Estimates with ",ci.level,"%-confidence intervals\nSignificance: * <0.05, ** <0.01, *** <0.001")
  if (!is.null(order))
    footer__ <- paste0(footer__, paste0("\nModels ordered by ", order, "."))
  if (!is.null(footerAdd))
    footer__ <- paste0(footer__, "\n", footerAdd)
  if (!is.null(filename)) {
    filename <- paste0(aux_strrep(filename,".txt",""),".txt")
    IQRoutputTable(xtable=table__,xfooter=footer__,xtitle=title__,report=FLAGreport,filename=filename)
    return(invisible(NULL))
  }
  output__ <- IQRoutputTable(xtable=table__,xfooter=footer__,xtitle=title__,report=FLAGreport)
  output__
}
#'@export
export_IQRlogisticFit <- function(obj, pathname, FLAGreport = TRUE) {
  if (!("IQRlogisticFit" %in% class(obj))) stopIQR("Input object is no IQRlogistFit object.")
  filename__ <- file.path(pathname, "parameters_table.txt")
  table__ <- IQRoutputTable(obj$xtable, xtitle = obj$xtitle, xfooter = obj$xfooter, filename = filename__, report = FLAGreport, na.string = "-")
  filename__ <- file.path(pathname, "estimates.csv")
  IQRoutputCSV(attr(obj,"estimates"), filename = filename__)
  filename__ <- file.path(pathname, "indiv_probabilities.csv")
  IQRoutputCSV(attr(obj,"indivProb"), filename = filename__)
  IQRoutputTable(attr(obj,"indivProb"), xtitle = "Predicted individual probabilities", filename = sub(".csv",".txt",filename__,fixed=TRUE), na.string = "")
  filename__ <- file.path(pathname, "PredictionPlots.pdf")
  IQRoutputPDF(attr(obj,"plots"), filename = filename__)
  filename__ <- file.path(pathname, "fittedModel.rds")
  saveRDS(attr(obj,"fit"), file = filename__)
  filename__ <- file.path(pathname, "fittedProject.rds")
  saveRDS(obj, file = filename__)
  return(invisible(NULL))
}
#'@export
import_IQRlogisticFit <- function(pathname) {
  filename__ <- file.path(pathname, "fittedProject.rds")
  if (!file.exists(filename__)) stopIQR("Given folder does not seem to contain IQRlogisticFit object.")
  obj__ <- readRDS(filename__)
  if (!("IQRlogisticFit" %in% class(obj__))) stopIQR("Object loaded is no IQRlogisticFit object.")
  return(obj__)
}
#'@export
plot_IQRlogistRegressFit <- function(
  fit,
  refValues = NULL,
  IDcol = "ID",
  xlab = NULL,
  ylab = NULL,
  ci.level = 0.95,
  SIGNIF = 4,
  filename = NULL,
  residualType = "pearson"
) {
  inclass__ <- class(fit)
  if (!any(c("glm", "IQRlogisticFit") %in% inclass__)) stopIQR("Input needs to be IQRlogisticFit or glm object.")
  if ("IQRlogisticFit" %in% inclass__) {
    fit__ <- attr(fit, "fit")
  } else {
    fit__ <- fit
  }
  VARcol <- all.vars(fit__$formula[[2]])
  PREDcol <- setdiff(all.vars(fit__$formula[[3]]), "Intercept")
  PREDcolCAT <- PREDcol[sapply(fit__$data[,PREDcol], class) %in% c("factor","character")]
  data__ <- fit__$data
  idxNAvar <- is.na(data__[[VARcol]])
  if (!is.null(refValues)) {
    refNames__ <- names(refValues)
    misRef__ <- setdiff(refNames__, PREDcol)
    if (length(misRef__) > 0) warningIQR(paste0(misRef__, collapse=", -"), "for which reference value is given is no preditor in model.")
    refNames__ <- intersect(refNames__, PREDcol)
    refValues <- refValues[refNames__]
    if (length(refValues) == 0) refValues <- NULL
  }
  if (ci.level <= 0 | ci.level >= 1) { stopIQR("Confidence levels needs to be between 0 and 1.")
  } else {
    CIlabel <- paste0("CI ",c("lower", "upper")," bound [", ci.level*100, "%]")
    CIfact <- stats::qnorm(1-(1-ci.level)/2)
  }
  fitsummary__ <- summary(fit__)
  Pvalues__ <- structure(stats::coef(fitsummary__)[,4], names = rownames(stats::coef(fitsummary__)))
  dataPred__ <- lapply(PREDcol, function(x__) {
    if (x__ %in% PREDcolCAT) {
      c(levels(factor(data__[[x__]])), rep(NA, 100-length(levels(factor(data__[[x__]])))))
    } else {
      seq(min(data__[[x__]]), max(data__[[x__]]), len=100)
    }
  })
  dataPred__     <- as.data.frame(dataPred__, col.names = PREDcol)
  dataPredReference__ <- lapply(PREDcol, function(x__) {
    if (x__ %in% PREDcolCAT) {
      dataPred__[[x__]][1]
    } else {
      mean(dataPred__[[x__]])
    }
  })
  dataPredReference__ <- structure(as.data.frame(dataPredReference__), names = PREDcol)[rep(1,nrow(dataPred__)),,drop=FALSE]
  dataPredReference__$Intercept <- 1
  if (!is.null(refValues)) {
    for (kref__ in refNames__) {
      dataPredReference__[[kref__]] <- rep(refValues[[kref__]], nrow(dataPredReference__))
    }
  }
  predPlot__ <- lapply(PREDcol, function(x__) {
    newdat <- dataPredReference__
    newdat[[x__]] <- dataPred__[[x__]]
    if (x__ %in% PREDcolCAT) {
      newdat <- newdat[!(is.na(newdat[[x__]])),]
    }
    prediction__ <- stats::predict(fit__, newdata=newdat, type="link", se.fit = TRUE)
    datPrd__ <- data.frame(
      x = newdat[[x__]],
      value = fit__$family$linkinv(prediction__$fit),
      upper = fit__$family$linkinv(prediction__$fit+CIfact*prediction__$se.fit),
      lower = fit__$family$linkinv(prediction__$fit-CIfact*prediction__$se.fit),
      stringsAsFactors = FALSE
    )
    datPrd__ <- mutate_if(datPrd__, is.factor, as.character)
    if (x__ %in% PREDcolCAT) {
    } else {
      datPrd__ <- tidyr::gather(
        datPrd__,
        NAME,VALUE,-x
      )
      datPrd__$NAME[datPrd__$NAME=="value"] <- "Prediction"
      datPrd__$NAME[datPrd__$NAME=="lower"] <- CIlabel[1]
      datPrd__$NAME[datPrd__$NAME=="upper"] <- CIlabel[2]
      datPrd__$NAME <- factor(datPrd__$NAME,levels = c("Prediction", CIlabel))
    }
    if (x__ %in% names(Pvalues__)) {
      pVal_PREDcol <- signif(Pvalues__[[x__]], SIGNIF)
      subtitle__ <- paste0("p-Value for predictor (",x__,"): ",pVal_PREDcol)
    } else {
      if (x__ %in% PREDcolCAT) {
        subtitle__ <- ""
        pVal_PREDcol <- signif(Pvalues__[grep(paste0("^",x__),names(Pvalues__))], SIGNIF)
        names(pVal_PREDcol) <- gsub(x__,"",names(pVal_PREDcol))
        pVal_PREDcol <- data.frame(
          x = names(pVal_PREDcol),
          Pvalue = pVal_PREDcol,
          stringsAsFactors = FALSE
        )
        datPrd__ <- dplyr::left_join(datPrd__, pVal_PREDcol, by = "x")
      } else {
        subtitle__ <- "Coefficient for predictor fixed."
      }
    }
    if (length(PREDcol) == 1) {
      datObs__ <- data.frame(
        x = data__[[x__]],
        NAME = "Observations",
        VALUE = data__[[VARcol]]
      )
      if (x__ %in% PREDcolCAT){
        datObsFA__ <- as.data.frame(with(datObs__, table(x)))
        datObsF__ <- as.data.frame(with(datObs__, table(x,VALUE)))
        datObsF__$VALUE <- as.numeric(as.character(datObsF__$VALUE))
        datObsF__ <- dplyr::left_join(datObsF__, datObsFA__, by = "x", suffix = c("", "total"))
        datObsF__$Fraction <- datObsF__$Freq / datObsF__$Freqtotal
      }
    } else {
      others__ <- which(!(names(dataPredReference__) %in% c(x__,"Intercept")))
      meanOther__ <- dataPredReference__[1, others__, drop = FALSE]
      meanOther__ <- dplyr::mutate_if(meanOther__, is.numeric, signif, digits = SIGNIF)
      meanOther__ <- dplyr::mutate_if(meanOther__, is.factor, as.character)
      meanOther__ <- data.frame(
        predcol = names(meanOther__),
        ref     = unlist(meanOther__)
      )
      tmp__ <- paste0("Fixed ", meanOther__$predcol, ": ", meanOther__$ref, collapse = "; ")
      subtitle__ <- paste0(subtitle__, "\n", tmp__)
    }
    if (x__ %in% PREDcolCAT) {
      p <- IQRggplot()
      if (length(PREDcol) == 1)
        p <- p +
          geom_bar(data=datObsF__,aes(x=x, y=Fraction, fill = VALUE==1),
                   stat="identity", position = "stack", orientation = "x",
                   width = 0.2, alpha = 0.5) +
          geom_label(data=datObsF__,aes(x=x, y=VALUE, label=Freq)) +
          scale_fill_manual("", values = c("dodgerblue", "darkorange"), guide = FALSE)
      p <- p + geom_crossbar(data=datPrd__,aes(x=x,y=value,ymin=upper,ymax=lower), width = 0.5)
      datPval <- subset(datPrd__, !is.na(Pvalue))
      if (nrow(datPval) > 0) {
        p <- p + geom_text(data=datPval, aes(x=x,y=value,label=(paste0("p-Value: ", Pvalue))), vjust = -0.3)
      }
      p <- p +
        ggtitle(paste0("Predictions for ", x__), subtitle = subtitle__) +
        xlab(xlab[[x__]]) +
        ylab(ylab)
      attr(p,"dataPlot") <- datPrd__
    } else {
      p <- IQRggplot() +
        geom_line(data=datPrd__,aes_string(x="x",y="VALUE",group="NAME",linetype="NAME",color="NAME"),size=2)
      if (length(PREDcol) == 1)
        p <- p + geom_jitter(data=datObs__,aes_string(x="x",y="VALUE",group="NAME"),height=0.01,width=0,size=3,alpha=0.5)
      p <- p +
        scale_linetype_manual("",values=c("solid","dashed","dashed")) +
        scale_color_manual("",values = c("black","red","red")) +
        ggtitle(paste0("Predictions along ", x__), subtitle = subtitle__) +
        xlab(xlab[[x__]]) +
        ylab(ylab) +
        theme(legend.position="bottom")
      attr(p,"dataPlot") <- datPrd__
    }
    p
  })
  names(predPlot__) <- paste0("predicted.",PREDcol)
  indivprob__ <- data__[,c(IDcol, VARcol)]
  idxNAval <- is.na(data__[[VARcol]])
  indivprob__$Probability <- NA; indivprob__$Probability[!idxNAval] <- fit__$fitted.values
  eval(parse(text=paste0("resFit <- stats::glm(",VARcol,"~Probability, data = indivprob__, family=binomial)")))
  newdata <- data.frame(Probability = seq(0,1,0.1))
  resPred__ <- stats::predict(resFit, newdata=newdata, type="link", se.fit = TRUE)
  Pval__ <- signif(summary(resFit)$coefficients[2,4], SIGNIF)
  resPlot__ <- tidyr::gather(
    data.frame(
      x = newdata$Probability,
      value = resFit$family$linkinv(resPred__$fit),
      upper = resFit$family$linkinv(resPred__$fit+CIfact*resPred__$se.fit),
      lower = resFit$family$linkinv(resPred__$fit-CIfact*resPred__$se.fit)
    ),
    NAME,VALUE,-x
  )
  resPlot__$NAME[resPlot__$NAME=="value"] <- "Prediction"
  resPlot__$NAME[resPlot__$NAME=="lower"] <- CIlabel[1]
  resPlot__$NAME[resPlot__$NAME=="upper"] <- CIlabel[2]
  resPlot__$NAME <- factor(resPlot__$NAME,levels = c("Prediction", CIlabel))
  overallPlot__ <- IQRggplot() +
    geom_line(data=resPlot__,aes_string(x="x",y="VALUE",group="NAME",linetype="NAME",color="NAME"),size=2) +
    geom_jitter(data=indivprob__,aes_string(x="Probability",y=VARcol),height=0.01,width=0,size=3,alpha=0.5) +
    scale_linetype_manual("",values=c("solid","dashed","dashed")) +
    scale_color_manual("",values = c("black","red","red")) +
    ggtitle("Regression of predicted probability and observations", subtitle = paste0("p-value: ", Pval__)) +
    xlab("Predicted probability") +
    ylab("Observation") +
    theme(legend.position="bottom")
  attr(overallPlot__, "dataPlot") <- resPlot__
  plotResid__ <- mutate(fit__$data[!idxNAvar,],
                        Pred = stats::fitted.values(fit__),
                        Residuals = stats::residuals(fit__, type = residualType))
  pResFit__ <- IQRggplot(plotResid__, aes(Pred, Residuals) ) +
    geom_point(shape = 1) +
    labs(title = "Residuals against predicted values",
         y = paste0("Residuals (",residualType,")"))
  pResPred__ <- lapply(PREDcol, function(predvar) {
    if (predvar %in% PREDcolCAT) {
      IQRggplot(plotResid__, aes_string(predvar, "Residuals")) +
        geom_hline(yintercept = 0, linetype = 2, color = "grey") +
        geom_boxplot() +
        labs(title = paste0("Residuals against predictor variable: ", predvar),
          y = paste0("Residuals (",residualType,")"))
    } else {
      IQRggplot(plotResid__, aes_string(predvar, "Residuals")) +
        geom_hline(yintercept = 0, linetype = 2, color = "grey") +
        geom_smooth(method = "loess", color = IQRtoolsColors[3]) +
        geom_point() +
        labs(title = paste0("Residuals against predictor variable: ", predvar),
             y = paste0("Residuals (",residualType,")"))
    }
  })
  names(pResPred__) <- paste0("residuals.",PREDcol)
  plotList__ <- c(predPlot__, list(predicted.overall = overallPlot__, residuals.fitted = pResFit__), pResPred__)
  if (!is.null(filename)) {
    IQRoutputPDF(plotList__, filename = filename, onefile = TRUE)
    return(invisible(NULL))
  }
  plotList__
}
#'@export
modelEvaluation_IQRlogisticRegression <- function (project,filename=NULL,SIGNIF=3,AUCthreshold=0.75,HLpValueThreshold=0.05) {
  if (is.character(project)) {
    projectLR <- import_IQRlogisticFit(project)
  } else  {
    projectLR <- project
  }
  info <- attributes(projectLR)
  fit <- info$fit
  PRED <- info$indivProb$Probability
  DVname <- aux_explode(info$formula,"~")[1]
  DV <- info$indivProb[[DVname]]
  rocobj <- pROC::roc(DV, PRED)
  HLtest <- broom::tidy(ResourceSelection::hoslem.test(fit$y, stats::fitted(fit)))
  pValueHLtest <- HLtest$p.value
  AUC <- rocobj$auc
  AUC_CI95 <- as.numeric(pROC::ci(rocobj))
  color <- "darkgreen"
  if (AUC < AUCthreshold) color <- "firebrick"
  GOFassessment <- pROC::ggroc(rocobj,color=color,size=2)+
    ggtitle("ROC curve") +
    ylab("Sensitivity")+
    xlab("Specificity")+
    themeIQRtools() +
    theme(plot.title = element_text(hjust = 0.5))
  p <- IQRoutputFigure(
    x = GOFassessment,
    title = "Model evaluation for logistic regression model",
    subtitle = paste0(
      "Hosmer-Lemeshow goodness of fit test p-Value: ",signif(pValueHLtest,SIGNIF),"\n",
      "Area under the ROC curve [95% CI]: ",signif(AUC,SIGNIF)," [",signif(AUC_CI95[1],SIGNIF),",",signif(AUC_CI95[3],SIGNIF),"]\n"
    ),opt.layout = opt.layout(subtitle.relheight = 0.1,footer.relheight = 0.1),
    footer = paste0(
      "Project: ",project,"\n",
      "Model: ",info$formula,"\n",
      "Number significant digits: ",SIGNIF
    )
  )
  if (!is.null(filename))  {
    IQRoutputFigure(p,filename = filename)
  }
  attr(p,"pValueHLtest") <- pValueHLtest
  attr(p,"AUC") <- as.numeric(AUC)
  attr(p,"AUC95CI") <- AUC_CI95[c(1,3)]
  p
}
#'@export
plotETACOV_IQRnlmeProject <- function(projectPath,filename=NULL,CORR_THRESHOLD=0.3, ETA_THRESHOLD_REL = 0, stratCov = NULL, includedPars = NULL, excludedPars = NULL) {
  data <- IQRloadCSVdata(paste0(projectPath,"/RESULTS/project_eta.csv"))
  dataPlot__ <- data
  pars.dataPlot__ <- sub("^ETA_", "",  names(dataPlot__)[grepl("^ETA_", names(dataPlot__))])
  includedPars0__ <- pars.dataPlot__
  if (!is.null(includedPars) & !is.null(excludedPars)) stopIQR("Either 'includedPars' or 'excludedPars' can be provided, not both.")
  if (!is.null(includedPars)) includedPars0__ <- intersect(includedPars0__, includedPars) else includedPars <- "NULL"
  if (!is.null(excludedPars)) includedPars0__ <- setdiff(includedPars0__, excludedPars) else excludedPars <- "NULL"
  if (length(includedPars0__) == 0) stopIQR("plotETA was called with includedPars = ", paste(includedPars, collapse = ", "),
                                            " and excludedPars = ", paste(excludedPars, collapse = ", "),
                                            ".\nThe number of parameters satisfying these inclusion and exclusion rules is 0.")
  if (!is.null(includedPars0__)) {
    namesNonETAcols__ <- grep("ETA_", names(dataPlot__), value = TRUE, invert = TRUE)
    namesETAcols__ <- grep("ETA_", names(dataPlot__), value = TRUE)
    keepETAcols__ <- paste0("ETA_", includedPars0__)
    if (!all(keepETAcols__ %in% namesETAcols__)) stopIQR("Not all selected parameters are in the set of parameters with IIV in the model.")
    dataPlot__ <- dataPlot__[,c(namesNonETAcols__, keepETAcols__)]
    attr(data,"paramNames") <- includedPars0__
  }
  if (is.null(dataPlot__)) {
    message("ETA information could not be read from the project.\n")
    return(invisible(NULL))
  }
  if (max(dataPlot__[,grepl("ETA_",names(dataPlot__))]) == 0) {
    message("No variability in model.\n")
    return(invisible(NULL))
  }
  dataPlotCATxchange__ <- mapCovValues_Categories_ATR(projectPath,dataPlot__)
  catNames__ <- attr(data, "catNames")
  for (cn__ in catNames__) {
    catValues__ <- dataPlotCATxchange__[[cn__]]
    catFrequency__ <- sapply(catValues__, function(v__) sum(catValues__ %in% v__))
    catNewValues__ <- paste0(catValues__, ": N=", catFrequency__)
    dataPlotCATxchange__[[cn__]] <- catNewValues__
  }
  if (all(c(attr(data,"covNames") == "", attr(data,"catNames") == "")) ) return()
  if (!is.null(stratCov)) {
    if (length(stratCov) > 1)
      stopIQR("Only a single covariate can be provided for stratification.")
    if (!(stratCov %in% attr(data,"covariateNames")))
      stopIQR("selected covariate for stratification is not in the data.")
    if (stratCov %in% attr(data,"covNames")) {
      covMedian__ <- stats::median(sapply(split(dataPlot__,dataPlot__$ID), function(x) x[[stratCov]][1]))
      covStrat__  <- rep("",nrow(dataPlot__))
      covStrat__[dataPlot__[[stratCov]]<covMedian__] <- paste0(stratCov," < ",covMedian__)
      covStrat__[dataPlot__[[stratCov]]>=covMedian__] <- paste0(stratCov," >= ",covMedian__)
      dataPlot__$Stratification <- factor(covStrat__,levels=c(paste0(stratCov," < ",covMedian__), paste0(stratCov," >= ",covMedian__)))
    }
    if (stratCov %in% attr(data,"catNames")) {
      catStrat__  <- paste0(stratCov," = ", dataPlot__[[stratCov]])
      dataPlot__$Stratification <- factor(catStrat__)
    }
  } else {
    dataPlot__$Stratification <- factor("unstratified")
  }
  stratLevels <- unique(dataPlot__$Stratification)
  pContinuousCovsList__ <- lapply(stratLevels, function(stratk){
    pContinuousCovs__ <- list()
    for (k__ in seq_along(attr(data,"covNames"))) {
      if (attr(data,"covNames")[k__] != "") {
        y <- dataPlot__[dataPlot__$Stratification == stratk,c("ID",paste0("ETA_",attr(data,"paramNames")),attr(data,"covNames")[k__])]
        names(y)[names(y)==attr(data,"covNames")[k__]] <- "X"
        if (sd(y$X) != 0)
        {
          for (k in paste0("ETA_",attr(data,"paramNames"))) y[, k][abs(y[, k]) < ETA_THRESHOLD_REL*mean(abs(y[ ,k]))] <- NA
          z <- tidyr::gather(y,NAME,VALUE,-ID,-X)
          z <- z[!is.na(z$VALUE),]
          z$NAME <- factor(z$NAME,levels=paste0("ETA_",attr(data,"paramNames")))
          zcheck <- do.call(rbind,lapply(split(z,z$NAME),function(x) {
            x$PLOT <- stats::sd(x$VALUE)!=0
            x
          }))
          if (!any(zcheck$PLOT)) return()
          cory <- suppressWarnings(stats::cor(y[,2:ncol(y)], use = "pairwise.complete.obs"))
          corv <- signif(cory[1:(nrow(cory)-1),ncol(cory)],3)
          cory.pval <- sapply(2:ncol(y), function(i) sapply(2:ncol(y), function(j) {
            pvalue <- try(suppressWarnings(stats::cor.test(y[, i], y[, j])[["p.value"]]), silent = TRUE)
            if (inherits(pvalue, "try-error") | is.na(pvalue)) {
              pvalue <- "p = NA"
            } else {
              if (pvalue < 0.05) pvalue <- "p < 0.05" else pvalue <- paste0("p = ", round(pvalue, 2))
            }
            return(pvalue)
          }))
          corv.pval <- cory.pval[1:(nrow(cory)-1), ncol(cory)]
          xxx <- colnames(cory)[1:(ncol(cory)-1)]
          names(corv) <- xxx
          z$CORR <- NA
          CORR_INFO <- c()
          for (k2__ in seq_along(corv)) {
            corr <- corv[k2__]
            corr.pval <- corv.pval[k2__]
            CORR_INFO <- c(CORR_INFO, paste0("corr: ",corr, " (", corr.pval, ")"))
            z$CORR[z$NAME==names(corv)[k2__]] <- corr
          }
          z$High.Correlation <- factor(abs(z$CORR)>CORR_THRESHOLD,levels=c("FALSE","TRUE"))
          ETAnames__ <- as.character(unique(z$NAME))
          ETAnamesCORR__ <- paste0(ETAnames__,"\n",CORR_INFO)
          z$NAME <- as.character(z$NAME)
          dummy__ <- sapply(seq_along(ETAnames__), function(x) {
            z$NAME[z$NAME==ETAnames__[x]] <<- ETAnamesCORR__[x]
          })
          z$NAME <- factor(z$NAME,levels=ETAnamesCORR__)
          xy__ <- mapContinuousCovariate_IQRnlmeProject(projectPath,attr(data,"covNames")[k__])
          if (length(xy__$NAME)==0) {
            title__ <- paste0("Covariate: ",attr(data,"covNames")[k__])
          } else {
            title__ <- paste0("Covariate: ",attr(data,"covNames")[k__], " (",xy__$NAME,")")
          }
          subtitle__ <- paste0("Individual random effects versus covariate")
          if (stratk != "unstratified")
            title__ <- paste0(title__, "\nfor ", stratk)
          p__ <- IQRggplot(z[!is.na(z$CORR),],aes_string(x="X",y="VALUE",color="High.Correlation")) +
            ggtitle(label=title__, subtitle=subtitle__) +
            geom_point(alpha=0.2) +
            scale_color_manual(paste0("|corr|>",CORR_THRESHOLD),values=c("FALSE"="black","TRUE"="#C5000B"),
                               labels = c("FALSE" = "no", "TRUE" = "yes")) +
            facet_wrap("NAME",scales="free") +
            stat_smooth(method="lm",se=FALSE,formula = 'y ~ x') +
            theme(legend.position="bottom",
                  legend.background=element_rect(linetype="solid",color="black")) +
            theme(aspect.ratio=1) +
            ylab(label=NULL) + xlab(label=NULL)
          attr(p__,"plotData") <- z[!is.na(z$CORR),]
          attr(p__,"Stratus") <- stratk
          pContinuousCovs__[[k__]] <- p__
          names(pContinuousCovs__)[k__] <- attr(data,"covNames")[k__]
        }
      }
    }
    pContinuousCovs__
  })
  if (is.null(stratCov)) {
    pContinuousCovs__ <- pContinuousCovsList__[[1]]
  } else {
    pContinuousCovs__ <- pContinuousCovsList__; names(pContinuousCovs__) <- stratLevels
  }
  pCategoricalCovsList__ <- lapply(stratLevels, function(stratk){
    pCategoricalCovs__ <- list()
    for (k__ in seq_along(attr(data,"catNames"))) {
      if (attr(data,"catNames")[k__] != "") {
        y <- dataPlot__[dataPlot__$Stratification == stratk,c("ID",paste0("ETA_",attr(data,"paramNames")),attr(data,"catNames")[k__])]
        names(y)[names(y)==attr(data,"catNames")[k__]] <- "X"
        for (k in paste0("ETA_",attr(data,"paramNames"))) y[, k][abs(y[, k]) < ETA_THRESHOLD_REL*mean(abs(y[ ,k]))] <- NA
        z <- tidyr::gather(y,NAME,VALUE,-ID,-X)
        z <- z[!is.na(z$VALUE),]
        z$NAME <- factor(z$NAME,levels=paste0("ETA_",attr(data,"paramNames")))
        z <- do.call(rbind,lapply(split(z,z$NAME),function(x) {
          x$PLOT <- stats::sd(x$VALUE)!=0
          x
        }))
        z <- z[z$PLOT,]
        if (nrow(z) == 0) return()
        z$NAME <- droplevels(z$NAME)
        z$X <- factor(z$X, levels=sort(unique(z$X)))
        z <- do.call(rbind,lapply(split(z,z$NAME), function (xz__) {
          ttt__ <- length(unique(xz__$X))
          if (ttt__!=2) {
            pval__ <- NA
            xz__$pval <- NA
            xz__$pvalResult <- "NA"
          } else {
            pval__ <- tryCatch({
              stats::t.test(data=xz__,VALUE ~ X)$p.value
            }, error=function (err) {
              NA
            })
            xz__$pval <- pval__
            if (is.na(pval__)) {
              xz__$pvalResult <- "NA"
            } else {
              if (pval__ < 0.05) {
                xz__$pvalResult <- "<0.05"
              } else {
                xz__$pvalResult <- ">=0.05"
              }
            }
          }
          xz__
        }))
        z$pvalResult <- factor(z$pvalResult,levels=c(">=0.05","<0.05","NA"))
        xy__ <- mapCategoricalCovariate_IQRnlmeProject(projectPath,attr(data,"catNames")[k__])
        if (length(xy__$NAME)==0) {
          title__ <- paste0("Covariate: ",attr(data,"catNames")[k__])
        } else {
          title__ <- paste0("Covariate: ",attr(data,"catNames")[k__], " (",xy__$NAME,")")
        }
        subtitle__ <- paste0("Individual random effects versus covariate\np-Value from t-test, p<0.05 suggests that means are different")
        subtitle__ <- paste0(subtitle__,"\n",paste0(sort(unique(unlist(dataPlotCATxchange__[attr(data,"catNames")[k__]]))),collapse="\n"))
        if (stratk != "unstratified")
          title__ <- paste0(title__, "\nfor ", stratk)
        p__ <- IQRggplot(z,aes_string(x="X",y="VALUE")) +
          ggtitle(label=title__, subtitle=subtitle__) +
          geom_boxplot(aes_string(color="pvalResult",linetype="pvalResult")) +
          scale_color_manual("p-Value",values=c(">=0.05"=IQRtoolsColors[1],"<0.05"=IQRtoolsColors[2],"NA"=IQRtoolsColors[3])) +
          scale_linetype("p-Value") +
          facet_wrap("NAME", scales="free") +
          xlab(label=attr(data,"catNames")[k__]) +
          geom_hline(yintercept=0, linetype=2, color=2) +
          coord_flip() +
          theme(aspect.ratio=1) +
          ylab(label=NULL) + xlab(label=NULL) +
          theme(legend.position="bottom",
                legend.background=element_rect(linetype="solid",color="black"))
        attr(p__,"plotData") <- z[!is.na(z$CORR),]
        attr(p__,"Stratus") <- stratk
        pCategoricalCovs__[[k__]] <- p__
        names(pCategoricalCovs__)[k__] <- attr(data,"catNames")[k__]
      }
    }
    pCategoricalCovs__
  })
  if (is.null(stratCov)) {
    pCategoricalCovs__ <- pCategoricalCovsList__[[1]]
  } else {
    pCategoricalCovs__ <- pCategoricalCovsList__; names(pCategoricalCovs__) <- stratLevels
  }
  output__ <- list(
    ETA_COVcont = pContinuousCovs__,
    ETA_COVcat = pCategoricalCovs__
  )
  if (!is.null(filename)) {
    plotList <- aux_extractObjects(output__, "ggplot")
    IQRoutputPDF(gr=plotList, filename, scale = 1.5)
    return(invisible(NULL))
  }
  return(output__)
}
#'@export
plotINDIV_IQRnlmeProject <- function (projectPath,outputNr=1,filename=NULL,plotLog=FALSE,nindiv=16) {
  data <- IQRloadCSVdata(paste0(projectPath,"/RESULTS/project_pred.csv"))
  dataPlot__ <- data[data$YTYPE==outputNr & data$MDV==0,]
  if (is.null(dataPlot__)) {
    cat("PRED information could not be read from the project.\n")
    return(invisible(NULL))
  }
  if (plotLog & length(which(dataPlot__$DV<=0)) > 0) return(0)
  y <- dataPlot__[,c("ID","TIME","XPRED","IPRED","DV","CENS")]
  z <- tidyr::gather(y,NAME,DV.IPRED.PRED,-ID,-TIME,-CENS)
  z$CENS <- factor(z$CENS,levels=c(0,1))
  IXpieces <- aux_splitVectorEqualPieces(unique(z$ID),nindiv)
  plotList__ <- list()
  for (k__ in 1:length(IXpieces)) {
    zk <- z[z$ID %in% IXpieces[[k__]],]
    zz <- split(zk,zk$NAME)
    p__ <- IQRggplot(zz$DV,aes_string(x="TIME",y="DV.IPRED.PRED",group="ID")) + geom_point(color="black")
    p__ <- p__ + geom_point(data=zz$DV[zz$DV$CENS==1,],aes_string(x="TIME",y="DV.IPRED.PRED",group="ID"),color="darkgrey")
    p__ <- p__ + geom_line(data=zz$IPRED,aes_string(x="TIME",y="DV.IPRED.PRED"),color="blue",size=0.7)
    p__ <- p__ + geom_line(data=zz$XPRED,aes_string(x="TIME",y="DV.IPRED.PRED"),color="red",linetype=2,size=0.7)
    p__ <- p__ +
      theme(legend.position="bottom",
            legend.background=element_rect(linetype="solid",color="black")) +
      facet_wrap("ID",scales="free") +
      ylab(label="DV (.), IPRED (-), PRED (--)") +
      theme(aspect.ratio=1)
    if (plotLog)
      p__ <- p__ + scale_y_log10()
    plotList__[[k__]] <- p__
  }
  attr(plotList__,"plotData") <- z
  output__ <- plotList__
  if (!is.null(filename)) {
    attr(output__,"plotData") <- NULL 
    plotList <- aux_extractObjects(output__, "ggplot")
    IQRoutputPDF(gr=plotList,filename,scale = 1.5)
    return(invisible(NULL))
  }
  return(output__)
}
#'@export
outlier_IQRnlmeProject <- function (projectPath,outputNr=1,filename=NULL,WRES_THRESHOLD=6) {
  data <- IQRloadCSVdata(paste0(projectPath,"/RESULTS/project_pred.csv"))
  dataPlot__ <- data[data$YTYPE==outputNr & data$MDV==0 & data$CENS==0,]
  if (is.null(dataPlot__)) {
    cat("PRED information could not be read from the project.\n")
    return()
  }
  WRESname <- attr(data,"ALT_NAMES_ORIG")[attr(data,"ALT_NAMES_USED") == "XWRES"]
  names(dataPlot__)[names(dataPlot__)=="XWRES"] <- WRESname
  dataOutlier <- dataPlot__[abs(dataPlot__[[WRESname]]) > WRES_THRESHOLD,c("USUBJID","ID","TIME","TAD","DV",WRESname)]
  Noutliers__ <- nrow(dataOutlier)
  if (nrow(dataOutlier)==0) {
    dataOutlier <- data.frame(
      USUBJID = "No outliers detected",
      ID = "-",
      TIME = "-",
      TAD = "-",
      DV = "-",
      PWRES = "-"
    )
  }
  if (!is.null(filename)) {
    filename <- paste0(aux_strrep(filename,".txt",""),".txt")
    IQRoutputTable(
      xtable  = dataOutlier,
      xtitle  = paste0("Detected outliers (N=",Noutliers__,")"),
      xfooter = paste0("N=",Noutliers__," outliers detected.<br>Rule for outlier detection: (|",WRESname,"| > ",WRES_THRESHOLD,")"),
      report = TRUE,
      filename = filename
    )
    return()
  }
  output__ <- IQRoutputTable(
    xtable  = dataOutlier,
    xtitle  = paste0("Detected outliers (N=",Noutliers__,")"),
    xfooter = paste0("N=",Noutliers__," outliers detected.<br>Rule for outlier detection: (|",WRESname,"| > ",WRES_THRESHOLD,")"),
    report = FALSE
  )
  output__
}
#'@export
plotConvergence_IQRnlmeProject <- function(projectPath,filename=NULL) {
  x__ <- parseNLMEprojectHeader(projectPath)
  if (x__$TOOL=="NONMEM" | x__$TOOL=="NLMIXR") {
    if (!any(c("SAEM","BAYES") %in% x__$METHOD)) {
      message("Convergence plots only plotted for SAEM or BAYES method.")
      return(invisible(NULL))
    }
  }
  p__ <- NULL
  if (is_NONMEM_IQRnlmeProject(projectPath)) {
    p__ <- plotConvergenceNONMEM(projectPath)
  }
  if (is_MONOLIX_IQRnlmeProject(projectPath)) {
    p__ <- plotConvergenceMONOLIX(projectPath)
  }
  if (is_NLMIXR_IQRnlmeProject(projectPath)) {
    p__ <- plotConvergenceNLMIXR(projectPath)
  }
  if (is.null(p__)) return(invisible(NULL))
  if (is.null(filename)) return(p__)
  IQRoutputPDF(p__,filename=filename,width=8.5,height=11,scale = 1.5)
}
#'@export
plotINDIVSIM_IQRnlmeProject <- function(projectPath,
                                        obssel = NULL,
                                        plotLog=FALSE,
                                        nsimtimes = 500,
                                        simtimes = NULL,
                                        ncol = 4,
                                        nrow = 2,
                                        filename = NULL,
                                        FLAGincludeIPRED = FALSE,
                                        opt_abstol = 1e-06, opt_reltol = 1e-06,
                                        opt_minstep = 0, opt_maxstep = 0,
                                        opt_initstep = 0) {
  data <- getData_IQRnlmeProject(projectPath)
  dataObs <- filter(data, EVID == 0 & MDV == 0)
  if (!is.null(obssel))
    eval(parse(text = paste0("dataObs <- filter(dataObs, ", obssel, ")")))
  dosing <- extract_IQRdosing(data)
  indSimtimes <- plyr::dlply(data, ~ID, function(xx) {
    if (is.null(simtimes)) {
      grid <- seq(min(xx$TIME), max(xx$TIME), length.out = nsimtimes)
    } else {
      grid <- simtimes 
    }
    grid <- unique(sort(union(grid, xx$TIME[xx$EVID == 0])))
    grid
  })
  obsInfo <- dataObs
  obsInfo <- select(obsInfo, YTYPE)
  obsInfo <- unique(obsInfo)
  obsInfo <- mutate(obsInfo, OUTPUT = paste0("OUTPUT", YTYPE), LABEL = paste0("Observation ", YTYPE))
  if ("NAME" %in% names(dataObs)) {
    obsInfo <- left_join(obsInfo, unique(dataObs[,c("YTYPE", "NAME")]), by = "YTYPE")
    obsInfo <- mutate(obsInfo, LABEL = gsub(":::", " ", NAME))
  }
  if ("UNIT" %in% names(dataObs)) {
    obsInfo <- left_join(obsInfo, unique(dataObs[,c("YTYPE", "UNIT")]), by = "YTYPE")
    obsInfo <- mutate(obsInfo, LABEL = paste0(LABEL, " (",UNIT,")"))
  }
  dataObs <- left_join(dataObs, obsInfo[,c("YTYPE", "OUTPUT", "LABEL")], by = "YTYPE")
  indPars <- getIndivParameters_IQRnlmeProject(projectPath, FLAGcovariate = FALSE)
  parNames <- setdiff(names(indPars), c("USUBJID", "ID"))
  subjMissingPars <- indPars$ID[apply(indPars[,parNames],1, function(x) all(is.na(x)))]
  if (length(subjMissingPars) > 0) {
    warningIQR(paste0("Subject(s) with ID ", paste0(subjMissingPars, collapse = ", "), " who have no individual parameter estimates are removed."))
    indPars     <- subset(indPars, !(ID %in% subjMissingPars))
    dataObs     <- subset(dataObs, !(ID %in% subjMissingPars))
    data        <- subset(data   , !(ID %in% subjMissingPars))
    dosing      <- dosing[setdiff(names(dosing)     , as.character(subjMissingPars))]
    indSimtimes <- indSimtimes[setdiff(names(indSimtimes), as.character(subjMissingPars))]
  }
  projHead <- getHeader_IQRnlmeProject(projectPath)
  regressionNames <- setdiff(projHead$REGRESSIONNAMES, "")
  if (length(regressionNames) != 0) {
    indRegress <- data[,c("ID", "TIME", regressionNames)]
    indRegressSplit <- split(indRegress, indRegress$ID)
    indRegressSplit <- lapply(indRegressSplit, function(x) {
      idxDupl <- duplicated(x[, regressionNames])
      x[!idxDupl,]
    })
    indRegress <- do.call(rbind, indRegressSplit)
  }
  abs0input <- which(projHead$DOSINGTYPES == "ABSORPTION0")
  abs0Tk0   <- projHead$TK0NAMES[abs0input]
  if (length(abs0input) == 0) {
    abs0input <- NULL
    abs0Tk0 <- NULL
  }
  model <- IQRmodel(file.path(projectPath, "model.txt"))
  nout <- length(model$outputs)
  if (length(regressionNames) == 0) {
    eT <- create_IQReventTable(dosing = dosing, indivData = indPars, regression = parNames)
  } else {
    dosData <- purrr::map_dfr(dosing, function(x) x, .id = "ID")
    dosData <- mutate(dosData, ID = as.numeric(ID))
    eData <- dplyr::arrange(dplyr::full_join(dosData, indRegress, by = c("ID", "TIME")), ID, TIME)
    idxNAcols <- which(sapply(eData, function(x) any(is.na(x))) & names(eData) %in% regressionNames)
    eData <- group_by(eData, ID)
    eData <- mutate_at(eData, idxNAcols, aux_na_locf)
    eData <- ungroup(eData)
    eData <- left_join(eData, indPars, by = c("ID"))
    eT <- IQReventTable(data = eData, regression = c(parNames, regressionNames),
                        abs0inputs = abs0input, abs0Tk0param = abs0Tk0)
  }
  sim <- sim_IQRmodel(model = model,
                      simtime = indSimtimes,
                      eventTable = eT,
                      FLAGoutputsOnly = TRUE,
                      opt_abstol   = opt_abstol , opt_reltol  = opt_reltol,
                      opt_minstep  = opt_minstep, opt_maxstep = opt_maxstep,
                      opt_initstep = opt_initstep)
  sim <- plyr::ddply(sim, ~ID, function(xxx) {
    id <- xxx$ID[1]
    xxx <- dplyr::filter(xxx, TIME %in% indSimtimes[[as.character(id)]])
    xxx
  })
  sim <- tidyr::gather(sim, "OUTPUT", "DV", 2+1:nout)
  simResults <- dplyr::left_join(sim, obsInfo, by = "OUTPUT")
  simResults <- dplyr::left_join(simResults, unique(dplyr::select(dataObs, ID, USUBJID)), by = "ID")
  if (FLAGincludeIPRED) {
    indPred <- getIndivPredictions_IQRnlmeProject(projectPath)
    indPred <- dplyr::left_join(indPred, obsInfo, by = "YTYPE")
  }
  subjects <- unique(dataObs$USUBJID)
  pList <- lapply(subjects, function(subj) {
    predk <- dplyr::filter(simResults, USUBJID %in% subj)
    obsk  <- dplyr::filter(dataObs, USUBJID %in% subj)
    if (FLAGincludeIPRED) ipredk <- dplyr::filter(indPred, USUBJID %in% subj)
    p <- IQRggplot(mapping = aes(TIME, DV)) +
      geom_point(data=obsk, aes(shape = CENS == 0), color = "black") +
      geom_line(data=predk, color = "steelblue", size = 0.8) +
      scale_shape_manual(values = c("TRUE" = 19, "FALSE" = 4)) +
      labs(x = "Time", y = "") +
      facet_grid(LABEL~ID, scales = "free_x") +
      theme(legend.position = "none")
    if (plotLog) p <- p + scale_y_log10_IQRtools()
    if (FLAGincludeIPRED) {
      p <- p +
        geom_point(data = ipredk, aes(y = IPRED), color = "darkorange", shape = 1)
    }
    p
  })
  names(pList) <- subjects
  figfooter <- "Black dots: observations\nBlue line: individual prediciton"
  if (FLAGincludeIPRED) figfooter <- paste0(figfooter, "\nYellow dots: individual prediction at observation times")
  fig <- IQRoutputFigure(pList,
                         footer = figfooter,
                         opt.layout = list(nrow = nrow, ncol = ncol))
  if (!is.null(filename)){
    IQRoutputPDF(fig, filename = filename, width = 21/2.65, height = 21/2.65*3/4)
    return(invisible(NULL))
  }
  out <- fig
  attr(out, "dataObs") <- dataObs
  attr(out, "dataSim") <- simResults
  if (FLAGincludeIPRED) attr(out, "indPred") <- indPred
  out
}
parseNLMEresults <- function (projectPath) {
  x__ <- aux_fileread(paste0(projectPath,"/RESULTS/project_results.x"))
  res__ <- eval(parse(text=x__))
  res__
}
sampleNLMEpopulationParameters <- function (input,FLAG_SAMPLE=FALSE,verbose=FALSE) {
  if (input$type=="NONMEM") return(sampleNONMEMpopulationParameters(input,FLAG_SAMPLE=FLAG_SAMPLE,verbose=verbose))
  if (input$type=="MONOLIX") return(sampleMONOLIXpopulationParameters(input,FLAG_SAMPLE=FLAG_SAMPLE,verbose=verbose))
  if (input$type=="NLMIXR") return(sampleNLMIXRpopulationParameters(input,FLAG_SAMPLE=FLAG_SAMPLE,verbose=verbose))
  if (input$type=="SYSFIT") return(sampleSYSFITpopulationParameters(input,FLAG_SAMPLE=FLAG_SAMPLE,verbose=verbose))
  stopIQR("Unknown project type")
}
convertETAINDIVPRED_IQRnlmeProject <- function (projectPath, pathName=NULL) {
  parsedInfo__ <- NULL
  if (is_NONMEM_IQRnlmeProject(projectPath)) parsedInfo__ <- read_ETA_INDIV_PRED_NONMEMoutputTables(projectPath)
  if (is_MONOLIX_IQRnlmeProject(projectPath)) parsedInfo__ <- read_ETA_INDIV_PRED_MONOLIXoutputTables(projectPath)
  if (is_NLMIXR_IQRnlmeProject(projectPath)) parsedInfo__ <- read_ETA_INDIV_PRED_NLMIXRoutputTables(projectPath)
  if (is.null(parsedInfo__)) return(NULL)
  ETA__ <- parsedInfo__$ETA
  INDIV__ <- parsedInfo__$INDIV
  PRED__ <- parsedInfo__$PRED
  ETAIOV__ <- parsedInfo__$ETAIOV
  data__ <- getData_IQRnlmeProject(projectPath)
  map__ <- unique(data__[,c("USUBJID","ID")])
  if (!is.null(ETA__)) ETA__ <- dplyr::left_join(ETA__,map__,by="ID")
  if (!is.null(INDIV__)) INDIV__ <- dplyr::left_join(INDIV__,map__,by="ID")
  if (!is.null(PRED__)) PRED__ <- dplyr::left_join(PRED__,map__,by="ID")
  if (!is.null(ETAIOV__)) ETAIOV__ <- dplyr::left_join(ETAIOV__,map__,by="ID")
  attr__ <- attributes(parsedInfo__)
  attr__$names <- NULL
  attributes(ETA__) <- c(attributes(ETA__),attr__)
  attributes(INDIV__) <- c(attributes(INDIV__),attr__)
  attributes(PRED__) <- c(attributes(PRED__),attr__)
  if (is.null(pathName)) {
    return ( list(ETA=ETA__,INDIV=INDIV__,PRED=PRED__,ETAIOV=ETAIOV__) )
  }
  if (length(ETA__>0)) IQRsaveCSVdata(ETA__,paste0(pathName,"/project_eta"))
  if (length(INDIV__>0)) IQRsaveCSVdata(INDIV__,paste0(pathName,"/project_indiv"))
  if (length(PRED__>0)) IQRsaveCSVdata(PRED__,paste0(pathName,"/project_pred"))
  if (length(ETAIOV__>0)) IQRsaveCSVdata(ETAIOV__,paste0(pathName,"/project_etaiov"))
}
parseNLMEprojectHeader <- function(projectPath,order=NULL) {
  FOUND__ <- FALSE
  if (is_MONOLIX_IQRnlmeProject(projectPath)) {
    projectinfo__ <- parseMONOLIXprojectHeader(projectPath)
    FOUND__ <- TRUE
  }
  if (is_NONMEM_IQRnlmeProject(projectPath)) {
    projectinfo__ <- parseNONMEMprojectHeader(projectPath)
    FOUND__ <- TRUE
  }
  if (is_NLMIXR_IQRnlmeProject(projectPath)) {
    projectinfo__ <- parseNLMIXRprojectHeader(projectPath)
    FOUND__ <- TRUE
  }
  tryCatch({
    if (is_IQRsysProject(projectPath)) {
      projectinfo__ <- parseSYSprojectHeader(projectPath)
      FOUND__ <- TRUE
    }
  }, error=function(err) {})
  if (!FOUND__) {
    stopIQR('Provided projectPath does not point to an NLME project.')
  }
  return(projectinfo__)
}
parseSelectedProjectFolderResults <- function(object) {
  if (!is_IQRnlmeProjectMulti(object)) {
    object <- as_IQRnlmeProjectMulti(object)
  }
  RESULTS__ <- list()
  for (k__ in seq_along(object)) {
    h__ <- parseNLMEprojectHeader(object[[k__]])
    tryCatch({
      x <- parseNLMEresults(object[[k__]])
      TESTallowMONOLIXgui <- tryCatch({
        if (allowMONOLIXgui) {
          TRUE
        }
      }, error=function (err) {FALSE})
      if (!TESTallowMONOLIXgui) {
        if (!is.null(x$parameters$covariancematrix)) {
          y__ <- sampleNLMEpopulationParameters(x,FLAG_SAMPLE=FALSE,verbose=FALSE)
        } else {
          y__ <- list()
          y__$randomEffects$correlationmatrix <- NULL
        }
      } else {
        y__ <- list()
      }
      RESULTSk__                                 <- list()
      RESULTSk__$FAILED                          <- FALSE
      RESULTSk__$COMMENT                         <- h__$COMMENT
      RESULTSk__$TOOL                            <- h__$TOOL
      RESULTSk__$model                           <- unclass(object[[k__]])
      RESULTSk__$OBJ                             <- x$objectivefunction$OBJ
      RESULTSk__$AIC                             <- x$objectivefunction$AIC
      RESULTSk__$BIC                             <- x$objectivefunction$BIC
      RESULTSk__$parameternames                  <- x$parameters$names
      RESULTSk__$parametervalues                 <- x$parameters$values
      RESULTSk__$stderrors                       <- x$parameters$stderrors
      RESULTSk__$correlationmatrixRandomEffects  <- y__$randomEffects$correlationmatrix
      RESULTSk__$rawParameterInfo                <- x$rawParameterInfo
      RESULTSk__$projectHeader                   <- parseNLMEprojectHeader(object[[k__]])
      RESULTS__[[k__]] <- RESULTSk__
    }, error = function(e) {
      RESULTSk__                                 <- list()
      RESULTSk__$FAILED                          <- TRUE
      RESULTSk__$COMMENT                         <- h__$COMMENT
      RESULTSk__$TOOL                            <- h__$TOOL
      RESULTSk__$model                           <- unclass(object[[k__]])
      RESULTSk__$OBJ                             <- NA
      RESULTSk__$AIC                             <- NA
      RESULTSk__$BIC                             <- NA
      RESULTSk__$parameternames                  <- NULL
      RESULTSk__$parametervalues                 <- NULL
      RESULTSk__$stderrors                       <- NULL
      RESULTSk__$correlationmatrixRandomEffects  <- NULL
      RESULTSk__$rawParameterInfo                <- NULL
      RESULTSk__$projectHeader                   <- NULL
      RESULTS__[[k__]] <<- RESULTSk__
    })
  }
  names(RESULTS__) <- names(object)
  return(RESULTS__)
}
shrinkageNLMEproject <- function(projectPath, ETA_THRESHOLD_REL = 0, stratifyShrinkageBy = NULL, type = c("eta", "eps")) {
  type <- match.arg(type)
  data__ <- getData_IQRnlmeProject(projectPath)
  IDs.data__ <- list(data__[["ID"]])
  stratinfo__ <- NULL
  if (!is.null(stratifyShrinkageBy)) {
    if (length(stratifyShrinkageBy) > 1) warningIQR("Stratification of shrinkage by more than one covariate is not supported. Only first entry is used.")
    catCOLNAME__ <- stratifyShrinkageBy[1]
    catInfo__ <- attr(data__, "catInfo")
    catIdx__ <- match(catCOLNAME__, catInfo__[["COLNAME"]])
    if (!is.na(catIdx__)) {
      catNAME__ <- catInfo__[["NAME"]][catIdx__]
      catVALUES__ <- as.numeric(strsplit(catInfo__[["VALUES"]][catIdx__], ",")[[1]])
      catVALUETXT__ <- strsplit(catInfo__[["VALUETXT"]][catIdx__], ",")[[1]]
      catVALUES.data__ <- sort(unique(data__[[catCOLNAME__]]))
      catVALUETXT.data__ <- catVALUETXT__[match(catVALUES.data__, catVALUES__)]
      IDs.data__ <- lapply(catVALUES.data__, function(value__) data__[["ID"]][data__[[catCOLNAME__]] == value__])
      names(IDs.data__) <- paste0("(", catCOLNAME__, " = ", catVALUETXT.data__, ")")
    } else {
      if (!catCOLNAME__ %in% names(data__)) stopIQR("The column '", catCOLNAME__, "' was not found in the NLME dataset of the provided IQR NLME project." )
      if (any(is.na(data__[[catCOLNAME__]]))) stopIQR("The column '", catCOLNAME__, "' used for stratification contains NA values. NA is not allowed in the stratification column." )
      n_levels_per_ID__ <- sapply(unique(data__[["ID"]]), function(myID) length(unique(data__[[catCOLNAME__]][data__[["ID"]] %in% myID])))
      if (any(n_levels_per_ID__ > 1)) stopIQR("Values of the stratification column '", catCOLNAME__, "' are not constant over one subject (ID).")
      catNAME__ <- NULL
      catVALUES.data__ <- sort(unique(data__[[catCOLNAME__]]))
      IDs.data__ <- lapply(catVALUES.data__, function(value__) data__[["ID"]][data__[[catCOLNAME__]] == value__])
      names(IDs.data__) <- paste0("(", catCOLNAME__, " = ", gsub(":::", "", catVALUES.data__), ")")
    }
    stratinfo__ <- paste0("Shrinkage was determined for separate groups of subjects stratified by ",
                          catCOLNAME__,
                          ifelse(is.null(catNAME__), "", paste0(" (", catNAME__, ")")),
                          ".")
  }
  if (type == "eta") {
    if (!file.exists(paste0(projectPath,"/RESULTS/project_eta.csv")))
      return (lapply(IDs.data__, function (xxx) NA))
    dataETA__ <- IQRloadCSVdata(paste0(projectPath,"/RESULTS/project_eta.csv"))
    xxx__             <- parseNLMEresults(projectPath)
    REvalues__        <- xxx__$rawParameterInfo$randomEffects$values
    names(REvalues__) <- xxx__$rawParameterInfo$fixedEffects$names
    y__ <- dataETA__[,c("ID",paste0("ETA_",attr(dataETA__,"paramNames")))]
    for (k in paste0("ETA_",attr(dataETA__,"paramNames"))) y__[, k][abs(y__[, k]) < ETA_THRESHOLD_REL*mean(abs(y__[ ,k]))] <- NA
    names(y__) <- gsub(x=names(y__),pattern="ETA_",replacement="")
    if (all(names(REvalues__) != names(y__)[2:ncol(y__)]))
      stopIQR("Issue with ordering (should not happen)")
    eta_shrinkage_percent__ <- lapply(IDs.data__, function(myIDs__) {
      y__ <- y__[y__[, "ID"] %in% myIDs__,]
      SDvalues_indiv__ <- apply(as.matrix(y__[,2:ncol(y__)],ncol=ncol(y__)-1),2, function(myy__) sd(myy__, na.rm = TRUE))
      round(100*(1-SDvalues_indiv__/REvalues__), 1)
    })
    attr(eta_shrinkage_percent__, "stratinfo") <- stratinfo__
    return(eta_shrinkage_percent__)
  }
  if (type == "eps") {
    x__ <- getIndivPredictions_IQRnlmeProject(projectPath)
    if (is.null(x__)) return (lapply(IDs.data__, function (xxx) NA))
    if ("MDV" %in% names(x__)) x__ <- x__[x__$MDV==0,]
    if ("CENS" %in% names(x__)) x__ <- x__[x__$CENS==0,]
    shringkageEpsilon__ <- lapply(IDs.data__, function(myIDs__) {
      x__ <- x__[x__[["ID"]] %in% myIDs__,]
      ytypes__ <- unique(x__[["YTYPE"]])
      shrinkage__ <- sapply(ytypes__, function(y__) {
        iwres__ <- x__[["IWRES"]][x__[["YTYPE"]] %in% y__]
        round(100*(1-sd(iwres__)), 2)
      })
      names(shrinkage__) <- ytypes__
      return(shrinkage__)
    })
    attr(shringkageEpsilon__, "stratinfo") <- stratinfo__
    return(shringkageEpsilon__)
  }
}
checkModelLinear <- function(model) {
  jacobian__ <- attr(model,"dfdx.IQRmodel")$jacobian
  if (is.null(jacobian__)) {
    message("Model has non-differentiable components not allowing to determine the Jacobian.")
    message("=> Model assumed non-linear.")
    return(FALSE)
  }
  stateNames__ <- attr(model,"dfdx.IQRmodel")$statenames
  LINEAR__ <- TRUE
  for (k in seq_along(stateNames__)) {
    ix__ <- which(unlist(gregexpr(text=as.vector(jacobian__),pattern=paste0("\\<",stateNames__[k],"\\>"))) > 0)
    if (length(ix__)>0) {
      LINEAR__ <- FALSE
      break
    }
  }
  return(LINEAR__)
}
constructNewVariablesLinearModel <- function(model) {
  variableInfo__ <- variablesInfo_IQRmodel(model)
  variableInfoExpanded__ <- prepareIQRmodelODEs4symbolic(model)$varInfo
  ixOUTPUT__ <- grep(x=variableInfo__$varnames,pattern="\\<OUTPUT[0-9]+\\>")
  if (length(ixOUTPUT__)==0)
    stopIQR("Model does not contain OUTPUT definitions.")
  ixVARS__ <- c()
  for (k in seq_along(ixOUTPUT__)) {
    outRHS__ <- variableInfo__$varformulas[ixOUTPUT__[k]]
    if (!(outRHS__ %in% variableInfo__$varnames))
      stopIQR("An OUTPUT RHS definition is not set to only a variable.")
    ixVARS__ <- c(ixVARS__,grep(pattern=paste0("\\<",outRHS__,"\\>"),x=variableInfoExpanded__$varnames))
  }
  output__ <- list(
    varInfoLinear = list(
      varnames    = c(variableInfoExpanded__$varnames[ixVARS__]),
      varformulas = c(variableInfoExpanded__$varformulas[ixVARS__])
    ),
    outInfoLinear = list(
      outnames    = c(variableInfo__$varnames[ixOUTPUT__]),
      outformulas = c(variableInfo__$varformulas[ixOUTPUT__])
    )
  )
  return(output__)
}
getInfoADVAN12341112compatibility <- function (model,seed) {
  set.seed(seed)
  compatible__ <- FALSE
  ADVANtype__  <- NULL
  ADVANparam__ <- NULL
  jacInfo__ <- symStateJacobian_IQRmodel(model)
  nCPT__ <- length(model$states)
  if (is.null(jacInfo__)) {
    return(list(
      compatible = compatible__,
      nCPT = nCPT__,
      ADVANtype = ADVANtype__,
      ADVANparam = ADVANparam__
    ))
  }
  dummy__ <- sapply(names(model$parameters), function(x) {
    eval(parse(text=paste0(x," <<- 5*exp(stats::rnorm(1,0,0.5))")))
  })
  jacVec__ <- eval(parse(text=paste0("c(",paste0(as.vector(jacInfo__$jacobian),collapse=","),")")))
  J__ <- matrix(jacVec__,ncol=nCPT__,nrow=nCPT__)
  if (any(is.na(J__)) | any(is.nan(J__))) {
    return(list(
      compatible = compatible__,
      nCPT = nCPT__,
      ADVANtype = ADVANtype__,
      ADVANparam = ADVANparam__
    ))
  }
  if (nCPT__ == 1) {
    if (J__[1,1]<0) {
      compatible__ <- TRUE
      ADVANtype__  <- "ADVAN1 TRANS1"
      ADVANparam__ <- list(
        K  = paste0("-(",jacInfo__$jacobian[1,1],")")
      )
    }
  }
  if (nCPT__ == 2) {
    if (J__[1,1]<0 & J__[1,2]==0 & J__[2,1]==-J__[1,1] & J__[2,2]<0) {
      compatible__ <- TRUE
      ADVANtype__  <- "ADVAN2 TRANS1"
      ADVANparam__ <- list(
        KA = jacInfo__$jacobian[2,1],
        K  = paste0("-(",jacInfo__$jacobian[2,2],")")
      )
    }
  }
  if (nCPT__ == 2) {
    if (J__[1,1]<-J__[2,1] & J__[1,2]>0 & J__[2,1]>0 & J__[2,2]==-J__[1,2]) {
      compatible__ <- TRUE
      ADVANtype__  <- "ADVAN3 TRANS1"
      ADVANparam__ <- list(
        K12 = jacInfo__$jacobian[2,1],
        K21 = jacInfo__$jacobian[1,2],
        K   = paste0("-(",jacInfo__$jacobian[1,1],")-(",jacInfo__$jacobian[2,1],")")
      )
    }
  }
  if (nCPT__ == 3) {
    if (J__[1,1]<0        & J__[1,2]==0        & J__[1,3]==0 &
        J__[2,1]==-J__[1,1] & J__[2,2] < -J__[3,2] & J__[2,3]>0  &
        J__[3,1]==0       & J__[3,2]>0         & J__[3,3]==-J__[2,3]) {
      compatible__ <- TRUE
      ADVANtype__  <- "ADVAN4 TRANS1"
      ADVANparam__ <- list(
        KA  = jacInfo__$jacobian[2,1],
        K23 = jacInfo__$jacobian[3,2],
        K32 = jacInfo__$jacobian[2,3],
        K   = paste0("-(",jacInfo__$jacobian[2,2],")-(",jacInfo__$jacobian[3,2],")")
      )
    }
  }
  if (nCPT__ == 3) {
    if (J__[1,1] < -J__[2,1]-J__[3,1] & J__[1,2]>0           & J__[1,3]>0        &
        J__[2,1]>0                    & J__[2,2]==-J__[1,2]  & J__[2,3]==0       &
        J__[3,1]>0                    & J__[3,2]==0          & J__[3,3]==-J__[1,3]) {
      compatible__ <- TRUE
      ADVANtype__  <- "ADVAN11 TRANS1"
      ADVANparam__ <- list(
        K12 = jacInfo__$jacobian[2,1],
        K21 = jacInfo__$jacobian[1,2],
        K13 = jacInfo__$jacobian[3,1],
        K31 = jacInfo__$jacobian[1,3],
        K   = paste0("-(",jacInfo__$jacobian[1,1],")-(",jacInfo__$jacobian[2,1],")-(",jacInfo__$jacobian[3,1],")")
      )
    }
  }
  if (nCPT__ == 4) {
    if (J__[1,1]<0        & J__[1,2]==0               & J__[1,3]==0        & J__[1,4]==0       &
        J__[2,1]==-J__[1,1] & J__[2,2] < -J__[3,2]-J__[4,2] & J__[2,3]>0         & J__[2,4]>0        &
        J__[3,1]==0       & J__[3,2]>0                & J__[3,3]==-J__[2,3]  & J__[3,4]==0       &
        J__[4,1]==0       & J__[4,2]>0                & J__[4,3]==0        & J__[4,4]==-J__[2,4]) {
      compatible__ <- TRUE
      ADVANtype__  <- "ADVAN12 TRANS1"
      ADVANparam__ <- list(
        KA  = jacInfo__$jacobian[2,1],
        K23 = jacInfo__$jacobian[3,2],
        K32 = jacInfo__$jacobian[2,3],
        K24 = jacInfo__$jacobian[4,2],
        K42 = jacInfo__$jacobian[2,4],
        K   = paste0("-(",jacInfo__$jacobian[2,2],")-(",jacInfo__$jacobian[3,2],")-(",jacInfo__$jacobian[4,2],")")
      )
    }
  }
  output__ <- list(
    compatible = compatible__,
    nCPT = nCPT__,
    ADVANtype = ADVANtype__,
    ADVANparam = ADVANparam__
  )
  return(output__)
}
#'@export
IQRnlmeData <- function(input,
                        covNames       = NULL,
                        catNames       = NULL,
                        regressorNames = NULL,
                        FLAGqsp        = FALSE) {
  if (is.character(input)) {
    if(!file.exists(input))
      stopIQR("Trouble loading the data file. Please check if provided datafile argument is correct")
    data__ <- IQRloadCSVdata(input)
  } else {
    if (is.data.frame(input)) {
      data__ <- input
    } else {
      stopIQR("datafile argument needs to be a path to a csv file or a data.frame object")
    }
  }
  covInfoOrig__ <- attr(data__,"covInfo")
  catInfoOrig__ <- attr(data__,"catInfo")
  colname.is.alphanumeric <- grepl("^[[:alnum:]]+$", names(data__))
  if (any(!colname.is.alphanumeric)) {
    if (!FLAGqsp) warningIQR("Some column names were not fully alphanumeric. Might lead to problems with NONMEM/MONOLIX ")
  }
  data__ <- data.frame(lapply(data__,function(x) {
    if (!is.character(x)) return(x)
    x <- gsub(x=x,pattern=" ",replacement=":::",fixed=TRUE)
    gsub(x=x,pattern=",",replacement=";",fixed=TRUE)
  }),stringsAsFactors=FALSE)
  info__ <- checkHeader_IQRnlmeData(data__)
  if (!info__$success)
    stopIQR(paste0("IQRnlmeData: NLME dataset header has issues:\n",info__$errorText__))
  if (!all(sapply(covNames, function(x) x %in% names(data__))))
    stopIQR("Not all provided 'covNames' are available in the dataset")
  if (!all(sapply(catNames, function(x) x %in% names(data__))))
    stopIQR("Not all provided 'catNames' are available in the dataset")
  if (!all(sapply(regressorNames, function(x) x %in% names(data__))))
    stopIQR("Not all provided 'regressorNames' are available in the dataset")
  if (any(grepl("_",covNames)))
    stopIQR("At least one continuous covariate name contains an '_' (underscore). This is not allowed.")
  if (any(grepl("_",catNames)))
    stopIQR("At least one categorical covariate name contains an '_' (underscore). This is not allowed.")
  headerInfo__     <- getHeaderIdent_IQRnlmeData(data__,covNames,catNames,regressorNames)
  covNames       <- names(data__)[which(headerInfo__$headerIdentVector=="COV")]
  catNames       <- names(data__)[which(headerInfo__$headerIdentVector=="CAT")]
  regressorNames <- names(data__)[which(headerInfo__$headerIdentVector=="X")]
  if (length(covNames) == 0) covNames <- NULL
  if (length(catNames) == 0) catNames <- NULL
  if (length(regressorNames) == 0) regressorNames <- NULL
  if (!is.null(covNames)) {
    covsAllIDs__ <- do.call(rbind,lapply(split(data__,data__$ID), function(x) x[1,covNames,drop=FALSE] ))
    covariateMedianValues__ <- sapply(covNames, function(x) stats::median(as.numeric(covsAllIDs__[[x]]),na.rm=TRUE))
  } else {
    covariateMedianValues__ <- NULL
  }
  if (!is.null(catNames)) {
    catsAllIDs__ <- as.data.frame(do.call(rbind,lapply(split(data__,data__$ID), function(x) x[1,catNames] )))
    if (length(catNames)==1) names(catsAllIDs__) <- catNames
    catValues <- lapply(catNames, function(x) sort(unique(as.numeric(catsAllIDs__[[x]]))))
    names(catValues) <- catNames
    if (sum(as.numeric(is.na(unlist(catValues)))) > 0)
      stopIQR("dataset contains undefined (NA) categorical covariates. Please impute")
    if (sum(as.numeric(is.nan(unlist(data__$catValues)))) > 0)
      stopIQR("dataset contains undefined (NaN) categorical covariates. Please impute")
    covariateCATreference <- sapply(catValues, function(x) min(x))
  } else {
    catValues <- NULL
    covariateCATreference <- NULL
  }
  dummy <- lapply(split(data__, data__$USUBJID), function (x) {
    if (length(which(diff(x$TIME) < 0)) > 0)
      stopIQR("TIME column is not monotounously non-decreasing in at least one subject")
  })
  data__$ADM[data__$EVID==0] <- NA
  if ("YTYPE" %in% names(data__)) {
    data__$YTYPE[data__$EVID==1] <- NA
  }
  attr(data__,"covNames")              <- covNames
  attr(data__,"covariateMedianValues") <- covariateMedianValues__
  attr(data__,"catNames")              <- catNames
  attr(data__,"catValues")             <- catValues
  attr(data__,"covariateCATreference") <- covariateCATreference
  attr(data__,"regressorNames")        <- regressorNames
  attr(data__,"headerIdent")           <- headerInfo__$headerIdent
  attr(data__,"headerIdentVector")     <- headerInfo__$headerIdentVector
  attr(data__,"covInfo")     <- covInfoOrig__
  attr(data__,"catInfo")     <- catInfoOrig__
  attr(data__,"class")                 <- c("IQRnlmeData", attr(data__,"class"))
  return(data__)
}
#'@export
is_IQRnlmeData <- function(input) {
  methods::is(input,"IQRnlmeData")
}
#'@export
plot.IQRnlmeData <- function(x, ..., pathname=getwd()) {
}
#'@export
export_IQRnlmeData <- function(data, filename) {
  filename__ <- paste0(aux_strrep(filename,".csv",""),".csv")
  IQRoutputCSV(data=data,filename=filename__,na=".",quote=FALSE,row.names=FALSE)
}
#'@export
print.IQRnlmeData <- function(x, ...) {
  print.data.frame(x[1:min(6,nrow(x)),])
  cat('\n')
  xtable__ <- data.frame(COLUMN.NAMES            = names(x),
                         HEADER.IDENT            = attr(x,"headerIdentVector")
  )
  print(IQRoutputTable(xtable__,xtitle="Matching between data column names and identifiers",report=FALSE))
  cat('\n')
  if (!is.null(attr(x,"covariateMedianValues"))) {
    cat('\n')
    xtable__ <- data.frame(NAME=names(attr(x,"covariateMedianValues")),VALUE=attr(x,"covariateMedianValues"))
    xtitle <- "Determined centering values for continuous covariates"
    xfooter <- "Median values (excluding NAs) used as default centering value"
    print(IQRoutputTable(xtable__,xtitle=xtitle,xfooter=xfooter))
    cat('\n')
  }
  if (!is.null(attr(x,"catValues"))) {
    cat('\n')
    ALLVALUES__ <- paste(attr(x,"catValues"))
    ALLVALUES__ <- gsub(pattern="c\\(",x=ALLVALUES__,replacement="")
    ALLVALUES__ <- gsub(pattern="\\)",x=ALLVALUES__,replacement="")
    xtable__ <- data.frame(NAME=names(attr(x,"covariateCATreference")),REFERENCE=attr(x,"covariateCATreference"),CATEGORIES=ALLVALUES__)
    xtitle <- "Determined reference values for categorical covariates"
    xfooter <- "Smallest category used as default reference value"
    print(IQRoutputTable(xtable__,xtitle=xtitle,xfooter=xfooter))
    cat('\n')
  }
  if (!is.null(attr(x,"regressorNames"))) {
    cat("\n")
    cat("   Regressors: ")
    cat(attr(x,"regressorNames"))
    cat("\n")
  }
  cat("\nIQRnlmeData object\n")
}
checkHeader_IQRnlmeData <- function (data__) {
  datanames       <- names(data__)
  requiredColumns__ <- c('IXGDF', 'USUBJID', 'ID', 'TIME', 'TIMEPOS', 'TAD', 'DV', 'MDV', 'EVID', 'CENS', 'AMT', 'ADM', 'TINF','RATE')
  errorText__       <- ""
  for (k in seq_along(requiredColumns__)) {
    ix__ <- aux_strmatch(searchString=requiredColumns__[k],inputVec=datanames)
    if (is.null(ix__))
      errorText__ <- sprintf("%s    The dataset does not contain the column '%s'.\n",errorText__,requiredColumns__[k]);
  }
  if ("CMT" %in% datanames & "YTYPE" %in% datanames)
    errorText__ <- paste0(errorText__,"\nYTYPE and CMT columns present. Only one allowed")
  if (!("CMT" %in% datanames) & !("YTYPE" %in% datanames))
    errorText__ <- paste0(errorText__,"\nNeither YTYPE or CMT column present. One of them needs to be defined")
  output__ <- list(success=!(nchar(errorText__) > 0), errorText__=errorText__)
  return(output__)
}
getHeaderIdent_IQRnlmeData <- function(data,covNames,catNames,regressorNames) {
  colName__ <- c('OCC', 'IXGDF',  'USUBJID', 'SS', 'II', 'ADDL', 'STUDYN', 'SUBJECT', 'ID', 'TIME', 'TIMEPOS', 'NT',     'TAD',  'TIMEUNIT', 'DV', 'NAME',   'UNIT',     'MDV', 'EVID', 'CENS', 'AMT',  'ADM', 'ROUTE',  'RATE', 'TINF',    'DOSE',   'TRT',    'YTYPE', 'CMT', 'LIMIT')
  colType__ <- c('OCC', 'IGNORE', 'IGNORE',  'SS', 'II', 'ADDL', 'IGNORE', 'IGNORE',  'ID', 'TIME', 'TIMEPOS', 'IGNORE', 'TAD',  'IGNORE',   'DV', 'IGNORE', 'IGNORE',   'MDV', 'EVID', 'CENS', 'AMT',  'ADM', 'IGNORE', 'RATE', 'TINF',    'IGNORE', 'IGNORE', 'YTYPE', 'CMT', 'LIMIT')
  columnNames__ <- names(data)
  headerContent__ <- rep("IGNORE",length(columnNames__))
  for (k in seq_along(colName__)) {
    ix__ <- which(colName__[k]==columnNames__)
    if (length(ix__)>0) {
      headerContent__[ix__] <- colType__[k]
    }
  }
  for (k in seq_along(covNames)) {
    ix__ <- which(covNames[k]==columnNames__)
    if (length(ix__)>0) {
      headerContent__[ix__] <- "COV"
    }
  }
  for (k in seq_along(catNames)) {
    ix__ <- which(catNames[k]==columnNames__)
    if (length(ix__)>0) {
      headerContent__[ix__] <- "CAT"
    }
  }
  for (k in seq_along(regressorNames)) {
    ix__ <- which(regressorNames[k]==columnNames__)
    if (length(ix__)>0) {
      headerContent__[ix__] <- "X"
    }
  }
  ixCOV__ <- which('COV'==headerContent__)
  for (k in ixCOV__) {
    if (length(unique(data[,k])) == 1) {
      headerContent__[k] <- "IGNORE"
      warningIQR(paste0("Only single value for candidate continuous covariate ",columnNames__[k]," => set to IGNORE"))
    }
  }
  ixCAT__ <- which('CAT'==headerContent__)
  for (k in ixCAT__) {
    if (length(unique(data[,k])) == 1) {
      headerContent__[k] <- "IGNORE"
      warningIQR(paste0("Only single cagtegory for candidate categorical covariate ",columnNames__[k]," => set to IGNORE"))
    }
  }
  output__ <- list(headerIdent = paste0(headerContent__,collapse=","), headerIdentVector = headerContent__)
  return(output__)
}
#'@export
is_IQRnlmeEst <- function(input) {
  methods::is(input,"IQRnlmeEst")
}
#'@export
print.IQRnlmeEst <- function(x, ...) {
  cat('\n')
  cat('==================================================================\n')
  cat('== IQRnlmeEst information\n')
  cat('==================================================================\n')
  cat('\n')
  cat(sprintf("   NLME data file: %s\n",x$data$datafile))
  cat('\n')
  cat('\n')
  DISTRIBUTION__ <- x$modelSpec$IIVdistribution
  DISTRIBUTION__[DISTRIBUTION__=="L"] <- "LogNormal"
  DISTRIBUTION__[DISTRIBUTION__=="N"] <- "Normal"
  DISTRIBUTION__[DISTRIBUTION__=="G"] <- "LogitNormal"
  FIXED.EFFECT__ <- x$modelSpec$POPestimate
  FIXED.EFFECT__[FIXED.EFFECT__==0] <- "FIXED"
  FIXED.EFFECT__[FIXED.EFFECT__==1] <- "ESTIMATED"
  IIV.RANDOM.EFFECT__ <- x$modelSpec$IIVestimate
  IIV.RANDOM.EFFECT__[IIV.RANDOM.EFFECT__==0] <- "NONE (kept on 0)"
  IIV.RANDOM.EFFECT__[IIV.RANDOM.EFFECT__==1] <- "ESTIMATED"
  IIV.RANDOM.EFFECT__[IIV.RANDOM.EFFECT__==2] <- "(kept on initial guess)"
  IOV.RANDOM.EFFECT__ <- x$modelSpec$IOVestimate
  IOV.RANDOM.EFFECT__[IOV.RANDOM.EFFECT__==0] <- "NONE (kept on 0)"
  IOV.RANDOM.EFFECT__[IOV.RANDOM.EFFECT__==1] <- "ESTIMATED"
  xtable <- data.frame(PARAMETER                       = names(x$modelSpec$POPvalues0),
                       INITIAL.GUESS.FIXED.EFFECT      = x$modelSpec$POPvalues0,
                       IIV.IOV.DISTRIBUTION            = DISTRIBUTION__,
                       INITIAL.GUESS.IIV.RANDOM.EFFECT = x$modelSpec$IIVvalues0,
                       INITIAL.GUESS.IOV.RANDOM.EFFECT = x$modelSpec$IOVvalues0,
                       FIXED.EFFECT                    = FIXED.EFFECT__,
                       IIV.RANDOM.EFFECT               = IIV.RANDOM.EFFECT__,
                       IOV.RANDOM.EFFECT               = IOV.RANDOM.EFFECT__
  )
  print(IQRoutputTable(xtable,xtitle="Summary of parameter estimation specification (parameters)",report=FALSE))
  cat('\n')
  cat('\n')
  cat("   Regression parameters considered in the model:\n")
  cat("   ==============================================\n")
  if (length(x$data$regNames)==0) {
    cat("   No regression parameters considered.\n");
  } else {
    cat(paste0("   ",paste(x$data$regNames,collapse=", ")))
    cat('\n')
    cat("   Names and ordering of regression parameters has been checked to be identical between model and data.\n")
  }
  cat('\n')
  cat('\n')
  xtable <- data.frame(DATAHEADER                  = names(x$data$dataModeling),
                       DATAHEADER.IDENT            = attr(x$data$dataModeling,"headerIdentVector")
  )
  print(IQRoutputTable(xtable,xtitle="Matching between data header names and identifiers",report=FALSE))
  cat('\n')
  cat('\n')
  ERROR.MODEL__ <- sapply(x$modelSpec$errorModel,function(x) x[1])
  ERROR.MODEL__[ERROR.MODEL__=="abs"] <- "Absolute (Additive)"
  ERROR.MODEL__[ERROR.MODEL__=="rel"] <- "Relative (Proportional)"
  ERROR.MODEL__[ERROR.MODEL__=="absrel"] <- "Absolute (Additive) / Relative (Proportional)"
  ERROR.MODEL__[ERROR.MODEL__=="event"] <- "Time-to-Event outcome (not repeated)"
  ERROR.GUESS__ <- paste(lapply(x$modelSpec$errorModel, function(x) as.numeric(x[2:length(x)])))
  ERROR.GUESS__ <- gsub(pattern="c\\(",x=ERROR.GUESS__,replacement="")
  ERROR.GUESS__ <- gsub(pattern="\\)",x=ERROR.GUESS__,replacement="")
  xtable <- data.frame(OUTPUT                 = names(x$modelSpec$errorModel),
                       ERROR.MODEL            = ERROR.MODEL__,
                       INITIAL.GUESS          = ERROR.GUESS__
  )
  print(IQRoutputTable(xtable,xtitle="Error model information",report=FALSE))
  cat('\n')
  if (!is.null(x$modelSpec$covariateModel)) {
    cat('\n')
    xtable <- do.call(rbind,lapply(seq_along(x$modelSpec$covariateModel),function (k__) {
      COVARIATE__     <- x$modelSpec$covariateModel[[k__]]
      PARAMETER__     <- rep(names(x$modelSpec$covariateModel)[[k__]],length(COVARIATE__))
      INITIAL.GUESS__ <- x$modelSpec$covariateModelValues[[k__]]
      ESTIMATED__     <- x$modelSpec$COVestimate[[k__]]
      ESTIMATED__[ESTIMATED__==0] <- "FIXED"
      ESTIMATED__[ESTIMATED__==1] <- "ESTIMATED"
      data.frame(PARAMETER     = PARAMETER__,
                 COVARIATE     = COVARIATE__,
                 INITIAL.GUESS = INITIAL.GUESS__,
                 ESTIMATED     = ESTIMATED__ )
    }))
    print(IQRoutputTable(xtable,xtitle="Covariate estimation information",report=FALSE))
    cat('\n')
    if (!is.null(x$data$covariateMedianValues)) {
      cat('\n')
      xtable <- data.frame(NAME=names(x$data$covariateMedianValues),VALUE=x$data$covariateMedianValues)
      xtitle <- "Determined centering values for continuous covariates"
      xfooter <- "Median values (excluding NAs) or defined by the user"
      print(IQRoutputTable(xtable,xtitle=xtitle,xfooter=xfooter))
      cat('\n')
    }
    if (!is.null(x$data$catValues)) {
      cat('\n')
      ALLVALUES__ <- paste(x$data$catValues)
      ALLVALUES__ <- gsub(pattern="c\\(",x=ALLVALUES__,replacement="")
      ALLVALUES__ <- gsub(pattern="\\)",x=ALLVALUES__,replacement="")
      xtable <- data.frame(NAME=names(x$data$covariateCATreference),REFERENCE=x$data$covariateCATreference,CATEGORIES=ALLVALUES__)
      xtitle <- "Determined reference values for categorical covariates"
      xfooter <- "Smallest category or defined by the user"
      print(IQRoutputTable(xtable,xtitle=xtitle,xfooter=xfooter))
      cat('\n')
    }
  } else {
    cat("   Covariate estimation information\n")
    cat("   ================================\n")
    cat("   No covariates considered.\n");
  }
  if (x$linearModel$isLinear) {
    cat("\n")
    cat("   The model is linear and can be solved analytically.\n")
    cat("   ===================================================\n")
    cat("     - In NONMEM ADVAN1,2,3,4,5,7,11, or 12 will be used, depending on the model structure.\n")
    cat("     - Please note that in MONOLIX an analytic solution can only be used if there is only one route of elimination.\n")
    cat("       Otherwise the model is integrated.\n")
    cat("     - Please ensure no constant zero order terms are entering ODE RHSs! These are unhandled and unchecked.\n")
    cat("       If such things are present, please use the ODE based solution for now.\n")
    cat("     - Using the analytic solution can be overriden by an input argument to IQRnlmeProject\n")
  } else {
    cat("\n")
    cat("   The model is nonlinear and numeric ODE integration will be used.\n")
    cat("   ================================================================\n")
  }
  cat("\n")
  cat("\nIQRnlmeEst object\n")
}
#'@export
IQRnlmeEst <- function(model,
                       dosing,
                       data,
                       modelSpec = NULL,
                       FLAGqsp = FALSE) {
  if (is.data.frame(data$datafile)) {
    if (nrow(data$datafile) == 0)
      stopIQR("Provided dataset in the data$datafile entry of IQRnlmeEst() is empty")
    datafile <- paste0(tempfileIQR(),".csv")
    IQRsaveCSVdata(data$datafile,filename = datafile)
    data$datafile <- datafile
    data$FLAGdataAsDataFrame <- TRUE
  } else {
    data$FLAGdataAsDataFrame <- FALSE
  }
  output__ <- list()
  output__$original$model <- model
  output__$original$dosing <- dosing
  output__$original$data <- data
  output__$original$modelSpec <- modelSpec
  if (is.character(model)) model <- IQRmodel(model)
  if (!is_IQRmodel(model)) stopIQR('First input argument is not an IQRmodel')
  if (checkModelLinear(model)) {
    output__$linearModel$isLinear <- TRUE
  } else {
    output__$linearModel$isLinear <- FALSE
  }
  if (any(sapply(model$states, function (x) x$IC) != 0)) {
    output__$linearModel$isLinear <- FALSE
  }
  output__$model <- model
  if (length(model$events) > 0 & is.null(modelSpec[["LOCmodel"]])) stopIQR("Model contains events - this can not be handled by any of the considered NLME tools")
  if (length(model$functions) > 0) stopIQR("Model contains functions - this can not be handled by any of the considered NLME tools")
  if (!is.null(model$Cfunctions)) stopIQR("Model contains C functions - this can not be handled by any of the considered NLME tools")
  if (length(setdiff(names(dosing),names(model$inputs)))>0)
    stopIQR("Inputs defined in dosing that do not appear in the model")
  if (length(setdiff(names(model$inputs),names(dosing)))>0)
    stopIQR("Inputs defined in model that do not appear in the dosing argument")
  if (length(dosing) > 0) {
    if (!("type" %in% unlist(as.vector((sapply(dosing, function(x) names(x)))))))
      stopIQR("dosing argument needs to contain at least a 'type' elment")
  }
  if (length(setdiff(sapply(dosing,function(x) x["type"]), c("BOLUS","INFUSION","ABSORPTION0"))) > 0)
    stopIQR("wrong dosing types defined (allowed: BOLUS, INFUSION, or ABSORPTION0")
  if (length(setdiff(unique(unlist(as.vector((sapply(dosing, function(x) names(x)))))),c("type","Tlag","Tk0"))) > 0)
    stopIQR("dosing argument contains names that are not recognized ('type', 'Tlag', 'Tk0' allowed only)")
  if (length(dosing) > 0) {
    if (!("type" %in% unlist(as.vector((sapply(dosing, function(x) names(x)))))))
      stopIQR("dosing argument needs to contain at least a 'type' elment")
  }
  dosingInfo__                 <- list()
  dosingInfo__$INPUTnames      <- names(dosing)
  dosingInfo__$types           <- sapply(dosing, function(x) x["type"])
  names(dosingInfo__$types)    <- names(dosing)
  dosingInfo__$lagTimes        <- sapply(dosing, function(x) x["Tlag"])
  names(dosingInfo__$lagTimes) <- names(dosing)
  dosingInfo__$TK0times        <- sapply(dosing, function(x) x["Tk0"])
  names(dosingInfo__$TK0times) <- names(dosing)
  if (length(which(is.na(dosingInfo__$TK0times[which(dosingInfo__$types=="ABSORPTION0")]))) > 0)
    stopIQR("At least one INPUT with ABSORPTION0 has no 'Tk0' parameter defined")
  lagTimeNames__ <- dosingInfo__$lagTimes[!is.na(dosingInfo__$lagTimes)]
  if (!all(lagTimeNames__ %in% names(model$parameters)))
    stopIQR("Lag time names need to be present in the model as parameters (use Tlag* for INPUT*)")
  TK0timesNames__ <- dosingInfo__$TK0times[!is.na(dosingInfo__$TK0times)]
  if (!all(unlist(TK0timesNames__) %in% names(model$parameters)))
    stopIQR("Tk0 (0-order-absorption) time names need to be present in the model as parameters")
  output__$dosingInfo          <- dosingInfo__
  if (length(setdiff(names(data),c("datafile", "covNames","catNames","regressorNames","FLAGdataAsDataFrame"))) > 0)
    stopIQR('Data input argument wrongly defined (needs to contain the element "datafile" and can contain the elements "covNames", "catNames", "regressorNames")')
  if (length(setdiff(c("datafile"),names(data))) > 0)
    stopIQR("Data input argument wrongly defined (needs to contain the element 'datafile')")
  if(!file.exists(data$datafile))
    stopIQR("Trouble loading the data file. Please check if data$datafile has been defined correctly")
  if (!is.null(data$regressorNames)) {
    modelparam__ <- names(model$parameters)
    if (length(setdiff(data$regressorNames,modelparam__)) > 0)
      stopIQR("At least one defined 'regressorName' in 'data' is not available in the model")
  }
  data$dataModeling <- IQRnlmeData(input=data$datafile,covNames=data$covNames,catNames=data$catNames,regressorNames=data$regressorNames,FLAGqsp=FLAGqsp)
  data$maxDATARECORDS    <- nrow(data$dataModeling)
  data$regNames <- attr(data$dataModeling,"regressorNames")
  data$headerIdent <- attr(data$dataModeling,"headerIdent")
  data$headerIdentVector <- attr(data$dataModeling,"headerIdentVector")
  data$covNames <- attr(data$dataModeling,"covNames")
  data$covariateMedianValues <- attr(data$dataModeling,"covariateMedianValues")
  if (!is.null(data$covNames)) {
    for (k__ in seq_along(modelSpec$COVcentering)) {
      ix__ <- aux_strmatch(searchString=names(modelSpec$COVcentering[k__]),inputVec=names(data$covariateMedianValues))
      data$covariateMedianValues[ix__] <- modelSpec$COVcentering[k__]
    }
  }
  data$catNames              <- attr(data$dataModeling,"catNames")
  data$catValues             <- attr(data$dataModeling,"catValues")
  dummy__ <- lapply(data$catValues, function (x__) {
    if (any(as.integer(x__) != x__))
      stopIQR("Not all categorical covariates have integer-only categories! This is not allowed.")
  })
  data$covariateCATreference <- attr(data$dataModeling,"covariateCATreference")
  if (!is.null(data$catNames)) {
    for (k__ in seq_along(modelSpec$COVcentering)) {
      ix__ <- aux_strmatch(searchString=names(modelSpec$COVcentering[k__]),inputVec=names(data$covariateCATreference))
      data$covariateCATreference[ix__] <- modelSpec$COVcentering[k__]
    }
  }
  output__$data <- data
  knownSpecs__ <- c("POPestimate", "POPvalues0", "IIVdistribution", "IIVestimate",
                    "IIVvalues0", "errorModel", "covarianceModel", "covariateModel",
                    "covariateModelValues", "COVestimate", "COVcentering",
                    "PriorVarPOP", "PriorVarCovariateModelValues", "PriorDFerrorModel", "PriorIIV", "PriorDFIIV",
                    "LOCmodel", "LOCvalues0", "LOCestimate", "LOCdistribution",
                    "IOVestimate","IOVvalues0"
  )
  unknownSpecs__ <- setdiff(names(modelSpec), knownSpecs__)
  if (length(unknownSpecs__) > 0)
    warningIQR("Model spec(s) ", paste(unknownSpecs__, collapse = ", "), " unknown. Will be ignored.")
  if (is.null(modelSpec$POPvalues0))
    stopIQR("modelSpec$POPvalues0 is a required input argument!\nThe function needs to know at least which parameters are in scope of the estimation.")
  modelparam__ <- names(model$parameters)
  if (length(setdiff(names(modelSpec$POPvalues0),modelparam__)) > 0)
    stopIQR("At least one defined in 'POPvalues0' that is not available in the model")
  if (is.null(modelSpec$covarianceModel)) {
    modelSpec$covarianceModel        <- "diagonal"
  } else {
    if (is.list(modelSpec$covarianceModel)) {
      stopIQR("modelSpec$covarianceModel needs to be defined as a vector, not as a list")
    }
  }
  estimated_parameter_names__ <- names(modelSpec$POPvalues0)
  ix_underscore_present <- which(grepl("_",estimated_parameter_names__))
  if (!FLAGqsp & length(ix_underscore_present) > 0) {
    stopIQR("The following parameters have underscores in the names.\nFor NLME modeling this is not allowed (there are 'raisons')\n",
            "       ",paste0(estimated_parameter_names__[ix_underscore_present],collapse = ", "))
  }
  if (length(intersect(estimated_parameter_names__,data$regressorNames)) > 0)
    stopIQR("Regressor parameters and parameters to be estimated intersect => not allowed")
  modelInfo__ <- basicmodelparsing(model,estimated_parameter_names__,data$regressorNames)
  output__$modelInfo <- modelInfo__
  modelSpec__ <- checkHandleDefaultNLMEmodelSpec(modelInfo__,modelSpec,data,FLAGqsp=FLAGqsp)
  output__$modelSpec <- modelSpec__
  attr(output__,"class") <- c("IQRnlmeEst", attr(output__,"class"))
  if (!FLAGqsp & any(output__$modelSpec$IIVestimate==0 & output__$modelSpec$POPestimate!=0)) {
    warningIQR("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n  IMPORTANT: When using SAEM on multiple cores IIVestimate=0 for POPestimate!=0\n             will lead to non-reproducible behavior of NONMEM - no way around!\n             Use instead IIVestimate=2 with a small IIVvalues0 value\n  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
  }
  return(output__)
}
basicmodelparsing <- function(model,estnames,regnames) {
  modelInfo__         <- list()
  modelInfo__$model   <- model
  modelInfo__$inputs  <- model$inputs
  modelInfo__$outputs <- model$outputs
  aaa__ <- sapply(seq_along(model$parameters), function(x) names(model$parameters)[x] %in% estnames)
  if (length(aaa__)==0) {
    par_indices_est__ <- list()
  } else {
    par_indices_est__ <- which(aaa__)
  }
  if (length(par_indices_est__)==0) {
    stopIQR("No parameters in model selected for estimation")
  }
  modelInfo__$param_est <- vector("list", length(par_indices_est__))
  for (k__ in seq_along(par_indices_est__)) {
    modelInfo__$param_est[[k__]]$name  <- names(model$parameters)[par_indices_est__[k__]]
    modelInfo__$param_est[[k__]]$notes <- model$parameters[[par_indices_est__[k__]]]$notes
    modelInfo__$param_est[[k__]]$value0 <- model$parameters[[par_indices_est__[k__]]]$value
    modelInfo__$param_est[[k__]]$parindex <- par_indices_est__[k__]
  }
  par_indices_reg__   <- which(sapply(1:length(model$parameters), function(x) names(model$parameters)[x] %in% regnames))
  modelInfo__$param_reg <- vector("list", length(par_indices_reg__))
  for (k__ in seq_along(par_indices_reg__)) {
    modelInfo__$param_reg[[k__]]$name  <- names(model$parameters)[par_indices_reg__[k__]]
    modelInfo__$param_reg[[k__]]$notes <- model$parameters[[par_indices_reg__[k__]]]$notes
    modelInfo__$param_reg[[k__]]$parindex <- par_indices_reg__[k__]
  }
  allfactors__ <- c()
  for (k__ in seq_along(modelInfo__$inputs))
    allfactors__ <- c(allfactors__, modelInfo__$inputs[[k__]]$factors)
  pn__    <- parametersInfo_IQRmodel(model)$paramnames
  pnest__ <- sapply(modelInfo__$param_est, function(x) x$name)
  pnreg__ <- sapply(modelInfo__$param_reg, function(x) x$name)
  pnnotest__ = setdiff(pn__,c(pnest__,pnreg__))
  for (k__ in seq_along(allfactors__)) {
    test__ <- allfactors__[k__]
    for (k2__ in seq_along(pnnotest__)) {
      index__ <- regexpr(text=test__,pattern=paste0('\\b',pnnotest__[k2__],'\\b'))
      if (index__ > 0) {
        x <- unlist(sapply(modelInfo__$param_pk, function(x) x$name))
        ix__ <- which(pnnotest__[k2__]==x)
        if (is.null(x) | length(ix__)==0) {
          param_pk__ <- list()
          parindex <- which(pnnotest__[k2__]==pn__)
          param_pk__$name <- names(model$parameters)[parindex]
          param_pk__$value <- model$parameters[[parindex]]$value
          param_pk__$parindex <- parindex
          param_pk__$notes <- model$parameters[[parindex]]$notes
          modelInfo__$param_pk[[length(modelInfo__$param_pk)+1]] <- param_pk__
        }
      }
    }
  }
  allother__ <- c(statesInfo_IQRmodel(model)$statenames,
                  variablesInfo_IQRmodel(model)$varnames,
                  reactionsInfo_IQRmodel(model)$reacnames)
  for (k__ in seq_along(allfactors__)) {
    test__ <- allfactors__[k__]
    for (k2__ in seq_along(allother__)) {
      index__ <- regexpr(text=test__,pattern=paste0('\\b',allother__[k2__],'\\b'))
      if (index__ > 0) {
        errorTxt__ <- sprintf("basicmodelparsing: The model component '%s' appears in an input pre-factor '%s'.\nPlease note that no states, variables, or reactions are allowed to\nappear in these pre-factors. Only parameters!",allother__[k2__],allfactors__[k__])
        stopIQR(errorTxt__)
      }
    }
  }
  return(modelInfo__)
}
#'@export
as_IQRnlmeProjectMulti <- function (input, FLAGrecursive=FALSE) {
  if (is_IQRnlmeProjectMulti(input)) {
    return(input)
  }
  output__ <- list()
  if ("character" %in% class(input)) {
    for (k__ in seq_along(input)) {
      if (!dir.exists(input[k__]))
        stopIQR("provided path does not exist.")
      if (is_IQRnlmeProject(input[k__])) {
        output__[[length(output__)+1]] <- as_IQRnlmeProject(input[k__])
      } else {
        dirs__ <- list.dirs(input[k__],recursive=FLAGrecursive)
        dirs__ <- dirs__[!grepl(".Internals",dirs__)]
        lapply(dirs__,function(x) {if (is_IQRnlmeProject(x)) {
          output__[[length(output__)+1]] <<- as_IQRnlmeProject(x) }
        })
      }
    }
  } else {
    tst <- sapply(input, function (x) is_IQRnlmeProject(x))
    if (all(tst)) {
      output__ <- input
    } else {
      stopIQR("argument 'input' of incorrect type")
    }
  }
  names(output__) <- unclass(output__)
  attr(output__,"class") <- "IQRnlmeProjectMulti"
  return(output__)
}
#'@export
is_IQRnlmeProjectMulti <- function (input) {
  methods::is(input,"IQRnlmeProjectMulti")
}
#'@export
print.IQRnlmeProjectMulti <- function(x, ...) {
  cat("IQRnlmeProjectMulti object\n")
  cat("\n")
  cat(sprintf("  The object contains N=%d IQRnlmeProjects\n",length(x)))
  if (length(x) > 0) {
    cat(sprintf("  %d out of these %d have been run (without issues) already",sum(sapply(x,function(xxx__) hasrun_IQRnlmeProject(xxx__))),length(x)))
  }
}
#'@export
summary.IQRnlmeProjectMulti <- function(object,
                                        ...,
                                        order=NULL,
                                        show=NULL,
                                        FLAGreport=NULL,
                                        pathname=NULL,
                                        SIGDIG=3,
                                        FLAGremovePath=FALSE,
                                        FLAGnamesMulti = FALSE
) {
  if (is.null(FLAGreport)) {
    FLAGreport <- TRUE
    if (is.null(pathname)) FLAGreport <- FALSE
  }
  output__ <- list()
  output__$SummaryComments <- summaryComments_IQRnlmeProjectMulti(
    object,
    order=order,
    FLAGreport=FLAGreport,
    filename={
      out <- NULL
      if (!is.null(pathname))       out <- paste0(pathname,"/01_model_overview.txt")
      out
    },
    FLAGremovePath=FLAGremovePath
  )
  output__$SummaryParameters <- summaryParameters_IQRnlmeProjectMulti(
    object,
    order=order,show = show,
    FLAGreport=FLAGreport,
    filename={
      out <- NULL
      if (!is.null(pathname))       out <- paste0(pathname,"/02_model_parameters.txt")
      out
    },
    SIGDIG=SIGDIG,
    FLAGremovePath=FLAGremovePath
  )
  output__$SummaryCorrelations <- summaryCorrelations_IQRnlmeProjectMulti(
    object,
    order=order, show = show,
    FLAGreport=FLAGreport,
    filename={
      out <- NULL
      if (!is.null(pathname))       out <- paste0(pathname,"/03_model_correlations.txt")
      out
    },
    SIGDIG=SIGDIG,
    FLAGremovePath=FLAGremovePath
  )
  output__$SummaryCovariates <- summaryCovariates_IQRnlmeProjectMulti(
    object,
    order=order, show = show,
    FLAGreport=FLAGreport,
    filename={
      out <- NULL
      if (!is.null(pathname))       out <- paste0(pathname,"/04_model_covariates.txt")
      out
    },
    SIGDIG=SIGDIG,
    FLAGremovePath=FLAGremovePath
  )
  if (is.null(pathname)) return(output__)
}
#'@export
hasrun_IQRnlmeProjectMulti <- function(object) {
  if (!is_IQRnlmeProjectMulti(object)) stopIQR("Input is not an IQRnlmeProjectMulti object.")
  out <- sapply(seq_along(object), function(i) hasrun_IQRnlmeProject(object[i]))
  out
}
#'@export
plot.IQRnlmeProjectMulti <- function(x, ..., filename=NULL, CORR_THRESHOLD=0.3) {
  if (!is_IQRnlmeProjectMulti(x))
    stopIQR("object not an IQRnlmeProjectMulti object")
  objectsRun__ <- list()
  dummy__ <- lapply(x,function (y) { if (hasrun_IQRnlmeProject(y)) objectsRun__[[length(objectsRun__)+1]] <<- y })
  objectsRun__ <- as_IQRnlmeProjectMulti(objectsRun__)
  RESULTS__ <- parseSelectedProjectFolderResults(objectsRun__)
  if (length(RESULTS__)==0) {
    cat("No model results present")
    return()
  }
  dataPlot__ <- do.call(rbind,lapply(1:length(RESULTS__), function (y__) {
    data.frame(INDEX=y__,
               OBJ=RESULTS__[[y__]]$OBJ,
               AIC=RESULTS__[[y__]]$AIC,
               BIC=RESULTS__[[y__]]$BIC)
  }))
  z1__ <- tidyr::gather(dataPlot__,NAME,VALUE,-INDEX)
  p__ <- IQRggplot(data=z1__, aes_string(x="INDEX",y="VALUE",color="NAME",shape="NAME")) +
    geom_point(size=2) +
    xlab(label="Model index (ordered by Objective Function Value)") +
    ylab(label=NULL) +
    scale_color_IQRtools() +
    theme(legend.position="bottom",
          legend.background=element_rect(linetype="solid",color="black"))
  pObjectiveFunction__ <- p__
  attr(pObjectiveFunction__,"plotData") <- z1__
  test__ <- suppressWarnings(check__ <- do.call(rbind,lapply(1:length(RESULTS__), function (y__) {
    out__ <- RESULTS__[[y__]]$parameternames
    out__
  })))
  if (nrow(unique(test__)) > 1) {
    cat("plot.IQRnlmeProjectMulti: Not the same parameters in all models - skipping additional plots")
    pCorrelationFixedEffects__ <- NULL
    pCorrelationRandomEffects__ <- NULL
  } else {
    dataPlot__ <- do.call(rbind,lapply(1:length(RESULTS__), function (y__) {
      c(RESULTS__[[y__]]$rawParameterInfo$fixedEffects$values,
        RESULTS__[[y__]]$OBJ)
    }))
    zz1__ <- as.data.frame(dataPlot__)
    names(zz1__) <- c(RESULTS__[[1]]$rawParameterInfo$fixedEffects$names,"OBJ")
    zz1__$INDEX <- 1:nrow(zz1__)
    y <- zz1__
    cory <- suppressWarnings(stats::cor(y[,1:(ncol(y)-1)]))
    z <- tidyr::gather(y,XNAME,XVALUE,-INDEX)
    zz <- dplyr::left_join(z,y,by="INDEX")
    zzz <- tidyr::gather(zz,YNAME,YVALUE,-INDEX,-XNAME,-XVALUE)
    zzz$CORR <- NA
    zzz$CORR_INFO <- NA
    for (row in seq_along(rownames(cory))) {
      for (col in seq_along(colnames(cory))) {
        corr <- signif(cory[row,col],3)
        corr_info <- paste0("corr:\n",corr)
        zzz$CORR[zzz$XNAME==rownames(cory)[row] & zzz$YNAME==colnames(cory)[col]] <- corr
        zzz$CORR_INFO[zzz$XNAME==rownames(cory)[row] & zzz$YNAME==colnames(cory)[col]] <- corr_info
      }
    }
    zzz$High.Correlation <- factor(abs(zzz$CORR)>CORR_THRESHOLD,levels=c("FALSE","TRUE"))
    zzz$XNAME <- factor(zzz$XNAME,names(zz1__))
    zzz$YNAME <- factor(zzz$YNAME,names(zz1__))
    zzz$X <- as.numeric(zzz$XNAME)
    zzz$Y <- as.numeric(zzz$YNAME)
    zzz$SHOW_CORR <- 0
    zzz$XYNAMES <- paste0(zzz$XNAME,"_",zzz$YNAME)
    zzzz <- do.call(rbind,lapply(split(zzz,zzz$XYNAMES), function(x) {x[1,"SHOW_CORR"] <- 1; x}))
    zzzz <- do.call(rbind,lapply(split(zzzz,zzzz$XYNAMES),function(x) {
      x$PLOT <- stats::sd(x$XVALUE)!=0 & stats::sd(x$YVALUE)!=0
      x
    }))
    zzzz <- zzzz[zzzz$PLOT,]
    zzzzz__ <- do.call(rbind,lapply(split(zzzz,zzzz$XYNAMES), function(x) {
      x$meanY <- (max(x$XVALUE,na.rm=TRUE) + min(x$XVALUE,na.rm=TRUE)) / 2
      x$meanX <- (max(x$YVALUE,na.rm=TRUE) + min(x$YVALUE,na.rm=TRUE)) / 2
      x
    }))
    p__ <- IQRggplot(zzzzz__,aes_string(x="YVALUE",y="XVALUE",color="High.Correlation")) +
      ggtitle("Correlation of Fixed Effect Parameters") +
      geom_point(data=subset(zzzzz__,X>Y),alpha=0.2) +
      scale_color_manual(values=c("FALSE"="black","TRUE"="#C5000B")) +
      facet_grid(XNAME~YNAME,scales="free") +
      stat_smooth(data=subset(zzzzz__,X>Y),se=FALSE,method="lm") +
      geom_text(data=subset(zzzzz__,SHOW_CORR==1 & X<Y),aes_string(label="CORR_INFO",x="meanX",y="meanY",color="High.Correlation"),size=3.5) +
      theme(legend.position="bottom",
            legend.background=element_rect(linetype="solid",color="black")) +
      theme(aspect.ratio=1) +
      xlab(label=NULL) + ylab(label=NULL) +
      theme(axis.text.x = element_text(angle = 90, hjust = 1))
    pCorrelationFixedEffects__ <- p__
    attr(pCorrelationFixedEffects__,"plotData") <- zzzzz__
    dataPlot__ <- do.call(rbind,lapply(1:length(RESULTS__), function (y__) {
      c(RESULTS__[[y__]]$rawParameterInfo$randomEffect$values,
        RESULTS__[[y__]]$OBJ)
    }))
    zz1__ <- as.data.frame(dataPlot__)
    names(zz1__) <- c(RESULTS__[[1]]$rawParameterInfo$fixedEffects$names, "OBJ") 
    zz1__$INDEX <- 1:nrow(zz1__)
    y <- zz1__
    cory <- suppressWarnings(stats::cor(y[,1:(ncol(y)-1)]))
    z <- tidyr::gather(y,XNAME,XVALUE,-INDEX)
    zz <- dplyr::left_join(z,y,by="INDEX")
    zzz <- tidyr::gather(zz,YNAME,YVALUE,-INDEX,-XNAME,-XVALUE)
    zzz$CORR <- NA
    zzz$CORR_INFO <- NA
    for (row in seq_along(rownames(cory))) {
      for (col in seq_along(colnames(cory))) {
        corr <- signif(cory[row,col],3)
        corr_info <- paste0("corr:\n",corr)
        zzz$CORR[zzz$XNAME==rownames(cory)[row] & zzz$YNAME==colnames(cory)[col]] <- corr
        zzz$CORR_INFO[zzz$XNAME==rownames(cory)[row] & zzz$YNAME==colnames(cory)[col]] <- corr_info
      }
    }
    zzz$High.Correlation <- factor(abs(zzz$CORR)>CORR_THRESHOLD,levels=c("FALSE","TRUE"))
    zzz$XNAME <- factor(zzz$XNAME,names(zz1__))
    zzz$YNAME <- factor(zzz$YNAME,names(zz1__))
    zzz$X <- as.numeric(zzz$XNAME)
    zzz$Y <- as.numeric(zzz$YNAME)
    zzz$SHOW_CORR <- 0
    zzz$XYNAMES <- paste0(zzz$XNAME,"_",zzz$YNAME)
    zzzz <- do.call(rbind,lapply(split(zzz,zzz$XYNAMES), function(x) {x[1,"SHOW_CORR"] <- 1; x}))
    zzzz <- do.call(rbind,lapply(split(zzzz,zzzz$XYNAMES),function(x) {
      x$PLOT <- stats::sd(x$XVALUE)!=0 & stats::sd(x$YVALUE)!=0
      x
    }))
    zzzz <- zzzz[zzzz$PLOT,]
    zzzzz__ <- do.call(rbind,lapply(split(zzzz,zzzz$XYNAMES), function(x) {
      x$meanY <- (max(x$XVALUE,na.rm=TRUE) + min(x$XVALUE,na.rm=TRUE)) / 2
      x$meanX <- (max(x$YVALUE,na.rm=TRUE) + min(x$YVALUE,na.rm=TRUE)) / 2
      x
    }))
    p__ <- IQRggplot(zzzzz__,aes_string(x="YVALUE",y="XVALUE",color="High.Correlation")) +
      ggtitle("Correlation of Random Effect Parameters") +
      geom_point(data=subset(zzzzz__,X>Y),alpha=0.2) +
      scale_color_manual(values=c("FALSE"="black","TRUE"="#C5000B")) +
      facet_grid(XNAME~YNAME,scales="free") +
      stat_smooth(data=subset(zzzzz__,X>Y),se=FALSE,method="lm") +
      geom_text(data=subset(zzzzz__,SHOW_CORR==1 & X<Y),aes_string(label="CORR_INFO",x="meanX",y="meanY",color="High.Correlation"),size=3.5) +
      theme(legend.position="bottom",
            legend.background=element_rect(linetype="solid",color="black")) +
      theme(aspect.ratio=1) +
      xlab(label=NULL) + ylab(label=NULL) +
      theme(axis.text.x = element_text(angle = 90, hjust = 1))
    pCorrelationRandomEffects__ <- p__
    attr(pCorrelationRandomEffects__,"plotData") <- zzzzz__
  }
  output__ <- list(
    ObjectiveFunction = pObjectiveFunction__,
    CorrelationFixedEffects = pCorrelationFixedEffects__,
    CorrelationRandomEffects = pCorrelationRandomEffects__
  )
  if (!is.null(filename)) {
    IQRoutputPDF(gr=output__,filename)
    return(invisible(NULL))
  }
  return(output__)
}
#'@export
run_IQRnlmeProjectMulti <- function (projectPath,
                                     pathname=NULL,
                                     ncores=1,
                                     Nparallel=1,
                                     FLAGrerun=FALSE,
                                     FLAGclean=TRUE,
                                     FLAGgof=TRUE,
                                     FLAGgofStratify=FALSE,
                                     FLAGremoveRESULTSORIG=FALSE) {
  if (!is_IQRnlmeProjectMulti(projectPath))
    stopIQR("provided projectPath is not an IQRnlmeProjectMulti object")
  if (any(sapply(projectPath, function (x) is_NLMIXR_IQRnlmeProject(x))) & Nparallel>1)
    stopIQR("If NLMIXR projects present then Nparallel is only allowed to be on 1 - seems there are parallelization issues ...")
  if (Nparallel==1) {
    cat(sprintf("run_IQRnlmeProjectMulti: Running %d models\n",length(projectPath)))
  } else {
    cat(sprintf("Running %d models, %d in parallel at the same time (output suppressed)\n",length(projectPath),Nparallel))
  }
  if (!FLAGrerun) cat("(Projects are only run if not run yet)\n")
  PASS_COMPLIANCEINFO_LOCAL_ENVIR__ <- globalenv()$COMPLIANCE_MODE_SCRIPT_NAME
  if (Nparallel > 1) {
    cluster__ <- parallel::makeCluster(Nparallel)
    doParallel::registerDoParallel(cluster__)
    parallel::clusterCall(cl=cluster__,function (x__) .libPaths(x__), .libPaths())
    parallel::clusterExport(cluster__,envir=environment(),varlist=ls())
    "%dopar%" <- foreach::"%dopar%"
  } else {
    DLLloaded__ <- FALSE
    "%dopar%" <- foreach::"%do%"
  }
  if (is_installed_NLMIXR()) {
    .packages = c("nlmixr","IQRtools")
  } else {
    .packages = c("IQRtools")
  }
  oldpath__ <- getwd()
  foreach::foreach (k__=1:length(projectPath), .packages=.packages, .inorder=TRUE) %dopar% {
    e__ <- globalenv()
    e__$COMPLIANCE_MODE_SCRIPT_NAME <- PASS_COMPLIANCEINFO_LOCAL_ENVIR__
    setwd(oldpath__)
    out <- try(run_IQRnlmeProject(projectPath=projectPath[[k__]],
                                  ncores=ncores,
                                  FLAGrerun=FLAGrerun,
                                  FLAGclean=FLAGclean,
                                  FLAGgof=FLAGgof,
                                  FLAGgofStratify=FLAGgofStratify,
                                  FLAGremoveRESULTSORIG=FLAGremoveRESULTSORIG), silent = FALSE)
    if (inherits(out, "try-error")) {
      message("An error was encountered in run_IQRnlmeProjec(). Continuing anyway.")
      return()
    }
    out
  }
  if (Nparallel > 1) {
    parallel::stopCluster(cluster__)
    doParallel::stopImplicitCluster()
  }
  loadSetupOptions_IQRtools()
  if (!is.null(pathname)) {
    summary.IQRnlmeProjectMulti(projectPath,pathname=pathname,FLAGreport=TRUE,order=.NLME_ORDER_CRITERION)
  }
  return(as_IQRnlmeProjectMulti(projectPath))
}
#'@export
summaryComments_IQRnlmeProjectMulti <- function(object,order=NULL,FLAGreport=FALSE,FLAGremovePath=FALSE,filename=NULL) {
  RESULTS <- getResults_IQRnlmeProjectMulti(object,order=order)
  MODEL__ <- names(RESULTS)
  if (FLAGremovePath) {
    MODEL__ <- paste0(aux_fileparts(MODEL__)$filename,aux_fileparts(MODEL__)$fileext)
  }
  OBJ__ <- round(sapply(RESULTS,function(x) x$OBJ))
  AIC <- round(sapply(RESULTS,function(x) x$AIC))
  BIC <- round(sapply(RESULTS,function(x) x$BIC))
  COMMENT__ <- sapply(RESULTS,function(x) paste0(x$COMMENT,collapse=", "))
  table__ <- data.frame(MODEL=MODEL__,OBJ=OBJ__,AIC=AIC,BIC=BIC,COMMENT=COMMENT__,stringsAsFactors=FALSE)
  footer__ <- paste0("Objective function values (OBJ, AIC, BIC) are rounded.")
  if (!is.null(order)) {
    footer__ <- paste0(footer__,"<br>Models ordered by ",order,".")
  }
  title__ <- "Model overview table with model comments"
  if (!is.null(filename)) {
    filename <- paste0(aux_strrep(filename,".txt",""),".txt")
    IQRoutputTable(xtable=table__,xfooter=footer__,xtitle=title__,report=FLAGreport,filename=filename)
    return()
  }
  output__ <- IQRoutputTable(xtable=table__,xfooter=footer__,xtitle=title__,report=FLAGreport)
  output__
}
#'@export
summaryParameters_IQRnlmeProjectMulti <- function(object,order=NULL,show=NULL,FLAGreport=FALSE,FLAGremovePath=FALSE,filename=NULL,SIGDIG=3) {
  if (is.null(show)) {
    if (is.null(order)) {
      show <- "OBJ"
    } else {
      show <- order
    }
  }
  if (!show %in% c("OBJ","AIC","BIC")) {
    stopIQR("Argument 'show' needs to be 'OBJ', 'AIC', or 'BIC'")
  }
  RESULTS <- getResults_IQRnlmeProjectMulti(object,order=order)
  MODEL__ <- names(RESULTS)
  if (FLAGremovePath) {
    MODEL__ <- paste0(aux_fileparts(MODEL__)$filename,aux_fileparts(MODEL__)$fileext)
  }
  OBJ__ <- round(sapply(RESULTS,function(x) x$OBJ))
  AIC <- round(sapply(RESULTS,function(x) x$AIC))
  BIC <- round(sapply(RESULTS,function(x) x$BIC))
  if (show=="OBJ") {
    parametersTable__ <- data.frame(MODEL=MODEL__,
                                    OBJ=OBJ__, stringsAsFactors=FALSE)
  } else {
    if (show=="AIC") {
      parametersTable__ <- data.frame(MODEL=MODEL__,
                                      AIC=AIC, stringsAsFactors=FALSE)
    } else {
      if (show=="BIC") {
        parametersTable__ <- data.frame(MODEL=MODEL__,
                                        BIC=BIC, stringsAsFactors=FALSE)
      }
    }
  }
  ALLfixEffectNames__ <- unique(as.vector(unlist(sapply(RESULTS,function(x) x$rawParameterInfo$fixedEffects$names))))
  df__ <- list()
  for (k__ in seq_along(ALLfixEffectNames__)) {
    df__[[length(df__)+1]] <- sapply(RESULTS, function(x) {
      if (ALLfixEffectNames__[k__] %in% x$rawParameterInfo$fixedEffects$names) {
        ix__ <- which(ALLfixEffectNames__[k__]==x$rawParameterInfo$fixedEffects$names)
        out__ <- signif(x$rawParameterInfo$fixedEffects$values[ix__],SIGDIG)
        if (x$rawParameterInfo$fixedEffects$estimated[ix__]==0) {
          out__ <- paste0(out__," (FIX)")
        } else {
          out__ <- paste0(out__," (",signif(x$rawParameterInfo$fixedEffects$rse[ix__],2),"%)")
        }
      } else {
        out__ <- "-"
      }
      out__
    })
  }
  df__ <- data.frame(df__,stringsAsFactors=FALSE)
  names(df__) <- ALLfixEffectNames__
  df_values_fe <- df__
  ALLerrorNames     <- unique(as.vector(unlist(sapply(RESULTS,function(x) x$rawParameterInfo$errorParameter$names))))
  if (!is.null(ALLerrorNames)) {
    df__ <- list()
    for (k__ in seq_along(ALLerrorNames)) {
      df__[[length(df__)+1]] <- sapply(RESULTS, function(x) {
        if (ALLerrorNames[k__] %in% x$rawParameterInfo$errorParameter$names) {
          out__ <- signif(x$rawParameterInfo$errorParameter$values[x$rawParameterInfo$errorParameter$names==ALLerrorNames[k__]],SIGDIG)
          out__ <- paste0(out__," (",signif(x$rawParameterInfo$errorParameter$rse[x$rawParameterInfo$errorParameter$names==ALLerrorNames[k__]],2),"%)")
        } else {
          out__ <- "-"
        }
        out__
      })
    }
    df__ <- data.frame(df__,stringsAsFactors=FALSE)
    names(df__) <- ALLerrorNames
    df_values_er <- df__
  } else {
    df_values_er <- NULL
  }
  ALLfixRandomNames__ <- unique(as.vector(unlist(sapply(RESULTS,function(x) x$rawParameterInfo$randomEffects$names))))
  df__ <- list()
  for (k__ in seq_along(ALLfixRandomNames__)) {
    df__[[length(df__)+1]] <- sapply(RESULTS, function(x) {
      if (ALLfixRandomNames__[k__] %in% x$rawParameterInfo$randomEffects$names) {
        ix__ <- which(ALLfixRandomNames__[k__]==x$rawParameterInfo$randomEffects$names)
        out__ <- signif(x$rawParameterInfo$randomEffects$values[ix__],SIGDIG)
        if (x$rawParameterInfo$randomEffects$estimated[ix__]!=1) {
          out__ <- paste0(out__," (FIX)")
        } else {
          out__ <- paste0(out__," (",signif(x$rawParameterInfo$randomEffects$rse[ix__],2),"%)")
        }
      } else {
        out__ <- "-"
      }
      out__
    })
  }
  df__ <- data.frame(df__,stringsAsFactors=FALSE)
  names(df__) <- ALLfixRandomNames__
  df_values_re <- df__
  if (!is.null(df_values_er)) {
    FEtable__ <- cbind(parametersTable__,df_values_fe,df_values_er)  
  } else {
    FEtable__ <- cbind(parametersTable__,df_values_fe)  
  }
  REtable__ <- cbind(parametersTable__,df_values_re)
  if (!is.null(df_values_er)) {
    N_error_cols <- ncol(df_values_er)
    REtable__ <- cbind(REtable__,matrix(" ",ncol=N_error_cols,nrow=nrow(df_values_er)))
  } else {
    N_error_cols <- 0
  }
  names(REtable__) <- names(FEtable__)
  if (!is.null(df_values_er)) {
    headerFEER <- c("**Fixed effects / Errors (RSE%)**",rep(" ",ncol(FEtable__)-1))
  } else {
    headerFEER <- c("**Fixed effects (RSE%)**",rep(" ",ncol(FEtable__)-1))
  }
  table__ <- rbind(
    headerFEER,
    FEtable__,
    rep(" ",ncol(FEtable__)),
    c("**Random effects (RSE%)**",paste0("**",names(FEtable__)[2],"**"),paste0("**omega(",names(FEtable__)[seq(3,ncol(FEtable__)-N_error_cols)],")**"),rep(" ",N_error_cols)),
    REtable__)
  footer__ <- paste0("Number of significant digits: ",SIGDIG,".<br>Objective function values (OBJ, AIC, BIC) are rounded.<br>Relative standard errors with 2 significant digits.")
  if (!is.null(order)) {
    footer__ <- paste0(footer__,"<br>Models ordered by ",order,".")
  }
  if (N_error_cols>0) {
    title__ <- "Parameter estimates (fixed effects, error model, random effects) and their relative standard errors"
  } else {
    title__ <- "Parameter estimates (fixed effects, random effects) and their relative standard errors"
  }
  if (!is.null(filename)) {
    filename <- paste0(aux_strrep(filename,".txt",""),".txt")
    IQRoutputTable(xtable=table__,xfooter=footer__,xtitle=title__,report=FLAGreport,filename=filename)
    return()
  }
  output__ <- IQRoutputTable(xtable=table__,xfooter=footer__,xtitle=title__,report=FLAGreport)
  output__
}
#'@export
summaryCorrelations_IQRnlmeProjectMulti <- function(object,order=NULL,show=NULL,FLAGreport=FALSE,FLAGremovePath=FALSE,filename=NULL,SIGDIG=3) {
  if (is.null(show)) {
    if (is.null(order)) {
      show <- "OBJ"
    } else {
      show <- order
    }
  }
  if (!show %in% c("OBJ","AIC","BIC")) {
    stopIQR("Argument 'show' needs to be 'OBJ', 'AIC', or 'BIC'")
  }
  RESULTS <- getResults_IQRnlmeProjectMulti(object,order=order)
  MODEL__ <- names(RESULTS)
  if (FLAGremovePath) {
    MODEL__ <- paste0(aux_fileparts(MODEL__)$filename,aux_fileparts(MODEL__)$fileext)
  }
  ALLfixRandomNames__ <- unique(as.vector(unlist(sapply(RESULTS,function(x) x$rawParameterInfo$fixedEffects$names))))
  table__ <- do.call(rbind,lapply(seq_along(RESULTS), function (k__) {
    x <- RESULTS[[k__]]
    MODELk__ <- MODEL__[[k__]]
    if (show=="OBJ") {
      MODELk__ <- c(MODELk__,paste0("OBJ: ",round(x$OBJ)),rep(" ",length(ALLfixRandomNames__)-2))
    } else {
      if (show=="AIC") {
        MODELk__ <- c(MODELk__,paste0("AIC: ",round(x$AIC)),rep(" ",length(ALLfixRandomNames__)-2))
      } else {
        if (show=="BIC") {
          MODELk__ <- c(MODELk__,paste0("BIC: ",round(x$BIC)),rep(" ",length(ALLfixRandomNames__)-2))
        }
      }
    }
    df__ <- data.frame(MODEL=MODELk__,
                       PAR=ALLfixRandomNames__,stringsAsFactors=FALSE)
    df2__ <- data.frame(matrix("0",ncol=length(ALLfixRandomNames__),nrow=length(ALLfixRandomNames__)),stringsAsFactors=FALSE)
    names(df2__) <- ALLfixRandomNames__
    cM__ <- x$correlationmatrixRandomEffects
    cMnames__ <- x$rawParameterInfo$fixedEffects$names
    for (col__ in seq_along(cMnames__)) {
      for (row__ in seq_along(cMnames__)) {
        ixcol__ <- which(ALLfixRandomNames__==cMnames__[col__])
        ixrow__ <- which(ALLfixRandomNames__==cMnames__[row__])
        if (is.nan(cM__[row__,col__])) {
          df2__[ixrow__,ixcol__] <- "0"
        } else {
          df2__[ixrow__,ixcol__] <- signif(cM__[row__,col__],SIGDIG)
        }
      }
    }
    diag(df2__) <- 1
    dfall__ <- cbind(df__,df2__)
    if (k__ > 1) {
      dfall__ <- rbind(rep(" ",ncol(dfall__)),
                       paste0("**",names(dfall__),"**"),
                       dfall__)
    }
    dfall__
  }))
  footer__ <- paste0("Number of significant digits: ",SIGDIG,".<br>Objective function values (OBJ, AIC, BIC) are rounded.")
  if (!is.null(order)) {
    footer__ <- paste0(footer__,"<br>Models ordered by ",order,".")
  }
  if (!is.null(filename)) {
    filename <- paste0(aux_strrep(filename,".txt",""),".txt")
    IQRoutputTable(xtable=table__,xfooter=footer__,xtitle="Estimated correlation coefficients",report=FLAGreport,filename=filename)
    return()
  }
  output__ <- IQRoutputTable(xtable=table__,xfooter=footer__,xtitle="Estimated correlation coefficients",report=FLAGreport)
  output__
}
#'@export
summaryCovariates_IQRnlmeProjectMulti <- function(object,order=NULL,show=NULL,FLAGreport=FALSE,FLAGremovePath=FALSE,filename=NULL,SIGDIG=3) {
  if (is.null(show)) {
    if (is.null(order)) {
      show <- "OBJ"
    } else {
      show <- order
    }
  }
  if (!show %in% c("OBJ","AIC","BIC")) {
    stopIQR("Argument 'show' needs to be 'OBJ', 'AIC', or 'BIC'")
  }
  RESULTS <- getResults_IQRnlmeProjectMulti(object,order=order)
  MODEL__ <- names(RESULTS)
  if (FLAGremovePath) {
    MODEL__ <- paste0(aux_fileparts(MODEL__)$filename,aux_fileparts(MODEL__)$fileext)
  }
  table__ <- do.call(rbind,lapply(seq_along(RESULTS), function (k__) {
    x <- RESULTS[[k__]]
    covNames__  <- x$rawParameterInfo$covariate$names
    if (length(covNames__)>0) {
      covValues__ <- signif(x$rawParameterInfo$covariate$values,SIGDIG)
      covStdErr__ <- x$rawParameterInfo$covariate$stderr
      covEst__    <- x$rawParameterInfo$covariate$estimated
      if (length(covNames__)==1) covNames__ <- c(covNames__,"")
    } else {
      covNames__ <- c("No covariates in the model","")
      covValues__ <- c("","")
      covStdErr__ <- c("","")
      covEst__ <-  c("","")
    }
    MODELk__ <- MODEL__[k__]
    if (show=="OBJ") {
      MODELk__ <- c(MODELk__,paste0("OBJ: ",round(x$OBJ)),rep("",max(length(covNames__)-2,0)))
    } else {
      if (show=="AIC") {
        MODELk__ <- c(MODELk__,paste0("AIC: ",round(x$AIC)),rep("",max(length(covNames__)-2,0)))
      } else {
        if (show=="BIC") {
          MODELk__ <- c(MODELk__,paste0("BIC: ",round(x$BIC)),rep("",max(length(covNames__)-2,0)))
        }
      }
    }
    VALUE__ <- covValues__
    if (length(x$rawParameterInfo$covariate$names) > 0) {
      VALUE__[covEst__==0] <- paste0(VALUE__[covEst__==0], " (FIX)")
      LOW.95.CI__ <- signif(covValues__ - 1.96*covStdErr__,SIGDIG)
      HIGH.95.CI__ <- signif(covValues__ + 1.96*covStdErr__,SIGDIG)
      LOW.95.CI__[covEst__==0] <- "-"
      HIGH.95.CI__[covEst__==0] <- "-"
      STAT.SIGNIF.05__ <- rep("-",length(VALUE__))
      STAT.SIGNIF.05__[which((suppressWarnings(as.numeric(LOW.95.CI__)*as.numeric(HIGH.95.CI__))>0) == TRUE)] <- "X"
      if (length(x$rawParameterInfo$covariate$names)==1) {
        VALUE__ <- c(VALUE__,"")
        LOW.95.CI__ <- c(LOW.95.CI__,"")
        HIGH.95.CI__ <- c(HIGH.95.CI__,"")
        STAT.SIGNIF.05__ <- c(STAT.SIGNIF.05__,"")
      }
    } else {
      LOW.95.CI__ <-  c("","")
      HIGH.95.CI__ <-  c("","")
      STAT.SIGNIF.05__ <-  c("","")
    }
    df__ <- data.frame(MODEL=MODELk__,
                       NAME=covNames__,
                       VALUE=VALUE__,
                       LOW.95.CI=LOW.95.CI__,
                       HIGH.95.CI=HIGH.95.CI__,
                       STAT.SIGNIF.05=STAT.SIGNIF.05__)
    if (k__ > 1) {
      df__ <- rbind(data.frame(MODEL=c(" ","**MODEL**"),
                               NAME=c(" ","**NAME**"),
                               VALUE=c(" ","**VALUE**"),
                               LOW.95.CI=c(" ","**LOW.95.CI**"),
                               HIGH.95.CI=c(" ","**HIGH.95.CI**"),
                               STAT.SIGNIF.05=c(" ","**STAT.SIGNIF.05**")),
                    df__)
    }
    df__
  }))
  footer__ <- paste0("Number of significant digits: ",SIGDIG,".<br>Objective function values (OBJ, AIC, BIC) are rounded.")
  if (!is.null(order)) {
    footer__ <- paste0(footer__,"<br>Models ordered by ",order,".")
  }
  if (!is.null(filename)) {
    filename <- paste0(aux_strrep(filename,".txt",""),".txt")
    IQRoutputTable(xtable=table__,xfooter=footer__,xtitle="Estimated covariate coefficients",report=FLAGreport,filename=filename)
    return(invisible(NULL))
  }
  output__ <- IQRoutputTable(xtable=table__,xfooter=footer__,xtitle="Estimated covariate coefficients",report=FLAGreport)
  output__
}
#'@export
getResults_IQRnlmeProjectMulti <- function (object,order=NULL) {
  if (!is_IQRnlmeProjectMulti(object))
    stopIQR("object not an IQRnlmeProjectMulti object")
  if (length(object) == 0) return(NULL)
  ixRun__ <- sapply(seq_along(object),function (k) hasrun_IQRnlmeProject(object[[k]]))
  objectsRun__ <- object[ixRun__]
  class(objectsRun__) <- "IQRnlmeProjectMulti"
  RESULTS__ <- parseSelectedProjectFolderResults(objectsRun__)
  if (is.null(order)) return(RESULTS__)
  ix_sorted__ <- sort.int(sapply(RESULTS__,function(x) x[[order]]),na.last=TRUE,index.return=TRUE)$ix
  RESULTS__ <- RESULTS__[ix_sorted__]
  return(RESULTS__)
}
#'@export
compareModels_IQRnlmeProjectMulti <- function(
  object,
  type = "result",
  selection = c("fixed", "random", "covariate", "correlation", "error", "metric"),
  order = NULL,
  SIGDIG = 3,
  FLAGreport = TRUE,
  filename = NULL,
  title = NULL,
  footer = NULL) {
  if (length(object) <= 1) {
    message("Comparison only makes sense for more than 1 model => No comparison done.")
    return(invisible(NULL))
  }
  if (is.null(names(object))){
    modelNames__ <- as.character(object)
    if (length(modelNames__) != length(unique(modelNames__)))
      stopIQR("Models are not unique")
  } else {
    modelNames__ <- names(object)
    if (length(modelNames__) != length(unique(modelNames__)))
      stopIQR("Provided list names for the models need to be unique!")
  }
  if (!is_IQRnlmeProjectMulti(object)) object <- as_IQRnlmeProjectMulti(object)
  type__ <- match.arg(type, c("specification", "result"), several.ok = FALSE)
  selection__ <- match.arg(selection, c("fixedEffects", "randomEffects", "covariate", "correlation", "errorParameter", "metrics"),several.ok = TRUE)
  allRes__ <- all(hasrun_IQRnlmeProjectMulti(object))
  if (!all(allRes__) & type__ == "result") {
    stopIQR("Not all models have been run and have results. Consider showing specification only.")
  }
  if (!all(allRes__) & type__ == "specification" & "metrics" %in% selection__) {
    warningIQR("Not all models have been run and have results. Model metrics cannot be shown")
    selection__ <- setdiff(selection__, "metrics")
  }
  joinModelResults__ <- function(xx__, what) {
    suppressMessages(out__ <- Reduce("full_join", lapply(seq_along(xx__), function(i) {
      if (length(xx__[[i]]$rawParameterInfo[[what]]$values) == 0) {
        d__ <- data.frame(Parameter = "dummy", Value = NA, stringsAsFactors = FALSE)
      } else {
        estimate <- xx__[[i]]$rawParameterInfo[[what]]$values
        estimated <- xx__[[i]]$rawParameterInfo[[what]]$estimated
        rse <- xx__[[i]]$rawParameterInfo[[what]]$rse
        value <- paste0(signif(estimate, digits = SIGDIG), " (", ifelse(estimated == 1, paste0(signif(rse, 2), "%"), "FIX"), ")" )
        if (what == "randomEffects") value[value == "0 (FIX)"] <- NA
        parameter <- xx__[[i]]$rawParameterInfo[[what]]$names
        d__ <- data.frame(
          Parameter = parameter,
          Value     = value,
          stringsAsFactors = FALSE
        )
      }
      names(d__) <- c("Parameter", modelNames__[i])
      return(d__)
    })))
    parNotUsed <- apply(is.na(out__[,-1]), 1, all)
    out__ <- out__[!parNotUsed,]
    out__[is.na(out__)] <- "-"
    out__
  }
  joinModelSpecification__ <- function(xx__, what) {
    suppressMessages(
      out__ <-   Reduce("full_join", lapply(seq_along(xx__), function(i) {
        modelSpec <- xx__[[i]][["modelSpec"]]
        if (what == "fixedEffects") {
          NAMES <- names(modelSpec$POPvalues0)
          d__ <- with(modelSpec, {
            d__ <- data.frame(
              NAMES,
              "*",
              stringsAsFactors = FALSE
            )
            d__[[2]][POPestimate == 0] <- paste0(POPvalues0[POPestimate == 0], " (FIX)")
            d__
          })
        }
        if (what == "randomEffects") {
          NAMES <- names(modelSpec$POPvalues0)
          d__ <- with(modelSpec, {
            d__ <- data.frame(
              paste0("omega(", NAMES, ")"),
              NA,   
              stringsAsFactors = FALSE
            )
            d__[[2]][IIVestimate == 1] <- "*"
            d__[[2]][IIVestimate == 2] <- paste0(IIVvalues0[IIVestimate == 2], " (FIX)")
            d__
          })
        }
        if (what == "covariate") {
          if ("covariateModel" %in% names(modelSpec)) {
            NAMES <- unlist(lapply(names(modelSpec$covariateModel), function(xx) {
              paste0("beta_", xx, "(",modelSpec$covariateModel[[xx]],")")
            }))
            d__ <- data.frame(NAMES, "*", stringsAsFactors = FALSE)
            CovEst <- plyr::adply(names(modelSpec$COVestimate), 1, function(xx) {
              data.frame(
                paste0("beta_", xx, "(",names(modelSpec$COVestimate[[xx]]),")"),
                modelSpec$COVestimate[[xx]]
              )
            }, .id = NULL)
            CovGuess <- plyr::adply(names(modelSpec$covariateModelValues), 1, function(xx) {
              data.frame(
                paste0("beta_", xx, "(",names(modelSpec$covariateModelValues[[xx]]),")"),
                modelSpec$covariateModelValues[[xx]]
              )
            }, .id = NULL)
            for (ii in which(CovEst[[2]] == 0)) d__[[2]][ii] <- paste0(CovGuess[[2]][ii], " (FIX)")
          } else {d__ <- data.frame(Parameter = "dummy", Value = NA, stringsAsFactors = FALSE)}
        }
        if (what == "correlation") {
          if (modelSpec$covarianceModel == "diagonal") {
            d__ <- data.frame(Parameter = "dummy", Value = NA, stringsAsFactors = FALSE)
          } else {
            d__ <- data.frame(
              paste0("corr(", modelSpec$covarianceModel,")"),
              "*", stringsAsFactors = FALSE
            )
          }
        }
        if (what == "errorParameter") {
          d__ <- data.frame(
            Parameter = names(modelSpec$errorModel),
            Value = sapply(modelSpec$errorModel, function(y__) y__[[1]]),
            stringsAsFactors = FALSE
          )
        }
        names(d__) <- c("Parameter", modelNames__[i])
        return(d__)
      }))
    )
    parNotUsed <- apply(is.na(out__[,-1]), 1, all)
    out__ <- out__[!parNotUsed,]
    out__[is.na(out__)] <- "-"
    out__
  }
  content__ <- switch(
    type__,
    specification = lapply(object, function(x) {
      out__ <- readRDS(file.path(x, "project.est"))
      out__
    }),
    result  = getResults_IQRnlmeProjectMulti(object)
  )
  joinModel__ <- switch(type__,
                        specification = joinModelSpecification__,
                        result        = joinModelResults__)
  tEmpty__ <- stats::setNames(as.data.frame(as.list(rep("", 1+length(modelNames__))), stringsAsFactors = FALSE), c("Parameter",modelNames__))
  table__ <- data.frame()
  if ("fixedEffects" %in% selection__) {tFixed__ <- joinModel__(content__, "fixedEffects");  if (nrow(tFixed__)>0) table__ <- bind_rows(table__,tFixed__,tEmpty__)}
  if ("randomEffects" %in% selection__) {tRandom__ <- joinModel__(content__, "randomEffects");  if (nrow(tRandom__)>0) table__ <- bind_rows(table__,tRandom__,tEmpty__)}
  if ("covariate" %in% selection__) {tCovariate__ <- joinModel__(content__, "covariate");  if (nrow(tCovariate__)>0) table__ <- bind_rows(table__,tCovariate__,tEmpty__)}
  if ("correlation" %in% selection__) {tCorrelation__ <- joinModel__(content__, "correlation"); if (nrow(tCorrelation__)>0) table__ <- bind_rows(table__,tCorrelation__,tEmpty__)}
  if ("errorParameter" %in% selection__) {tResidualError__ <- joinModel__(content__, "errorParameter");  if (nrow(tResidualError__)>0) table__ <- bind_rows(table__,tResidualError__,tEmpty__)}
  if ("metrics" %in% selection__) {
    res__ <- switch(type__,
                    specification = getResults_IQRnlmeProjectMulti(object),
                    result = content__)
    suppressMessages(
      tObj__ <- Reduce("left_join", lapply(seq_along(res__), function(i) {
        metrics <- c("OBJ", "BIC", "AIC")
        obj <- unlist(res__[[i]][metrics])
        d__ <- data.frame(
          metrics,
          obj,
          stringsAsFactors = FALSE
        )
        names(d__) <- c("Parameter", modelNames__[i])
        return(d__)
      }))
    )
    tObjChar__ <- tObj__
    for (k in modelNames__) tObjChar__[[k]] <- as.character(round(tObjChar__[[k]]))
    table__ <- bind_rows(table__,tObjChar__,tEmpty__)
  }
  table__ <- table__[-dim(table__)[1],]
  if (!is.null(order) & "metrics" %in% selection__) {
    if (order %in% c("BIC", "AIC", "OBJ")) {
      idx__ <- order(tObj__[tObj__$Parameter == order,-1])
      table__ <- table__[,c(1, idx__+1)]
    } else {
      warningIQR(paste0(order, " is not a model GOF metric. Ordering kept as in input object."))
    }
  }
  if (is.null(title)) {
    title__ <- paste0("Comparison of model ",type__,"s for multiple models")
  } else {
    title__ <- title
  }
  footer__ <- switch(
    type__,
    specification = "* (estimate parameter), FIX (parameter fixed to this value), - (parameter not used)",
    result        = "FIX (parameter fixed to this value), - (parameter not used)"
  )
  if (type__ == "result" & any(c("fixedEffects", "randomEffects", "covariate", "correlation") %in% selection__))
    footer__ <- paste0(footer__, "<br>Number of significant digits: ",SIGDIG,".<br>Relative standard errors (RSE) given in parenthesis with 2 significant digits.")
  if ("metrics" %in% selection__)
    footer__ <- paste0(footer__, "<br>Model metrics (OBJ, AIC, BIC) are rounded to nearest integer.")
  footer__ <- paste(
    c(footer__,
      footer,
      paste0(colnames(table__)[-1], " (", as.character(object), ")")),
    collapse = ", ")
  if (!is.null(filename)) {
    filename <- paste0(aux_strrep(filename,".txt",""),".txt")
    IQRoutputTable(xtable=table__,xfooter=footer__,xtitle=title__,report=FLAGreport,filename=filename)
    return(invisible(NULL))
  }
  output__ <- IQRoutputTable(xtable=table__,xfooter=footer__,xtitle=title__,report=FLAGreport)
  output__
}
#'@export
results_MONOLIX <- function (pathMLXTRANproject,
                             outputPath = NULL,
                             CORR_THRESHOLD = 0.3,
                             nindiv = 16,
                             WRES_THRESHOLD = 6,
                             FLAGgofStratify = FALSE) {
  startPath <- getwd()
  .GlobalEnv$allowMONOLIXgui <- TRUE
  tryCatch({
    resultsMONOLIXaux(pathMLXTRANproject=pathMLXTRANproject,
                      outputPath=outputPath,
                      CORR_THRESHOLD=CORR_THRESHOLD,
                      nindiv=nindiv,
                      WRES_THRESHOLD=WRES_THRESHOLD,
                      FLAGgofStratify=FLAGgofStratify)
  }, error=function(err) {
    message(paste0("Issues with generating results for MONOLIX project. Error message:\n",err$message))
  })
  rm(allowMONOLIXgui,envir = .GlobalEnv)
  setwd(startPath)
}
resultsMONOLIXaux <- function (pathMLXTRANproject,
                               outputPath = NULL,
                               CORR_THRESHOLD = 0.3,
                               nindiv = 16,
                               WRES_THRESHOLD = 6,
                               FLAGgofStratify = FALSE) {
  if (!file.exists(pathMLXTRANproject)) stopIQR("The MLXTRAN project does not exist")
  pM <- aux_fileread(pathMLXTRANproject)
  projectPath <- aux_fileparts(pathMLXTRANproject)$pathname
  projectFile <- paste0(aux_fileparts(pathMLXTRANproject)$filename,aux_fileparts(pathMLXTRANproject)$fileext)
  if (is.null(outputPath)) outputPath <- file.path(projectPath,"RESULTSIQR")
  startPath <- getwd()
  setwd(projectPath)
  m <- regexpr("\nexportpath\\s*=\\s*[^\n]+\n",pM)
  x <- regmatches(pM,m)
  text <- aux_strtrim(x)
  eval(parse(text=text))
  resultsFolder <- exportpath
  m <- regexpr("file\\s*=\\s*[^\n]+\n",pM)
  file <- regmatches(pM,m)
  if (length(file)==0) {
    output <- list(
      projectinfo = NULL,
      message = "Could not find data path in MLXTRAN project file"
    )
    return(output)
  }
  fileText <- aux_strtrim(file)
  eval(parse(text=fileText))
  dataPath <- file
  checkFile <- paste0(resultsFolder,"/summary.txt")
  if (!file.exists(checkFile)) {
    stopIQR("MONOLIX project has not been run yet")
  }
  tmp <- file.path(tempdirIQR(),"MODEL")
  aux_rmdir(tmp)
  aux_mkdir(tmp)
  aux_mkdir(file.path(tmp,"RESULTSORIG"))
  file.copy(from= projectFile,to=file.path(tmp,"project.mlxtran"))
  files <- list.files(path=resultsFolder,recursive = TRUE)
  dd__ <- sapply(seq_along(files), function (k__) {
    destfile <- file.path(tmp,"RESULTSORIG",files[k__])
    aux_mkdir(aux_fileparts(destfile)$pathname)
    file.copy(
      from = file.path(resultsFolder,files[k__]),
      to = file.path(tmp,"RESULTSORIG",files[k__]),
      overwrite = TRUE
    )
  })
  data <- IQRloadCSVdata(dataPath)
  IQRsaveCSVdata(data,file.path(tmp,"data.csv"))
  content <- aux_fileread(file.path(tmp,"project.mlxtran"))
  content <- gsub(paste0("exportpath\\s*=\\s*'",resultsFolder,"'"),"exportpath = 'RESULTSORIG'",content)
  content <- gsub(paste0("file\\s*=\\s*[^\n]+\n"),"file = 'data.csv'\n",content)
  aux_filewrite(content,file.path(tmp,"project.mlxtran"))
  setwd(tmp)
  projectPath = "."
  header <- parseMONOLIXprojectHeaderNoHeader(projectPath)$projectinfo
  aux_mkdir(file.path(projectPath,"RESULTS"))
  tryCatch({
    content__ <- aux_fileread(file.path(projectPath,header$RESULTSFOLDER,"summary.txt"))
    IQRoutputFile(content__,"RESULTS/project_results.txt")
  }, error=function(err) {warningIQR("Could not find MONOLIX summary.txt file.")})
  x__ <- parseMONOLIXresults(".")
  info__ <- deparse(x__)
  aux_filewrite(info__,filename=sprintf('RESULTS/project_results.x',projectPath))
  loadSetupOptions_IQRtools()
  PATH_SYSTEM_MONOLIX <- .PATH_SYSTEM_MONOLIX[[1]]
  installMONOLIXapi(PATH_SYSTEM_MONOLIX)
  #require(MlxConnectors,quietly=TRUE)
  # MlxConnectors::initializeMlxConnectors("monolix",mlxDirectory=PATH_SYSTEM_MONOLIX)
  # MlxConnectors::loadProject("project.mlxtran")
  # SAEMiterations__ <- MlxConnectors::getSAEMiterations()
  info__ <- deparse(SAEMiterations__)
  IQRoutputFile(info__,filename=file.path(projectPath,header$RESULTSFOLDER,"SAEMiterations.res"))
  if (.Platform$OS.type=="windows") {
    x__ <- unclass(getLoadedDLLs()$mlxConnectors)$path
  } else {
    x__ <- unclass(getLoadedDLLs()$libmlxConnectors)$path
  }
  dyn.unload(x__)
  convertETAINDIVPRED_IQRnlmeProject(projectPath = projectPath,
                                     pathName = file.path(projectPath,"RESULTS"))
  summary.IQRnlmeProject(projectPath,FLAGreport=TRUE,filename=paste0(projectPath,"/RESULTS/project_parameters_table.txt"))
  x <- plotConvergence_IQRnlmeProject(projectPath,sprintf('%s/RESULTS/project_convergence',projectPath))
  if (is.null(x)) {
    message("MONOLIX project does not contain information for convergence trajectories. Output not done.")
  }
  plotETA_IQRnlmeProject(projectPath,filename = paste0(projectPath,"/RESULTS/GOF_GENERAL/01_Random_Effects"),CORR_THRESHOLD=CORR_THRESHOLD)
  plotETACOV_IQRnlmeProject(projectPath,filename = paste0(projectPath,"/RESULTS/GOF_GENERAL/02_ETAs_vs_COVs"),CORR_THRESHOLD=CORR_THRESHOLD)
  tryCatch({
    covariateEffect_IQRnlmeProject(projectPath,filename = paste0(projectPath,"/RESULTS/GOF_GENERAL/03_COV_Impact_Parameters"),Nsamples=1e5,ClinicalRelevanceLow=0.8,ClinicalRelevanceHigh=1.2)
  }, error=function(err) {
    message("Issue with forest plots. Probably due to covariate model setup. Output omitted.")
  })
  PROJECTINFO     <- parseNLMEprojectHeader(projectPath)
  outputNumberALL <- 1:length(PROJECTINFO$OUTPUTS)
  outputNamesALL  <- PROJECTINFO$OUTPUTS
  for (k__ in seq_along(outputNumberALL)) {
    basefilenameOutput <- sprintf(paste0(projectPath, '/RESULTS/GOF_OUTPUT_%d_%s/'),outputNumberALL[k__],outputNamesALL[k__]);
    plotINDIV_IQRnlmeProject(
      projectPath,
      outputNr=outputNumberALL[k__],
      filename=paste0(basefilenameOutput, '01_Individual_Fits_LinearY'),
      plotLog=FALSE,nindiv=nindiv
    )
    plotINDIV_IQRnlmeProject(
      projectPath,
      outputNr=outputNumberALL[k__],
      filename=paste0(basefilenameOutput, '02_Individual_Fits_LogY'),
      plotLog=TRUE,nindiv=nindiv
    )
    plotGOF_IQRnlmeProject(
      projectPath,
      outputNr=outputNumberALL[k__],
      stratCov=NULL,
      filename=paste0(basefilenameOutput, '03_GOF_Plots'),
      plotLog=TRUE
    )
    if (FLAGgofStratify) {
      for (k2__ in 1:length(PROJECTINFO$COVARIATENAMES)) {
        stratCov <- PROJECTINFO$COVARIATENAMES[k2__]
        plotGOF_IQRnlmeProject(
          projectPath,
          outputNr=outputNumberALL[k__],
          stratCov=stratCov,
          filename=paste0(basefilenameOutput, '03_GOF_Plots_stratified/',stratCov),
          plotLog=TRUE
        )
      }
    }
    outlier_IQRnlmeProject(
      projectPath,
      outputNr=outputNumberALL[k__],
      filename=paste0(basefilenameOutput, '04_OutlierDetection.txt'),
      WRES_THRESHOLD=WRES_THRESHOLD
    )
  }
  setwd(startPath)
  aux_rmdir(outputPath)
  aux_mkdir(outputPath)
  files <- list.files(path=file.path(tmp,"RESULTS"),recursive = TRUE)
  files <- files[!grepl(".log$",files)]
  files <- files[!grepl(".atr$",files)]
  files <- files[!grepl(".csv$",files)]
  files <- files[!grepl(".x$",files)]
  files <- files[!grepl("project_results.txt",files)]
  dd__ <- sapply(seq_along(files), function (k__) {
    destfile <- file.path(outputPath,files[k__])
    aux_mkdir(aux_fileparts(destfile)$pathname)
    file.copy(
      from = file.path(tmp,"RESULTS",files[k__]),
      to = destfile,
      overwrite = TRUE
    )
  })
  content <- aux_fileread(file.path(outputPath,"project_parameters_table.txt"))
  content <- aux_strrep(content,"Model: .",paste0("Model: ",projectFile))
  aux_filewrite(content,file.path(outputPath,"project_parameters_table.txt"))
  files <- file.path(outputPath,list.files(outputPath,recursive = TRUE))
  d <- sapply(files, function (file) {
    genComplianceLog(file)
  })
  return(invisible(NULL))
}
parseMONOLIXprojectHeaderNoHeader <- function(projectPath) {
  projectFile <- "project.mlxtran"
  projectinfo <- list(
    PROJECTFILE         = NA,
    RESULTSFOLDER       = NA,
    COMMENT             = NA,
    TOOL                = "MONOLIX",
    TOOLSVERSION        = "Unknown",
    DATA                = "",
    DOSINGTYPES         = "",
    COVNAMES            = "",
    CATNAMES            = "",
    CATCATEGORIES       = "",
    REGRESSIONNAMES     = "",
    OUTPUTS             = "",
    ERRORMODELS         = "",
    PARAMNAMES          = "",
    PARAMTRANS          = "",
    PARAMINVTRANS       = "",
    COVARIATENAMES      = "",
    COVARIATESUSED      = "",
    BETACOVNAMES        = "",
    BETACOVTRANS        = "",
    BETACATNAMES        = "",
    BETACATREFERENCE    = ""
  )
  pF <- file.path(projectPath,projectFile)
  pM <- aux_fileread(pF)
  pM <- gsub("\\r","",pM,fixed = TRUE)
  m <- regexpr("\nexportpath\\s*=\\s*[^\n]+\n",pM)
  x <- regmatches(pM,m)
  text <- aux_strtrim(x)
  eval(parse(text=text))
  projectinfo$RESULTSFOLDER <- exportpath
  m <- regexpr("file\\s*=\\s*[^\n]+\n",pM)
  file <- regmatches(pM,m)
  if (length(file)==0) {
    output <- list(
      projectinfo = NULL,
      message = "Could not find data path in MLXTRAN project file"
    )
    return(output)
  }
  fileText <- aux_strtrim(file)
  eval(parse(text=fileText))
  projectinfo$DATA <- file
  if (!file.exists(projectinfo$DATA)) {
    output <- list(
      projectinfo = NULL,
      message = "Could not find data file"
    )
    return(output)
  }
  data <- IQRloadCSVdata(projectinfo$DATA)
  m <- gregexpr("\n[A-Za-z0-9_ ]*=\\s*\\{use=identifier}",pM)
  x <- regmatches(pM,m)
  IDname <- unname(sapply(x[[1]], function (y) {
    aux_strtrim(aux_explode(y,"=")[1])
  }))
  dataUnique <- data[!duplicated(data[[IDname]]),]
  m <- gregexpr("\n[A-Za-z0-9_ ]*=\\s*\\{use=covariate,\\s*type=continuous}",pM)
  x <- regmatches(pM,m)
  COVNAMES <- unname(sapply(x[[1]], function (y) {
    aux_strtrim(aux_explode(y,"=")[1])
  }))
  if (length(COVNAMES)==0) COVNAMES <- ""
  projectinfo$COVNAMES <- COVNAMES
  m <- gregexpr("\n[A-Za-z0-9_ ]*=\\s*\\{use=covariate,\\s*type=categorical}",pM)
  x <- regmatches(pM,m)
  CATNAMES <- unname(sapply(x[[1]], function (y) {
    aux_strtrim(aux_explode(y,"=")[1])
  }))
  if (length(CATNAMES)==0) CATNAMES <- ""
  projectinfo$CATNAMES <- CATNAMES
  CATCATEGORIES1 <- sapply(projectinfo$CATNAMES, function (y) {
    cats <- sort(unique(dataUnique[[y]]))
    x <- paste0(cats,collapse=" ")
    paste0("[",x,"]")
  })
  CATCATEGORIES2 <- unlist(sapply(projectinfo$CATNAMES, function (y) {
    m <- regexpr(paste0("transform\\s*=\\s*",y,"[^}]+"),pM)
    z <- regmatches(pM,m)
    if (length(z) > 0) {
      z <- gsub(paste0("transform\\s*=\\s*",y,",\\s*categories\\s*=\\s*\\{"),"",z)
      z <- aux_strrep(z," ","")
      z <- aux_strrep(z,"\n","")
      cats <- sapply(aux_explodePC(z), function (x) {
        aux_explode(x,"=")[[1]]
      })
      x <- paste0(cats,collapse=" ")
      return(paste0("[",x,"]"))
    } else {
      return(NULL)
    }
  }))
  CATCATEGORIES <- CATCATEGORIES1
  if (length(CATCATEGORIES2) > 0) CATCATEGORIES <- CATCATEGORIES2
  if (length(CATCATEGORIES)==0) CATCATEGORIES <- ""
  projectinfo$CATCATEGORIES <- CATCATEGORIES
  m <- gregexpr("\n[A-Za-z0-9_ ]*=\\s*\\{use=regressor}",pM)
  x <- regmatches(pM,m)
  REGRESSIONNAMES <- unname(sapply(x[[1]], function (y) {
    aux_strtrim(aux_explode(y,"=")[1])
  }))
  if (length(REGRESSIONNAMES)==0) REGRESSIONNAMES <- ""
  projectinfo$REGRESSIONNAMES <- REGRESSIONNAMES
  m <- gregexpr("\\<prediction\\s*=\\s*[^,]+",pM)
  x <- regmatches(pM,m)
  OUTPUTS <- unname(sapply(x[[1]], function (y) {
    aux_strtrim(aux_explode(y,"=")[2])
  }))
  projectinfo$OUTPUTS <- OUTPUTS
  m <- gregexpr("\\<errorModel\\s*=\\s*[^(]+\\(",pM)
  x <- regmatches(pM,m)
  ERRORMODELS <- unname(sapply(x[[1]], function (y) {
    x <- aux_strtrim(aux_explode(y,"=")[2])
    x <- aux_strrep(x,"(","")
    if (x=="constant") return("abs")
    if (x=="proportional") return("rel")
    if (x=="combined1") return("absrel")
    return(x)
  }))
  projectinfo$ERRORMODELS <- ERRORMODELS
  m <- gregexpr("\n[A-Za-z0-9_ ]*=\\s*\\{distribution\\s*=[^,]*,\\s*typical",pM)
  x <- regmatches(pM,m)
  PARAMNAMES <- unname(sapply(x[[1]], function (y) {
    aux_strtrim(aux_explode(y,"=")[1])
  }))
  projectinfo$PARAMNAMES <- PARAMNAMES
  m <- gregexpr("\n[A-Za-z0-9_ ]*=\\s*\\{distribution\\s*=[^,]*,\\s*typical",pM)
  x <- regmatches(pM,m)
  PARAMTRANS <- unname(sapply(x[[1]], function (y) {
    m <- regexpr("distribution\\s*=[^,]*",y)
    x <- regmatches(y,m)
    dist <- aux_strtrim(aux_explode(x,"=")[2])
    if (dist=="logNormal") return("exp(phi)")
    if (dist=="normal") return("(phi)")
    if (dist=="logitNormal") return("exp(phi)/(1+exp(phi))")
    return(paste0("inv(",dist,")"))
  }))
  projectinfo$PARAMTRANS <- PARAMTRANS
  m <- gregexpr("\n[A-Za-z0-9_ ]*=\\s*\\{distribution\\s*=[^,]*,\\s*typical",pM)
  x <- regmatches(pM,m)
  PARAMINVTRANS <- unname(sapply(x[[1]], function (y) {
    m <- regexpr("distribution\\s*=[^,]*",y)
    x <- regmatches(y,m)
    dist <- aux_strtrim(aux_explode(x,"=")[2])
    if (dist=="logNormal") return("log(psi)")
    if (dist=="normal") return("(psi)")
    if (dist=="logitNormal") return("log(psi/(1-psi))")
    return(paste0("inv(",dist,")"))
  }))
  projectinfo$PARAMINVTRANS <- PARAMINVTRANS
  COVARIATENAMES <- c(projectinfo$COVNAMES,projectinfo$CATNAMES)
  COVARIATENAMES <- COVARIATENAMES[COVARIATENAMES!=""]
  if (length(COVARIATENAMES) == 0) COVARIATENAMES <- ""
  projectinfo$COVARIATENAMES <- COVARIATENAMES
  COVARIATESUSED <- unique(unname(unlist(sapply(projectinfo$PARAMNAMES, function (p) {
    m <- regexpr(paste0("\n",p,"\\s*=\\s*[^\n]+\n"),pM)
    x <- regmatches(pM,m)
    m <- regexpr("covariate\\s*=\\s*[^}]*",x)
    x <- regmatches(x,m)
    x <- aux_strrep(x,"covariate","")
    if (length(x) == 0) return(NULL)
    return(projectinfo$COVARIATENAMES[sapply(projectinfo$COVARIATENAMES, function (c) grepl(c,x))])
  }))))
  if (is.null(COVARIATESUSED)) COVARIATESUSED <- ""
  projectinfo$COVARIATESUSED <- COVARIATESUSED
  BETACOVNAMES <- unique(unname(unlist(sapply(projectinfo$PARAMNAMES, function (p) {
    m <- regexpr(paste0("\n",p,"\\s*=\\s*[^\n]+\n"),pM)
    x <- regmatches(pM,m)
    m <- regexpr("covariate\\s*=\\s*[^}]*",x)
    x <- regmatches(x,m)
    x <- aux_strrep(x,"covariate","")
    if (length(x) == 0) return(NULL)
    covNames <- projectinfo$COVARIATENAMES[sapply(projectinfo$COVARIATENAMES, function (c) grepl(c,x))]
    sapply(covNames, function (c) {
      if (c %in% projectinfo$CATNAMES) return(NULL)
      paste0("beta_",p,"(",c,")")
    })
  }))))
  if (is.null(BETACOVNAMES)) BETACOVNAMES <- ""
  projectinfo$BETACOVNAMES <- BETACOVNAMES
  BETACATNAMES <- unique(unname(unlist(sapply(projectinfo$PARAMNAMES, function (p) {
    m <- regexpr(paste0("\n",p,"\\s*=\\s*[^\n]+\n"),pM)
    x <- regmatches(pM,m)
    m <- regexpr("covariate\\s*=\\s*[^}]*",x)
    x <- regmatches(x,m)
    x <- aux_strrep(x,"covariate","")
    if (length(x) == 0) return(NULL)
    covNames <- projectinfo$COVARIATENAMES[sapply(projectinfo$COVARIATENAMES, function (c) grepl(c,x))]
    sapply(covNames, function (c) {
      if (c %in% projectinfo$COVNAMES) return(NULL)
      paste0("beta_",p,"(",c,")")
    })
  }))))
  if (is.null(BETACATNAMES)) BETACATNAMES <- ""
  projectinfo$BETACATNAMES <- BETACATNAMES
  BETACATREFERENCE <- sapply(projectinfo$BETACATNAMES, function (p) {
    p <- projectinfo$BETACATNAMES[[1]]
    p <- aux_strrep(p,"(","_")
    p <- aux_strrep(p,")","_")
    p <- aux_explode(p,"_")
    par <- p[2]
    cov <- p[3]
    m <- regexpr(paste0("\n",par,"\\s*=\\s*[^\n]+\n"),pM)
    x <- regmatches(pM,m)
    m <- gregexpr(paste0("beta_",par,"_[A-Za-z_0-9]+\\>"),x)
    y <- regmatches(x,m)
    catest <- sapply(y, function (z) {
      o <- aux_strrep(z,paste0("beta_",par,"_t",cov,"_"),"")
      o <- aux_strrep(o,paste0("beta_",par,"_",cov,"_"),"")
      o
    })
    allCat <- projectinfo$CATCATEGORIES[cov]
    allCat <- aux_strrep(allCat,"[","")
    allCat <- aux_strrep(allCat,"]","")
    allCat <- aux_explode(allCat," ")
    catRef <- setdiff(allCat,catest)
    catRef
  })
  if (is.na(BETACATREFERENCE[1])) BETACATREFERENCE <- ""
  projectinfo$BETACATREFERENCE <- BETACATREFERENCE
  output <- list(
    projectinfo = projectinfo,
    message = NULL
  )
  output
}
#'@export
is_MONOLIX_IQRnlmeProject <- function (projectPath) {
  testfile__ <- paste0(projectPath,'/','project.mlxtran')
  tryCatch({
    if (allowMONOLIXgui) return (file.exists(testfile__))
  }, error=function (err) {})
  if (file.exists(testfile__)) return(hasHeader_IQRnlmeProject(testfile__))
  return(FALSE)
}
hasHeader_IQRnlmeProject <- function (file) {
  content <- aux_fileread(file)
  if (grepl("==PROJECT HEADER START",content)) return(TRUE)
  return(FALSE)
}
installMONOLIXapi <- function (PATH_MONOLIX) {
  if (!("RJSONIO" %in% rownames(utils::installed.packages()))) {
    utils::install.packages("RJSONIO")
  }
  if (dir.exists(paste0(PATH_MONOLIX,"/connectors"))) {
    packagePath <- paste0(PATH_MONOLIX,"/connectors/lixoftConnectors.tar.gz")
    utils::install.packages(packagePath, repos = NULL, type = "source")
  } else {
    stopIQR("Could not identify MONOLIX version ... ")
  }
}
runMONOLIXproject <- function(projectPath,ncores=1) {
  loadSetupOptions_IQRtools()
  toolVersion <- parseNLMEprojectHeader(projectPath)$TOOLVERSION
  PATH_SYSTEM_MONOLIX <- .PATH_SYSTEM_MONOLIX[[toolVersion]]
  if (nchar(PATH_SYSTEM_MONOLIX) == 0) {
    stopIQR('Path to MONOLIX executable not defined in setup_options_IQRtools.R file')
  }
  if (grepl("2019R1",PATH_SYSTEM_MONOLIX)) version_lixoftConnectors <- "2019.1"
  if (grepl("2019R2",PATH_SYSTEM_MONOLIX)) version_lixoftConnectors <- "2019.2"
  if (grepl("2020R1",PATH_SYSTEM_MONOLIX)) version_lixoftConnectors <- "2020.1"
  if (grepl("2020R2",PATH_SYSTEM_MONOLIX)) version_lixoftConnectors <- "2020.2"
  if (grepl("2021R1",PATH_SYSTEM_MONOLIX)) version_lixoftConnectors <- "2021.1"
  if (grepl("2021R2",PATH_SYSTEM_MONOLIX)) version_lixoftConnectors <- "2021.2"
  if (grepl("2022R1",PATH_SYSTEM_MONOLIX)) version_lixoftConnectors <- "2022.1"
  if (grepl("2022R2",PATH_SYSTEM_MONOLIX)) version_lixoftConnectors <- "2022.2"
  if (aux_version("lixoftConnectors") != version_lixoftConnectors) {
    installMONOLIXapi(PATH_SYSTEM_MONOLIX)
  }
  oldpath__ <- getwd()
  setwd(projectPath)
  fullProjectPath__ <-getwd()
  #require(lixoftConnectors,quietly=TRUE)
  # lixoftConnectors::initializeLixoftConnectors(software = "monolix",path=PATH_SYSTEM_MONOLIX)
  # lixoftConnectors::loadProject("project.mlxtran")
  # lixoftConnectors::setPreferences(exportChartsData = TRUE)
  # lixoftConnectors::setPreferences(threads = ncores)
  # scenario__ <- lixoftConnectors::getScenario()
  # scenario__$plotList <- c(scenario__$plotList,"residualsscatter")
  # lixoftConnectors::setScenario(scenario__)
  # lixoftConnectors::runScenario(wait=TRUE)
  # SAEMiterations__ <- lixoftConnectors::getSAEMiterations()
  if (.Platform$OS.type=="windows") {
    x__ <- unclass(getLoadedDLLs()$lixoftConnectors)$path
  } else {
    x__ <- unclass(getLoadedDLLs()$liblixoftConnectors)$path
  }
  dyn.unload(x__)
  tryCatch({
    content__ <- aux_fileread("RESULTSORIG/summary.txt")
    IQRoutputFile(content__,"RESULTS/project_results.txt")
  }, error=function(err) {warningIQR("Monolix run seems to have had issues.")})
  x__ <- parseMONOLIXresults(".")
  info__ <- deparse(x__)
  aux_filewrite(info__,filename=sprintf('RESULTS/project_results.x'))
  info__ <- deparse(SAEMiterations__)
  IQRoutputFile(info__,filename="RESULTSORIG/SAEMiterations.res")
  setwd(oldpath__)
  convertETAINDIVPRED_IQRnlmeProject(projectPath,paste0(projectPath,"/RESULTS"))
}
plotConvergenceMONOLIX <- function(projectPath) {
  content__ <- aux_fileread(sprintf('%s/RESULTSORIG/SAEMiterations.res',projectPath))
  SAEMiterations__ <- eval(parse(text=content__))
  if (is.null(SAEMiterations__)) return(NULL)
  projectinfo__ <- parseMONOLIXprojectHeader(projectPath)
  nrs__ <- SAEMiterations__$iterationNumbers
  x__ <- SAEMiterations__$estimates
  ITER__ <- 1:nrow(x__)
  x__ <- cbind(ITERATION=ITER__,x__)
  names(x__) <- gsub(pattern="_pop",replacement="",x=names(x__))
  names(x__)[names(x__)=="convergenceIndicator"] <- "Convergence"
  gathercols__ <- setdiff(names(x__),"ITERATION")
  plotData__ <- tidyr::gather(data = x__, key = "NAME", value = "VALUE",
                              dplyr::one_of(gathercols__))
  plotData__$TYPE  <- "Default"
  plotData__$GROUP <- "Default"
  plotData__$TYPE[plotData__$NAME=="Convergence"] <- "Convergence"
  dummy__ <- sapply(projectinfo__$PARAMNAMES, function (n__) {
    plotData__$TYPE[plotData__$NAME==n__] <<- "Fixed Effects"
  })
  plotData__$TYPE[grepl("^omega_",plotData__$NAME)] <- "Random Effects"
  plotData__$TYPE[grepl("^corr_",plotData__$NAME)] <- "IIV Correlations"
  plotData__$GROUP[grepl("^corr_",plotData__$NAME)] <- plotData__$NAME[grepl("^corr_",plotData__$NAME)]
  plotData__$NAME[grepl("^corr_",plotData__$NAME)] <- "IIV Correlations"
  plotData__$TYPE[grepl("^a[0-9]*$",plotData__$NAME)] <- "Error Parameters"
  plotData__$TYPE[grepl("^b[0-9]*$",plotData__$NAME)] <- "Error Parameters"
  plotData__$TYPE[grepl("^beta_[a-zA-Z0-9]+_[a-zA-Z0-9]+$",plotData__$NAME)] <- "Continuous Covariates"
  plotData__$TYPE[grepl("^beta_[a-zA-Z0-9]+_[a-zA-Z0-9]+_",plotData__$NAME)] <- "Categorical Covariates"
  plotData__$TYPE <- factor(plotData__$TYPE,levels=c("Convergence",
                                                     "Fixed Effects",
                                                     "Random Effects",
                                                     "Continuous Covariates",
                                                     "Categorical Covariates",
                                                     "IIV Correlations",
                                                     "Error Parameters"))
  cols__ <- c(
    gathercols__[!grepl("^corr_",gathercols__)],
    "IIV Correlations"
  )
  plotData__$NAME <- factor(plotData__$NAME,levels=cols__)
  p <- IQRggplot(data=plotData__, aes_string(x="ITERATION",y="VALUE", color="TYPE", group="GROUP")) +
    geom_line(size=0.5) +
    scale_color_IQRtools() +
    facet_wrap(~NAME,scales="free") +
    geom_vline(xintercept=nrs__[1],color="red",linetype="dashed") +
    ylab(label=NULL) +
    theme(legend.position="bottom",
          legend.background=element_rect(linetype="solid",color="black"))  +
    ggtitle("Convergence trajectories for MONOLIX estimation",
            subtitle = "'omega_' elements indicate standard deviations of random effects")
  attr(p,"plotData") <- plotData__
  p
}
parseMONOLIXprojectHeader <- function(projectPath) {
  if (file.exists(paste0(projectPath, '/project.mlxtran'))) {
    project__ <- aux_fileread(paste0(projectPath, '/project.mlxtran'))
  } else {
    stopIQR('project.mlxtran file could not be found.')
  }
  ixstart__ <- aux_strFindAll(project__,'; ==PROJECT HEADER START===================================================')$end
  ixend__   <- aux_strFindAll(project__,  '; ==PROJECT HEADER END=====================================================')$start
  if (is.null(ixstart__) | is.null(ixend__)) {
    result <- parseMONOLIXprojectHeaderNoHeader(projectPath)
    if (is.null(result$projectinfo)) {
      stopIQR(result$message)
    }
    return(result$projectinfo)
  }
  headertext__ <- aux_strtrim(substr(project__,ixstart__+1,ixend__-1))
  headertext__  <- aux_strrep(headertext__,"; ","")
  headertext__  <- aux_strrep(headertext__,"\n",",\n")
  projectinfo__ <- eval(parse(text=paste0("list(",headertext__,")")))
  projectinfo__ <- lapply(projectinfo__,function(x) aux_explodePC(x))
  return(projectinfo__)
}
parseMONOLIXparameterEstimates <- function(projectPath) {
  if (!file.exists(paste0(projectPath,"/RESULTSORIG/populationParameters.txt")))
    stopIQR("Could not find the populationParameters.txt file in the provided project folder. Issues with fit or wrong path?")
  estimates__ <- as.matrix(utils::read.csv(file=paste0(projectPath,"/RESULTSORIG/populationParameters.txt"),header=TRUE,sep=","))
  correlationEstimates__ <- NULL
  if (file.exists(paste0(projectPath,"/RESULTSORIG/FisherInformation/correlationEstimatesLin.txt"))) {
    correlationEstimates__ <- as.matrix(utils::read.csv(file=paste0(projectPath,"/RESULTSORIG/FisherInformation/correlationEstimatesLin.txt"),header=FALSE,sep=","))
  }
  if (file.exists(paste0(projectPath,"/RESULTSORIG/FisherInformation/correlationEstimatesSA.txt"))) {
    correlationEstimates__ <- as.matrix(utils::read.csv(file=paste0(projectPath,"/RESULTSORIG/FisherInformation/correlationEstimatesSA.txt"),header=FALSE,sep=","))
  }
  if (is.null(correlationEstimates__))
    stopIQR("Could not read the correlationEstimatesLin.txt or correlationEstimatesSA.txt file in the MONOLIX results")
  FEnames__ <- gsub("_pop\\>","",estimates__[grepl("_pop\\>",estimates__[,1]),1])
  firstOmega__ <- min(which(grepl("\\<omega_",estimates__[,1])))
  lastOmega__ <- max(which(grepl("\\<omega_",estimates__[,1])))
  allNfe__ <- estimates__[,1][1:(firstOmega__-1)]
  allNre__ <- paste0("omega_",FEnames__)
  countOmegaEstimates <- sum(grepl("^omega_",estimates__[,1]))
  countOmegas <- length(allNre__)
  if (nrow(estimates__) > length(c(allNfe__,allNre__)) + (countOmegaEstimates-countOmegas)) {
    allNrest__ <- estimates__[,1][(lastOmega__+1):length(estimates__[,1])]
  } else {
    allNrest__ <- NULL
  }
  allNamesCORRECT__ <- c(allNfe__,allNre__,allNrest__)
  namesx__ <- estimates__[,1]
  desiredorder__ <- namesx__[namesx__ %in% correlationEstimates__[,1]]
  ix__ <- match(desiredorder__, correlationEstimates__[,1], nomatch = NULL)
  correlationEstimates__ <- cbind(correlationEstimates__[ix__,1],correlationEstimates__[ix__,1+ix__])
  test__ <- allNamesCORRECT__ %in% correlationEstimates__[,1]
  correlationEstimatesFIXED__ <- cbind(allNamesCORRECT__,diag(1,nrow=length(allNamesCORRECT__)))
  colnames(correlationEstimatesFIXED__) <- c("",correlationEstimatesFIXED__[,1])
  correlationEstimatesFIXED__[which(test__),1+which(test__)] <- correlationEstimates__[,-1]
  correlationEstimates__ <- correlationEstimatesFIXED__
  colnames(correlationEstimates__) <- c("",correlationEstimates__[,1])
  estimatesFIXED__ <- matrix(NA,nrow=length(allNamesCORRECT__),ncol=ncol(estimates__))
  colnames(estimatesFIXED__) <- colnames(estimates__)
  estimatesFIXED__[,1] <- allNamesCORRECT__
  estimatesFIXED__[,2] <- 0
  test__ <- allNamesCORRECT__  %in% estimates__[,1]
  estimatesFIXED__[which(test__),] <- estimates__
  estimates__ <- estimatesFIXED__
  MLX_project_header__ <- parseMONOLIXprojectHeader(projectPath)
  content__ <- aux_fileread(paste0(projectPath,"/RESULTSORIG/summary.txt"))
  m__ <- gregexpr(pattern="Monolix version :[\\s]+[0-9.]+",text=content__,perl=TRUE)
  MONOLIXversion__ <- aux_strrep(regmatches(x=content__,m__),"Monolix version : ","")
  mlxtran__ <- aux_fileread(paste0(projectPath,"/project.mlxtran"))
  ix1__ <- aux_strFindAll(mlxtran__,"<PARAMETER>\n")
  if (is.null(ix1__$start)) stopIQR("Problems parsing MLXTRAN file for start of parameter definitions")
  ix2__ <- aux_strFindAll(mlxtran__,"<MONOLIX>\n")
  if (is.null(ix2__$start)) stopIQR("Problems parsing MLXTRAN file for end of parameter definitions")
  textParamDef__ <- aux_strtrim(substr(mlxtran__,ix1__$end+1,ix2__$start-1))
  paramDef__ <- aux_explode(textParamDef__,"\n")
  correlationEstimates__[,1] <- aux_removeWhiteSpace(correlationEstimates__[,1])
  estimates__[,1] <- aux_removeWhiteSpace(estimates__[,1])
  allParamNames__ <- estimates__[,1]
  estimatedFlag__ <- sapply(allParamNames__, function (x__) {
    ixParamDef__ <- which(grepl(paste0("\\b",x__,"\\b"),paramDef__))
    if (length(ixParamDef__)==0) {
      return(FALSE)
    }
    fixed__ <- grepl("method=FIXED",paramDef__[ixParamDef__])
    return(!fixed__)
  })
  ParamNamesFIXED__ <- allParamNames__[!estimatedFlag__]
  ParamNamesESTIMATED__ <- allParamNames__[estimatedFlag__]
  ix_cat_ref_param__ <- c()
  catnamesused__ <- intersect(MLX_project_header__$CATNAMES, MLX_project_header__$COVARIATESUSED)
  for (k__ in seq_along(catnamesused__)) {
    catname__ <- catnamesused__[k__]
    ix <- which(grepl(pattern=paste0("(",catname__,")"),x=MLX_project_header__$BETACATNAMES))
    ix <- ix[1]
    ref__ <- MLX_project_header__$BETACATREFERENCE[ix]
    search__ <- paste0("t",catnamesused__[k__],"_",ref__,"$")
    ix_cat_ref_param__ <- c(ix_cat_ref_param__, which(grepl(pattern=search__,x=allParamNames__)))
  }
  ix_retain__ <- setdiff(1:length(allParamNames__),ix_cat_ref_param__)
  namesBetaRefParam <- allParamNames__[ix_cat_ref_param__]
  estimates__ <- estimates__[ix_retain__,]
  correlationEstimates__ <- correlationEstimates__[ix_retain__,c(1,1+ix_retain__)]
  allParamNames__ <- setdiff(allParamNames__,namesBetaRefParam)
  ParamNamesFIXED__ <- setdiff(ParamNamesFIXED__,namesBetaRefParam)
  ParamNamesESTIMATED__ <- setdiff(ParamNamesESTIMATED__,namesBetaRefParam)
  correlationMatrix__ <- as.double(correlationEstimates__[,2:ncol(correlationEstimates__)])
  correlationMatrix__[is.na(correlationMatrix__)] <- 0
  correlationMatrix__ <- matrix(correlationMatrix__, nrow=length(allParamNames__), ncol=length(allParamNames__))
  colnames(correlationMatrix__) <- allParamNames__
  rownames(correlationMatrix__) <- allParamNames__
  parameters <- list()
  parameters$MONOLIXversion <- MONOLIXversion__
  parameters$names <- allParamNames__
  parameters$values <- as.numeric(estimates__[,2])
  parameters$stderrors <- as.numeric(estimates__[,3])
  parameters$rse <- as.numeric(estimates__[,4])
  parameters$FLAGestimated <- as.numeric(sapply(allParamNames__, function (x) x %in% ParamNamesESTIMATED__))
  parameters$stderrors[parameters$FLAGestimated==0] <- 0
  parameters$rse[parameters$FLAGestimated==0] <- 0
  parameters$correlationmatrix <- correlationMatrix__
  parameters$covariancematrix <- tryCatch({
    nearPD(correlationMatrix__*(parameters$stderrors%*%t(parameters$stderrors)))
  }, error=function(e) {
    warningIQR("Covariance matrix not positive semidefinite. This can have several reasons:\n  - Non identifiability (NaN in std errors)\n  - Bug in Monolix in case of numeric covariate categories with different lengths\n - ...\nBetter check Monolix output!")
    matrix(NA,nrow=nrow(correlationMatrix__),ncol=ncol(correlationMatrix__))
  })
  parameters$names <- aux_strrep(parameters$names,'_pop','')
  if (MLX_project_header__$COVARIATENAMES[1] != "") {
    dummy__ <- sapply(MLX_project_header__$COVARIATENAMES, function (x) parameters$names <<- aux_strrep(parameters$names,paste0("_t",x),paste0("_",x)))
  }
  parameters$names <- aux_strrep(parameters$names,'beta_','beta(')
  parameters$names <- aux_strrep(parameters$names,'corr_','corr(')
  parameters$names <- aux_strrep(parameters$names,'omega_','omega(')
  parameters$names <- sapply(parameters$names, function (x__) {
    out__ <- x__
    if (grepl(pattern="\\(",x=x__)) out__ <- paste0(x__,")")
    out__
  })
  parameters$names <- sapply(parameters$names, function (x) {
    terms__ <- aux_explode(x,"_")
    if (length(terms__)==4) out__ <- paste0(terms__[1],",",terms__[2],"_",terms__[3],"_",terms__[4])
    if (length(terms__)==3) out__ <- paste0(terms__[1],",",terms__[2],"_",terms__[3])
    if (length(terms__)==2) out__ <- paste0(terms__[1],",",terms__[2])
    if (length(terms__)==1) out__ <- x
    if (length(terms__) > 4)
      stopIQR("Problem with parameter names ... too many underscores")
    out__
  })
  parameters$names <- sapply(parameters$names, function (x__) {
    out__ <- x__
    if (x__=="a") out__ <- "error_ADD1"
    if (x__=="b") out__ <- "error_PROP1"
    if (grepl(pattern="\\<a[0-9]+\\>",x__)) out__ <- aux_strrep(x__,"a","error_ADD")
    if (grepl(pattern="\\<b[0-9]+\\>",x__)) out__ <- aux_strrep(x__,"b","error_PROP")
    out__
  })
  covnames__ <- parameters$names[grepl(pattern="beta\\(",x=parameters$names)]
  covnames__ <- aux_strrep(covnames__,"(","_")
  covnames__ <- aux_strrep(covnames__,",","(")
  parameters$names[grepl(pattern="beta\\(",x=parameters$names)] <- covnames__
  names(parameters$names) <- parameters$names
  names(parameters$values) <- parameters$names
  names(parameters$stderrors) <- parameters$names
  names(parameters$rse) <- parameters$names
  names(parameters$FLAGestimated) <- parameters$names
  rownames(parameters$correlationmatrix) <- parameters$names
  colnames(parameters$correlationmatrix) <- parameters$names
  if (any(!is.na(parameters$covariancematrix))) {
    rownames(parameters$covariancematrix) <- parameters$names
    colnames(parameters$covariancematrix) <- parameters$names
  }
  return(parameters)
}
parseMONOLIXresults <- function(projectPath) {
  PROJECTINFO__ <- parseMONOLIXprojectHeader(projectPath)
  parameters__ <- parseMONOLIXparameterEstimates(projectPath)
  output__                          <- list()
  output__$type                     <- "MONOLIX"
  output__$method                   <- "SAEM"
  output__$path                     <- projectPath
  output__$parameters               <- parameters__
  output__$objectivefunction        <- list()
  output__$residualerrormodels      <- PROJECTINFO__$ERRORMODELS 
  output__$trans_randeffects        <- PROJECTINFO__$PARAMTRANS
  output__$inv_trans_randeffects    <- PROJECTINFO__$PARAMINVTRANS
  output__$covariates               <- list()
  output__$PROJECTINFO              <- PROJECTINFO__
  output__$rawParameterInfo         <- list()
  estimates__ <- as.matrix(utils::read.csv(file=paste0(projectPath,"/RESULTSORIG/LogLikelihood/logLikelihood.txt"),header=TRUE,sep=","))
  LL__ <- as.numeric(estimates__[match("-2LL", estimates__[,1]), 2])
  if (is.na(LL__)) {
    LL__ <- as.numeric(estimates__[match("OFV", estimates__[,1]), 2])
  }
  AIC__ <- as.numeric(estimates__[match("AIC", estimates__[,1]),2])
  BIC__ <- as.numeric(estimates__[match("BIC", estimates__[,1]),2])
  BICc__ <- as.numeric(estimates__[match("BICc", estimates__[,1]),2])
  output__$objectivefunction$OBJ <- LL__
  output__$objectivefunction$AIC <- AIC__
  output__$objectivefunction$BIC <- BIC__
  output__$objectivefunction$BICc <- BICc__
  output__$covariates$covNames <- intersect(PROJECTINFO__$COVARIATESUSED,PROJECTINFO__$COVNAMES)
  output__$covariates$covTransformation <- sapply(output__$covariates$covNames, function (x) {
    ix__ <- which(grepl(pattern=paste0("(",x,")"),x=PROJECTINFO__$BETACOVNAMES))
    if (length(ix__) > 0) {
      ix__ <- ix__[1]
      out__ <- PROJECTINFO__$BETACOVTRANS[ix__]
    } else {
      out__ <- NULL
    }
    out__
  })
  output__$covariates$catNames <- intersect(PROJECTINFO__$COVARIATESUSED,PROJECTINFO__$CATNAMES)
  output__$covariates$catReference <- sapply(output__$covariates$catNames, function (x) {
    ix__ <- which(grepl(pattern=paste0("(",x,")"),x=PROJECTINFO__$BETACATNAMES))
    if (length(ix__) > 0) {
      ix__ <- ix__[1]
      out__ <- PROJECTINFO__$BETACATREFERENCE[ix__]
    } else {
      out__ <- NULL
    }
    out__
  })
  output__$covariates$catCategories <- lapply(output__$covariates$catNames, function (x) {
    ix__ <- which(grepl(pattern=paste0("(",x,")"),x=PROJECTINFO__$CATNAMES))
    if (length(ix__) > 0) {
      ix__ <- ix__[1]
      out__ <- PROJECTINFO__$CATCATEGORIES[ix__]
    } else {
      out__ <- NULL
    }
    out__
  })
  names(output__$covariates$catCategories) <- output__$covariates$catNames
  paramnames__ <- output__$parameters$names
  paramvalues__ <- output__$parameters$values
  paramstderr__ <- output__$parameters$stderrors
  paramrse__ <- output__$parameters$rse
  FLAGestimated__ <- output__$parameters$FLAGestimated
  ix_omega__ <- which(grepl(pattern="omega\\(",x=paramnames__))
  ix_corr__  <- which(grepl(pattern="corr\\(",x=paramnames__))
  ix_cov__ <- which(grepl(pattern="beta_",x=paramnames__))
  omega_names__  <- paramnames__[ix_omega__]
  omega_values__ <- paramvalues__[ix_omega__]
  omega_stderr__ <- paramstderr__[ix_omega__]
  omega_rse__    <- paramrse__[ix_omega__]
  omega_estimated__ <- FLAGestimated__[ix_omega__]
  corr_names__  <- paramnames__[ix_corr__]
  corr_values__ <- paramvalues__[ix_corr__]
  corr_stderr__ <- paramstderr__[ix_corr__]
  corr_rse__    <- paramrse__[ix_corr__]
  corr_estimated__ <- FLAGestimated__[ix_corr__]
  cov_names__  <- paramnames__[ix_cov__]
  cov_values__ <- paramvalues__[ix_cov__]
  cov_stderr__ <- paramstderr__[ix_cov__]
  cov_rse__    <- paramrse__[ix_cov__]
  cov_estimated__ <- FLAGestimated__[ix_cov__]
  ix_keep__ <- setdiff(1:length(paramnames__),c(ix_omega__, ix_corr__, ix_cov__))
  paramnames__ <- paramnames__[ix_keep__]
  paramvalues__ <- paramvalues__[ix_keep__]
  paramstderr__ <- paramstderr__[ix_keep__]
  paramrse__ <- paramrse__[ix_keep__]
  FLAGestimated__ <- FLAGestimated__[ix_keep__]
  ix_fixed__ <- 1:length(omega_names__)
  fixed_names__  <- paramnames__[ix_fixed__]
  fixed_values__ <- paramvalues__[ix_fixed__]
  fixed_stderr__ <- paramstderr__[ix_fixed__]
  fixed_rse__    <- paramrse__[ix_fixed__]
  fixed_estimated__ <- FLAGestimated__[ix_fixed__]
  output__$rawParameterInfo$fixedEffects$names      <- fixed_names__
  output__$rawParameterInfo$fixedEffects$values     <- fixed_values__
  output__$rawParameterInfo$fixedEffects$stderr     <- fixed_stderr__
  output__$rawParameterInfo$fixedEffects$rse        <- fixed_rse__
  output__$rawParameterInfo$fixedEffects$estimated  <- fixed_estimated__
  output__$rawParameterInfo$fixedEffects$distribution_info  <- output__$inv_trans_randeffects
  output__$rawParameterInfo$randomEffects$names     <- omega_names__
  output__$rawParameterInfo$randomEffects$values    <- omega_values__
  output__$rawParameterInfo$randomEffects$stderr    <- omega_stderr__
  output__$rawParameterInfo$randomEffects$rse       <- omega_rse__
  output__$rawParameterInfo$randomEffects$estimated <- omega_estimated__
  output__$rawParameterInfo$correlation$names       <- corr_names__
  output__$rawParameterInfo$correlation$values      <- corr_values__
  output__$rawParameterInfo$correlation$stderr      <- corr_stderr__
  output__$rawParameterInfo$correlation$rse         <- corr_rse__
  output__$rawParameterInfo$correlation$estimated   <- corr_estimated__
  output__$rawParameterInfo$covariate$names         <- cov_names__
  output__$rawParameterInfo$covariate$values        <- cov_values__
  output__$rawParameterInfo$covariate$stderr        <- cov_stderr__
  output__$rawParameterInfo$covariate$rse           <- cov_rse__
  output__$rawParameterInfo$covariate$estimated     <- cov_estimated__
  if (length(omega_names__)+1 <= length(paramnames__)) {
    ix__ <- (length(omega_names__)+1):length(paramnames__)
    residual_error_names                            <- paramnames__[ix__]
    residual_error_values                           <- paramvalues__[ix__]
    residual_error_stderr                           <- paramstderr__[ix__]
    residual_error_rse__                              <- paramrse__[ix__]
    residual_error_estimated__                        <- FLAGestimated__[ix__]
    output__$rawParameterInfo$errorParameter$names     <- residual_error_names
    output__$rawParameterInfo$errorParameter$values    <- residual_error_values
    output__$rawParameterInfo$errorParameter$stderr    <- residual_error_stderr
    output__$rawParameterInfo$errorParameter$rse       <- residual_error_rse__
    output__$rawParameterInfo$errorParameter$estimated <- residual_error_estimated__
  }
  return(output__)
}
sampleMONOLIXpopulationParameters <- function(input, FLAG_SAMPLE=FALSE, verbose=TRUE) {
  if (is.na(input$objectivefunction$OBJ)) return(NULL)
  if (is.null(input$objectivefunction$OBJ)) return(NULL)
  output__                                      <- list()
  output__$type                                 <- 'MONOLIX'
  output__$path                                 <- input$path
  paramNames__                                  <- input$parameters$names
  values                                      <- input$parameters$values
  covariance                                  <- input$parameters$covariancematrix
  covariance[abs(covariance)<100*.Machine$double.eps] <- 0
  covariance <- matrix(covariance,ncol=ncol(input$parameters$covariancematrix))
  rownames(covariance) <- rownames(input$parameters$covariancematrix)
  colnames(covariance) <- colnames(input$parameters$covariancematrix)
  RUN__ <- TRUE
  count__ <- 1
  while (RUN__) {
    if (FLAG_SAMPLE) {
      if (!is.null(covariance)) {
        VALUESOK__ <- FALSE
        while (!VALUESOK__) {
          VALUESOK__ <- TRUE
          samples__ <- mvrnorm(n=1,mu=values,Sigma=covariance)
          feInfo__ <- input$rawParameterInfo$fixedEffects$distribution_info
          log__ <- grepl("log\\(psi\\)",feInfo__)
          logit__ <- grepl("log\\(psi/\\(1-psi\\)\\)",feInfo__)
          names(log__) <- input$rawParameterInfo$fixedEffects$names
          names(logit__) <- input$rawParameterInfo$fixedEffects$names
          logFEvalues__ <- samples__[names(log__)[log__]]
          logitFEvalues__ <- samples__[names(logit__)[logit__]]
          if (length(logFEvalues__) != 0 & any(logFEvalues__<=0)) VALUESOK__ <- FALSE
          if (length(logitFEvalues__) != 0 & (any(logitFEvalues__<=0 || logitFEvalues__>=1))) VALUESOK__ <- FALSE
          reInfo__ <- samples__[grepl("omega\\(",input$parameters$names)]
          mult__ <- as.numeric(values[grepl("omega\\(",input$parameters$names)] != 0)
          if (any((reInfo__*mult__)<0)) VALUESOK__ <- FALSE
          ixOmegas__ <- grepl("omega(",names(values),fixed=TRUE)
          samples__[ixOmegas__] <- samples__[ixOmegas__]*as.numeric(values[ixOmegas__] != 0)
          errInfo__ <- samples__[grepl("error_",input$parameters$names)]
          if (any(errInfo__<0)) VALUESOK__ <- FALSE
        }
      } else {
        if (verbose) {
          warningIQR('The covariance matrix was not determined => No sampling of population parameters from uncertainty distributions.')
        }
        samples__ <- values
      }
    } else {
      samples__ <- values
      if (verbose) {
        cat('No sampling of population parameters from uncertainty distributions.')
      }
    }
    ixo__   <- which(grepl('omega\\(',paramNames__))
    no__       <- paramNames__[ixo__]
    output__$randomEffects$names  <- aux_strrep(aux_strrep(no__,"omega(",""),")","")
    output__$randomEffects$values <- samples__[ixo__]
    correlationmatrix           <- diag(length(output__$randomEffects$names))
    ixc__                         <- which(grepl('corr\\(',paramNames__))
    recorrelationnames__          <- aux_strrep(aux_strrep(paramNames__[ixc__],'corr(',''),')','')
    recorrelationvalues__         <- samples__[ixc__]
    for (k in seq_along(recorrelationvalues__)) {
      terms <- aux_explode(recorrelationnames__[k],',')
      ix1__ <- which(terms[1]==output__$randomEffects$names)
      ix2__ <- which(terms[2]==output__$randomEffects$names)
      correlationmatrix[ix1__,ix2__] <- recorrelationvalues__[k]
      correlationmatrix[ix2__,ix1__] <- recorrelationvalues__[k]
    }
    output__$randomEffects$correlationmatrix <- correlationmatrix
    output__$randomEffects$covariancematrix <- correlationmatrix*(output__$randomEffects$values%*%t(output__$randomEffects$values))
    suppressWarnings(output__$randomEffects$covariancematrix <- nearPD(output__$randomEffects$covariancematrix))
    if (min(eigen(output__$randomEffects$covariancematrix)$values) >= 0) RUN__ <- FALSE
    count__ <- count__ + 1
    if (count__ > 100) {
      warningIQR("Difficulty to get a possemidef covariance matrix.")
      break()
    }
  }
  output__$randomEffects$transformation <- input$trans_randeffects
  output__$randomEffects$inv_transformation <- input$inv_trans_randeffects
  ix__ <- setdiff(1:length(samples__),c(ixo__, ixc__))
  samples__ <- samples__[ix__]
  paramNames__ <- paramNames__[ix__]
  output__$fixedEffects$names <- output__$randomEffects$names
  output__$fixedEffects$values <- samples__[output__$fixedEffects$names]
  samples__ <- samples__[setdiff(paramNames__,output__$fixedEffects$names)]
  paramNames__ <- setdiff(paramNames__,output__$fixedEffects$names)
  Noutput <- length(input$residualerrormodels)
  removeIX__ <- c()
  if (Noutput > 0) {
    for (k__ in 1:Noutput) {
      outputInfo   <- list()
      outputInfo$alias <- input$residualerrormodels[k__]
      outputInfo$abcr <- c(NA,NA)
      ix__ <- which(paste0('error_ADD', k__)==paramNames__)
      if (length(ix__)>0) {
        outputInfo$abcr[1] <- samples__[ix__]
        removeIX__ <- c(removeIX__, ix__)
      }
      ix__ <- which(paste0('error_PROP', k__)==paramNames__)
      if (length(ix__)>0) {
        outputInfo$abcr[2] <- samples__[ix__]
        removeIX__ <- c(removeIX__, ix__)
      }
      output__$residualErrorModel[[k__]] <- outputInfo
    }
  }
  ix_keep <- setdiff(seq_along(samples__),removeIX__)
  samples__ <- samples__[ix_keep]
  paramNames__ <- paramNames__[ix_keep]
  if (Noutput > 0) {
    for (k__ in 1:Noutput) {
      ix__ <- which(output__$residualErrorModel[[k__]]$alias=='abs')
      if (length(ix__)>0) {
        output__$residualErrorModel[[k__]]$formula <- 'abcr(1).*ones(size(f))'
        output__$residualErrorModel[[k__]]$FlagTransf <- 0
      }
      ix__ <- which(output__$residualErrorModel[[k__]]$alias=='rel')
      if (length(ix__)>0) {
        output__$residualErrorModel[[k__]]$formula <- 'abcr(2).*f'
        output__$residualErrorModel[[k__]]$FlagTransf <- 0
      }
      ix__ <- which(output__$residualErrorModel[[k__]]$alias=='absrel')
      if (length(ix__)>0) {
        output__$residualErrorModel[[k__]]$formula <- 'abcr(1) + abcr(2).*f'
        output__$residualErrorModel[[k__]]$FlagTransf <- 0
      }
    }
  }
  ix__            <- which(grepl('beta_',paramNames__))
  covariates      <- paramNames__[ix__]
  covariatevalues <- samples__[ix__]
  ix_keep      <- setdiff(seq_along(samples__),ix__)
  samples__    <- samples__[ix_keep]
  paramNames__   <- paramNames__[ix_keep]
  categorical_covariates              <- list()
  categorical_covariates$parameter    <- c()
  categorical_covariates$covariate    <- c()
  for (k__ in seq_along(input$PROJECTINFO$BETACATNAMES)) {
    if (nchar(input$PROJECTINFO$BETACATNAMES[k__]) > 0) {
      bcnk <- input$PROJECTINFO$BETACATNAMES[k__]
      bcnk <- aux_strrep(bcnk,'beta_','')
      bcnk <- aux_strrep(bcnk,'(',',')
      bcnk <- aux_strrep(bcnk,')','')
      terms <- aux_explodePC(bcnk)
      catname <- terms[2]
      ix_cat <- which(catname==input$PROJECTINFO$CATNAMES)
      BETACATCATEGORIES <- input$PROJECTINFO$CATCATEGORIES[ix_cat]
      xx <- aux_strrep(BETACATCATEGORIES,"[","c(")
      xx <- aux_strrep(xx,"]",")")
      xx <- aux_strrep(xx," ",",")
      categories <- eval(parse(text=xx))
      reference  <- as.double(input$PROJECTINFO$BETACATREFERENCE[k__])
      categorical_covariates$parameter <- c(categorical_covariates$parameter, terms[1])
      categorical_covariates$covariate <- c(categorical_covariates$covariate, terms[2])
      categorical_covariates$categories[[k__]] <- categories
      categorical_covariates$reference <- c(categorical_covariates$reference, reference)
      values_cat <- c()
      for (k2__ in seq_along(categories)) {
        n__ <- sprintf("beta_%s(%s_%d)",terms[1],terms[2],categories[k2__])
        if (categories[k2__] == reference) {
          value <- 0
        } else {
          value <- covariatevalues[which(n__==covariates)]
        }
        values_cat <- c(values_cat,value)
      }
      categorical_covariates$value[[k__]] <- values_cat
    }
  }
  continuous_covariates <- list()
  continuous_covariates$parameter <- c()
  continuous_covariates$covariate <- c()
  continuous_covariates$formula   <- c()
  continuous_covariates$value     <- c()
  for (k__ in seq_along(input$PROJECTINFO$BETACOVNAMES)) {
    if (nchar(input$PROJECTINFO$BETACOVNAMES[k__]) > 0) {
      bcnk <- input$PROJECTINFO$BETACOVNAMES[k__]
      bcnk <- aux_strrep(bcnk,'beta_','')
      bcnk <- aux_strrep(bcnk,'(',',')
      bcnk <- aux_strrep(bcnk,')','')
      terms <- aux_explodePC(bcnk)
      continuous_covariates$parameter  <- c(continuous_covariates$parameter, terms[1])
      continuous_covariates$covariate  <- c(continuous_covariates$covariate, terms[2])
      continuous_covariates$formula    <- c(continuous_covariates$formula, input$PROJECTINFO$BETACOVTRANS[k__])
      n__ <- sprintf("beta_%s(%s)",terms[1],terms[2])
      continuous_covariates$value      <- c(continuous_covariates$value, covariatevalues[which(n__==covariates)])
    }
  }
  continuous <- list()
  for (k__ in seq_along(continuous_covariates$parameter)) {
    if (k__==1) {
      continuous[[k__]] <- list(
        parameter  = continuous_covariates$parameter[k__],
        covariates = continuous_covariates$covariate[k__],
        values     = continuous_covariates$value[k__],
        formula    = continuous_covariates$formula[k__])
    } else {
      ix__ <- which(continuous_covariates$parameter[k__]==sapply(continuous,function(x) x$parameter))
      if (length(ix__) == 0) {
        continuous[[length(continuous)+1]] <- list(
          parameter  = continuous_covariates$parameter[k__],
          covariates = continuous_covariates$covariate[k__],
          values     = continuous_covariates$value[k__],
          formula    = continuous_covariates$formula[k__])
      } else {
        continuous[[ix__]]$covariates <- c(continuous[[ix__]]$covariates, continuous_covariates$covariate[k__])
        continuous[[ix__]]$values     <- c(continuous[[ix__]]$values, continuous_covariates$value[k__])
        continuous[[ix__]]$formula    <- c(continuous[[ix__]]$formula, continuous_covariates$formula[k__])
      }
    }
  }
  output__$covariates$continuous <- continuous
  categorical <- list()
  for (k__ in seq_along(categorical_covariates$parameter)) {
    if (k__==1) {
      information <- list()
      information[[1]] <- list(
        categories = categorical_covariates$categories[k__],
        values = categorical_covariates$value[k__]
      )
      categorical[[k__]] <- list(
        parameter  = categorical_covariates$parameter[k__],
        covariates = categorical_covariates$covariate[k__],
        information = information)
    } else {
      ix__ <- which(categorical_covariates$parameter[k__]==sapply(categorical,function(x) x$parameter))
      if (length(ix__) == 0) {
        information <- list()
        information[[1]] <- list(categories = categorical_covariates$categories[k__],
                                 values = categorical_covariates$value[k__]
        )
        categorical[[length(categorical)+1]] <- list(
          parameter  = categorical_covariates$parameter[k__],
          covariates = categorical_covariates$covariate[k__],
          information = information)
      } else {
        information <- list()
        information[[1]] <- list(
          categories = categorical_covariates$categories[k__],
          values = categorical_covariates$value[k__]
        )
        categorical[[ix__]]$covariates <- c(categorical[[ix__]]$covariates, categorical_covariates$covariate[k__])
        categorical[[ix__]]$information[[length(categorical[[ix__]]$information)+1]] <- list(
          categories = categorical_covariates$categories[k__],
          values = categorical_covariates$value[k__]
        )
      }
    }
  }
  output__$covariates$categorical <- categorical
  if (length(paramNames__)>0) {
    if (!is.na(paramNames__[1])) {
      warningIQR('The MONOLIX output contained information that are currently not handled.')
    }
  }
  return(output__)
}
read_ETA_INDIV_PRED_MONOLIXoutputTables <- function (projectPath) {
  tableInfo__ <- list()
  PROJECTINFO__ <- parseMONOLIXprojectHeader(projectPath)
  oldpath__ <- getwd()
  setwd(projectPath)
  data__ <- IQRloadCSVdata(PROJECTINFO__$DATA)
  setwd(oldpath__)
  if (length(PROJECTINFO__$COVARIATENAMES) > 0) {
    if (nchar(PROJECTINFO__$COVARIATENAMES[1]) > 0) {
      covariates__ <- unique(data__[,c("ID",PROJECTINFO__$COVARIATENAMES)])
      covariates__ <- do.call(rbind,lapply(split(covariates__,covariates__$ID), function (x__) {
        x__[1,]
      }))
    } else {
      covariates__ <- NULL
    }
  } else {
    covariates__ <- NULL
  }
  etafile__ <- paste0(projectPath,"/RESULTSORIG/IndividualParameters/estimatedRandomEffects.txt")
  if (file.exists(etafile__)) {
    eta__ <- utils::read.csv(etafile__)
    eta__ <- cbind(ID=eta__$id, eta__)
    if (any(grepl("_mode",names(eta__)))) {
      eta__ <- eta__[,names(eta__)=="ID" | grepl("_mode",names(eta__))]
    } else {
      eta__ <- eta__[,names(eta__)=="ID" | grepl("_SAEM\\>",names(eta__))]
    }
    names(eta__) <- gsub("^eta_","ETA_", names(eta__))
    names(eta__) <- gsub("_mode$","", names(eta__))
    names(eta__) <- gsub("_SAEM$","", names(eta__))
    if (!is.null(covariates__)) {
      eta__ <- dplyr::left_join(eta__,covariates__,by="ID")
    }
    tableInfo__$ETA <- eta__
  } else {
    tableInfo__$ETA <- NULL
  }
  indivfile__ <- paste0(projectPath,"/RESULTSORIG/IndividualParameters/estimatedIndividualParameters.txt")
  if (file.exists(indivfile__)) {
    indiv__ <- utils::read.csv(indivfile__)
    indiv__ <- cbind(ID=indiv__$id, indiv__)
    if (any(grepl("_mode",names(indiv__)))) {
      indiv__ <- indiv__[,names(indiv__)=="ID" | grepl("_mode",names(indiv__))]
    } else {
      indiv__ <- indiv__[,names(indiv__)=="ID" | grepl("_SAEM\\>",names(indiv__))]
    }
    names(indiv__) <- aux_strrep(names(indiv__),"_mode","")
    names(indiv__) <- aux_strrep(names(indiv__),"_SAEM","")
    if (!is.null(covariates__)) {
      indiv__ <- dplyr::right_join(indiv__,covariates__,by="ID")
    }
    tableInfo__$INDIV <- indiv__
  } else {
    tableInfo__$INDIV <- NULL
  }
  SINGLE__ <- FALSE
  if (length(PROJECTINFO__$OUTPUTS) == 1) SINGLE__ <- TRUE
  DVcolName <- NULL
  IPREDcolName <- NULL
  IWREScolName <- NULL
  XWREScolName <- NULL
  XPREDcolName <- NULL
  pred__ <- do.call(rbind,lapply(seq_along(PROJECTINFO__$OUTPUTS), function (k__) {
    if (k__==1 & SINGLE__) {
      predfile__ <- paste0(projectPath,"/RESULTSORIG/predictions.txt")
    } else {
      predfile__ <- paste0(projectPath,"/RESULTSORIG/predictions_y",k__,".txt")
    }
    if (!file.exists(predfile__)) return(NULL)
    predkMLX__ <- utils::read.csv(predfile__)
    predkMLX__ <- cbind(ID=predkMLX__$id, predkMLX__)
    if (k__==1 & SINGLE__) {
      resfile__ <- paste0(projectPath,"/RESULTSORIG/ChartsData/ScatterPlotOfTheResiduals/y_residuals.txt")
    } else {
      resfile__ <- paste0(projectPath,"/RESULTSORIG/ChartsData/ScatterPlotOfTheResiduals/y",k__,"_residuals.txt")
    }
    if (file.exists(resfile__)) {
      reskMLX__ <- utils::read.csv(resfile__)
      if (nrow(predkMLX__) != nrow(reskMLX__)) {
        stopIQR("Issue with number of rows in predictions vs residuals file - MONOLIX >=2018R1")
      }
      predkMLX__$NPDE <- reskMLX__$npde
      predkMLX__$pwRes <- reskMLX__$pwRes
    } else {
      predkMLX__$NPDE <- NA
      predkMLX__$pwRes <- NA
    }
    if (SINGLE__) {
      DVcolName <<- "y"
    } else {
      DVcolName <<- paste0("y",k__)
    }
    if ("indivPred_mode" %in% names(predkMLX__)) {
      IPREDcolName <<- "indivPred_mode"
    } else {
      IPREDcolName <<- "indivPred_SAEM"
    }
    if ("indWRes_mode" %in% names(predkMLX__)) {
      IWREScolName <<- "indWRes_mode"
    } else {
      IWREScolName <<- "indWRes_SAEM"
    }
    XWREScolName <<- "pwRes"
    XPREDcolName <<- "popPred"
    predk__ <- data.frame(ID=predkMLX__$ID,
                          TIME=predkMLX__$time,
                          TIME2=predkMLX__$time,
                          TAD=NA,
                          YTYPE=k__,
                          MDV=0,   
                          EVID=0,  
                          CENS=0,
                          DV=predkMLX__[[DVcolName]],
                          IPRED=predkMLX__[[IPREDcolName]],
                          IRES=NA,
                          IWRES=predkMLX__[[IWREScolName]],
                          NPDE=predkMLX__$NPDE,
                          XPRED=predkMLX__[[XPREDcolName]],
                          XRES=NA,
                          XWRES=predkMLX__[[XWREScolName]])
    if (length(PROJECTINFO__$COVARIATENAMES) > 0) {
      if (nchar(PROJECTINFO__$COVARIATENAMES[1]) > 0) {
        datak__ <- data__[data__$EVID==0 & data__$MDV==0 & data__$YTYPE==k__,c("ID","TIME","TIMEPOS","TAD","CENS",PROJECTINFO__$COVARIATENAMES)]
      } else {
        datak__ <- data__[data__$EVID==0 & data__$MDV==0 & data__$YTYPE==k__,c("ID","TIME","TIMEPOS","TAD","CENS")]
      }
    } else {
      datak__ <- data__[data__$EVID==0 & data__$MDV==0 & data__$YTYPE==k__,c("ID","TIME","TIMEPOS","TAD","CENS")]
    }
    if (nrow(datak__) != nrow(predkMLX__))
      stopIQR("Issue with lengths of datasets - Monolix output vs. data")
    if ("TIMEPOS" %in% names(datak__)) predk__$TIME2 <- datak__$TIMEPOS
    if ("TAD" %in% names(datak__)) predk__$TAD <- datak__$TAD
    if ("CENS" %in% names(datak__)) predk__$CENS <- datak__$CENS
    dummy__ <- sapply(PROJECTINFO__$COVARIATENAMES, function (x) predk__[[x]] <<- datak__[[x]])
    predk__
  }))
  if (!is.null(pred__)) {
    pred__ <- dplyr::arrange(pred__,ID,TIME,YTYPE)
    tableInfo__$PRED <- pred__
  }
  attr(tableInfo__,"paramNames")     <- PROJECTINFO__$PARAMNAMES
  attr(tableInfo__,"covariateNames") <- PROJECTINFO__$COVARIATENAMES
  attr(tableInfo__,"covNames")       <- PROJECTINFO__$COVNAMES
  attr(tableInfo__,"catNames")       <- PROJECTINFO__$CATNAMES
  attr(tableInfo__,"ALT_NAMES_USED") <- c("XPRED", "XWRES", "IPRED", "IWRES")
  attr(tableInfo__,"ALT_NAMES_ORIG") <- c(XPREDcolName,XWREScolName,IPREDcolName,IWREScolName)
  return(tableInfo__)
}
#'@export
is_installed_NLMIXR <- function () {
  "nlmixr" %in% rownames(utils::installed.packages())
}
#'@export
is_NLMIXR_IQRnlmeProject <- function (projectPath) {
  testfile__ <- paste0(projectPath,'/','project_NLMIXR.R')
  if (file.exists(testfile__)) return(hasHeader_IQRnlmeProject(testfile__))
  return(FALSE)
}
genIQRnlmeNLMIXRproject <- function(est,comment,verbose=TRUE) {
  nlmixr.method                 <- est$algorithmSpec$nlmixr.method
  nlmixr.control                <- est$algorithmSpec$nlmixr.control
  oldPath__ <- getwd()
  setwd(est$projectPath)
  datafileName <- paste0(est$data$relPathFromProject,"/",est$data$fileName)
  if (!file.exists(datafileName)) {
    setwd(oldPath__)
    stopIQR("Please check your working directory. The data file can not be found.")
  }
  data <- IQRloadCSVdata(datafileName)
  setwd(oldPath__)
  catCovariateValues <- unique(unlist(data[,est$data$catNames,drop=FALSE]))
  if (length(setdiff(catCovariateValues,c(0,1))) > 0) {
    stopIQR("Categorical covariates for NLMIXR can only contain levels 0 and 1 where 0 is the reference group")
  }
  if (any(data$CENS==1)) {
    stopIQR("The M3/M4 method using CENS=1 in the dataset is not available for NLMIXR yet")
  }
  if (any(data$EVID==0 & data$MDV==1)) {
    warningIQR("The MDV column is ignored for NLMIXR - during conversion to the RxODE dataset the MDV=1 observations will be removed")
  }
  ALLCONTENT__ <- ""
  ALLCONTENT__ <- paste0(ALLCONTENT__,"# NLMIXR project generated with IQRtools\n")
  ALLCONTENT__ <- paste0(ALLCONTENT__,"\n")
  ALLCONTENT__ <- paste0(ALLCONTENT__,"# ==PROJECT HEADER START===================================================\n")
  ALLCONTENT__ <- paste0(ALLCONTENT__,"PROJECT_HEADER_PLACEHOLDER\n")
  ALLCONTENT__ <- paste0(ALLCONTENT__,"# ==PROJECT HEADER END=====================================================\n")
  ALLCONTENT__ <- paste0(ALLCONTENT__,"\n")
  ALLCONTENT__ <- paste0(ALLCONTENT__,"# ----------------------------------------\n")
  ALLCONTENT__ <- paste0(ALLCONTENT__,"# Load dataset and convert to RxODE format\n")
  ALLCONTENT__ <- paste0(ALLCONTENT__,"# ----------------------------------------\n")
  dataFilePath__ <- paste0(est$data$relPathFromProject,"/",est$data$fileName)
  ALLCONTENT__ <- paste0(ALLCONTENT__,"dataNLMIXR <- convertDataRxODE_IQRnlmixr(\"",dataFilePath__,"\")\n")
  ALLCONTENT__ <- paste0(ALLCONTENT__,"IQRsaveCSVdata(dataNLMIXR,\"dataNLMIXR.csv\")\n")
  ALLCONTENT__ <- paste0(ALLCONTENT__,"\n")
  ALLCONTENT__ <- paste0(ALLCONTENT__,"# ----------------------------------------\n")
  ALLCONTENT__ <- paste0(ALLCONTENT__,"# Define the NLMIXR model function\n")
  ALLCONTENT__ <- paste0(ALLCONTENT__,"# ----------------------------------------\n")
  ALLCONTENT__ <- paste0(ALLCONTENT__,"modelNLMIXR <- function() {\n")
  ALLCONTENT__ <- paste0(ALLCONTENT__,"  ini({\n")
  PARGUESS__ <- genINI_IQRnlmixr(est)
  ALLCONTENT__ <- paste0(ALLCONTENT__,PARGUESS__,"\n")
  ALLCONTENT__ <- paste0(ALLCONTENT__,"  })\n")
  ALLCONTENT__ <- paste0(ALLCONTENT__,"  model({\n")
  PARTRANSINFO__ <- genModelParInfo_IQRnlmixr(est)
  ALLCONTENT__ <- paste0(ALLCONTENT__,PARTRANSINFO__$output)
  modelRxODEtext__ <- aux_strtrim(genRxODEmodel_IQRnlmixr(est))
  ALLCONTENT__ <- paste0(ALLCONTENT__,"\n",modelRxODEtext__,"\n")
  ALLCONTENT__ <- paste0(ALLCONTENT__,"\n")
  ALLCONTENT__ <- paste0(ALLCONTENT__,"# Error model\n")
  errorModelText__ <- aux_strtrim(genERRORmodel_IQRnlmixr(est))
  ALLCONTENT__ <- paste0(ALLCONTENT__,"    ",errorModelText__,"\n")
  ALLCONTENT__ <- paste0(ALLCONTENT__,"  })\n")
  ALLCONTENT__ <- paste0(ALLCONTENT__,"}\n")
  ALLCONTENT__ <- paste0(ALLCONTENT__,"\n")
  ALLCONTENT__ <- paste0(ALLCONTENT__,"# ----------------------------------------\n")
  ALLCONTENT__ <- paste0(ALLCONTENT__,"# Define NLMIXR method/control settings\n")
  ALLCONTENT__ <- paste0(ALLCONTENT__,"# ----------------------------------------\n")
  ALLCONTENT__ <- paste0(ALLCONTENT__,"nlmixr.method <- \"",tolower(nlmixr.method),"\"\n")
  ALLCONTENT__ <- paste0(ALLCONTENT__,getControlNLMIXRsettings(est$algorithmSpec))
  ALLCONTENT__ <- paste0(ALLCONTENT__,"\n")
  ALLCONTENT__ <- paste0(ALLCONTENT__,"# ----------------------------------------\n")
  ALLCONTENT__ <- paste0(ALLCONTENT__,"# Run the NLMIXR model\n")
  ALLCONTENT__ <- paste0(ALLCONTENT__,"# ----------------------------------------\n")
  ALLCONTENT__ <- paste0(ALLCONTENT__,"fit <- nlmixr::nlmixr(modelNLMIXR,dataNLMIXR,est=nlmixr.method,control=nlmixr.control,table=nlmixr::tableControl(npde=TRUE,cwres=TRUE))\n")
  ALLCONTENT__ <- paste0(ALLCONTENT__,"\n")
  ALLCONTENT__ <- paste0(ALLCONTENT__,"# ----------------------------------------\n")
  ALLCONTENT__ <- paste0(ALLCONTENT__,"# Store fit as Rdata object\n")
  ALLCONTENT__ <- paste0(ALLCONTENT__,"# ----------------------------------------\n")
  ALLCONTENT__ <- paste0(ALLCONTENT__,"save(fit,file=\"RESULTSORIG/project.fit\")\n")
  PROJECT_INFO_TEXT__ <- ''
  COMMENT_info__ <- sprintf("# COMMENT             = '%s'\n",comment)
  PROJECT_INFO_TEXT__ <- sprintf('%s%s',PROJECT_INFO_TEXT__,COMMENT_info__)
  TOOL_info__ <- sprintf("# TOOL                = 'NLMIXR'\n")
  PROJECT_INFO_TEXT__ <- sprintf('%s%s',PROJECT_INFO_TEXT__,TOOL_info__)
  PROJECTFILE_info__ <- sprintf("# FILE                = 'project_NLMIXR.R'\n")
  PROJECT_INFO_TEXT__ <- sprintf('%s%s',PROJECT_INFO_TEXT__,PROJECTFILE_info__)
  METHOD_info__ <- sprintf("# METHOD              = '%s'\n",est$algorithmSpec$nlmixr.method)
  PROJECT_INFO_TEXT__ <- sprintf('%s%s',PROJECT_INFO_TEXT__,METHOD_info__)
  DATA_info__ <- sprintf("# DATA                = '%s'\n",aux_strrep(paste0(est$data$relPathFromProject,"/",est$data$fileName),'//','/'))
  PROJECT_INFO_TEXT__ <- sprintf("%s%s",PROJECT_INFO_TEXT__,DATA_info__)
  x__ <- paste0(est$dosingInfo$types,collapse=",")
  DOSINGTYPES_info__ <- sprintf("# DOSINGTYPES         = '%s'\n",x__)
  PROJECT_INFO_TEXT__ <- sprintf("%s%s",PROJECT_INFO_TEXT__,DOSINGTYPES_info__)
  x <- as.character(est$dosingInfo$TK0times)
  x[is.na(x)] <- "NA"
  x <- paste0(x,collapse=",")
  TK0NAMES_info__ <- sprintf("# TK0NAMES            = '%s'\n",x)
  PROJECT_INFO_TEXT__ <- sprintf("%s%s",PROJECT_INFO_TEXT__,TK0NAMES_info__)
  x__ <- paste0(est$data$covNames,collapse = ",")
  COVNAMES_info__ <- sprintf("# COVNAMES            = '%s'\n",x__)
  PROJECT_INFO_TEXT__ <- sprintf("%s%s",PROJECT_INFO_TEXT__,COVNAMES_info__)
  x__ <- paste0(est$data$catNames,collapse = ",")
  CATNAMES_info__ <- sprintf("# CATNAMES            = '%s'\n",x__)
  PROJECT_INFO_TEXT__ <- sprintf("%s%s",PROJECT_INFO_TEXT__,CATNAMES_info__)
  x__ <- paste0(sapply(est$modelInfo$param_reg, function(x) x$name),collapse = ",")
  REGRESSNAMES_info__ <- sprintf("# REGRESSIONNAMES     = '%s'\n",x__)
  PROJECT_INFO_TEXT__ <- sprintf("%s%s",PROJECT_INFO_TEXT__,REGRESSNAMES_info__)
  x__ <- paste0(sapply(est$modelInfo$outputs, function(x) x$formula),collapse = ",")
  OUTPUTS_info__ <- sprintf("# OUTPUTS             = '%s'\n",x__)
  PROJECT_INFO_TEXT__ <- sprintf("%s%s",PROJECT_INFO_TEXT__,OUTPUTS_info__)
  x__ <- paste0(sapply(est$modelSpec$errorModel, function(x) x[1]),collapse = ",")
  ERRORMODELS_info__ <- sprintf("# ERRORMODELS         = '%s'\n",x__)
  PROJECT_INFO_TEXT__ <- sprintf("%s%s",PROJECT_INFO_TEXT__,ERRORMODELS_info__)
  ERRnames__ <- NULL
  NRerrParams__ <- 0
  for (k in seq_along(est$modelSpec$errorModel)) {
    if (est$modelSpec$errorModel[[k]][1] == "abs") {
      NRerrParams__ <- NRerrParams__+1
      ERRnames__ <- c(ERRnames__,paste0("error_ADD",k))
    }
    if (est$modelSpec$errorModel[[k]][1] == "rel") {
      NRerrParams__ <- NRerrParams__+1
      ERRnames__ <- c(ERRnames__,paste0("error_PROP",k))
    }
    if (est$modelSpec$errorModel[[k]][1] == "absrel") {
      NRerrParams__ <- NRerrParams__+2
      ERRnames__ <- c(ERRnames__,paste0("error_ADD",k),paste0("error_PROP",k))
    }
  }
  ERRORNAMES_info__ <- paste0("# ERRORNAMES          = '",paste0(ERRnames__,collapse = ","),"'\n")
  PROJECT_INFO_TEXT__ <- sprintf("%s%s",PROJECT_INFO_TEXT__,ERRORNAMES_info__)
  x__ <- paste0(PARTRANSINFO__$parameters,collapse = ",")
  PARAMNAMES_info__ <- sprintf("# PARAMNAMES          = '%s'\n",x__)
  PROJECT_INFO_TEXT__ <- sprintf("%s%s",PROJECT_INFO_TEXT__,PARAMNAMES_info__)
  x__ <- paste0(PARTRANSINFO__$paramsInit,collapse = ",")
  PARAMGUESS_info__ <- sprintf("# PARAMGUESS          = '%s'\n",x__)
  PROJECT_INFO_TEXT__ <- sprintf("%s%s",PROJECT_INFO_TEXT__,PARAMGUESS_info__)
  x__ <- paste0(PARTRANSINFO__$paramsEstimated,collapse = ",")
  PARAMESTIMATE_info__ <- sprintf("# PARAMESTIMATE       = '%s'\n",x__)
  PROJECT_INFO_TEXT__ <- sprintf("%s%s",PROJECT_INFO_TEXT__,PARAMESTIMATE_info__)
  augmentedwithCovs__ <- c(est$modelSpec$IIVdistribution, rep("NA",length(PARTRANSINFO__$parameters)-length(est$modelSpec$IIVdistribution)))
  PARAM_TRANSNAME_STRING__ <- sapply(augmentedwithCovs__, function (x__) {
    if (x__=="L") return("exp(phi)")
    if (x__=="N") return("phi")
    if (x__=="G") return("exp(phi)/(1+exp(phi))")
    if (x__=="NA") return("")
  })
  x__ <- paste0(PARAM_TRANSNAME_STRING__,collapse = ",")
  PARAMTRANS_info__ <- sprintf("# PARAMTRANS          = '%s'\n",x__)
  PROJECT_INFO_TEXT__ <- sprintf("%s%s",PROJECT_INFO_TEXT__,PARAMTRANS_info__)
  augmentedwithCovs__ <- c(est$modelSpec$IIVdistribution, rep("NA",length(PARTRANSINFO__$parameters)-length(est$modelSpec$IIVdistribution)))
  PARAM_INVTRANSNAME_STRING__ <- sapply(augmentedwithCovs__, function (x__) {
    if (x__=="L") return("log(psi)")
    if (x__=="N") return("psi")
    if (x__=="G") return("log(psi/(1-psi))")
    if (x__=="NA") return("")
  })
  x__ <- paste0(PARAM_INVTRANSNAME_STRING__,collapse = ",")
  PARAMINVTRANS_info__ <- sprintf("# PARAMINVTRANS       = '%s'\n",x__)
  PROJECT_INFO_TEXT__ <- sprintf("%s%s",PROJECT_INFO_TEXT__,PARAMINVTRANS_info__)
  x__ <- paste0(c(est$data$covNames,est$data$catNames),collapse = ",")
  COVARIATENAMES_info__ <- sprintf("# COVARIATENAMES      = '%s'\n",x__)
  PROJECT_INFO_TEXT__ <- sprintf("%s%s",PROJECT_INFO_TEXT__,COVARIATENAMES_info__)
  x__ <- paste0(unique(unlist(est$modelSpec$covariateModel)),collapse = ",")
  COVARIATESUSED_info__ <- sprintf("# COVARIATESUSED      = '%s'\n",x__)
  PROJECT_INFO_TEXT__ <- sprintf("%s%s",PROJECT_INFO_TEXT__,COVARIATESUSED_info__)
  x__ <- paste0(PARTRANSINFO__$covParam,collapse = ",")
  BETACOVNAMES_info__ <- sprintf("# BETACOVNAMES        = '%s'\n",x__)
  PROJECT_INFO_TEXT__ <- sprintf("%s%s",PROJECT_INFO_TEXT__,BETACOVNAMES_info__)
  x__ <- paste0(PARTRANSINFO__$covTrans,collapse = ",")
  BETACOVTRANS_info__ <- sprintf("# BETACOVTRANS        = '%s'\n",x__)
  PROJECT_INFO_TEXT__ <- sprintf("%s%s",PROJECT_INFO_TEXT__,BETACOVTRANS_info__)
  x__ <- paste0(PARTRANSINFO__$catParam,collapse = ",")
  BETACATNAMES_info__ <- sprintf("# BETACATNAMES        = '%s'\n",x__)
  PROJECT_INFO_TEXT__ <- sprintf("%s%s",PROJECT_INFO_TEXT__,BETACATNAMES_info__)
  x__ <- paste0(PARTRANSINFO__$catRef,collapse = ",")
  BETACATREFERENCE_info__ <- sprintf("# BETACATREFERENCE    = '%s'\n",x__)
  PROJECT_INFO_TEXT__ <- sprintf("%s%s",PROJECT_INFO_TEXT__,BETACATREFERENCE_info__)
  x__ <- paste0(sapply(PARTRANSINFO__$betacatcategories, function(x__) {
    paste0("[",paste(x__,collapse = " "),"]")
  }),collapse = ",")
  BETACATCATEGORIES_info__ <- sprintf("# BETACATCATEGORIES   = '%s'\n",x__)
  PROJECT_INFO_TEXT__ <- sprintf("%s%s",PROJECT_INFO_TEXT__,BETACATCATEGORIES_info__)
  x__ <- paste0(c(PARTRANSINFO__$parameters,ERRnames__),collapse = ",")
  THETANAMES_info__ <- sprintf("# THETANAMES          = '%s'\n",x__)
  PROJECT_INFO_TEXT__ <- sprintf("%s%s",PROJECT_INFO_TEXT__,THETANAMES_info__)
  x__ <- paste0(c(PARTRANSINFO__$paramsEstimated,rep(1,NRerrParams__)),collapse = ",")
  x__ <- THETAESTIMATE_info__ <- sprintf("# THETAESTIMATE       = '%s'\n",x__)
  PROJECT_INFO_TEXT__ <- sprintf("%s%s",PROJECT_INFO_TEXT__,THETAESTIMATE_info__)
  x__ <- paste0("omega(",sapply(est$modelInfo$param_est,function(x__) x__$name),")",collapse=",")
  ETANAMES_info__ <- sprintf("# ETANAMES            = '%s'\n",x__)
  PROJECT_INFO_TEXT__ <- sprintf("%s%s",PROJECT_INFO_TEXT__,ETANAMES_info__)
  ETAESTIMATE__ <- paste0(est$modelSpec$IIVestimate,collapse = ",")
  ETAESTIMATE_info__ <- sprintf("# ETAESTIMATE         = '%s'\n",ETAESTIMATE__)
  PROJECT_INFO_TEXT__ <- sprintf("%s%s",PROJECT_INFO_TEXT__,ETAESTIMATE_info__)
  cov__ <- est$modelSpec$covarianceModel
  text__ <- c()
  for (k__ in seq_along(cov__)) {
    covk__ <- aux_explode(cov__[k__])
    for (k1__ in seq_along(covk__)) {
      for (k2__ in 1:k1__) {
        if (k1__!=k2__) text__ <- c(text__, sprintf("corr(%s,%s)",covk__[k2__],covk__[k1__]))
      }
    }
  }
  x__<- paste(text__,collapse = ",")
  CORR_info__ <- sprintf("# CORRELATIONNAMES    = '%s'\n",x__)
  PROJECT_INFO_TEXT__ <- sprintf("%s%s",PROJECT_INFO_TEXT__,CORR_info__)
  if (length(text__)>0) {
    CORRestimate__ <- rep(1,length(text__))
    x__ <- paste(CORRestimate__,collapse = ",")
    CORRESTIMATE_info__ <- sprintf("# CORRESTIMATE        = '%s'\n",x__)
  } else {
    CORRestimate__ <- NULL
    CORRESTIMATE_info__ <- sprintf("# CORRESTIMATE        = ''\n")
  }
  PROJECT_INFO_TEXT__ <- sprintf("%s%s",PROJECT_INFO_TEXT__,CORRESTIMATE_info__)
  x__ <- est$data$dataModeling[est$data$dataModeling$MDV==0,]
  nrOUTPUTS__ <- length(est$modelInfo$outputs)
  x__ <- x__[x__$YTYPE <= nrOUTPUTS__,]
  nOBS__ <- nrow(x__)
  NROBS_info__ <- sprintf("# NROBSERVATIONS      = '%d'\n",nOBS__)
  PROJECT_INFO_TEXT__ <- sprintf("%s%s",PROJECT_INFO_TEXT__,NROBS_info__)
  NRPARAMETERS_ESTIMATED__ <-
    sum(PARTRANSINFO__$paramsEstimated) +  
    sum(est$modelSpec$IIVestimate) + 
    sum(CORRestimate__) + 
    NRerrParams__ 
  NRPARAMETERS_ESTIMATED_info__ <- sprintf("# NRPARAM_ESTIMATED   = '%d'\n",NRPARAMETERS_ESTIMATED__)
  PROJECT_INFO_TEXT__ <- sprintf("%s%s",PROJECT_INFO_TEXT__,NRPARAMETERS_ESTIMATED_info__)
  ALLCONTENT__ <- aux_strrep(ALLCONTENT__,"PROJECT_HEADER_PLACEHOLDER",aux_strtrim(PROJECT_INFO_TEXT__))
  IQRoutputFile(ALLCONTENT__,filename=paste0(est$projectPath,"/project_NLMIXR.R"))
}
getControlNLMIXRsettings <- function(algorithmSpec) {
  method <- toupper(algorithmSpec$nlmixr.method)
  control <- algorithmSpec$nlmixr.control
  out__ <- paste0("nlmixr.control <- ",control,"\n")
  if (method=="SAEM") {
    if (!grepl("\\<nBurn\\>",control)) out__ <- paste0(out__,"nlmixr.control$mcmc$niter[1] <- ",algorithmSpec$K1,"\n")
    if (!grepl("\\<nEm\\>",control)) out__ <- paste0(out__,"nlmixr.control$mcmc$niter[2] <- ",algorithmSpec$K2,"\n")
    if (!grepl("\\<seed\\>",control)) out__ <- paste0(out__,"nlmixr.control$seed <- ",algorithmSpec$SEED,"\n")
    if (!grepl("\\<nmc\\>",control)) out__ <- paste0(out__,"nlmixr.control$mcmc$nmc <- ",algorithmSpec$NRCHAINS,"\n")
  }
  return(out__)
}
runNLMIXRproject <- function(projectPath,ncores=1,FLAGclean=TRUE) {
  assign("last.warning", NULL, envir = baseenv())
  if (.Platform$OS.type=="windows" & ncores > 1) {
    warningIQR("Parallel processing not supported for NLMIXR on Windows")
    ncores = 1;
  }
  oldPath____ <- getwd()
  setwd(projectPath)
  terminationMessage <- ""
  tryCatch({
    source("project_NLMIXR.R")
  }, error = function (err) {
    terminationMessage <<- paste0("NLMIXR stopped with the following error message:\n",err$message)
  })
  tryCatch({
    if (FLAGclean) {
      cleanUpNLMIXR()
    }
  }, error = function(e) {
    warningIQR(paste0('Problem with cleanup after NLMIXR',e))
  })
  setwd(oldPath____)
  if (nchar(terminationMessage) > 0) {
    stopIQR(terminationMessage)
  }
  x__ <- parseNLMIXRresults(projectPath)
  info__ <- deparse(x__)
  aux_filewrite(info__,filename=sprintf('%s/RESULTS/project_results.x',projectPath))
  genTablesNLMIXRfit(projectPath)
  tryCatch({
    createNLMIXRresultsTable(projectPath,filename=sprintf('%s/RESULTS/project_results.txt',projectPath))
  }, error = function(e) {
    warningIQR(paste0('Problem with creation of results table.',e))
  })
  convertETAINDIVPRED_IQRnlmeProject(projectPath,paste0(projectPath,"/RESULTS"))
}
cleanUpNLMIXR <- function () {
  unlink("*.inv")
  loadedDLLs__ <- names(getLoadedDLLs())
  loadedFILE_NLMIXR_DLLs__ <- loadedDLLs__[grepl("\\<(rx|saem)",loadedDLLs__)]
  dummy__ <- sapply(loadedFILE_NLMIXR_DLLs__, function (x) {
    tryCatch({
      if (.Platform$OS.type=="windows") {
        suppressWarnings(dyn.unload(paste0(x,".d/",x,".dll")))
      } else {
        suppressWarnings(dyn.unload(paste0(x,".d/",x,".so"))) 
      }
    },error=function (err) {
    })
    tryCatch({
      if (.Platform$OS.type=="windows") {
        suppressWarnings(dyn.unload(paste0(x,".dll")))
      } else {
        suppressWarnings(dyn.unload(paste0(x,".so")))
      }
    },error=function (err) {
    })
  })
  unlink("saem*.*")
  unlink("rx_*.*")
}
#'@export
convertDataRxODE_IQRnlmixr <- function(dataFilePath) {
  est <- NULL
  est <- readRDS("project.est")
  model__ <- est$model
  data__ <- IQRloadCSVdata(dataFilePath)
  data__$VALUE <- NULL
  data__ <- data__[data__$MDV==0 | data__$EVID==1,]
  data__$ADM[is.na(data__$ADM)] <- 0
  data__$YTYPE[is.na(data__$YTYPE)] <- 0
  if (is.null(data__$II)) {
    data__$II <- NA
  }
  if (is.null(data__$ADDL)) {
    data__$ADDL <- NA
  }
  inputInfo <- model__$inputs
  data__$II[is.na(data__$II)] <- 0
  data__$ADDL[is.na(data__$ADDL)] <- 0
  dataIIADDL__ <- data__[data__$II>0 & data__$ADDL>0,]
  if (nrow(dataIIADDL__) > 0) {
    expandedDoseRecords__ <- do.call(rbind,lapply(1:nrow(dataIIADDL__), function (krow) {
      II <- dataIIADDL__[krow,]$II
      NRDOSES__ <- dataIIADDL__[krow,]$ADDL + 1
      doseRecords__ <- dataIIADDL__[krow*rep(1,NRDOSES__),]
      doseRecords__$TIME <- dataIIADDL__[krow,]$TIME + seq(0,by=II,length.out=nrow(doseRecords__))
      doseRecords__$TIMEPOS <- dataIIADDL__[krow,]$TIMEPOS + seq(0,by=II,length.out=nrow(doseRecords__))
      doseRecords__$NT <- dataIIADDL__[krow,]$NT + seq(0,by=II,length.out=nrow(doseRecords__))
      doseRecords__$ADDL <- 0
      doseRecords__$II <- 0
      doseRecords__
    }))
    data__ <- data__[!(data__$II>0 & data__$ADDL>0),]
    data__ <- rbind(data__,expandedDoseRecords__)
    data__ <- dplyr::arrange(data__,USUBJID,TIME,TYPENAME,NAME)
  }
  if (nrow(data__[data__$MDV==1 & data__$EVID==0,]) > 0) {
    warningIQR(paste("The data contains ignored observation records (MDV=1). NLMIXR does not recognize the MDV column.",
                  "For conversion of data into NLMIXR format these records are removed from the data.",
                  "Please talk to the NLMIXR development team to support the MDV column in a similar manner as NONMEM and MONOLIX do.",
                  sep="\n"))
    data__ <- data__[!(data__$MDV==1 & data__$EVID==0),]
  }
  aux__ <- data__[,c("USUBJID","EVID","ADM","RATE")]
  aux__$EVID_NLMIXR <- "0"
  aux__$EVID_NLMIXR[aux__$EVID==1] <- "01"
  compartmentNumbersInputs__ <- sapply(inputInfo, function (x) x$stateindex)
  if (length(compartmentNumbersInputs__) > length(inputInfo)) {
    stopIQR("Currently only one INPUT on one state at a time is handled.")
  }
  allADMdoses <- sort(unique(aux__$ADM[aux__$ADM!=0]))
  for (ADM in allADMdoses) {
    stateNumber__ <- compartmentNumbersInputs__[paste0("INPUT",ADM)]
    aux__$EVID_NLMIXR[aux__$ADM==ADM] = paste0(stateNumber__,aux__$EVID_NLMIXR[aux__$ADM==ADM])
  }
  aux__$EVID_NLMIXR[nchar(aux__$EVID_NLMIXR) == 3] <- paste0("0",aux__$EVID_NLMIXR[nchar(aux__$EVID_NLMIXR) == 3])
  if (any(nchar(aux__$EVID_NLMIXR) > 4)) {
    stopIQR("Input numbers are limited to 1-99. 99 possible dosing inputs should be sufficient for most applications in the next couple of years :-)\nBut depending on how the development and adoption of NLMIXR goes ... this might be the source of a new 'Millenium Bug'.")
  }
  aux__$EVID_NLMIXR[aux__$EVID==1 & aux__$RATE>0] <- paste0("1",aux__$EVID_NLMIXR[aux__$EVID==1 & aux__$RATE>0])
  aux__$EVID_NLMIXR <- as.numeric(aux__$EVID_NLMIXR)
  data__$EVID <- aux__$EVID_NLMIXR
  dataDoseRateOFF__ <- data__[data__$EVID>0 & data__$RATE>0,]
  dataDoseRateOFF__$TIME <- dataDoseRateOFF__$TIME + dataDoseRateOFF__$AMT/dataDoseRateOFF__$RATE
  dataDoseRateOFF__$AMT <- -dataDoseRateOFF__$RATE
  data__$AMT[data__$EVID>0 & data__$RATE>0] <- data__$RATE[data__$EVID>0 & data__$RATE>0]
  data__ <- dplyr::arrange(rbind(data__,dataDoseRateOFF__),USUBJID,TIME)
  if (any(data__$RATE<0)) {
    stopIQR("RATE < 0 not handled")
  }
  catNames__ <- est$data$catNames
  dummy__ <- sapply(catNames__, function (cat) {
    values__ <- unique(data__[[cat]])
    if (any(values__ < 0) | any(values__ > 1)) {
      stopIQR("At least one categorical covariate has other categories than 0 or 1. For the NLMIXR interface this is not allowed. Sorry!")
    }
  })
  if (any(est$data$covariateCATreference != 0)) {
    stopIQR("At least one categorical covariate has a reference value which is not 0. For NLMIXR interface this is not allowed.")
  }
  if (max(data__$YTYPE)>1) {
    data__$DVID <- data__$YTYPE
  }
  IQRoutputCSV(data__,"temp_XYZ.csv")
  data__ <- utils::read.csv("temp_XYZ.csv")
  unlink("temp_XYZ.csv")
  unlink("temp_XYZ.csv.log")
  return(data__)
}
genERRORmodel_IQRnlmixr <- function (est) {
  paste0(sapply(seq_along(est$modelSpec$errorModel) , function (k__) {
    eM__ <- est$modelSpec$errorModel[[k__]][1]
    if (eM__ == "abs") {
      out__ <- paste0("    OUTPUT",k__," ~ add(error_ADD",k__,")")
    }
    if (eM__ == "rel") {
      out__ <- paste0("    OUTPUT",k__," ~ prop(error_PROP",k__,")")
    }
    if (eM__ == "absrel") {
      out__ <- paste0("    OUTPUT",k__," ~ add(error_ADD",k__,") + prop(error_PROP",k__,")")
    }
    out__
  }),collapse = "\n")
}
genRxODEmodel_IQRnlmixr <- function (est) {
  checkINPUTprefactor1__ <- unlist(lapply(est$model$inputs, function (x__) {
    x__$factors == 1 
  }))
  if (!all(checkINPUTprefactor1__)) {
    stopIQR(paste("NLMIXR currently does not allow to specify a fraction term for dose administered (e.g. NONMEM F).",
               "There is a workaround if you are willing to use ODEs - more: info@intiquan.com",
               sep="\n"))
  }
  if (length(est$model$functions) > 0) {
    stopIQR("NLMIXR/RxODE can not handle functions in IQRmodels (neither can NONMEM, nor MONOLIX)")
  }
  if (length(est$model$events) > 0) {
    stopIQR("NLMIXR/RxODE can not handle events in IQRmodels (neither can NONMEM, nor MONOLIX)")
  }
  variablesText__ <- paste0(sapply(names(est$model$variables), function (x) {
    paste0("    ",x," = ",gsub("\\s","",est$model$variables[[x]]$formula),";")
  }),collapse = "\n")
  if (nchar(variablesText__)>0) {
    variablesText__ <- paste0("# Model variables\n",variablesText__)
  } else {
    variablesText__ <- NULL
  }
  reactionsText__ <- paste0(sapply(names(est$model$reactions), function (x) {
    paste0("    ",x," = ",gsub("\\s","",est$model$variables[[x]]$formula),";")
  }),collapse = "\n")
  if (nchar(reactionsText__)>0) {
    reactionsText__ <- paste0("# Model reactions\n",reactionsText__)
  } else {
    reactionsText__ <- NULL
  }
  ICs__ <- sapply(est$model$states, function (s) s$IC)
  icText__ <- paste0(unlist(sapply(names(ICs__), function (s) {
    if (ICs__[s] != 0) {
      out__ <- paste0("    ",s,"(0) = ",ICs__[s],";")
    } else {
      out__ <- NULL
    }
    out__
  })),collapse="\n")
  if (nchar(icText__) > 0) {
    icText__ <- paste0("# State initial conditions\n",icText__)
  } else {
    icText__ <- NULL
  }
  statesText__ <- paste0(sapply(names(est$model$states), function (x) {
    paste0("    d/dt(",x,") = ",gsub("\\s","",est$model$states[[x]]$ODE),";")
  }),collapse = "\n")
  if (nchar(statesText__)>0) {
    statesText__ <- paste0("# Model differential equations\n",statesText__)
  } else {
    statesText__ <- NULL
  }
  modelRxODEtext__ <- paste0(c(variablesText__,reactionsText__,icText__,statesText__),collapse="\n\n")
  dummy__ <- sapply(est$model$input, function (x) {
    modelRxODEtext__ <<- gsub(x$terms,"",modelRxODEtext__,fixed=TRUE)
  })
  if (grepl("piecewise",modelRxODEtext__)) {
    stopIQR("At least one piecwise expression is present in the model.\nThis is currently not handled for NLMIXR.\nPlease use NONMEM or MONOLIX instead")
  }
  param_model__ <- names(est$model$parameters)
  param_model__ <- param_model__[!grepl("INPUT[0-9]+",param_model__)]
  param_model__ <- param_model__[!grepl("Tlag[0-9]+",param_model__)]
  param_est__ <- sapply(est$modelInfo$param_est, function (x) x$name)
  param_reg__ <- sapply(est$modelInfo$param_reg, function (x) x$name)
  paramcheck__ <- c(param_est__,param_reg__)
  if (any(grepl("Tlag[0-9]+",paramcheck__))) {
    stopIQR("Estimation of lagtime parameters not supported in NLMIXR with ODEs.\nPlease use NONMEM or MONOLIX")
  }
  paramnomValuesfixed__ <- setdiff(param_model__,paramcheck__)
  paramnomValuesfixedtext__ <- sapply(paramnomValuesfixed__, function (x) {
    paste0("    ",x," = ",est$model$parameters[[x]]$value,";")
  })
  if (length(paramnomValuesfixedtext__) > 0) {
    parametersText__ <- paste0(c("# Fixed model parameters (not considered in modelSpec)",paramnomValuesfixedtext__),collapse="\n")
    modelRxODEtext__ <- paste0(c(parametersText__,modelRxODEtext__),collapse="\n\n")
  }
  return(modelRxODEtext__)
}
genModelParInfo_IQRnlmixr <- function(est) {
  if (any(est$modelSpec$IIVestimate==2)) {
    stopIQR("Fixed random effect values defined (IIVestimate=2).\nThis is not handled for NLMIXR.\nPlease use NONMEM or MONOLIX instead")
  }
  if (any((est$modelSpec$POPestimate==0)[est$modelSpec$IIVestimate==1])) {
    stopIQR("There are random effects defined to be estimated where the fixed effect is not estimated.\nThis is not supported for NLMIXR.\nPlease use NONMEM or MONOLIX instead")
  }
  param_fixed <- names(est$modelSpec$POPestimate)[est$modelSpec$POPestimate==0]
  param_estimated <- names(est$modelSpec$POPestimate)[est$modelSpec$POPestimate==1]
  cov_param <- as.vector(unlist(sapply(names(est$modelSpec$covariateModel), function(x) {
    paste0("beta_",x,"_",est$modelSpec$covariateModel[[x]])
  })))
  cov_param_estimated <- cov_param[unlist(sapply(names(est$modelSpec$covariateModel), function(x) {
    est$modelSpec$COVestimate[[x]]
  }))==1]
  cov_param_fixed <- setdiff(cov_param,cov_param_estimated)
  covariates <- unique(unlist(est$modelSpec$covariateModel))
  covariateValues <- as.vector(unlist(sapply(names(est$modelSpec$covariateModel), function(x) {
    est$modelSpec$covariateModelValues[[x]]
  })))
  names(covariateValues) <- cov_param
  output <- ""
  covParamFixedText <- sapply(cov_param_fixed, function (x) {
    paste0("    ",x," <- ",covariateValues[x])
  })
  if (length(covParamFixedText) > 0) {
    output <- paste0(output,"# Fixed covariate coefficients")
    output <- paste0(output,"\n",paste0(covParamFixedText,collapse="\n"))
    output <- paste0(output,"\n\n")
  }
  paramTextEstimated <- sapply(param_estimated, function (param) {
    covModel <- ""
    if (!is.null(est$modelSpec$covariateModel[[param]])) {
      cats <- intersect(est$data$catNames,est$modelSpec$covariateModel[[param]])
      covs <- intersect(est$data$covNames,est$modelSpec$covariateModel[[param]])
      catText <- sapply(cats, function (cat) {
        paste0(" + beta_",param,"_",cat,"*",cat)
      })
      if (length(catText) > 0) {
        catText <- paste0(catText,collapse="")
      } else {
        catText <- ""
      }
      covText <- sapply(covs, function (cov) {
        covReference <- est$data$covariateMedianValues[cov] 
        paste0(" + beta_",param,"_",cov,"*log(",cov,"/",covReference,")")
      })
      if (length(covText) > 0) {
        covText <- paste0(covText,collapse="")
      } else {
        covText <- ""
      }
      covModel <- paste0(covText,catText)
    }
    if (est$modelSpec$IIVestimate[param]==1) {
      etaText__ <- paste0(" + ETA_",param)
    } else {
      etaText__ <- ""
    }
    out <- paste0("    ",param," <- ")
    if (est$modelSpec$IIVdistribution[param]=="G") {
      x__ <- paste0("trans",param,etaText__,covModel)
      out <- paste0(out,"exp(",x__,")/(1+exp(",x__,"))")
    }
    if (est$modelSpec$IIVdistribution[param]=="L") out <- paste0(out,"exp(trans",param,etaText__,covModel,")")
    if (est$modelSpec$IIVdistribution[param]=="N") out <- paste0(out,"trans",param,etaText__,covModel)
    out
  })
  output <- paste0(output,"# Parameter transformations\n")
  output <- paste0(output,paste0(paramTextEstimated,collapse="\n"))
  output <- paste0(output,"\n\n")
  paramTextFixed <- sapply(param_fixed, function (param) {
    covModel <- ""
    if (!is.null(est$modelSpec$covariateModel[[param]])) {
      cats <- intersect(est$data$catNames,est$modelSpec$covariateModel[[param]])
      covs <- intersect(est$data$covNames,est$modelSpec$covariateModel[[param]])
      catText <- sapply(cats, function (cat) {
        paste0(" + beta_",param,"_",cat,"*",cat)
      })
      if (length(catText) > 0) {
        catText <- paste0(catText,collapse="")
      } else {
        catText <- ""
      }
      covText <- sapply(covs, function (cov) {
        covReference <- est$data$covariateMedianValues[cov] 
        paste0(" + beta_",param,"_",cov,"*log(",cov,"/",covReference,")")
      })
      if (length(covText) > 0) {
        covText <- paste0(covText,collapse="")
      } else {
        covText <- ""
      }
      covModel <- paste0(covText,catText)
    }
    value <- est$modelSpec$POPvalues[param]
    out <- paste0("    ",param," <- ")
    if (est$modelSpec$IIVdistribution[param]=="G") out <- paste0(out,"inv_logit(logit(",value,")",covModel,")")
    if (est$modelSpec$IIVdistribution[param]=="L") out <- paste0(out,"exp(log(",value,")",covModel,")")
    if (est$modelSpec$IIVdistribution[param]=="N") out <- paste0(out,value,covModel,param)
    out
  })
  if (length(paramTextFixed) > 0) {
    output <- paste0(output,"# Fixed model parameters (considered in modelSpec)")
    output <- paste0(output,"\n",paste0(paramTextFixed,collapse="\n"))
    output <- paste0(output,"\n")
  }
  cov_param <- sapply(cov_param, function (x) {
    x <- aux_strrep(x,"beta_","")
    x <- aux_strrep(x,"_","(")
    paste0("beta_",x,")")
  })
  cov_param_estimated <- sapply(cov_param_estimated, function (x) {
    x <- aux_strrep(x,"beta_","")
    x <- aux_strrep(x,"_","(")
    paste0("beta_",x,")")
  })
  paramsAll <- c(names(est$modelSpec$POPestimate),
                 cov_param)
  paramsEstimated <- c(est$modelSpec$POPestimate,
                       as.numeric(cov_param %in% cov_param_estimated))
  paramsInit <- c(est$modelSpec$POPvalues0,
                  covariateValues)
  if (!is.null(est$data$covNames)) {
    covParam <- cov_param[sort(unique(unlist(sapply(est$data$covNames, function (x) {
      which(grepl(paste0("(",x),cov_param,fixed=TRUE))
    }))))]
  } else {
    covParam <- NULL
  }
  if (!is.null(est$data$catNames)) {
    catParam <- cov_param[sort(unique(unlist(sapply(est$data$catNames, function (x) {
      which(grepl(paste0("(",x),cov_param,fixed=TRUE))
    }))))]
  } else {
    catParam <- NULL
  }
  covTrans <- sapply(covParam, function (cov) {
    ix <- gregexpr("(",cov,fixed=TRUE)[[1]][1]
    cov <- substr(cov,ix+1,nchar(cov)-1)
    covReference <- est$data$covariateMedianValues[cov]
    paste0("log(cov/",covReference,")")
  })
  if (any(est$data$covariateCATreference!=0)) {
    stopIQR("Categorical covariates in NLMIXR models need to have 0 as reference group")
  }
  catRef <- rep(0,length(catParam))
  names(catRef) <- catParam
  betacatcategories <- lapply(catParam, function (x) {
    c(0,1)
  })
  names(betacatcategories) <- catParam
  return(list(output=output,
              parameters = paramsAll,
              paramsEstimated = paramsEstimated,
              paramsInit = paramsInit,
              covariatesused = covariates,
              covParam = covParam,
              covTrans = covTrans,
              catParam = catParam,
              catRef   = catRef, 
              betacatcategories = betacatcategories 
  )
  )
}
genINI_IQRnlmixr <- function(est) {
  if (est$modelSpec$covarianceModel[1] == "diagonal") {
    covarianceModel <- ""
  } else {
    covarianceModel <- est$modelSpec$covarianceModel
  }
  param_estimated <- names(est$modelSpec$POPestimate)[est$modelSpec$POPestimate==1]
  cov_param <- unlist(sapply(names(est$modelSpec$covariateModel), function(x) {
    paste0("beta_",x,"_",est$modelSpec$covariateModel[[x]])
  }))
  cov_param_estimated <- cov_param[unlist(sapply(names(est$modelSpec$covariateModel), function(x) {
    est$modelSpec$COVestimate[[x]]
  }))==1]
  covariateValues <- unlist(sapply(names(est$modelSpec$covariateModel), function(x) {
    est$modelSpec$covariateModelValues[[x]]
  }))
  names(covariateValues) <- cov_param
  param_estimated_random <- names(est$modelSpec$IIVestimate)[est$modelSpec$IIVestimate==1]
  out <- "# Initial guesses fixed effects\n"
  x1 <- sapply(param_estimated, function (para) {
    value <- est$modelSpec$POPvalues0[para]
    if (est$modelSpec$IIVdistribution[para] == "L") out <- paste0("    trans",para," <- log(",value,")")
    if (est$modelSpec$IIVdistribution[para] == "G") out <- paste0("    trans",para," <- logit(",value,")")
    if (est$modelSpec$IIVdistribution[para] == "N") out <- paste0("    trans",para," <- ",value)
    out
  })
  out <- paste0(out,paste0(paste0(x1,collapse="\n")))
  out <- paste0(out,"\n")
  if (length(cov_param_estimated) > 0) {
    x2 <- sapply(cov_param_estimated, function (para) {
      paste0("    ",para," <- ",covariateValues[para])
    })
    out <- paste0(out,"\n","# Initial guesses covariate coefficients")
    out <- paste0(out,"\n",paste0(paste0(x2,collapse="\n")))
    out <- paste0(out,"\n")
  }
  out <- paste0(out,"\n","# Initial guesses random effects and covariance structure\n")
  allREparam <- paste0(names(est$modelSpec$IIVestimate)[est$modelSpec$IIVestimate==1])
  covarREparam <- paste0(aux_explode(paste0(covarianceModel,collapse=",")))
  covarREparam <- setdiff(covarREparam,covarianceModel)
  singleREparam <- paste0(setdiff(allREparam,covarREparam))
  text__ <- paste0(sapply(singleREparam, function (pn__) {
    paste0("    ETA_",pn__," ~ ",est$modelSpec$IIVvalues0[pn__]^2," ","# (variance)\n")
  }),collapse="")
  out <- paste0(out,text__)
  blocksCov__ <- setdiff(covarianceModel,allREparam)
  if (blocksCov__[1] != "") {
    text__ <- paste0("    ",sapply(blocksCov__, function (x__) {
      param__ <- aux_explode(x__)
      SDvalues__ <- est$modelSpec$IIVvalues0[param__]
      CORRmatrix__ <- 0.1*(matrix(1,nrow=length(param__),ncol=length(param__)) - diag(rep(1,length(param__)))) + diag(rep(1,length(param__)))
      COVARmatrix__ <- diag(SDvalues__)%*%CORRmatrix__%*%diag(SDvalues__)
      N <- nrow(COVARmatrix__)
      text__ <- ""
      for (row in 1:N) {
        for (col in 1:row) {
          text__ <- paste0(text__,COVARmatrix__[row,col],", ")
        }
        text__ <- paste0(text__,"\n")
      }
      text__ <- substr(text__,1,nchar(text__)-3)
      text__ <- paste0("c(",text__,")")
      equ__ <- paste0("    ",paste0("ETA_",param__,collapse=" + "))
      text__ <- aux_strrep(text__,"\n",paste("\n",paste0(rep(" ",nchar(equ__)+4),collapse = "")))
      text__ <- paste0(paste0("ETA_",param__,collapse=" + ")," ~ ",text__)
    }),collapse="\n")
    out <- paste0(out,text__,"\n")
  }
  out <- paste0(out,"\n","# Initial guesses error model parameters")
  for (k in seq_along(est$modelSpec$errorModel)) {
    eM <- est$modelSpec$errorModel[[k]]
    if (eM[1] == "abs") {
      text__ <- paste0("    error_ADD",k," <- ",eM[2])
    }
    if (eM[1] == "rel") {
      text__ <- paste0("    error_PROP",k," <- ",eM[2])
    }
    if (eM[1] == "absrel") {
      text__ <- paste0("    error_ADD",k," <- ",eM[2],"\n","    error_PROP",k," <- ",eM[3])
    }
    out <- paste0(out,"\n",text__)
  }
  return(out)
}
parseNLMIXRprojectHeader <- function(projectPath) {
  if (file.exists(paste0(projectPath, '/project_NLMIXR.R'))) {
    project__ <- aux_fileread(paste0(projectPath, '/project_NLMIXR.R'))
  } else {
    stopIQR('project_NLMIXR.R file could not be found.')
  }
  ixstart__ <- aux_strFindAll(project__,'# ==PROJECT HEADER START===================================================')$end
  ixend__   <- aux_strFindAll(project__,  '# ==PROJECT HEADER END=====================================================')$start
  if (is.null(ixstart__) | is.null(ixend__)) stopIQR('Project header could not be found in project_NLMIXR.R file.')
  headertext__ <- aux_strtrim(substr(project__,ixstart__+1,ixend__-1))
  headertext__  <- aux_strrep(headertext__,"# ","")
  headertext__  <- aux_strrep(headertext__,"\n",",\n")
  projectinfo__ <- eval(parse(text=paste0("list(",headertext__,")")))
  projectinfo__ <- lapply(projectinfo__,function(x) aux_explodePC(x))
  return(projectinfo__)
}
parseNLMIXRresults <- function(projectPath) {
  projectHeader__ <- parseNLMIXRprojectHeader(projectPath)
  fit <- NULL
  suppressWarnings(fit <- tryCatch({
    load(paste0(projectPath,"/RESULTSORIG/project.fit"))
    fit
  }, error = function(err) {
    NULL
  }))
  if (is.null(fit$TIME)) {
    return (NULL)
  }
  results__ <- list()
  results__$type <- projectHeader__$TOOL
  results__$method <- projectHeader__$METHOD
  results__$termination_info <- fit$termination_info
  results__$path <- projectPath
  if (!is.null(fit$fit)) {
    results__ <- handleOldFITobjectNLMIXR(projectHeader__,fit,results__)
  } else {
    results__ <- handleNewFITobjectNLMIXR(projectHeader__,fit,results__)
  }
  fixedEffects_transformed <- list()
  ix_FE <- which(!grepl("\\<(beta_|error_)",results__$parameters$names))
  fixedEffects_transformed$names <- results__$parameters$names[ix_FE]
  fixedEffects_transformed$trans <- projectHeader__$PARAMTRANS[ix_FE]
  fixedEffects_transformed$invtrans <- projectHeader__$PARAMINVTRANS[ix_FE]
  fixedEffects_transformed$estimated <- results__$parameters$FLAGestimated[ix_FE]
  fixedEffects_transformed$values <- results__$parameters$values[ix_FE]
  fixedEffects_transformed$stderr <- results__$parameters$stderrors[ix_FE]
  fixedEffects_transformed$rse <- abs(100*fixedEffects_transformed$stderr/fixedEffects_transformed$values)
  fixedEffects_transformed$distribution_info <- projectHeader__$PARAMINVTRANS[ix_FE]
  fixedEffects <- fixedEffects_transformed
  fixedEffects$values <- sapply(1:length(fixedEffects$values), function (k) {
    phi <- as.numeric(fixedEffects$values[k])
    if (fixedEffects$trans[k]=="") return (phi)
    eval(parse(text=fixedEffects$trans[k]))
  })
  fixedEffects$stderr <- sapply(1:length(fixedEffects$values), function (k) {
    phi <- fixedEffects_transformed$values[k]
    jac_kk <- stats::D(parse(text = fixedEffects$trans[k]), "phi")
    abs(eval(jac_kk))*fixedEffects_transformed$stderr[k]
  })
  fixedEffects$trans <- rep("",length(fixedEffects$names))
  fixedEffects$invtrans <- rep("",length(fixedEffects$names))
  fixedEffects$rse <- abs(100*fixedEffects$stderr/fixedEffects$values)
  randomEffects <- list()
  randomEffects$names <- projectHeader__$ETANAMES
  randomEffects$estimated <- as.numeric(projectHeader__$ETAESTIMATE)
  randomEffects$values <- rep(0,length(randomEffects$names))
  omegaNLMIXR <- fit$omega
  covnames <- paste0("omega(",gsub("\\<ETA_","",colnames(omegaNLMIXR)),")")
  se <- sqrt(diag(omegaNLMIXR))
  names(se) <- covnames
  ix_RE <- sapply(covnames, function (x) {
    which(randomEffects$names==x)
  })
  randomEffects$values[ix_RE] <- se
  randomEffects$covariance <- matrix(0,ncol=length(randomEffects$names),nrow=length(randomEffects$names))
  randomEffects$covariance[ix_RE,ix_RE] <- omegaNLMIXR
  randomEffects$stderr <- rep(NA,length(randomEffects$names))
  randomEffects$rse <- rep(NA,length(randomEffects$names))
  if (projectHeader__$CORRELATIONNAMES[1] != "") {
    correlation <- list()
    correlation$names <- projectHeader__$CORRELATIONNAMES
    correlation$estimated <- projectHeader__$CORRESTIMATE
    se <- sqrt(diag(randomEffects$covariance))
    corr <- array(t(randomEffects$covariance/se)/se,dim(randomEffects$covariance))
    correlation$values <- as.numeric(sapply(correlation$names, function (x) {
      param <- aux_explode(gsub("\\)","",gsub("corr\\(","",x)))
      ix <- sapply(param, function (y) {
        which(fixedEffects_transformed$names == y)
      })
      corr[ix[1],ix[2]]
    }))
    correlation$stderr <- rep(NA,length(correlation$names))
    correlation$rse <- rep(NA,length(correlation$names))
  } else {
    correlation <- NULL
  }
  errorParameter <- list()
  ix_ERR <- which(grepl("\\<error_",results__$parameters$names))
  errorParameter$names <- results__$parameters$names[ix_ERR]
  errorParameter$estimated <- results__$parameters$FLAGestimated[ix_ERR]
  errorParameter$values <- results__$parameters$values[ix_ERR]
  errorParameter$stderr <- rep(NA,length(errorParameter$names))
  errorParameter$rse <- rep(NA,length(errorParameter$names))
  ix_COV <- which(grepl("beta_",results__$parameters$names))
  if (length(ix_COV) > 0) {
    covariate <- list()
    covariate$names  <- results__$parameters$names[ix_COV]
    covariate$estimated <- results__$parameters$FLAGestimated[ix_COV]
    covariate$values <- results__$parameters$values[ix_COV]
    covariate$stderr <- results__$parameters$stderrors[ix_COV]
    covariate$rse <- abs(100*covariate$stderr/covariate$values)
  } else {
    covariate <- NULL
  }
  rawParameterInfo <- list()
  rawParameterInfo$fixedEffects <- fixedEffects
  rawParameterInfo$fixedEffects_transformed <- fixedEffects_transformed
  rawParameterInfo$randomEffects <- randomEffects
  rawParameterInfo$correlation <- correlation
  rawParameterInfo$errorParameter <- errorParameter
  rawParameterInfo$covariate <- covariate
  results__$rawParameterInfo <- rawParameterInfo
  return(results__)
}
handleNewFITobjectNLMIXR <- function (projectHeader__,fit,results__) {
  fixfix__ <- attr((attr(fit, "class")), ".foceiEnv")
  class(fixfix__) <- "environment"
  fitInfo__ <- as.list(fixfix__)
  results__$objectivefunction$OBJ <- as.numeric(fitInfo__$objective)
  results__$objectivefunction$AIC <- calcAICBIC(OFV = results__$objectivefunction$OBJ,
                                                nData = projectHeader__$NROBSERVATIONS,
                                                nParam = projectHeader__$NRPARAM_ESTIMATED)$AIC
  results__$objectivefunction$BIC <- calcAICBIC(OFV = results__$objectivefunction$OBJ,
                                                nData = projectHeader__$NROBSERVATIONS,
                                                nParam = projectHeader__$NRPARAM_ESTIMATED)$BIC
  results__$residualerrormodels <- projectHeader__$ERRORMODELS
  results__$trans_randeffects <- projectHeader__$PARAMTRANS[1:length(projectHeader__$ETANAMES)]
  results__$inv_trans_randeffects <- projectHeader__$PARAMINVTRANS[1:length(projectHeader__$ETANAMES)]
  results__$PROJECTINFO <- projectHeader__
  parameters <- list()
  names__ <- c(projectHeader__$THETANAMES)
  if (projectHeader__$CATNAMES[1] != "") {
    names__ <- sapply(names__, function (x__) {
      if (!grepl("\\<beta_",x__)) return(x__)
      search__ <- paste0(projectHeader__$CATNAMES,")")
      replace__ <- paste0(projectHeader__$CATNAMES,"_1)")
      dummy__ <- sapply(1:length(search__), function (k__) {
        x__ <<- gsub(search__[k__],replace__[k__],x__,fixed=TRUE)
      })
      x__
    })
  }
  parameters$names <- names__
  names(parameters$names) <- names__
  parameters$FLAGestimated <- as.numeric(projectHeader__$THETAESTIMATE)
  parameters$transformation <- c(projectHeader__$PARAMTRANS,rep("",length(projectHeader__$ERRORNAMES)))
  parameters$values <- c(
    sapply(1:length(projectHeader__$PARAMGUESS), function (k) {
      psi <- as.numeric(projectHeader__$PARAMGUESS[k])
      if (projectHeader__$PARAMINVTRANS[k]=="") return (psi)
      eval(parse(text=projectHeader__$PARAMINVTRANS[k]))
    }),
    rep(NA,length(projectHeader__$ERRORNAMES))
  )
  parameters$stderrors <- rep(0,length(parameters$values))
  parameters$covariancematrix <- matrix(0,ncol=length(parameters$values),nrow=length(parameters$values))
  parameters$correlationmatrix <- diag(length(parameters$values))
  thetaNLMIXR__ <- fit$theta
  namesThetaNLMIXR__ <- gsub("\\<trans","",names(thetaNLMIXR__))
  covNames__ <- namesThetaNLMIXR__[grepl("\\<beta_",namesThetaNLMIXR__)]
  for (k__ in seq_along(covNames__)) {
    x__ <- covNames__[k__]
    if (projectHeader__$COVNAMES[1] != "") {
      search__ <- paste0("_",projectHeader__$COVNAMES)
      replace__ <- paste0("(",projectHeader__$COVNAMES,")")
      for (k2__ in seq_along(search__)) x__ <- gsub(search__[k2__],replace__[k2__],x__)
    }
    if (projectHeader__$CATNAMES[1] != "") {
      search__ <- paste0("_",projectHeader__$CATNAMES)
      replace__ <- paste0("(",projectHeader__$CATNAMES,"_1)")
      for (k2__ in seq_along(search__)) x__ <- gsub(search__[k2__],replace__[k2__],x__)
    }
    namesThetaNLMIXR__[namesThetaNLMIXR__==covNames__[k__]] <- x__
  }
  names(thetaNLMIXR__) <- namesThetaNLMIXR__
  ixest <- which(parameters$FLAGestimated==1)
  names(parameters$values) <- parameters$names
  parameters$values[names(thetaNLMIXR__)] <- thetaNLMIXR__
  ixestWOerr <- ixest[1:(length(ixest)-length(projectHeader__$ERRORNAMES))]
  nRC <- rownames(fit$parFixed)
  nRC <- gsub("\\<trans","",nRC)
  covNames__ <- nRC[grepl("\\<beta_",nRC)]
  for (k__ in seq_along(covNames__)) {
    x__ <- covNames__[k__]
    if (projectHeader__$COVNAMES[1] != "") {
      search__ <- paste0("_",projectHeader__$COVNAMES)
      replace__ <- paste0("(",projectHeader__$COVNAMES,")")
      for (k2__ in seq_along(search__)) x__ <- gsub(search__[k2__],replace__[k2__],x__)
    }
    if (projectHeader__$CATNAMES[1] != "") {
      search__ <- paste0("_",projectHeader__$CATNAMES)
      replace__ <- paste0("(",projectHeader__$CATNAMES,"_1)")
      for (k2__ in seq_along(search__)) x__ <- gsub(search__[k2__],replace__[k2__],x__)
    }
    nRC[nRC==covNames__[k__]] <- x__
  }
  parameters$stderrors[ixestWOerr] <- sqrt(diag(fitInfo__$cov))
  parameters$covariancematrix[ixestWOerr,ixestWOerr] <- as.matrix(fitInfo__$cov)
  parameters$correlationmatrix[ixestWOerr,ixestWOerr] <- array(t(fit$cov/parameters$stderrors[ixestWOerr]) / parameters$stderrors[ixestWOerr],dim(fit$varFix))
  results__$parameters <- parameters
  return(results__)
}
handleOldFITobjectNLMIXR <- function (projectHeader__,fit,results__) {
  results__$objectivefunction$OBJ <- as.numeric(fit$fit$objective)
  results__$objectivefunction$AIC <- calcAICBIC(OFV = results__$objectivefunction$OBJ,
                                                nData = projectHeader__$NROBSERVATIONS,
                                                nParam = projectHeader__$NRPARAM_ESTIMATED)$AIC
  results__$objectivefunction$BIC <- calcAICBIC(OFV = results__$objectivefunction$OBJ,
                                                nData = projectHeader__$NROBSERVATIONS,
                                                nParam = projectHeader__$NRPARAM_ESTIMATED)$BIC
  results__$residualerrormodels <- projectHeader__$ERRORMODELS
  results__$trans_randeffects <- projectHeader__$PARAMTRANS[1:length(projectHeader__$ETANAMES)]
  results__$inv_trans_randeffects <- projectHeader__$PARAMINVTRANS[1:length(projectHeader__$ETANAMES)]
  results__$PROJECTINFO <- projectHeader__
  parameters <- list()
  names__ <- c(projectHeader__$THETANAMES)
  if (projectHeader__$CATNAMES[1] != "") {
    names__ <- sapply(names__, function (x__) {
      if (!grepl("\\<beta_",x__)) return(x__)
      search__ <- paste0(projectHeader__$CATNAMES,")")
      replace__ <- paste0(projectHeader__$CATNAMES,"_1)")
      dummy__ <- sapply(1:length(search__), function (k__) {
        x__ <<- gsub(search__[k__],replace__[k__],x__,fixed=TRUE)
      })
      x__
    })
  }
  parameters$names <- names__
  names(parameters$names) <- names__
  parameters$FLAGestimated <- as.numeric(projectHeader__$THETAESTIMATE)
  parameters$transformation <- c(projectHeader__$PARAMTRANS,rep("",length(projectHeader__$ERRORNAMES)))
  parameters$values <- c(
    sapply(1:length(projectHeader__$PARAMGUESS), function (k) {
      psi <- as.numeric(projectHeader__$PARAMGUESS[k])
      if (projectHeader__$PARAMINVTRANS[k]=="") return (psi)
      eval(parse(text=projectHeader__$PARAMINVTRANS[k]))
    }),
    rep(NA,length(projectHeader__$ERRORNAMES))
  )
  parameters$stderrors <- rep(0,length(parameters$values))
  parameters$covariancematrix <- matrix(0,ncol=length(parameters$values),nrow=length(parameters$values))
  parameters$correlationmatrix <- diag(length(parameters$values))
  thetaNLMIXR__ <- fit$fit$theta
  namesThetaNLMIXR__ <- gsub("\\<trans","",names(thetaNLMIXR__))
  covNames__ <- namesThetaNLMIXR__[grepl("\\<beta_",namesThetaNLMIXR__)]
  for (k__ in seq_along(covNames__)) {
    x__ <- covNames__[k__]
    if (projectHeader__$COVNAMES[1] != "") {
      search__ <- paste0("_",projectHeader__$COVNAMES)
      replace__ <- paste0("(",projectHeader__$COVNAMES,")")
      for (k2__ in seq_along(search__)) x__ <- gsub(search__[k2__],replace__[k2__],x__)
    }
    if (projectHeader__$CATNAMES[1] != "") {
      search__ <- paste0("_",projectHeader__$CATNAMES)
      replace__ <- paste0("(",projectHeader__$CATNAMES,"_1)")
      for (k2__ in seq_along(search__)) x__ <- gsub(search__[k2__],replace__[k2__],x__)
    }
    namesThetaNLMIXR__[namesThetaNLMIXR__==covNames__[k__]] <- x__
  }
  names(thetaNLMIXR__) <- namesThetaNLMIXR__
  ixest <- which(parameters$FLAGestimated==1)
  names(parameters$values) <- parameters$names
  parameters$values[names(thetaNLMIXR__)] <- thetaNLMIXR__
  ixestWOerr <- ixest[1:(length(ixest)-length(projectHeader__$ERRORNAMES))]
  nRC <- colnames(fit$varFix)
  nRC <- gsub("\\<trans","",nRC)
  covNames__ <- nRC[grepl("\\<beta_",nRC)]
  for (k__ in seq_along(covNames__)) {
    x__ <- covNames__[k__]
    if (projectHeader__$COVNAMES[1] != "") {
      search__ <- paste0("_",projectHeader__$COVNAMES)
      replace__ <- paste0("(",projectHeader__$COVNAMES,")")
      for (k2__ in seq_along(search__)) x__ <- gsub(search__[k2__],replace__[k2__],x__)
    }
    if (projectHeader__$CATNAMES[1] != "") {
      search__ <- paste0("_",projectHeader__$CATNAMES)
      replace__ <- paste0("(",projectHeader__$CATNAMES,"_1)")
      for (k2__ in seq_along(search__)) x__ <- gsub(search__[k2__],replace__[k2__],x__)
    }
    nRC[nRC==covNames__[k__]] <- x__
  }
  ix <- match(nRC,parameters$names)
  parameters$stderrors[ix] <- c(sqrt(diag(as.matrix(fit$varFix))))
  parameters$covariancematrix[ix,ix] <- as.matrix(fit$varFix)
  parameters$correlationmatrix[ix,ix] <- array(t(fit$varFix/parameters$stderrors[ix])/parameters$stderrors[ix],dim(fit$varFix))
  results__$parameters <- parameters
  return(results__)
}
createNLMIXRresultsTable <- function(projectPath, filename=NULL) {
  x <- parseNLMEresults(projectPath)
  OUTPUT <- ""
  OUTPUT  <- sprintf('%s========================================================================================================\n',OUTPUT)
  OUTPUT  <- sprintf('%s    Summary results\n',OUTPUT)
  OUTPUT  <- sprintf('%s    Project: %s\n',OUTPUT,x$path)
  OUTPUT  <- sprintf('%s========================================================================================================\n',OUTPUT)
  OUTPUT  <- sprintf('%s\n',OUTPUT)
  if (is.null(x)) {
    OUTPUT <- sprintf('%s--------------------------------------------------------------------------------------------------------\n',OUTPUT)
    method <- sprintf('%s',paste0(x$PROJECTINFO$METHOD,collapse=","))
    OUTPUT <- sprintf('%sPlease check the NLMIXR fit manually ... it seems not to have run through.\n',OUTPUT)
    OUTPUT <- sprintf('%s--------------------------------------------------------------------------------------------------------\n',OUTPUT)
    IQRoutputFile(OUTPUT,filename) 
    cat(OUTPUT)
    return(OUTPUT)
  }
  OUTPUT <- sprintf('%s--------------------------------------------------------------------------------------------------------\n',OUTPUT)
  OUTPUT  <- sprintf('%sName                           Value          stderr         RSE (%%)          95%%CI\n',OUTPUT)
  OUTPUT <- sprintf('%s--------------------------------------------------------------------------------------------------------\n',OUTPUT)
  fe <- x$rawParameterInfo$fixedEffects_transformed
  names <- c()
  values <- c()
  stderrs <- c()
  RSEs <- c()
  for (k__ in seq_along(fe$names)) {
    if (fe$trans[k__] == 'phi') {
      names[k__] <- fe$names[k__]
    }
    if (fe$trans[k__] == 'exp(phi)') {
      names[k__] <- paste0('log(', fe$names[k__], ')')
    }
    if (fe$trans[k__] == 'exp(phi)/(1+exp(phi))') {
      names[k__] <- paste0('logit(', fe$names[k__], ')')
    }
    if (fe$estimated[k__]==1) {
      values[k__] <- sprintf('%1.4g',fe$values[k__])
      stderrs[k__] <- sprintf('%1.4g',fe$stderr[k__])
      RSEs[k__] <- sprintf('%1.4g',fe$rse[k__])
    } else {
      values[k__] <- sprintf('%1.4g (FIX)',fe$values[k__])
      stderrs[k__] <- '-'
      RSEs[k__] <- '-'
    }
  }
  for (k__ in seq_along(names)) {
    text__ <- sprintf('%s%s%s%s\n',aux_postFillChar(names[k__],20,' '),
                      aux_preFillChar(values[k__],16,' '),
                      aux_preFillChar(stderrs[k__],16,' '),
                      aux_preFillChar(RSEs[k__],16,' '))
    OUTPUT <- sprintf('%s%s',OUTPUT,text__)
  }
  OUTPUT  <- sprintf('%s\n',OUTPUT)
  fe <- x$rawParameterInfo$fixedEffects
  names <- c()
  values <- c()
  stderrs <- c()
  RSEs <- c()
  for (k__ in seq_along(fe$names)) {
    names[k__] <- fe$names[k__]
    value <- fe$values[k__]
    stderr <- fe$stderr[k__]
    if (fe$estimated[k__]==1) {
      values[k__] <- sprintf('%1.4g',value)
      rse <- sprintf('%1.4g',100*stderr/value)
      stderr <- sprintf('%1.4g',stderr)
    } else {
      values[k__] <- sprintf('%1.4g (FIX)',value)
      stderr <- '-'
      rse <- '-'
    }
    stderrs[k__] <- stderr
    RSEs[k__] <- rse
  }
  for (k__ in seq_along(names)) {
    text__ <- sprintf('%s%s%s%s\n',aux_postFillChar(names[k__],20,' '),
                      aux_preFillChar(values[k__],16,' '),
                      aux_preFillChar(stderrs[k__],16,' '),
                      aux_preFillChar(RSEs[k__],16,' '))
    OUTPUT <- sprintf('%s%s',OUTPUT,text__)
  }
  OUTPUT  <- sprintf('%s\n',OUTPUT)
  fe <- x$rawParameterInfo$covariate
  names <- c()
  values <- c()
  stderrs <- c()
  RSEs <- c()
  CI <- c()
  for (k__ in seq_along(fe$names)) {
    names[k__] <- fe$names[k__]
    if (fe$estimated[k__]==1) {
      values[k__] <- sprintf('%1.4g',fe$values[k__])
      stderrs[k__] <- sprintf('%1.4g',fe$stderr[k__])
      RSEs[k__] <- sprintf('%1.4g',fe$rse[k__])
      CI[k__] <- sprintf('[%1.4g %1.4g]',fe$values[k__]-1.96*fe$stderr[k__],fe$values[k__]+1.96*fe$stderr[k__])
    } else {
      values[k__] <- sprintf('%1.4g (FIX)',fe$values[k__])
      stderrs[k__] <- '-'
      RSEs[k__] <- '-'
      CI[k__] <- '-'
    }
  }
  for (k__ in seq_along(names)) {
    text__ <- sprintf('%s%s%s%s%s\n',aux_postFillChar(names[k__],20,' '),
                      aux_preFillChar(values[k__],16,' '),
                      aux_preFillChar(stderrs[k__],16,' '),
                      aux_preFillChar(RSEs[k__],16,' '),
                      aux_preFillChar(CI[k__],30,' '))
    OUTPUT <- sprintf('%s%s',OUTPUT,text__)
  }
  if (length(fe$names) > 0) OUTPUT  <- sprintf('%s\n',OUTPUT)
  fe <- x$rawParameterInfo$randomEffects
  names <- c()
  values <- c()
  stderrs <- c()
  RSEs <- c()
  for (k__ in seq_along(fe$names)) {
    names[k__] <- fe$names[k__]
    if (fe$estimated[k__] == 1) {
      values[k__] <- sprintf('%1.4g',fe$values[k__])
      if (is.na(fe$stderr[k__])) {
        stderrs[k__] <- sprintf('%1.4g*',fe$stderr[k__])
        RSEs[k__] <- sprintf('%1.4g*',fe$rse[k__])
      } else {
        stderrs[k__] <- sprintf('%1.4g',fe$stderr[k__])
        RSEs[k__] <- sprintf('%1.4g',fe$rse[k__])
      }
    } else {
      values[k__] <- sprintf('%1.4g (FIX)',fe$values[k__])
      stderrs[k__] <- '-'
      RSEs[k__] <- '-'
    }
  }
  for (k__ in seq_along(names)) {
    text__ <- sprintf('%s%s%s%s\n',aux_postFillChar(names[k__],20,' '),
                      aux_preFillChar(values[k__],16,' '),
                      aux_preFillChar(stderrs[k__],16,' '),
                      aux_preFillChar(RSEs[k__],16,' '))
    OUTPUT <- sprintf('%s%s',OUTPUT,text__)
  }
  OUTPUT  <- sprintf('%s                                    (*standard errors not computed by NLMIXR)\n',OUTPUT)
  if (length(fe$names) > 0) OUTPUT  <- sprintf('%s\n',OUTPUT)
  if (!is.null(x$rawParameterInfo$correlation$names)) {
    fe <- x$rawParameterInfo$correlation
    names <- c()
    values <- c()
    stderrs <- c()
    RSEs <- c()
    CI <- c()
    for (k__ in seq_along(fe$names)) {
      names[k__] <- fe$names[k__]
      values[k__] <- sprintf('%1.4g',fe$values[k__])
      stderrs[k__] <- sprintf('%1.4g*',fe$stderr[k__])
      RSEs[k__] <- sprintf('%1.4g*',fe$rse[k__])
      CI[k__] <- sprintf('[%1.4g %1.4g]*',fe$values[k__]-1.96*fe$stderr[k__],fe$values[k__]+1.96*fe$stderr[k__])
    }
    for (k__ in seq_along(names)) {
      text__ <- sprintf('%s%s%s%s%s\n',aux_postFillChar(names[k__],20,' '),
                        aux_preFillChar(values[k__],16,' '),
                        aux_preFillChar(stderrs[k__],16,' '),
                        aux_preFillChar(RSEs[k__],16,' '),
                        aux_preFillChar(CI[k__],30,' '))
      OUTPUT <- sprintf('%s%s',OUTPUT,text__)
    }
    OUTPUT  <- sprintf('%s                                    (*standard errors not computed by NLMIXR)\n',OUTPUT)
    OUTPUT  <- sprintf('%s\n',OUTPUT)
  }
  fe <- x$rawParameterInfo$errorParameter
  names <- c()
  values <- c()
  stderrs <- c()
  RSEs <- c()
  for (k__ in seq_along(fe$names)) {
    names[k__] <- fe$names[k__]
    if (fe$estimated[k__] == 1) {
      values[k__] <- sprintf('%1.4g',fe$values[k__])
      stderrs[k__] <- sprintf('%1.4g*',fe$stderr[k__])
      RSEs[k__] <- sprintf('%1.4g*',fe$rse[k__])
    } else {
      values[k__] <- sprintf('%1.4g (FIX)',fe$values[k__])
      stderrs[k__] <- '-'
      RSEs[k__] <- '-'
    }
  }
  for (k__ in seq_along(names)) {
    text__ <- sprintf('%s%s%s%s\n',aux_postFillChar(names[k__],20,' '),
                      aux_preFillChar(values[k__],16,' '),
                      aux_preFillChar(stderrs[k__],16,' '),
                      aux_preFillChar(RSEs[k__],16,' '))
    OUTPUT <- sprintf('%s%s',OUTPUT,text__)
  }
  OUTPUT  <- sprintf('%s                                    (*standard errors not computed by NLMIXR)\n',OUTPUT)
  OUTPUT  <- sprintf('%s\n',OUTPUT)
  if (!is.null(x$parameters$correlationmatrix)) {
    OUTPUT <- sprintf('%s--------------------------------------------------------------------------------------------------------\n',OUTPUT)
    OUTPUT <- sprintf('%sCorrelation of fixed effects and covariate coefficients\n',OUTPUT)
    OUTPUT <- sprintf('%s--------------------------------------------------------------------------------------------------------\n',OUTPUT)
    names <- c(x$rawParameterInfo$fixedEffects$names, x$rawParameterInfo$covariate$names)
    ix_all <- c()
    for (k__ in seq_along(names)) ix_all[k__] <- which(names[k__]==x$parameters$names)
    cor <- x$parameters$correlationmatrix[ix_all,ix_all]
    for (row in 1:nrow(cor)) {
      rowtext__ <- aux_postFillChar(names[row],max(nchar(names))+1,' ')
      for (col in 1:row) {
        rowtext__ <- sprintf('%s%s',rowtext__,aux_preFillChar(sprintf('%1.2g',signif(cor[row,col],2)),12,' '))
      }
      OUTPUT <- sprintf('%s%s\n',OUTPUT,rowtext__)
    }
    OUTPUT  <- sprintf('%s\n',OUTPUT)
    eigM    <- eigen(cor)$values
    eigMmin <- min(eigM)
    eigMmax <- max(eigM)
    OUTPUT  <- sprintf('%sEigenvalues (min, max, max/min): %1.2f  %1.2f  %1.2f\n',OUTPUT,eigMmin,eigMmax,eigMmax/eigMmin)
    OUTPUT  <- sprintf('%s\n',OUTPUT)
  }
  add <- ""
  if (is.na(x$objectivefunction$OBJ)) {
    add <- "**"
  }
  OUTPUT <- sprintf('%s--------------------------------------------------------------------------------------------------------\n',OUTPUT)
  OUTPUT <- sprintf('%sObjective function\n',OUTPUT)
  OUTPUT <- sprintf('%s--------------------------------------------------------------------------------------------------------\n',OUTPUT)
  OUTPUT <- sprintf('%sOFV:    %g%s\n',OUTPUT,x$objectivefunction$OBJ,add)
  OUTPUT <- sprintf('%sAIC:    %g%s\n',OUTPUT,x$objectivefunction$AIC,add)
  OUTPUT <- sprintf('%sBIC:    %g%s\n',OUTPUT,x$objectivefunction$BIC,add)
  if (nchar(add) > 0) {
    OUTPUT <- sprintf('%s      (** Not computed by NLMIXR for the chosen optimization method)\n',OUTPUT)
  }
  OUTPUT  <- sprintf('%s\n',OUTPUT)
  IQRoutputFile(OUTPUT,filename) 
  cat(OUTPUT)
}
genTablesNLMIXRfit <- function (projectPath) {
  projectHeader__ <- parseNLMIXRprojectHeader(projectPath)
  oldPath__ <- getwd()
  setwd(projectPath)
  data <- IQRloadCSVdata(projectHeader__$DATA)
  setwd(oldPath__)
  fit <- NULL
  load(paste0(projectPath,"/RESULTSORIG/project.fit"))
  if (is.null(fit$TIME)) {
    return (NULL)
  }
  fit$ID <- as.numeric(levels(fit$ID)[fit$ID])
  covsData__ <- projectHeader__$COVARIATENAMES
  if (covsData__[1] != "") {
    missingCovs__ <- covsData__[!covsData__ %in% names(fit)]
    dataCOV__ <- do.call(rbind,lapply(split(data,data$ID), function (datak) {
      datak[1,c("ID",missingCovs__)]
    }))
    fit <- dplyr::left_join(fit,dataCOV__,by="ID")
  }
  id__ <- "ID"
  covs__ <- projectHeader__$COVARIATENAMES
  if (covs__[1] == "") covs__ <- NULL
  etasNLMIXT__ <- names(fit)[grepl("ETA_",names(fit))]
  feNames__ <- projectHeader__$PARAMNAMES[!grepl("beta_",projectHeader__$PARAMNAMES)]
  etasADD__ <- paste0("ETA_",setdiff(
    feNames__,
    gsub("ETA_","",etasNLMIXT__)
  ))
  for (k__ in seq_along(etasADD__)) {
    fit[[etasADD__[k__]]] <- 0
  }
  etas__ <- paste0("ETA_",feNames__)
  ETAvalues <- as.data.frame(fit[!duplicated(fit$ID),c(id__,etas__,covs__)])
  IQRsaveCSVdata(ETAvalues,filename=paste0(projectPath,"/RESULTSORIG/project_eta.csv"))
  id__ <- "ID"
  covs__ <- projectHeader__$COVARIATENAMES
  feNames__ <- projectHeader__$PARAMNAMES[!grepl("beta_",projectHeader__$PARAMNAMES)]
  if (covs__[1] == "") covs__ <- NULL
  missingFEfixed__ <- setdiff(feNames__,names(fit))
  if (length(missingFEfixed__) > 0) {
    x__ <- parseNLMEresults(projectPath)$rawParameterInfo$fixedEffects
    values__ <- x__$values[match(missingFEfixed__,x__$names)]
    for (kkk__ in seq_along(missingFEfixed__)) {
      fit[[missingFEfixed__[kkk__]]] <- values__[kkk__]
    }
  }
  INDIVvalues <- fit[!duplicated(fit$ID),c(id__,feNames__,covs__)]
  IQRsaveCSVdata(INDIVvalues,filename=paste0(projectPath,"/RESULTSORIG/project_indiv.csv"))
  covs__ <- projectHeader__$COVARIATENAMES
  if (covs__[1] == "") covs__ <- NULL
  if ("CMT" %in% names(fit)) {
    PRED__ <- fit[,c("ID","TIME","DV","PRED","CPRED","IPRED","CWRES","RES","IWRES","NPDE","EPRED","ERES",covs__,"CMT")]
    PRED__$CMT <- as.character(PRED__$CMT)
    PRED__$CMT <- as.numeric(gsub("OUTPUT","",PRED__$CMT))
    names(PRED__)[names(PRED__)=="CMT"] <- "YTYPE"
  } else {
    PRED__ <- fit[,c("ID","TIME","DV","PRED","CPRED","IPRED","CWRES","RES","IWRES","NPDE","EPRED","ERES",covs__)]
    PRED__$YTYPE <- 1 
  }
  PRED__$TIMEPOS <- NA
  PRED__$TAD <- NA
  PRED__$MDV <- 0 
  PRED__$EVID <- 0 
  PRED__$CENS <- 0 
  sort__ <- c("ID","TIME","TIMEPOS","TAD","YTYPE","MDV","EVID","CENS","DV","IPRED","PRED","CPRED","EPRED","IWRES","RES","CWRES","ERES","NPDE",covs__)
  PRED__ <- PRED__[,sort__]
  PRED__ <- dplyr::arrange(PRED__,ID,TIME)
  IQRsaveCSVdata(PRED__,filename=paste0(projectPath,"/RESULTSORIG/project_pred.csv"))
}
plotConvergenceNLMIXR <- function(projectPath) {
  projectinfo__ <- parseNLMIXRprojectHeader(projectPath)
  if (toupper(projectinfo__$METHOD) != "SAEM") {
    return(NULL)
  }
  fit <- NULL
  suppressWarnings(fit <- tryCatch({
    load(paste0(projectPath,"/RESULTSORIG/project.fit"))
    fit
  }, error = function(err) {
    NULL
  }))
  if (is.null(fit$TIME)) {
    return (NULL)
  }
  data <- tidyr::spread(fit$par.hist.stacked,par,val)
  names(data) <- gsub("\\<trans","",names(data))
  names(data) <- gsub("\\<ETA_","omega_",names(data))
  names(data) <- gsub("\\<iter\\>","ITERATION",names(data))
  fenames <- projectinfo__$PARAMNAMES[!grepl("\\<beta_",projectinfo__$PARAMNAMES)]
  fixnames <- intersect(fenames,names(data))
  dummy__ <- sapply(fixnames, function (fn) {
    phi <- as.numeric(data[[fn]])
    trans <- projectinfo__$PARAMTRANS[which(projectinfo__$PARAMNAMES==fn)]
    if (trans=="") {
      new <- phi
    } else {
      new <- eval(parse(text=trans))
    }
    data[[fn]] <<- new
  })
  renames <- names(data)[grepl("\\<omega_",names(data))]
  dummy__ <- sapply(renames, function (rn) {
    data[[rn]] <<- sqrt(data[[rn]])
  })
  gathercols__ <- setdiff(names(data),"ITERATION")
  plotData__ <- tidyr::gather(data = data, key = "NAME",value = "VALUE",
                               dplyr::one_of(gathercols__))
  plotData__$TYPE <- "Default"
  plotData__$GROUP <- "Default"
  dummy__ <- sapply(projectinfo__$PARAMNAMES, function (n__) {
    plotData__$TYPE[plotData__$NAME==n__] <<- "Fixed Effects"
  })
  plotData__$TYPE[grepl("^omega_",plotData__$NAME)] <- "Random Effects"
  plotData__$TYPE[grepl("^error_",plotData__$NAME)] <- "Error Parameters"
  plotData__$TYPE[grepl("^beta_",plotData__$NAME)] <- "Covariates"
  plotData__$TYPE <- factor(plotData__$TYPE,levels=c("Fixed Effects",
                                                     "Random Effects",
                                                     "Covariates",
                                                     "Error Parameters"))
  un <- unique(plotData__$NAME)
  cols__ <- c(
    fixnames,
    un[grepl("\\<omega_",un)],
    un[grepl("\\<beta_",un)],
    projectinfo__$ERRORNAMES
  )
  plotData__$NAME <- factor(plotData__$NAME,levels=cols__)
  p <- IQRggplot(data=plotData__, aes_string(x="ITERATION",y="VALUE", color="TYPE", group="GROUP")) +
    geom_line(size=0.5) +
    scale_color_IQRtools() +
    facet_wrap(~NAME,scales="free") +
    ylab(label=NULL) +
    theme(legend.position="bottom",
          legend.background=element_rect(linetype="solid",color="black")) +
    ggtitle("Convergence trajectories for NLMIXR/SAEM estimation",
            subtitle = "'omega_' elements indicate standard deviations of random effects")
  attr(p,"plotData") <- plotData__
  p
}
sampleNLMIXRpopulationParameters <- function(input, FLAG_SAMPLE=FALSE, verbose=TRUE) {
  output__                                      <- list()
  output__$type                                 <- 'NLMIXR'
  output__$path                                 <- input$path
  paramNames                                  <- input$parameters$names
  values                                      <- input$parameters$values
  covariance                                  <- input$parameters$covariancematrix
  covariance[abs(covariance)<100*.Machine$double.eps] <- 0
  covariance <- matrix(covariance,ncol=ncol(input$parameters$covariancematrix))
  rownames(covariance) <- rownames(input$parameters$covariancematrix)
  colnames(covariance) <- colnames(input$parameters$covariancematrix)
  if (FLAG_SAMPLE) {
    if (!is.null(covariance)) {
      samples__ <- mvrnorm(n=1,mu=values,Sigma=covariance)
    } else {
      if (verbose) {
        warningIQR('The covariance matrix was not determined => No sampling of population parameters from uncertainty distributions.')
      }
      samples__ <- values
    }
  } else {
    samples__ <- values
    if (verbose) {
      message('No sampling of population parameters from uncertainty distributions.')
    }
  }
  output__$fixedEffects$names <- input$parameters$names[!grepl("\\<(beta_|error_)",input$parameters$names)]
  FEsamples__ <- samples__[!grepl("\\<(beta_|error_)",input$parameters$names)]
  trans__ <- input$parameters$transformation[!grepl("\\<(beta_|error_)",input$parameters$names)]
  output__$fixedEffects$values <- sapply(1:length(trans__), function (k__) {
    phi <- FEsamples__[k__]
    eval(parse(text=trans__[k__]))
  })
  output__$randomEffects$names <- output__$fixedEffects$names
  output__$randomEffects$values <- input$rawParameterInfo$randomEffects$values
  output__$randomEffects$covariancematrix <- input$rawParameterInfo$randomEffects$covariance
  cov__ <- output__$randomEffects$covariancematrix
  sd__ <- sqrt(diag(cov__))
  cor__ <- array(t(cov__/sd__)/sd__,dim(cov__))
  aux__ <- array(t(cov__/sd__)/sd__)
  aux__[is.nan(aux__)] <- 0
  cor__ <- array(aux__,dim(cov__))
  for (k__ in 1:ncol(cor__)) {
    cor__[k__,k__] <- ifelse(cor__[k__,k__]==0,1,cor__[k__,k__])
  }
  output__$randomEffects$correlationmatrix <- cor__
  output__$randomEffects$transformation     <- input$trans_randeffects
  output__$randomEffects$inv_transformation <- input$inv_trans_randeffects
  output__$residualErrorModel$alias <- input$residualerrormodels
  output__$residualErrorModel$abcr <- c(NA,NA)
  if (input$residualerrormodels == "abs") output__$residualErrorModel$abcr[1] <- input$raw$errorParameter$values[1]
  if (input$residualerrormodels == "rel") output__$residualErrorModel$abcr[2] <- input$raw$errorParameter$values[1]
  if (input$residualerrormodels == "absrel") {
    output__$residualErrorModel$abcr[1] <- input$raw$errorParameter$values[1]
    output__$residualErrorModel$abcr[2] <- input$raw$errorParameter$values[2]
  }
  output__$residualErrorModel$formula <- NULL
  output__$residualErrorModel$FlagTransf <- 0
  ix__            <- which(grepl('beta_',paramNames))
  covariates      <- paramNames[ix__]
  covariatevalues <- samples__[ix__]
  categorical_covariates              <- list()
  categorical_covariates$parameter    <- c()
  categorical_covariates$covariate    <- c()
  for (k__ in seq_along(input$PROJECTINFO$BETACATNAMES)) {
    if (nchar(input$PROJECTINFO$BETACATNAMES[k__]) > 0) {
      bcnk <- input$PROJECTINFO$BETACATNAMES[k__]
      bcnk <- aux_strrep(bcnk,'beta_','')
      bcnk <- aux_strrep(bcnk,'(',',')
      bcnk <- aux_strrep(bcnk,')','')
      terms <- aux_explodePC(bcnk)
      xx <- aux_strrep(input$PROJECTINFO$BETACATCATEGORIES[k__],"[","c(")
      xx <- aux_strrep(xx,"]",")")
      xx <- aux_strrep(xx," ",",")
      categories <- eval(parse(text=xx))
      reference  <- as.double(input$PROJECTINFO$BETACATREFERENCE[k__])
      categorical_covariates$parameter <- c(categorical_covariates$parameter, terms[1])
      categorical_covariates$covariate <- c(categorical_covariates$covariate, terms[2])
      categorical_covariates$categories[[k__]] <- categories
      categorical_covariates$reference <- c(categorical_covariates$reference, reference)
      values_cat <- c()
      for (k2__ in seq_along(categories)) {
        n <- aux_strrep(input$PROJECTINFO$BETACATNAMES[k__],')',sprintf('_%d)',categories[k2__]))
        if (categories[k2__] == reference) {
          value <- 0
        } else {
          value <- covariatevalues[which(n==covariates)]
        }
        values_cat <- c(values_cat,value)
      }
      categorical_covariates$value[[k__]] <- values_cat
    }
  }
  continuous_covariates <- list()
  continuous_covariates$parameter <- c()
  continuous_covariates$covariate <- c()
  continuous_covariates$formula   <- c()
  continuous_covariates$value     <- c()
  for (k__ in seq_along(input$PROJECTINFO$BETACOVNAMES)) {
    if (nchar(input$PROJECTINFO$BETACOVNAMES[k__]) > 0) {
      bcnk <- input$PROJECTINFO$BETACOVNAMES[k__]
      bcnk <- aux_strrep(bcnk,'beta_','')
      bcnk <- aux_strrep(bcnk,'(',',')
      bcnk <- aux_strrep(bcnk,')','')
      terms <- aux_explodePC(bcnk)
      continuous_covariates$parameter  <- c(continuous_covariates$parameter, terms[1])
      continuous_covariates$covariate  <- c(continuous_covariates$covariate, terms[2])
      continuous_covariates$formula    <- c(continuous_covariates$formula, input$PROJECTINFO$BETACOVTRANS[k__])
      continuous_covariates$value      <- c(continuous_covariates$value, covariatevalues[which(input$PROJECTINFO$BETACOVNAMES[k__]==covariates)])
    }
  }
  continuous <- list()
  for (k__ in seq_along(continuous_covariates$parameter)) {
    if (k__==1) {
      continuous[[k__]] <- list(
        parameter  = continuous_covariates$parameter[k__],
        covariates = continuous_covariates$covariate[k__],
        values     = continuous_covariates$value[k__],
        formula    = continuous_covariates$formula[k__])
    } else {
      ix__ <- which(continuous_covariates$parameter[k__]==sapply(continuous,function(x) x$parameter))
      if (length(ix__) == 0) {
        continuous[[length(continuous)+1]] <- list(
          parameter  = continuous_covariates$parameter[k__],
          covariates = continuous_covariates$covariate[k__],
          values     = continuous_covariates$value[k__],
          formula    = continuous_covariates$formula[k__])
      } else {
        continuous[[ix__]]$covariates <- c(continuous[[ix__]]$covariates, continuous_covariates$covariate[k__])
        continuous[[ix__]]$values     <- c(continuous[[ix__]]$values, continuous_covariates$value[k__])
        continuous[[ix__]]$formula    <- c(continuous[[ix__]]$formula, continuous_covariates$formula[k__])
      }
    }
  }
  output__$covariates$continuous <- continuous
  categorical <- list()
  for (k__ in seq_along(categorical_covariates$parameter)) {
    if (k__==1) {
      information <- list()
      information[[1]] <- list(
        categories = categorical_covariates$categories[k__],
        values = categorical_covariates$value[k__]
      )
      categorical[[k__]] <- list(
        parameter  = categorical_covariates$parameter[k__],
        covariates = categorical_covariates$covariate[k__],
        information = information)
    } else {
      ix__ <- which(categorical_covariates$parameter[k__]==sapply(categorical,function(x) x$parameter))
      if (length(ix__) == 0) {
        information <- list()
        information[[1]] <- list(categories = categorical_covariates$categories[k__],
                                 values = categorical_covariates$value[k__]
        )
        categorical[[length(categorical)+1]] <- list(
          parameter  = categorical_covariates$parameter[k__],
          covariates = categorical_covariates$covariate[k__],
          information = information)
      } else {
        information <- list()
        information[[1]] <- list(
          categories = categorical_covariates$categories[k__],
          values = categorical_covariates$value[k__]
        )
        categorical[[ix__]]$covariates <- c(categorical[[ix__]]$covariates, categorical_covariates$covariate[k__])
        categorical[[ix__]]$information[[length(categorical[[ix__]]$information)+1]] <- list(
          categories = categorical_covariates$categories[k__],
          values = categorical_covariates$value[k__]
        )
      }
    }
  }
  output__$covariates$categorical <- categorical
  return(output__)
}
read_ETA_INDIV_PRED_NLMIXRoutputTables <- function (projectPath) {
  etafile__   <- paste0(projectPath,"/RESULTSORIG/project_eta.csv")
  indivfile__ <- paste0(projectPath,"/RESULTSORIG/project_indiv.csv")
  predfile__  <- paste0(projectPath,"/RESULTSORIG/project_pred.csv")
  tableInfo__ <- lapply(c(etafile__,indivfile__,predfile__), function (filename) {
    IQRloadCSVdata(filename)
  })
  names(tableInfo__) <- c("ETA","INDIV","PRED")
  paramNames__ <- gsub(x = names(tableInfo__$ETA)[grepl(pattern = "ETA_",names(tableInfo__$ETA))],pattern = "ETA_",replacement = "")
  headerInfo__ <- parseNLMIXRprojectHeader(projectPath)
  attr(tableInfo__,"paramNames")     <- paramNames__
  attr(tableInfo__,"covariateNames") <- headerInfo__$COVARIATENAMES
  attr(tableInfo__,"covNames")       <- headerInfo__$COVNAMES
  attr(tableInfo__,"catNames")       <- headerInfo__$CATNAMES
  attr(tableInfo__,"ALT_NAMES_USED") <- c("XPRED", "XWRES", "IPRED", "IWRES")
  if (headerInfo__$METHOD=="SAEM") {
    tableInfo__$PRED$XPRED <- tableInfo__$PRED$EPRED
    tableInfo__$PRED$XWRES <- tableInfo__$PRED$ERES
    attr(tableInfo__,"ALT_NAMES_ORIG") <- c("EPRED", "ERES", "IPRED", "IWRES")
  } else {
    tableInfo__$PRED$XPRED <- tableInfo__$PRED$CPRED
    tableInfo__$PRED$XWRES <- tableInfo__$PRED$CWRES
    attr(tableInfo__,"ALT_NAMES_ORIG") <- c("CPRED", "CWRES", "IPRED", "IWRES")
  }
  return(tableInfo__)
}
#'@export
is_NONMEM_IQRnlmeProject <- function (projectPath) {
  testfile__ <- paste0(projectPath,'/','project.nmctl')
  if (file.exists(testfile__)) return(hasHeader_IQRnlmeProject(testfile__))
  return(FALSE)
}
plotConvergenceNONMEM <- function(projectPath) {
  projectinfo__ <- parseNONMEMprojectHeader(projectPath)
  THETANAMES__      = aux_strrep(aux_strrep(aux_strrep(projectinfo__$THETANAMES,'(','_'),')','_'),',','_');
  ETANAMES__        = aux_strrep(aux_strrep(aux_strrep(projectinfo__$ETANAMES,'(','_'),')','_'),',','_');
  BETACATNAMES__    = aux_strrep(aux_strrep(aux_strrep(projectinfo__$BETACATNAMES,'(','_'),')','_'),',','_');
  ERRORNAMES__      = projectinfo__$ERRORNAMES
  ixSAEM__ <- which(projectinfo__$METHOD=="SAEM")
  ixBAYES__ <- which(projectinfo__$METHOD=="BAYES")
  ixPlot__ <- c(SAEM=ixSAEM__,BAYES=ixBAYES__)
  if (length(ixPlot__) > 1) stopIQR("Several convergence plots not handled at the moment ... sorry")
  nrTable__ <- ixPlot__[1]
  if (!file.exists(paste0(projectPath, '/RESULTSORIG/project.ext')))
    stopIQR('project.ext file could not be found.');
  x <- getTableNnonmemOutput(paste0(projectPath, '/RESULTSORIG/project.ext'),nrTable__)
  names(x) <- gsub(x=names(x),pattern="\\.",replacement="_")
  namesCol__ <- names(x)
  x <- matrix(as.double(as.matrix(x)), ncol=length(namesCol__))
  colnames(x) <- namesCol__
  x <- as.data.frame(x)
  x <- x[x$ITERATION>-100000000,]
  x <- x[,which(apply(abs(x),2,sum)!=0)]
  ix__ <- which(apply(x,2,sd) > .Machine$double.eps)
  ix__ <- unique(c(ix__, ncol(x)))
  x <- x[,ix__]
  header__          <- names(x)
  n <- names(x)[which(grepl("ITERATION",names(x)))]
  xITERATION__      <- as.data.frame(x[,which(grepl("ITERATION",names(x)))])
  names(xITERATION__) <- n
  n <- names(x)[which(grepl("THETA",names(x)))]
  xTHETA__          <- as.data.frame(x[,which(grepl("THETA",names(x)))])
  names(xTHETA__) <- n
  n <- names(x)[which(grepl("OMEGA",names(x)))]
  xOMEGA__          <- as.data.frame(x[,which(grepl("OMEGA",names(x)))])
  names(xOMEGA__) <- n
  n <- names(x)[ncol(x)]
  xOBJ__            <- as.data.frame(x[,ncol(x)])
  names(xOBJ__) <- n
  n <- names(x)[which(grepl("SIGMA",names(x)))]
  xSIGMA__          <- as.data.frame(x[,which(grepl("SIGMA",names(x)))])
  names(xSIGMA__) <- n
  xSTDCORR__ <- list()
  h <- aux_strrep(aux_strrep(names(xOMEGA__),'OMEGA',''),'_',',')
  h2 <- names(xOMEGA__)
  for (k__ in seq_along(h)) {
    rc <- aux_explodePC(substr(h[k__],2,nchar(h[k__])-1))
    r <- as.double(rc[1])
    c <- as.double(rc[2])
    if (r==c) {
      xSTDCORR__[[sprintf('%s',ETANAMES__[r])]] <- sqrt(xOMEGA__[,k__])
    }
  }
  xSTDCORR__ <- as.data.frame(xSTDCORR__)
  nSTD__ <- ncol(xSTDCORR__)
  for (k__ in seq_along(h)) {
    rc <- aux_explodePC(substr(h[k__],2,nchar(h[k__])-1))
    r <- as.double(rc[1])
    c <- as.double(rc[2])
    if (r!=c) {
      covariance <- xOMEGA__[,k__]
      variance1  <- xOMEGA__[[(sprintf('OMEGA_%d_%d_',r,r))]]
      variance2  <- xOMEGA__[[(sprintf('OMEGA_%d_%d_',c,c))]]
      correlation <- xOMEGA__[,k__]/sqrt(variance1*variance2)
      xSTDCORR__[[(sprintf('corr_%s_%s',ETANAMES__[c],ETANAMES__[r]))]] <- correlation
    }
  }
  if (ncol(xSTDCORR__)>0) {
    n <- names(xSTDCORR__)[1:nSTD__]
    xSTANDARD__ <- as.data.frame(xSTDCORR__[,n])
    names(xSTANDARD__) <- n
    if (ncol(xSTDCORR__) > nSTD__) {
      n <- names(xSTDCORR__)[(nSTD__+1):ncol(xSTDCORR__)]
      xCORR__     <- as.data.frame(xSTDCORR__[,n])
      names(xCORR__) <- n
    } else {
      xCORR__ <- NULL
    }
  } else {
    xCORR__ <- NULL
    xSTANDARD__ <- NULL
  }
  header__ <- names(xTHETA__)
  theta_name_indices__ <- c()
  for (k__ in seq_along(header__))
    theta_name_indices__ <- c(theta_name_indices__, as.double(aux_strrep(header__[k__],'THETA','')))
  names(xTHETA__) <- THETANAMES__[theta_name_indices__]
  n <- names(xTHETA__)[grepl('beta_',names(xTHETA__))]
  xBETA__ <- as.data.frame(xTHETA__[,grepl('beta_',names(xTHETA__))])
  names(xBETA__) <- n
  n <- names(xTHETA__)[!grepl('beta_',names(xTHETA__))]
  xTHETA__ <- as.data.frame(xTHETA__[,!grepl('beta_',names(xTHETA__))])
  names(xTHETA__) <- n
  n <- projectinfo__$ERRORNAMES
  xERROR__ <- sqrt(xSIGMA__)
  names(xERROR__) <- n
  if (ncol(xBETA__) > 0) {
    xBETA_cov__ <- xBETA__
    header__ <- names(xBETA__)
    ix_beta_cat <- c()
    for (k__ in seq_along(BETACATNAMES__)) {
      if (nchar(BETACATNAMES__[k__]) > 0) {
        ix_beta_cat <- c(ix_beta_cat, which(grepl(BETACATNAMES__[k__],header__)))
      }
    }
    n <- names(xBETA__)[ix_beta_cat]
    xBETA_cat__ <- as.data.frame(xBETA__[,ix_beta_cat])
    names(xBETA_cat__) <- n
    if (ncol(xBETA_cat__) * nrow(xBETA_cat__)==0) xBETA_cat__ <- NULL
    n <- names(xBETA__)[setdiff(1:ncol(xBETA__),ix_beta_cat)]
    xBETA_cov__ <- as.data.frame(xBETA__[,setdiff(1:ncol(xBETA__),ix_beta_cat)])
    names(xBETA_cov__) <- n
    if (ncol(xBETA_cov__) * nrow(xBETA_cov__)==0) xBETA_cov__ <- NULL
  } else {
    xBETA_cov__ <- NULL
    xBETA_cat__ <- NULL
  }
  xTHETA_trans__ <- as.data.frame(lapply(names(xTHETA__),function(x) {
    ix__ <- which(x==projectinfo__$PARAMNAMES)
    trans <- projectinfo__$PARAMTRANS[ix__]
    phi <- xTHETA__[,x]
    eval(parse(text=trans))
  }))
  names(xTHETA_trans__) <- names(xTHETA__)
  xTHETA__ <- xTHETA_trans__
  if (projectinfo__$METHOD[nrTable__]!='IMP') {
    plotTHETA__ <- tidyr::gather(cbind(xITERATION__,xTHETA__),NAME,VALUE,-ITERATION)
    plotTHETA__$TYPE  <- "Fixed Effects"
    plotTHETA__$GROUP <- "Default"
    if (is.null(xBETA_cov__)) {
      plotBETA_cov__ <- NULL
    } else {
      plotBETA_cov__ <- tidyr::gather(cbind(xITERATION__,xBETA_cov__),NAME,VALUE,-ITERATION)
      plotBETA_cov__$TYPE <- "Continuous Covariates"
      plotBETA_cov__$GROUP <- "Default"
      NAME <- gsub(x=plotBETA_cov__$NAME,pattern="beta_",replacement="")
      NAME <- gsub(x=NAME,pattern="_$",replacement="")
      plotBETA_cov__$NAME <- NAME
    }
    if (is.null(xBETA_cat__)) {
      plotBETA_cat__ <- NULL
    } else {
      plotBETA_cat__ <- tidyr::gather(cbind(xITERATION__,xBETA_cat__),NAME,VALUE,-ITERATION)
      plotBETA_cat__$TYPE <- "Categorical Covariates"
      NAME  <- plotBETA_cat__$NAME
      GROUP <- gsub(x=plotBETA_cat__$NAME,pattern="beta_",replacement="")
      GROUP <- gsub(x=GROUP,pattern="_[0-9]+_","")
      plotBETA_cat__$GROUP <- NAME
      plotBETA_cat__$NAME  <- GROUP
    }
    if (is.null(xSTANDARD__)) {
      plotSTANDARD__ <- NULL
    } else {
      plotSTANDARD__ <- tidyr::gather(cbind(xITERATION__,xSTANDARD__),NAME,VALUE,-ITERATION)
      plotSTANDARD__$TYPE <- "Random Effects"
      plotSTANDARD__$GROUP <- "Default"
      NAME <- gsub(x=plotSTANDARD__$NAME,pattern="omega_",replacement="omega(")
      NAME <- gsub(x=NAME,pattern="_$",replacement=")")
      plotSTANDARD__$NAME <- NAME
    }
    if (is.null(xCORR__)) {
      plotCORR__ <- NULL
    } else {
      plotCORR__ <- tidyr::gather(cbind(xITERATION__,xCORR__),NAME,VALUE,-ITERATION)
      plotCORR__$TYPE <- "IIV Correlations"
      NAME  <- plotCORR__$NAME
      plotCORR__$GROUP <- NAME
      plotCORR__$NAME  <- "IIV Correlations"
    }
    plotERROR__ <- tidyr::gather(cbind(xITERATION__,xERROR__),NAME,VALUE,-ITERATION)
    plotERROR__$TYPE <- "Error Parameters"
    plotERROR__$GROUP <- "Default"
    plotOBJ__ <- tidyr::gather(cbind(xITERATION__,xOBJ__),NAME,VALUE,-ITERATION)
    plotOBJ__$TYPE <- "Objective Function"
    plotOBJ__$GROUP <- "Default"
    plotALL__ <- rbind(plotTHETA__,plotBETA_cov__,plotBETA_cat__,plotSTANDARD__,plotCORR__,plotERROR__,plotOBJ__)
    plotALL__$NAME <- factor(plotALL__$NAME, levels = unique(plotALL__$NAME))
    plotALL__$TYPE <- factor(plotALL__$TYPE, levels = unique(plotALL__$TYPE))
  } else {
    plotOBJ__ <- tidyr::gather(cbind(xITERATION__,xOBJ__),NAME,VALUE,-ITERATION)
    plotOBJ__$TYPE <- "Objective Function"
    plotOBJ__$GROUP <- "Default"
    plotALL__ <- rbind(plotOBJ__)
    plotALL__$NAME <- factor(plotALL__$NAME, levels = unique(plotALL__$NAME))
    plotALL__$TYPE <- factor(plotALL__$TYPE, levels = unique(plotALL__$TYPE))
  }
  p <- IQRggplot(data=plotALL__, aes_string(x="ITERATION",y="VALUE",color="TYPE",group="GROUP")) +
    scale_color_IQRtools() +
    geom_line(size=0.5) +
    facet_wrap(~NAME,scales="free") +
    theme(legend.position="bottom",
          legend.background=element_rect(linetype="solid",color="black"))  +
    ggtitle("Convergence trajectories for NONMEM estimation",
            subtitle = "'omega_' elements indicate standard deviations of random effects")
  attr(p,"plotData") <- plotALL__
  p
}
#'@export
getTableNnonmemOutput <- function(filename, nrTable) {
  content__ <- aux_fileread(filename)
  ix__ <- aux_strFindAll(content__,sprintf('TABLE NO.     %d',nrTable))$start
  if (is.null(ix__)) stopIQR(sprintf('getTableNnonmemOutput: Table %d could not be found.',nrTable))
  table <- substr(content__,ix__,nchar(content__))
  ix__ <- aux_strFindAll(table,sprintf('TABLE NO.'))$start
  if (length(ix__)>1) table <- substr(table,1,ix__[2]-1)
  data__ <- NONMEMoutputTable2dataframe(table)
  return(data__)
}
NONMEMoutputTable2dataframe <- function(table) {
  ix__ <- aux_strFindAll(table,"\n")$start
  table <- substr(table,ix__[1]+1,nchar(table))
  table <- gsub(x=table,pattern="\\n",replacement=":@:@:@:@")
  table <- gsub(x=table,pattern="\\s+",replacement=" ")
  table <- gsub(x=table,pattern=":@:@:@:@",replacement="\n")
  table <- gsub(x=table,pattern="\n ",replacement="\n")
  table <- aux_strtrim(table)
  tempname__ <- tempfileIQR()
  aux_filewrite(table,tempname__) 
  data__ <- utils::read.delim(file=tempname__,header=TRUE,sep=" ",stringsAsFactors=FALSE,na.strings=c(".","NA","NaN"))
  unlink(tempname__)
  return(data__)
}
read_ETA_INDIV_PRED_NONMEMoutputTables <- function (projectPath) {
  etafile__   <- paste0(projectPath,"/RESULTSORIG/project.eta")
  indivfile__ <- paste0(projectPath,"/RESULTSORIG/project.indiv")
  predfile__  <- paste0(projectPath,"/RESULTSORIG/project.pred")
  iovetafile__ <- paste0(projectPath,"/RESULTSORIG/project.etaiov")
  tableInfo__ <- lapply(rbind(etafile__,indivfile__,predfile__,iovetafile__), function (filename) {
    if (file.exists(filename)) {
      out__ <- NONMEMoutputTable2dataframe(aux_fileread(filename))
    } else {
      out__ <- NULL
    }
    out__
  })
  names(tableInfo__) <- c("ETA","INDIV","PRED","ETAIOV")
  tableInfo__$PRED <- tableInfo__$PRED[tableInfo__$PRED$EVID==0,]
  paramNamesOK__ <- gsub(x = names(tableInfo__$ETA)[grepl(pattern = "ETA_",names(tableInfo__$ETA))],pattern = "ETA_",replacement = "")
  if (length(paramNamesOK__) > 0 & !is.null(tableInfo__$INDIV)) {
    names(tableInfo__$INDIV)[2:(1+length(paramNamesOK__))] <- paramNamesOK__
  }
  headerInfo__ <- parseNONMEMprojectHeader(projectPath)
  attr(tableInfo__,"paramNames")     <- paramNamesOK__
  attr(tableInfo__,"covariateNames") <- headerInfo__$COVARIATENAMES
  attr(tableInfo__,"covNames")       <- headerInfo__$COVNAMES
  attr(tableInfo__,"catNames")       <- headerInfo__$CATNAMES
  attr(tableInfo__,"ALT_NAMES_USED") <- headerInfo__$RESIDUAL_NAMES_USED
  attr(tableInfo__,"ALT_NAMES_ORIG") <- headerInfo__$RESIDUAL_NAMES_ORIG
  return(tableInfo__)
}
runNONMEMproject <- function(projectPath,ncores=1,FLAGclean=TRUE) {
  loadSetupOptions_IQRtools()
  toolVersion <- parseNLMEprojectHeader(projectPath)$TOOLVERSION
  PATH_SYSTEM_NONMEM <- .PATH_SYSTEM_NONMEM[[toolVersion]]
  PATH_SYSTEM_NONMEM_PARALLEL <- .PATH_SYSTEM_NONMEM_PARALLEL[[toolVersion]]
  if (nchar(PATH_SYSTEM_NONMEM) == 0 & ncores==1)
    stopIQR('Path to NONMEM executable not defined in setup_options_IQRtools.R file')
  if (nchar(PATH_SYSTEM_NONMEM_PARALLEL) == 0 & ncores > 1)
    stopIQR('Path to NONMEM parallel executable not defined in setup_options_IQRtools.R')
  oldpath__ <- getwd()
  setwd(projectPath)
  if (ncores == 1) {
    system(paste0(PATH_SYSTEM_NONMEM,' project.nmctl project.nmlog'))
  } else {
    system(paste0(PATH_SYSTEM_NONMEM_PARALLEL,' ',ncores,' project.nmctl project.nmlog'))
  }
  setwd(oldpath__)
  tryCatch({
    cleanNONMEMprojectFolder(projectPath,FLAGclean)
  }, error = function(e) {
    warningIQR(paste0('Problem with cleanup - NONMEM run pbly created a problem. Please check.',e))
  })
  x__ <- parseNONMEMresults(projectPath)
  info__ <- deparse(x__)
  aux_filewrite(info__,filename=sprintf('%s/RESULTS/project_results.x',projectPath))
  tryCatch({
    createNONMEMresultsTable(projectPath,filename=sprintf('%s/RESULTS/project_results.txt',projectPath))
  }, error = function(e) {
    warningIQR(paste0('Problem with creation of results table.',e))
  })
  convertETAINDIVPRED_IQRnlmeProject(projectPath = projectPath,pathName = paste0(projectPath,"/RESULTS"))
}
checkAndChangeModelSyntax4NONMEMconversion <- function(model,FLAG_CMT__) {
  if (length(model$reactions) > 0) {
    stopIQR("Model not allowed to contain reactions")
  }
  if (length(model$functions) > 0) {
    stopIQR("Model not allowed to contain functions")
  }
  if (length(model$events) > 0) {
    stopIQR("Model not allowed to contain events")
  }
  if (hasCcodeFunctions_IQRmodel(model)) {
    stopIQR("Model not allowed to contain C code functions")
  }
  nonmemfct__   <- c('LOG','LOG10','EXP','SQRT','SIN','COS','ABS','TAN','ASIN','ACOS','ATAN','ABS')
  iqrmodelfct__ <- tolower(c('LOG','LOG10','EXP','SQRT','SIN','COS','ABS','TAN','ASIN','ACOS','ATAN','ABS'))
  for (k__ in seq_along(model$states)) {
    model$states[[k__]]$IC <- aux_repStringElements(model$states[[k__]]$IC,nonmemfct__,iqrmodelfct__)
    model$states[[k__]]$ODE <- aux_repStringElements(model$states[[k__]]$ODE,nonmemfct__,iqrmodelfct__)
    model$states[[k__]]$IC <- gsub("^","**",model$states[[k__]]$IC,fixed = TRUE)
    model$states[[k__]]$ODE <- gsub("^","**",model$states[[k__]]$ODE,fixed = TRUE)
  }
  for (k__ in seq_along(model$variables)) {
    model$variables[[k__]]$formula <- aux_repStringElements(model$variables[[k__]]$formula,nonmemfct__,iqrmodelfct__)
    model$variables[[k__]]$formula <- gsub("^","**",model$variables[[k__]]$formula,fixed = TRUE)
  }
  if (FLAG_CMT__) return(model)
  for (k__ in seq_along(model$inputs)) {
    if (length(model$inputs[[k__]]$stateindex) > 1) {
      stopIQR('An INPUTn definition is used on more than one state. This can not be handled.')
    }
  }
  all_state_indices_with_input__ <- unlist(lapply(model$inputs,function(x) x$stateindex))
  if (length(all_state_indices_with_input__) != length(unique(all_state_indices_with_input__))) {
    stopIQR(sprintf('Multiple INPUTn definitions on the same state.\n\tThe ADM/YTYPE version can not be used.\n\tPlease use the CMT version.'))
  }
  if (!is.null(model$inputs)) {
    inputNumbers__ <- c()
    state_numbers__ <- c()
    for (k__ in seq_along(model$inputs)) {
      inputNumbers__ <- as.numeric(c(inputNumbers__, gsub(x=names(model$inputs)[k__],pattern='INPUT',replacement='')))
      state_numbers__ <- c(state_numbers__, model$inputs[[k__]]$stateindex)
    }
    if (length(model$states) < max(inputNumbers__)) {
      stopIQR('Model can not be handled by NONMEM due to INPUT* number larger than state numbers - consider changing INPUT* number.')
    }
    inputStates__ <- data.frame(INPUTS=NaN, STATES=1:length(model$states))
    for (k__ in seq_along(state_numbers__))
      inputStates__$INPUTS[state_numbers__[k__]] <- inputNumbers__[k__]
    available_state_numbers__ = setdiff(1:length(model$states),inputNumbers__)
    inputStates__$INPUTS[is.nan(inputStates__$INPUTS)] <- available_state_numbers__
    inputStates__ <- dplyr::arrange(inputStates__,INPUTS)
    model$states <- model$states[inputStates__$STATES]
    for (k__ in seq_along(model$inputs)) model$inputs[[k__]]$stateindex <- inputNumbers__[k__]
  }
  return(model)
}
reorderParameters4NONMEMcov <- function(param_est, modelSpec) {
  if (is.null(modelSpec$covarianceModel) | modelSpec$covarianceModel[1]=="diagonal") {
    out__ <- list(param_est=param_est, modelSpec=modelSpec)
    return(out__)
  }
  allEstParam_ordered__ <- sapply(param_est, function(x) x$name)
  allCovarianceParam_ordered__ <- aux_explode(paste(modelSpec$covarianceModel,collapse=","))
  if (length(allCovarianceParam_ordered__) != length(unique(allCovarianceParam_ordered__))) {
    stopIQR('Covariance model parameters not unique')
  }
  newOrderParameters__ <- c(allCovarianceParam_ordered__,setdiff(allEstParam_ordered__,allCovarianceParam_ordered__))
  originalOrderPOPvalues0__ <- names(modelSpec$POPvalues0)
  modelSpec$POPestimate     <- modelSpec$POPestimate[newOrderParameters__]
  modelSpec$POPvalues0      <- modelSpec$POPvalues0[newOrderParameters__]
  modelSpec$IIVestimate     <- modelSpec$IIVestimate[newOrderParameters__]
  modelSpec$IIVvalues0      <- modelSpec$IIVvalues0[newOrderParameters__]
  modelSpec$IIVdistribution <- modelSpec$IIVdistribution[newOrderParameters__]
  param_est                 <- param_est[sapply(newOrderParameters__, function(x) which(x==allEstParam_ordered__))]
  ixOrderFE__ <- match(newOrderParameters__,originalOrderPOPvalues0__)
  modelSpec$PriorVarPOP     <- modelSpec$PriorVarPOP[ixOrderFE__]
  modelSpec$PriorIIV        <- modelSpec$PriorIIV[ixOrderFE__,ixOrderFE__]
  out__ <- list(param_est=param_est, modelSpec=modelSpec)
  return(out__)
}
getmodelPartTextInfo4NONMEMconversion <- function(modelInfo,model_element_prefix__,timevariablereplacement__) {
  model__ <- modelInfo$model
  model__ <- strReplace_IQRmodel(model__,"time",timevariablereplacement__);
  sn__ <- statesInfo_IQRmodel(model__)$statenames
  rn__ <- reactionsInfo_IQRmodel(model__)$reacnames
  vn__ <- variablesInfo_IQRmodel(model__)$varnames
  vn__ <- vn__[which(!grepl("OUTPUT",vn__))]
  pn__ <- parametersInfo_IQRmodel(model__)$paramnames
  pn_not_consider__ <- c(
    sapply(modelInfo$param_est, function(x) x$name),
    sapply(modelInfo$param_pk, function(x) x$name),
    sapply(modelInfo$param_reg, function(x) x$name)
  )
  pn__ <- setdiff(pn__,pn_not_consider__)
  pn__ <- pn__[which(!grepl("INPUT",pn__))]
  allelements__ <- c(sn__, pn__, vn__, rn__)
  model__ <- strReplace_IQRmodel(model__,allelements__,paste0(model_element_prefix__,allelements__))
  if (length(sn__) > 0) sn__ <- paste0(model_element_prefix__,sn__)
  if (length(pn__) > 0) pn__ <- paste0(model_element_prefix__,pn__)
  if (length(vn__) > 0) vn__ <- paste0(model_element_prefix__,vn__)
  if (length(rn__) > 0) rn__ <- paste0(model_element_prefix__,rn__)
  StatesText <- ""
  for (k__ in seq_along(model__$states)) {
    StatesText <- sprintf('%s    %s = A(%d)\n',StatesText,names(model__$states)[k__],k__)
  }
  ParametersText <- ""
  pvalues <- parametersInfo_IQRmodel(model__)$paramvalues[pn__]
  for (k__ in seq_along(pn__)) {
    ParametersText = sprintf('%s    %s = %g\n',ParametersText,pn__[k__],pvalues[pn__[k__]])
  }
  VariablesText <- ""
  allvarindices__ <- seq(1,length(model__$variables))
  outputvarindices__ <- sapply(modelInfo$outputs,function(x) x$varindex)
  varindices__ <- setdiff(allvarindices__,outputvarindices__)
  if (length(varindices__) > 0) {
    for (k__ in seq_along(varindices__)) {
      formula        <- model__$variables[[varindices__[k__]]]$formula
      flag_piecewise__ <- grepl("piecewise\\(",formula)
      flag_min__       <- grepl("min\\(",formula)
      flag_max__       <- grepl("max\\(",formula)
      if (sum(c(flag_piecewise__,flag_min__,flag_max__)) > 1) {
        stopIQR('Model contains more than one MAX, MIN or PIECEWISEIQM expression in a variable assignment. Only one is allowed.');
      }
      if (sum(c(flag_piecewise__,flag_min__,flag_max__)) == 0) {
        VariablesText <- sprintf('%s    %s = %s\n',VariablesText,names(model__$variables)[varindices__[k__]],model__$variables[[varindices__[k__]]]$formula)
      } else {
        if (flag_piecewise__) {
          newText__ <- handleNONMEMpiecewise(names(model__$variables)[varindices__[k__]],model__$variables[[varindices__[k__]]]$formula)
          VariablesText <- sprintf('%s\n    %s\n\n',VariablesText,newText__);
        } else {
          if (flag_min__) {
            newText__ <- handleNONMEMminmax(names(model__$variables)[varindices__[k__]],model__$variables[[varindices__[k__]]]$formula,'min')
            VariablesText <- sprintf('%s\n    %s\n\n',VariablesText,newText__);
          } else {
            if (flag_max__) {
              newText__ <- handleNONMEMminmax(names(model__$variables)[varindices__[k__]],model__$variables[[varindices__[k__]]]$formula,'max')
              VariablesText <- sprintf('%s\n    %s\n\n',VariablesText,newText__);
            }
          }
        }
      }
    }
  }
  ODEsText__ <- ""
  ODEs <- c()
  for (k__ in seq_along(model__$states)) {
    ODE <- aux_removeWhiteSpace(model__$states[[k__]]$ODE)
    for (k2__ in seq_along(modelInfo$inputs)) {
      index <- which(modelInfo$inputs[[k2__]]$stateindex==k__)
      if (length(index) > 0) {
        termreplace__ <- gsub("^","**",aux_removeWhiteSpace(modelInfo$inputs[[k2__]]$terms[index]),fixed = TRUE)
        ODE <- gsub(x=ODE,pattern=termreplace__,replacement='',fixed=TRUE)
      }
    }
    if (substr(ODE,1,1) == '+') ODE <- substr(ODE,2,nchar(ODE))
    ODE <- gsub(x=ODE,pattern="^",replacement='**',fixed=TRUE)
    ODEs[k__] <- ODE
  }
  for (k__ in seq_along(model__$states)) {
    name <- names(model__$states)[k__]
    if (nchar(model_element_prefix__)>0) name <- gsub(x=name,pattern=model_element_prefix__,replacement='',fixed=TRUE)
    ODEsText__ <- sprintf('%s    DADT(%d) = %s ; %s\n',ODEsText__,k__,ODEs[k__],name)
  }
  out__ <- list(StatesText=StatesText, ParametersText=ParametersText, VariablesText=VariablesText, ODEsText__=ODEsText__)
  return(out__)
}
handleCovariateDefinitionsNONMEM <- function(MU_param_text__,
                                             modelSpec,
                                             modelInfo,
                                             data) {
  beta_parameters                  <- c()
  beta_parameters_cov_project_info <- c()
  beta_parameters_cat_project_info <- c()
  THETA_INDEX_BETA                 <- c()
  cov_type_continuous              <- c()
  covparam                         <- c()
  covcov                           <- c()
  COV_transformation_info__          <- c()
  CAT_reference_info               <- c()
  CAT_categories_info              <- list()
  COVCATestimate_info              <- c()
  COVCATguesses_info               <- c()
  COVCATpriorsVar_info             <- c()
  parameter_add_cov   <- c()
  cov_add_cov         <- c()
  cov_add_median      <- c()
  covTrans_text__       <- c()
  count__               <- 1
  text_defining_cat_auxiliaries__ <- ""
  cov_text <- rep("",length(modelInfo$param_est))
  covs_handled_text_defining_cat_auxiliaries__ <- c()
  for (kcov__ in seq_along(modelSpec$covariateModel)) {
    covParam <- names(modelSpec$covariateModel)[kcov__]
    covCOVs  <- modelSpec$covariateModel[[kcov__]]
    for (k2__ in seq_along(covCOVs)) {
      if (covCOVs[k2__] %in% data$covNames) {
        cov                         <- covCOVs[k2__]
        beta_parameters             <- c(beta_parameters, sprintf('beta_%s(%s)',covParam,covCOVs[k2__]))
        beta_parameters_cov_project_info <- c(beta_parameters_cov_project_info, sprintf('beta_%s(%s)',covParam,covCOVs[k2__]))
        if (length(THETA_INDEX_BETA)==0) {
          nextindex <- length(modelInfo$param_est)+1
        } else {
          nextindex <- max(THETA_INDEX_BETA)+1
        }
        THETA_INDEX_BETA            <- c(THETA_INDEX_BETA, nextindex)
        cov_type_continuous         <- c(cov_type_continuous, 1)
        parameter_add_cov           <- c(parameter_add_cov, covParam)
        cov_add_cov                 <- c(cov_add_cov, covCOVs[k2__])
        cov_median                  <- data$covariateMedianValues[covCOVs[k2__]]
        cov_add_median              <- c(cov_add_median, cov_median)
        COVCATestimate_info         <- c(COVCATestimate_info, modelSpec$COVestimate[[covParam]][cov])
        COVCATguesses_info          <- c(COVCATguesses_info, modelSpec$covariateModelValues[[covParam]][cov])
        COVCATpriorsVar_info        <- c(COVCATpriorsVar_info, modelSpec$PriorVarCovariateModelValues[[covParam]][cov])
        covparam <- c(covparam, covParam)
        covcov <- c(covcov, cov)
        ix__                          <- which(covParam==sapply(modelInfo$param_est,function(x) x$name))
        TRANS__                       <- modelSpec$IIVdistribution[ix__]
        if (TRANS__=='N') {
          covTrans_text__ <- c(covTrans_text__, sprintf('+ THETA(%d)*log(%s/%g) ',nextindex,covCOVs[k2__],cov_median))
          COV_transformation_info__ <- c(COV_transformation_info__, sprintf('log(cov/%g)',cov_median))
        }
        if (TRANS__=='L') {
          covTrans_text__ <- c(covTrans_text__, sprintf('+ THETA(%d)*log(%s/%g) ',nextindex,covCOVs[k2__],cov_median))
          COV_transformation_info__ <- c(COV_transformation_info__, sprintf('log(cov/%g)',cov_median))
        }
        if (TRANS__=='G') {
          covTrans_text__ <- c(covTrans_text__, sprintf('+ THETA(%d)*log(%s/%g) ',nextindex,covCOVs[k2__],cov_median))
          COV_transformation_info__ <- c(COV_transformation_info__, sprintf('log(cov/%g)',cov_median))
        }
      } else {
        cov                         <- covCOVs[k2__]
        cov_values                  <- data$catValues[[covCOVs[k2__]]]
        reference_value             <- data$covariateCATreference[[covCOVs[k2__]]]
        other_values                <- setdiff(cov_values,reference_value)
        CAT_reference_info          <- c(CAT_reference_info, reference_value)
        CAT_categories_info[[length(CAT_categories_info)+1]]  <- cov_values
        if (!(cov %in% covs_handled_text_defining_cat_auxiliaries__)) {
          for (kaux in seq_along(other_values)) {
            tryCatch({
              text_defining_cat_auxiliaries__ <- sprintf('%s    %s_%d = 0 ; reference: %d\n',text_defining_cat_auxiliaries__,cov,other_values[kaux],reference_value)
            }, error=function(e) {
              stopIQR("Please check if there are categorical covariate categories that are not integers!")
            })
          }
          for (kaux in seq_along(other_values)) {
            text_defining_cat_auxiliaries__ <- sprintf('%s    IF(%s.EQ.%d) %s_%d = 1\n',text_defining_cat_auxiliaries__,cov,other_values[kaux],cov,other_values[kaux])
          }
          covs_handled_text_defining_cat_auxiliaries__ <- c(covs_handled_text_defining_cat_auxiliaries__, cov)
        }
        for (kaux in seq_along(other_values)) {
          COVCATestimate_info   <- c(COVCATestimate_info,modelSpec$COVestimate[[covParam]][cov])
          COVCATguesses_info    <- c(COVCATguesses_info, modelSpec$covariateModelValues[[covParam]][cov])
          COVCATpriorsVar_info  <- c(COVCATpriorsVar_info, modelSpec$PriorVarCovariateModelValues[[covParam]][cov])
          covparam <- c(covparam, covParam)
          covcov <- c(covcov, cov)
          beta_parameters <- c(beta_parameters, sprintf('beta_%s(%s_%d)',covParam,cov,other_values[kaux]))
          element_add_check__ <- sprintf('beta_%s(%s)',covParam,cov)
          if (length(which(element_add_check__==beta_parameters_cat_project_info)) == 0) {
            beta_parameters_cat_project_info <- c(beta_parameters_cat_project_info,element_add_check__)
          }
          if (length(THETA_INDEX_BETA)==0) {
            nextindex <- length(modelInfo$param_est)+1
          } else {
            nextindex <- max(THETA_INDEX_BETA)+1
          }
          THETA_INDEX_BETA            <- c(THETA_INDEX_BETA, nextindex)
          cov_type_continuous         <- c(cov_type_continuous, 0)
          ixParam                     <- which(covParam==sapply(modelInfo$param_est,function(x) x$name))
          cov_text[ixParam]           <- sprintf('%s + THETA(%d)*%s_%d',cov_text[ixParam],nextindex,cov,other_values[kaux])
        }
      }
    }
  }
  cov_add_text_param__ <- rep("",length(modelInfo$param_est))
  for (k__ in seq_along(parameter_add_cov)) {
    ix__ <- which(parameter_add_cov[k__]==sapply(modelInfo$param_est,function(x) x$name))
    cov_add_text_param__[ix__] <- paste0(cov_add_text_param__[ix__], covTrans_text__[k__])
  }
  for (k__ in seq_along(MU_param_text__)) {
    MU_param_text__[k__] <- aux_strrep(MU_param_text__[k__],'X@X@X',paste0(aux_strtrim(cov_add_text_param__[k__]),'X@X@X'))
  }
  for (k__ in seq_along(MU_param_text__)) {
    MU_param_text__[k__] <- aux_strrep(MU_param_text__[k__],'X@X@X',cov_text[k__])
  }
  out <- list(
    MU_param_text__ = MU_param_text__,
    THETA_INDEX_BETA = THETA_INDEX_BETA,
    beta_parameters = beta_parameters,
    text_defining_cat_auxiliaries__ = text_defining_cat_auxiliaries__,
    cov_type_continuous = cov_type_continuous,
    covparam = covparam,
    covcov = covcov,
    beta_parameters_cov_project_info = beta_parameters_cov_project_info,
    beta_parameters_cat_project_info = beta_parameters_cat_project_info,
    COV_transformation_info = COV_transformation_info__,
    CAT_reference_info = CAT_reference_info,
    CAT_categories_info = CAT_categories_info,
    COVCATestimate_info = COVCATestimate_info,
    COVCATguesses_info  = COVCATguesses_info,
    COVCATpriorsVar_info = COVCATpriorsVar_info
  )
  return(out)
}
handleNONMEMminmax <- function (name,formula,type) {
  formula <- aux_removeWhiteSpace(formula)
  index <- aux_strFindAll(formula, paste0(type,"("))
  if (length(index$start) > 1) {
    stopIQR('More than one min or max expression in a formula. Only one is allowed.')
  }
  mmformula__ <- substr(formula,index$start,nchar(formula))
  offset__ <- nchar(type) + 2
  po__ <- 1
  while (po__!=0) {
    if (substr(mmformula__,offset__,offset__) == '(') po__ <- po__+1
    if (substr(mmformula__,offset__,offset__) == ')') po__ <- po__-1
    offset__ <- offset__+1
  }
  mmformula__ <- substr(mmformula__,1,offset__-1)
  if (nchar(formula) != nchar(mmformula__)) {
    stopIQR("A min or max function is present as a variable formula. In this formula\nthe expression is more complex than a simple VAR = min(...) or max(...)\nPlease rewrite your model to have the min() or max() statement as only\ncomponent of the formula RHS.")
  }
  arguments <- substr(mmformula__,5,nchar(mmformula__)-1)
  elements <- aux_explodePC(arguments)
  if (type=='max') {
    text__ <- sprintf('IF((%s).GT.(%s)) THEN\n',elements[1],elements[2]);
    text__ <- sprintf('%s        %s = %s\n',text__,name,elements[1]);
    text__ <- sprintf('%s    ELSE\n',text__);
    text__ <- sprintf('%s        %s = %s\n',text__,name,elements[2]);
    text__ <- sprintf('%s    ENDIF',text__);
  } else {
    text__ <- sprintf('IF((%s).LT.(%s)) THEN\n',elements[1],elements[2]);
    text__ <- sprintf('%s        %s = %s\n',text__,name,elements[1]);
    text__ <- sprintf('%s    ELSE\n',text__);
    text__ <- sprintf('%s        %s = %s\n',text__,name,elements[2]);
    text__ <- sprintf('%s    ENDIF',text__);
  }
  changedformula__ <- text__
  return(changedformula__)
}
handleNONMEMpiecewise <- function (name,formula) {
  formula <- aux_removeWhiteSpace(formula)
  index__ <- aux_strFindAll(formula, "piecewise(")
  if (length(index__$start) > 1) {
    stopIQR('More than one piecewise expression in a formula. Only one is allowed.')
  }
  pwformula__ <- substr(formula,index__$start,nchar(formula))
  offset__ <- nchar("piecewise") + 2
  po__ <- 1
  while (po__!=0) {
    if (substr(pwformula__,offset__,offset__) == '(') po__ <- po__+1
    if (substr(pwformula__,offset__,offset__) == ')') po__ <- po__-1
    offset__ <- offset__+1
  }
  pwformula__ <- substr(pwformula__,1,offset__-1)
  if (nchar(formula) != nchar(pwformula__)) {
    stopIQR("A piecewise function is present as a variable formula. In this formula\nthe expression is more complex than a simple VAR = piecewise(...)\nPlease rewrite your model to have the piecewise() statement as only\ncomponent of the formula RHS.")
  }
  arguments <- substr(pwformula__,11,nchar(pwformula__)-1)
  elements <- aux_explodePC(arguments)
  for (k__ in seq(2,length(elements),2))
    elements[k__] <- convertlogicalrelationalexpressionsNONMEM(elements[k__])
  n <- length(elements)
  if (n/2 == floor(n/2)) {
    elsepresent__ <- FALSE
  } else {
    elsepresent__ <- TRUE
  }
  if (elsepresent__) {
    elseelement__ <- elements[length(elements)]
    elements <- elements[1:(length(elements)-1)]
  }
  text__ <- sprintf('IF(%s) THEN\n        %s = %s\n',elements[2],name,elements[1])
  if (length(elements) > 2) {
    for (k__ in seq(4,length(elements),2)) {
      text__ <- sprintf('%s    ELSEIF(%s) THEN\n        %s = %s\n',text__,elements[k__],name,elements[k__-1])
    }
  }
  if (elsepresent__) text__ <- sprintf('%s    ELSE\n        %s = %s\n',text__,name,elseelement__)
  text__ <- sprintf('%s    ENDIF',text__)
  changedformula__ <- text__
  return(changedformula__)
}
convertlogicalrelationalexpressionsNONMEM <- function(exp) {
  operatorsfind__ <- c('and','or','andIQM','orIQM','lt','gt','le','ge','eq','ne')
  operatorsuse__  <- c('.AND.','.OR.','.AND.','.OR.',' < ',' > ',' <= ',' >= ',' == ',' /= ')
  exp <- paste0("#",exp,"#")
  for (k__ in seq_along(operatorsfind__)) {
    index__ <- regexpr(text=exp,pattern=paste0('\\W', operatorsfind__[k__], '\\W'))
    if (index__ != -1) {
      exppre__ <- substr(exp,1,index__)
      temp <- substr(exp,index__+1+nchar(operatorsfind__[k__])+1,nchar(exp))
      offset__ <- 1
      po__ <- 1
      while (po__!=0) {
        if (substr(temp,offset__,offset__) == '(') po__ <- po__+1
        if (substr(temp,offset__,offset__) == ')') po__ <- po__-1
        offset__ <- offset__+1
      }
      tempx__ <- substr(temp,1,offset__-2)
      args <- aux_explodePC(tempx__)
      if (length(args) > 2) {
        stopIQR('Only two arguments allowed in an "and" or "or" statements when converting "piecewise" to NONMEM')
      }
      exppost__ <- substr(temp,offset__,nchar(temp))
      exp <- paste0(exppre__,'(',args[1],')',operatorsuse__[k__],'(',args[2],')',exppost__)
    }
  }
  exp <- substr(exp,2,nchar(exp)-1)
  return(exp)
}
cleanNONMEMprojectFolder <- function(projectPath,FLAGclean=TRUE) {
  oldpath__ <- getwd()
  setwd(projectPath)
  dirs <- list.dirs()
  remove_dirs__ <- dirs[which(!grepl(x=list.dirs(),pattern="RESULTS") & dirs!=".")]
  if (FLAGclean) {
    for (k__ in seq_along(remove_dirs__)) aux_rmdir(remove_dirs__[k__])
  } else {
    for (k__ in seq_along(remove_dirs__)) file.rename(from = remove_dirs__[k__],  to = paste0("./RESULTSORIG",remove_dirs__[k__]))
  }
  x <- list.files(pattern="project.*")
  x <- x[which(x!="project.nmctl")]
  x <- x[which(x!="project.nmctl.log")]
  x <- x[which(x!="project.est")]
  dd__ <- sapply(seq_along(x), function (k__) file.rename(from = x[k__],  to = paste0("./RESULTSORIG/",x[k__])))
  x <- list.files(pattern="*")
  x <- x[which(x!="project.nmctl")]
  x <- x[which(x!="project.nmctl.log")]
  x <- x[!grepl(x=x,pattern=".csv")]
  x <- x[!grepl(x=x,pattern=".csv.log")]
  x <- x[!grepl(x=x,pattern=".atr")]
  x <- x[!grepl(x=x,pattern=".atr.log")]
  x <- x[!grepl(x=x,pattern="model.txt")]
  x <- x[!grepl(x=x,pattern="model.txtbc")]
  x <- x[!grepl(x=x,pattern="project.est")]
  x <- x[!grepl(x=x,pattern = "RESULTS")]
  x <- x[!grepl(x=x,pattern = "RESULTSORIG")]
  if (FLAGclean) {
    dd__ <- sapply(seq_along(x), function (k__) unlink(x[k__]))
  } else {
    for (k__ in seq_along(x)) file.rename(from = x[k__],  to = paste0("./RESULTSORIG/",x[k__]))
  }
  setwd(oldpath__)
}
parseNONMEMprojectHeader <- function(projectPath) {
  if (file.exists(paste0(projectPath, '/project.nmctl'))) {
    project__ <- aux_fileread(paste0(projectPath, '/project.nmctl'))
  } else {
    stopIQR('project.nmctl file could not be found.')
  }
  ixstart__ <- aux_strFindAll(project__,'; ==PROJECT HEADER START===================================================')$end
  ixend__   <- aux_strFindAll(project__,  '; ==PROJECT HEADER END=====================================================')$start
  if (is.null(ixstart__) | is.null(ixend__)) stopIQR('Project header could not be found in project.nmctl file.')
  headertext__ <- aux_strtrim(substr(project__,ixstart__+1,ixend__-1))
  headertext__  <- aux_strrep(headertext__,"; ","")
  headertext__  <- aux_strrep(headertext__,"\n",",\n")
  projectinfo__ <- eval(parse(text=paste0("list(",headertext__,")")))
  projectinfo__ <- lapply(projectinfo__,function(x) aux_explodePC(x))
  return(projectinfo__)
}
nearPD <- function (x, corr = FALSE)
{
  X__ <- 0.5*(x+t(x))
  e__ <- eigen(X__)
  eV__ <- e__$values
  if (min(eV__) > 0) return(X__)
  if (min(eV__) < -1e-4) {
    warningIQR("could not adjust matrix to be positive semidefinite")
    return(X__)
  }
  eV__[eV__<0] <- 0
  Xout__ <- e__$vectors %*% diag(eV__) %*% ginv(e__$vectors)
  if (corr) diag(Xout__) <- 1
  return(Xout__)
}
sampleNONMEMpopulationParameters <- function(input, FLAG_SAMPLE=FALSE, verbose=TRUE) {
  if (is.na(input$objectivefunction$OBJ)) return(NULL)
  IOVpresent <- grepl("iov_omega2(",input$parameters$names,fixed = TRUE)
  if (any(IOVpresent)) {
    if (verbose) warningIQR("IOV was estimated in the project. Sampling of population mean parameters will not sample IOV parameters")
    ixNONiov <- which(!IOVpresent)
    input$parameters$names <- input$parameters$names[ixNONiov]
    input$parameters$FLAGestimated <- input$parameters$FLAGestimated[ixNONiov]
    input$parameters$transformation <- input$parameters$transformation[ixNONiov]
    input$parameters$values <- input$parameters$values[ixNONiov]
    input$parameters$stderrors <- input$parameters$stderrors[ixNONiov]
    input$parameters$correlationmatrix <- input$parameters$correlationmatrix[ixNONiov,ixNONiov]
    input$parameters$covariancematrix <- input$parameters$covariancematrix[ixNONiov,ixNONiov]
  }
  output__                                      <- list()
  output__$type                                 <- 'NONMEM'
  output__$path                                 <- input$path
  paramNames                                  <- input$parameters$names
  values                                      <- input$parameters$values
  covariance                                  <- input$parameters$covariancematrix
  covariance[abs(covariance)<100*.Machine$double.eps] <- 0
  covariance <- matrix(covariance,ncol=ncol(input$parameters$covariancematrix))
  rownames(covariance) <- rownames(input$parameters$correlationmatrix)
  colnames(covariance) <- colnames(input$parameters$correlationmatrix)
  RUN__ <- TRUE
  count__ <- 1
  while (RUN__) {
    if (FLAG_SAMPLE) {
      if (!is.null(covariance)) {
        samples__ <- mvrnorm(n=1,mu=values,Sigma=covariance)
      } else {
        if (verbose) {
          warningIQR('The covariance matrix was not determined => No sampling of population parameters from uncertainty distributions.')
        }
        samples__ <- values
      }
    } else {
      samples__ <- values
      if (verbose) {
        message('No sampling of population parameters from uncertainty distributions.')
      }
    }
    ixo__     <- which(grepl('omega2\\(',paramNames))
    n       <- paramNames[ixo__]
    ixno__    <- grep(",", n, invert = TRUE, fixed = TRUE) 
    no      <- n[ixno__]
    ixouseo__ <- sapply(no, function(x) which(x==paramNames))
    no      <- gsub(x=no,pattern='omega2\\(',replacement='')
    no      <- gsub(x=no,pattern='\\)',replacement='')
    output__$randomEffects$names  <- no
    output__$randomEffects$values <- sqrt(abs(samples__[ixouseo__]))
    covariancematrix <- diag(nrow = length(ixouseo__), ncol = length(ixouseo__))
    diag(covariancematrix) <- samples__[ixouseo__]
    ixo__              <- which(grepl('omega2\\(',paramNames))
    n                <- paramNames[ixo__]
    ixousec__          <- which(aux_strFindAll(n,',')$start > 0)
    if (length(ixousec__) > 0) {
      no               <- n[ixousec__]
      ixousec__          <- sapply(no, function(x) which(x==paramNames))
      no               <- gsub(x=no,pattern='omega2\\(',replacement='')
      recovnames__       <- gsub(x=no,pattern='\\)',replacement='')
      recovvalues__      <- samples__[ixousec__]
      for (k__ in seq_along(recovnames__)) {
        terms <- aux_explode(recovnames__[k__])
        ix1__ <- which(terms[1]==output__$randomEffects$names)
        ix2__ <- which(terms[2]==output__$randomEffects$names)
        covariancematrix[ix1__,ix2__] <- recovvalues__[k__]
        covariancematrix[ix2__,ix1__] <- recovvalues__[k__]
      }
    }
    suppressWarnings(output__$randomEffects$covariancematrix <- nearPD(covariancematrix))
    if (min(eigen(covariancematrix)$values) >= 0) RUN__ <- FALSE
    count__ <- count__ + 1
    if (count__ > 100) {
      warningIQR("Difficulty to get a possemidef covariance matrix.")
      break()
    }
  }
  corrmatrix <- matrix(NaN, ncol=ncol(covariancematrix),nrow=ncol(covariancematrix))
  for (krow in 1:nrow(corrmatrix)) {
    for (kcol in 1:ncol(corrmatrix)) {
      corrmatrix[krow,kcol] <- covariancematrix[krow,kcol]/sqrt(abs(covariancematrix[krow,krow]*covariancematrix[kcol,kcol]))
    }
  }
  output__$randomEffects$correlationmatrix <- corrmatrix
  ix__ <- c(ixouseo__, ixousec__)
  ix_keep <- setdiff(seq_along(samples__),ix__)
  samples__ <- samples__[ix_keep]
  paramNames <- paramNames[ix_keep]
  output__$fixedEffects$names <- output__$randomEffects$names
  ixfe <- c()
  for (k__ in seq_along(output__$fixedEffects$names)) {
    ix__ <- which(output__$fixedEffects$names[k__]==paramNames)
    output__$fixedEffects$values[k__] <- samples__[ix__]
    ixfe <- c(ixfe, ix__)
  }
  ix_keep <- setdiff(seq_along(samples__),ixfe)
  samples__ <- samples__[ix_keep]
  paramNames <- paramNames[ix_keep]
  output__$randomEffects$transformation     <- input$trans_randeffects
  output__$randomEffects$inv_transformation <- input$inv_trans_randeffects
  output__$fixedEffects$transformation      <- input$trans_randeffects
  Noutput <- length(input$residualerrormodels)
  removeIX <- c()
  for (k__ in 1:Noutput) {
    outputInfo   <- list()
    outputInfo$alias <- input$residualerrormodels[k__]
    outputInfo$abcr <- c(NA,NA)
    ix__ <- which(paste0('error_ADD', k__)==paramNames)
    if (length(ix__)>0) {
      outputInfo$abcr[1] <- samples__[ix__]
      removeIX <- c(removeIX, ix__)
    }
    ix__ <- which(paste0('error_PROP', k__)==paramNames)
    if (length(ix__)>0) {
      outputInfo$abcr[2] <- samples__[ix__]
      removeIX <- c(removeIX, ix__)
    }
    output__$residualErrorModel[[k__]] <- outputInfo
  }
  ix_keep <- setdiff(seq_along(samples__),removeIX)
  samples__ <- samples__[ix_keep]
  paramNames <- paramNames[ix_keep]
  for (k__ in 1:Noutput) {
    ix__ <- which(output__$residualErrorModel[[k__]]$alias=='abs')
    if (length(ix__)>0) {
      output__$residualErrorModel[[k__]]$formula <- 'abcr(1).*ones(size(f))'
      output__$residualErrorModel[[k__]]$FlagTransf <- 0
    }
    ix__ <- which(output__$residualErrorModel[[k__]]$alias=='rel')
    if (length(ix__)>0) {
      output__$residualErrorModel[[k__]]$formula <- 'abcr(2).*f'
      output__$residualErrorModel[[k__]]$FlagTransf <- 0
    }
    ix__ <- which(output__$residualErrorModel[[k__]]$alias=='absrel')
    if (length(ix__)>0) {
      output__$residualErrorModel[[k__]]$formula <- 'abcr(1) + abcr(2).*f'
      output__$residualErrorModel[[k__]]$FlagTransf <- 0
    }
  }
  ix__            <- which(grepl('beta_',paramNames))
  covariates      <- paramNames[ix__]
  covariatevalues <- samples__[ix__]
  ix_keep    <- setdiff(seq_along(samples__),ix__)
  samples__    <- samples__[ix_keep]
  paramNames   <- paramNames[ix_keep]
  categorical_covariates              <- list()
  categorical_covariates$parameter    <- c()
  categorical_covariates$covariate    <- c()
  for (k__ in seq_along(input$PROJECTINFO$BETACATNAMES)) {
    if (nchar(input$PROJECTINFO$BETACATNAMES[k__]) > 0) {
      bcnk <- input$PROJECTINFO$BETACATNAMES[k__]
      bcnk <- aux_strrep(bcnk,'beta_','')
      bcnk <- aux_strrep(bcnk,'(',',')
      bcnk <- aux_strrep(bcnk,')','')
      terms <- aux_explodePC(bcnk)
      xx <- aux_strrep(input$PROJECTINFO$BETACATCATEGORIES[k__],"[","c(")
      xx <- aux_strrep(xx,"]",")")
      xx <- aux_strrep(xx," ",",")
      categories <- eval(parse(text=xx))
      reference  <- as.double(input$PROJECTINFO$BETACATREFERENCE[k__])
      categorical_covariates$parameter <- c(categorical_covariates$parameter, terms[1])
      categorical_covariates$covariate <- c(categorical_covariates$covariate, terms[2])
      categorical_covariates$categories[[k__]] <- categories
      categorical_covariates$reference <- c(categorical_covariates$reference, reference)
      values_cat <- c()
      for (k2__ in seq_along(categories)) {
        n <- aux_strrep(input$PROJECTINFO$BETACATNAMES[k__],')',sprintf('_%d)',categories[k2__]))
        if (categories[k2__] == reference) {
          value <- 0
        } else {
          value <- covariatevalues[which(n==covariates)]
        }
        values_cat <- c(values_cat,value)
      }
      categorical_covariates$value[[k__]] <- values_cat
    }
  }
  continuous_covariates <- list()
  continuous_covariates$parameter <- c()
  continuous_covariates$covariate <- c()
  continuous_covariates$formula   <- c()
  continuous_covariates$value     <- c()
  for (k__ in seq_along(input$PROJECTINFO$BETACOVNAMES)) {
    if (nchar(input$PROJECTINFO$BETACOVNAMES[k__]) > 0) {
      bcnk <- input$PROJECTINFO$BETACOVNAMES[k__]
      bcnk <- aux_strrep(bcnk,'beta_','')
      bcnk <- aux_strrep(bcnk,'(',',')
      bcnk <- aux_strrep(bcnk,')','')
      terms <- aux_explodePC(bcnk)
      continuous_covariates$parameter  <- c(continuous_covariates$parameter, terms[1])
      continuous_covariates$covariate  <- c(continuous_covariates$covariate, terms[2])
      continuous_covariates$formula    <- c(continuous_covariates$formula, input$PROJECTINFO$BETACOVTRANS[k__])
      continuous_covariates$value      <- c(continuous_covariates$value, covariatevalues[which(input$PROJECTINFO$BETACOVNAMES[k__]==covariates)])
    }
  }
  continuous <- list()
  for (k__ in seq_along(continuous_covariates$parameter)) {
    if (k__==1) {
      continuous[[k__]] <- list(
        parameter  = continuous_covariates$parameter[k__],
        covariates = continuous_covariates$covariate[k__],
        values     = continuous_covariates$value[k__],
        formula    = continuous_covariates$formula[k__])
    } else {
      ix__ <- which(continuous_covariates$parameter[k__]==sapply(continuous,function(x) x$parameter))
      if (length(ix__) == 0) {
        continuous[[length(continuous)+1]] <- list(
          parameter  = continuous_covariates$parameter[k__],
          covariates = continuous_covariates$covariate[k__],
          values     = continuous_covariates$value[k__],
          formula    = continuous_covariates$formula[k__])
      } else {
        continuous[[ix__]]$covariates <- c(continuous[[ix__]]$covariates, continuous_covariates$covariate[k__])
        continuous[[ix__]]$values     <- c(continuous[[ix__]]$values, continuous_covariates$value[k__])
        continuous[[ix__]]$formula    <- c(continuous[[ix__]]$formula, continuous_covariates$formula[k__])
      }
    }
  }
  output__$covariates$continuous <- continuous
  categorical <- list()
  for (k__ in seq_along(categorical_covariates$parameter)) {
    if (k__==1) {
      information <- list()
      information[[1]] <- list(
        categories = categorical_covariates$categories[k__],
        values = categorical_covariates$value[k__]
      )
      categorical[[k__]] <- list(
        parameter  = categorical_covariates$parameter[k__],
        covariates = categorical_covariates$covariate[k__],
        information = information)
    } else {
      ix__ <- which(categorical_covariates$parameter[k__]==sapply(categorical,function(x) x$parameter))
      if (length(ix__) == 0) {
        information <- list()
        information[[1]] <- list(categories = categorical_covariates$categories[k__],
                                 values = categorical_covariates$value[k__]
        )
        categorical[[length(categorical)+1]] <- list(
          parameter  = categorical_covariates$parameter[k__],
          covariates = categorical_covariates$covariate[k__],
          information = information)
      } else {
        information <- list()
        information[[1]] <- list(
          categories = categorical_covariates$categories[k__],
          values = categorical_covariates$value[k__]
        )
        categorical[[ix__]]$covariates <- c(categorical[[ix__]]$covariates, categorical_covariates$covariate[k__])
        categorical[[ix__]]$information[[length(categorical[[ix__]]$information)+1]] <- list(
          categories = categorical_covariates$categories[k__],
          values = categorical_covariates$value[k__]
        )
      }
    }
  }
  output__$covariates$categorical <- categorical
  if (length(paramNames)>0) {
    if (!is.na(paramNames[1])) {
      warningIQR('The NONMEM output contained information that are currently not handled.')
    }
  }
  values  <- output__$fixedEffects$values
  trans   <- output__$fixedEffects$transformation
  tvalues <- c()
  for (k__ in seq_along(values)) {
    phi <- values[k__]
    tvalues[k__] <- eval(parse(text=trans[k__]))
  }
  output__$fixedEffects$values <- tvalues
  output__$fixedEffects$transformation <- NULL
  return(output__)
}
#'@export
pred_IQRnlmeProject <- function (project,
                                 model=NULL,
                                 data=NULL,
                                 simtime=NULL,
                                 abs0inputs=NULL,
                                 abs0Tk0param=NULL,
                                 opt_abstol=1e-6,
                                 opt_reltol=1e-6) {
  if (is.null(model)) {
    model <- getModel_IQRnlmeProject(project)
  }
  if (is.null(data)) {
    data <- getData_IQRnlmeProject(project)
  }
  indiv <- getIndivParameters_IQRnlmeProject(project)
  header <- getHeader_IQRnlmeProject(project)
  if (is.null(simtime)) {
    dataObs <- data[data$EVID==0,]
    simtime <- lapply(split(dataObs,dataObs$ID), function (d) unique(d$TIME))
  }
  if ("ABSORPTION0" %in% header$DOSINGTYPES) {
    if (is.null(abs0inputs) || is.null(abs0Tk0param)) stopIQR("ABSORPTION0 present in model. Specify 'abs0inputs' and 'abs0Tk0param' arguments!")
  }
  dataparam <- dplyr::left_join(data,indiv,by=c("USUBJID","ID"))
  if (header$REGRESSIONNAMES[1] == "") {
    regressors <- NULL
  } else {
    regressors <- header$REGRESSIONNAMES
  }
  regression <- c(regressors,setdiff(names(indiv),c("USUBJID","ID")))
  eT <- IQReventTable(
    data = dataparam,
    regression = regression,
    abs0inputs = abs0inputs,
    abs0Tk0param = abs0Tk0param
  )
  res <- sim_IQRmodel(model = model,
                      eventTable = eT,
                      simtime = simtime,
                      opt_abstol = opt_abstol,
                      opt_reltol = opt_reltol)
  res
}
#'@export
as_IQRnlmeProject <- function (projectPath) {
  if (!is_IQRnlmeProject(projectPath))
    stopIQR("Provided path does not point to an IQRnlmeProject")
  output__ <- projectPath
  attr(output__,"class") <- "IQRnlmeProject"
  oldpath__ <- getwd()
  setwd(projectPath)
  absPathIQRnlmeProject__ <- getwd()
  setwd(oldpath__)
  attr(output__,"absProjectPath") <- absPathIQRnlmeProject__
  attr(output__,"absModelPath") <- paste0(absPathIQRnlmeProject__,"/model.txt")
  dataPathRel__ <- parseNLMEprojectHeader(projectPath)$DATA
  dataFileInfo__ <- aux_fileparts(dataPathRel__)
  dataFileName__ <- paste0(dataFileInfo__$filename,dataFileInfo__$fileext)
  oldpath__ <- getwd()
  setwd(projectPath)
  if (!dir.exists(dataFileInfo__$pathname)) {
    setwd(oldpath__)
    stopIQR("Could not find the dataset that the model use")
  }
  setwd(dataFileInfo__$pathname)
  absPathData__ <- getwd()
  setwd(oldpath__)
  absDataPath__ <- paste0(absPathData__,"/",dataFileName__)
  attr(output__,"absDataPath") <- absDataPath__
  return(output__)
}
#'@export
is_IQRnlmeProject <- function (projectPath) {
  out <- FALSE
  if (is_NONMEM_IQRnlmeProject(projectPath)) out <- TRUE
  if (is_MONOLIX_IQRnlmeProject(projectPath)) out <- TRUE
  if (is_NLMIXR_IQRnlmeProject(projectPath)) out <- TRUE
  tryCatch({
    if (is_IQRsysProject(projectPath)) out <- TRUE
  }, error=function(err) {
  })
  return(out)
}
#'@export
print.IQRnlmeProject <- function(x, ...) {
  if (file.exists(paste0(x,"/RESULTS/project_results.txt"))) {
    text__ <- aux_fileread(paste0(x,"/RESULTS/project_results.txt"))
    cat(text__)
    cat(paste0("\nIQRnlmeProject: ",x,"\n\n"))
  } else {
    cat(paste0("IQRnlmeProject: ",x,"\n"))
    cat("Project has not been run yet (most likely)\n\n")
  }
}
#'@export
summary.IQRnlmeProject <- function(object, ..., FLAGreport=FALSE, filename=NULL, SIGDIG=3, ETA_THRESHOLD_REL = 0, stratifyShrinkageBy = NULL) {
  if (!is_IQRnlmeProject(object)) stopIQR("Provided projectPath does not point to an NLME project.")
  if (!hasrun_IQRnlmeProject(object)) {
    print.IQRnlmeProject(object)
    return(NULL)
  }
  RESULT__ <- parseSelectedProjectFolderResults(object)[[1]]
  if (RESULT__$FAILED) {
    message("Parsing of project failed. No summary table generated.")
    return(invisible(NULL))
  }
  header__ <- parseNLMEprojectHeader(object)
  oldpath__ <- getwd()
  setwd(object)
  ATRinfo__ <- loadATRinfo_csvData(header__$DATA)
  setwd(oldpath__)
  table__ <- summaryTable_IQRnlmeSysProject(RESULT__, SIGDIG, object, ATRinfo__,FLAGreport, ETA_THRESHOLD_REL, stratifyShrinkageBy)
  if (!is.null(filename)) {
    filename <- paste0(aux_strrep(filename,".txt",""),".txt")
    IQRoutputTable(object = table__,report=FLAGreport,filename=filename)
    return(invisible(NULL))
  }
  table__
}
#'@export
plot.IQRnlmeProject <- function(x, ..., FLAGgofStratify=FALSE, CORR_THRESHOLD=0.3,nindiv=16,WRES_THRESHOLD=6,pathname=NULL) {
  if (!is_IQRnlmeProject(x)) {
    stopIQR("Please check if you are in the right working directory")
  }
  projectPath <- x
  if (!hasrun_IQRnlmeProject(x)) {
    cat(paste0("IQRnlmeProject: ",x,"\n"))
    cat("Project has not been run yet (most likely)\n\n")
    return()
  }
  PROJECTINFO     <- parseNLMEprojectHeader(projectPath)
  output__ <- list()
  cat(paste0("Generation of general GoF plots of project: ",x,"\n"))
  basefilename__ <- "GOF_GENERAL"
  if (!is.null(pathname)) cat(paste0("  .. plots created in ",pathname,"/",basefilename__,"\n"))
  tryCatch({
    output__$GENERAL$ETA <- plotETA_IQRnlmeProject(
      projectPath,
      filename={
        out <- NULL
        if (!is.null(pathname)) out <- file.path(pathname, basefilename__, '01_Random_Effects')
        out
      },
      CORR_THRESHOLD=CORR_THRESHOLD
    )
  }, error = function(e) {
    warningIQR(paste0("Problem with ETA plots.\n",e))
  })
  tryCatch({
    if (FLAGgofStratify) {
      for (k2__ in 1:length(PROJECTINFO$COVARIATENAMES)) {
        stratCov <- PROJECTINFO$COVARIATENAMES[k2__]
        output__$GENERAL$ETASTRAT[[stratCov]] <- plotETA_IQRnlmeProject(
          projectPath,
          filename={
            out <- NULL
            if (!is.null(pathname)) out <- file.path(pathname, basefilename__, '01_Random_Effects_stratified', stratCov)
            out
          },
          stratCov=stratCov,
          CORR_THRESHOLD=CORR_THRESHOLD
        )
      }
    }
  }, error = function(e) {
    warningIQR(paste0("Problem with stratified ETA plots.\n",e))
  })
  tryCatch({
    output__$GENERAL$ETACOV <- plotETACOV_IQRnlmeProject(
      projectPath,
      filename={
        out <- NULL
        if (!is.null(pathname)) out <- file.path(pathname, basefilename__, '02_ETAs_vs_COVs')
        out
      },
      CORR_THRESHOLD=CORR_THRESHOLD
    )
  }, error = function(e) {
    warningIQR(paste0("Problem with ETA/COV plots.\n",e))
  })
  tryCatch({
    if (FLAGgofStratify) {
      for (k2__ in 1:length(PROJECTINFO$COVARIATENAMES)) {
        stratCov <- PROJECTINFO$COVARIATENAMES[k2__]
        output__$GENERAL$ETACOVSTRAT[[stratCov]] <- plotETACOV_IQRnlmeProject(
          projectPath,
          filename={
            out <- NULL
            if (!is.null(pathname)) out <- file.path(pathname, basefilename__, '02_ETAs_vs_COVs_stratified', stratCov)
            out
          },
          stratCov=stratCov,
          CORR_THRESHOLD=CORR_THRESHOLD
        )
      }
    }
  }, error = function(e) {
    warningIQR(paste0("Problem with stratified ETA/COV plots.\n",e))
  })
  tryCatch({
    output__$GENERAL$COVEFFECT <- covariateEffect_IQRnlmeProject(
      projectPath,
      filename={
        out <- NULL
        if (!is.null(pathname)) out <- file.path(pathname, basefilename__, '03_COV_Impact_Parameters')
        out
      },
      Nsamples=1e5,
      ClinicalRelevanceLow=0.8,
      ClinicalRelevanceHigh=1.2
    )
  }, error = function(e) {
    warningIQR(paste0("Problem with Covariate Effect Forest plots.\n",e))
  })
  cat(paste0("Generation of output specific GoF plots of project: ",x,"\n"))
  if (!is.null(pathname)) cat(paste0("  .. plots created in specific subfolders of ",pathname,"\n"))
  outputNumberALL <- 1:length(PROJECTINFO$OUTPUTS)
  outputNamesALL  <- PROJECTINFO$OUTPUTS
  for (k__ in seq_along(outputNumberALL)) {
    basefilenameOutput <- sprintf('GOF_OUTPUT_%d_%s/',outputNumberALL[k__],outputNamesALL[k__])
    tryCatch({
      output__$OUTPUT[[outputNamesALL[k__]]]$INDIVLIN <- plotINDIV_IQRnlmeProject(
        projectPath,
        outputNr=outputNumberALL[k__],
        filename={
          out <- NULL
          if (!is.null(pathname)) out <- file.path(pathname, basefilenameOutput, '01_Individual_Fits_LinearY')
          out
        },
        plotLog=FALSE,nindiv=nindiv
      )
    }, error = function(e) {
      warningIQR(paste0("Problem with INDIV-linear plots.\n",e))
    })
    tryCatch({
      output__$OUTPUT[[outputNamesALL[k__]]]$INDIVLOG <- plotINDIV_IQRnlmeProject(
        projectPath,
        outputNr=outputNumberALL[k__],
        filename={
          out <- NULL
          if (!is.null(pathname)) out <- file.path(pathname, basefilenameOutput, '02_Individual_Fits_LogY')
          out
        },
        plotLog=TRUE,nindiv=nindiv
      )
    }, error = function(e) {
      warningIQR(paste0("Problem with INDIV-log plots.\n",e))
    })
    tryCatch({
      output__$OUTPUT[[outputNamesALL[k__]]]$GOF <- plotGOF_IQRnlmeProject(
        projectPath,
        outputNr=outputNumberALL[k__],
        stratCov=NULL,
        filename={
          out <- NULL
          if (!is.null(pathname)) out <- file.path(pathname, basefilenameOutput, '03_GOF_Plots')
          out
        },
        plotLog=TRUE
      )
    }, error = function(e) {
      warningIQR(paste0("Problem with GOF plots.\n",e))
    })
    tryCatch({
      if (FLAGgofStratify) {
        for (k2__ in 1:length(PROJECTINFO$COVARIATENAMES)) {
          stratCov <- PROJECTINFO$COVARIATENAMES[k2__]
          output__$OUTPUT[[outputNamesALL[k__]]]$GOFSTRAT[[stratCov]] <- plotGOF_IQRnlmeProject(
            projectPath,
            outputNr=outputNumberALL[k__],
            stratCov=stratCov,
            filename={
              out <- NULL
              if (!is.null(pathname)) out <- file.path(pathname, basefilenameOutput, '03_GOF_Plots_stratified',stratCov)
              out
            },
            plotLog=TRUE
          )
        }
      }
    }, error = function(e) {
      warningIQR(paste0("Problem with stratified GOF plots.\n",e))
    })
    tryCatch({
      output__$OUTPUT[[outputNamesALL[k__]]]$OUTLIER <- outlier_IQRnlmeProject(
        projectPath,
        outputNr=outputNumberALL[k__],
        filename={
          out <- NULL
          if (!is.null(pathname)) out <- file.path(pathname, basefilenameOutput, '04_OutlierDetection.txt')
          out
        },
        WRES_THRESHOLD=WRES_THRESHOLD
      )
    }, error = function(e) {
      warningIQR(paste0("Problem with outlier table.\n",e))
    })
  }
  if (is.null(pathname)) {
    return(output__)
  }
}
#'@export
run_IQRnlmeProject <- function (projectPath,
                                ncores=1,
                                Nparallel=1,
                                FLAGrerun=FALSE,
                                FLAGclean=TRUE,
                                FLAGgof=TRUE,
                                FLAGgofStratify=FALSE,
                                FLAGremoveRESULTSORIG=FALSE) {
  if (is_IQRnlmeProjectMulti(projectPath)) {
    return(run_IQRnlmeProjectMulti(projectPath=projectPath,
                                   ncores=ncores,
                                   Nparallel=Nparallel,
                                   FLAGrerun=FLAGrerun,
                                   FLAGclean=FLAGclean,
                                   FLAGgof=FLAGgof,
                                   FLAGgofStratify=FLAGgofStratify,
                                   FLAGremoveRESULTSORIG=FLAGremoveRESULTSORIG))
  }
  if (!is_IQRnlmeProject(projectPath))
    stopIQR("provided projectPath is not an IQRnlmeProject object")
  project__ <- as_IQRnlmeProject(projectPath)
  aux_mkdir(paste0(projectPath,"/RESULTSORIG"))
  if (!hasrun_IQRnlmeProject(projectPath) | FLAGrerun) {
    if (is_NONMEM_IQRnlmeProject(projectPath)) {
      runNONMEMproject(projectPath=projectPath,
                       ncores=ncores,
                       FLAGclean=FLAGclean)
    }
    if (is_MONOLIX_IQRnlmeProject(projectPath)) {
      runMONOLIXproject(projectPath=projectPath,
                        ncores=ncores)
    }
    if (is_NLMIXR_IQRnlmeProject(projectPath)) {
      runNLMIXRproject(projectPath=projectPath,
                       ncores=ncores,
                       FLAGclean=FLAGclean)
    }
    tryCatch({
      suppressWarnings(plotConvergence_IQRnlmeProject(project__,sprintf('%s/RESULTS/project_convergence',projectPath)))
    }, error = function(e) {
      warningIQR(paste0('Problem with generation of covergence plots.',e))
    })
    if (FLAGgof) {
      tryCatch({
        suppressWarnings(summary(project__,FLAGreport=TRUE,filename=paste0(projectPath,"/project_parameters_table.txt")))
      }, error = function(e) {
        warningIQR("Problem with generation of summary table. Please check if model run had issues.")
      })
      tryCatch({
        suppressWarnings(plot.IQRnlmeProject(project__,FLAGgofStratify=FLAGgofStratify,CORR_THRESHOLD=0.3,pathname=paste0(projectPath,"/RESULTS")))
      }, error = function(e) {
        warningIQR("Problem with generation of diagnostic plots. Please check if model run had issues.")
      })
    }
    if (FLAGremoveRESULTSORIG) {
      aux_rmdir(paste0(projectPath,"/RESULTSORIG"))
    }
  }
  return(project__)
}
#'@export
duplicate_IQRnlmeProject <- function(projectSource,projectDestination,FLAGcopyData=FALSE) {
  projectSource <- as_IQRnlmeProject(projectSource)
  aux_rmdir(projectDestination)
  aux_mkdir(projectDestination)
  oldpath__ <- getwd()
  setwd(projectDestination)
  absPathDestination__ <- getwd()
  setwd(oldpath__)
  oldpath__ <- getwd()
  setwd(projectSource)
  file.copy(from=".", to=absPathDestination__,recursive=TRUE)
  setwd(oldpath__)
  relPathSourceDataInfo__ <- aux_fileparts(parseNLMEprojectHeader(projectSource)$DATA)
  datafile__ <- paste0(relPathSourceDataInfo__$filename,relPathSourceDataInfo__$fileext)
  dataRelPathSource__ <- relPathSourceDataInfo__$pathname
  oldpath__ <- getwd()
  setwd(projectSource)
  setwd(dataRelPathSource__)
  absDataPath__ <- getwd()
  setwd(oldpath__)
  if (FLAGcopyData & dataRelPathSource__!=".") {
    file.copy(file.path(absDataPath__, datafile__), file.path(projectDestination, datafile__),overwrite = FALSE)
    atrfile__ <- gsub(".csv",".atr",file.path(absDataPath__, datafile__))
    if (file.exists(atrfile__)) {
      file.copy(atrfile__, file.path(projectDestination, gsub(".csv",".atr",datafile__)),overwrite = FALSE)
    }
  }
  oldpath__ <- getwd()
  setwd(projectDestination)
  absDestinationPath__ <- getwd()
  setwd(oldpath__)
  if (FLAGcopyData | dataRelPathSource__==".") {
    dataRelPathDestination__ <- "."
  } else {
    dataRelPathDestination__ <- aux_getRelPath(absDestinationPath__,absDataPath__)
  }
  FOUND__ <- FALSE
  if (is_NONMEM_IQRnlmeProject(projectDestination)) {
    content__ <- aux_fileread(paste0(projectDestination,"/project.nmctl"))
    content__ <- aux_strrep(content__,paste0(dataRelPathSource__,"/"),paste0(dataRelPathDestination__,"/"))
    aux_filewrite(content__,paste0(projectDestination,"/project.nmctl"))
    FOUND__ <- TRUE
  }
  if (is_MONOLIX_IQRnlmeProject(projectDestination)) {
    content__ <- aux_fileread(paste0(projectDestination,"/project.mlxtran"))
    content__ <- aux_strrep(content__,paste0(dataRelPathSource__,"/"),paste0(dataRelPathDestination__,"/"))
    aux_filewrite(content__,paste0(projectDestination,"/project.mlxtran"))
    FOUND__ <- TRUE
  }
  if (is_NLMIXR_IQRnlmeProject(projectDestination)) {
    content__ <- aux_fileread(paste0(projectDestination,"/project_NLMIXR.R"))
    content__ <- aux_strrep(content__,paste0(dataRelPathSource__,"/"),paste0(dataRelPathDestination__,"/"))
    aux_filewrite(content__,paste0(projectDestination,"/project_NLMIXR.R"))
    FOUND__ <- TRUE
  }
  if (!FOUND__) {
    stopIQR("Unknown NLME project type")
  }
  return(as_IQRnlmeProject(projectDestination))
}
#'@export
IQRnlmeProject <- function(est,
                           projectPath,
                           comment                          = "",
                           tool                             = "MONOLIX",
                           toolVersion                      = NULL,
                           multiTestN                       = 1,
                           multiTestSD                      = 0.5,
                           FLAGanalytic                     = TRUE,
                           keepProjectFolder                = FALSE,
                           algOpt.SEED                      = 123456,
                           algOpt.K1                        = 500,
                           algOpt.K2                        = 200,
                           algOpt.NRCHAINS                  = NA,
                           algOpt.NONMEM.METHOD             = "SAEM",
                           algOpt.NONMEM.MAXEVAL            = 9999,
                           algOpt.NONMEM.SIGDIGITS          = 3,
                           algOpt.NONMEM.PRINT              = 1,
                           algOpt.NONMEM.COVSTEP_MATRIX     = "S", 
                           algOpt.NONMEM.ADVAN7             = TRUE,
                           algOpt.NONMEM.N1                 = 1000,
						               algOpt.NONMEM.TOL                = 6,
                           algOpt.NONMEM.SIGL               = NULL,
                           algOpt.NONMEM.M4                 = FALSE,
						               algOpt.NONMEM.FOCEIOFV           = FALSE,
                           algOpt.NONMEM.IMPORTANCESAMPLING = TRUE,
                           algOpt.NONMEM.IMP_ITERATIONS     = 10,
                           algOpt.NONMEM.ITS                = TRUE,
                           algOpt.NONMEM.ITS_ITERATIONS     = 10,
                           algOpt.NONMEM.WRES               = NULL,
                           algOpt.NONMEM.PRED               = NULL,
                           algOpt.NONMEM.RES                = NULL,
                           algOpt.MONOLIX.individualParameters  = 'conditionalMode',
                           algOpt.MONOLIX.indivMCMClength   = 50,
                           algOpt.MONOLIX.indivNsim         = 10,
                           algOpt.MONOLIX.indivRatio        = 0.05,
                           algOpt.MONOLIX.logLikelihood         = 'Linearization',
                           algOpt.MONOLIX.fim                   = 'Linearization',
                           algOpt.MONOLIX.variability           = 'FirstStage',
                           algOpt.MONOLIX.startTime             = NULL,
                           algOpt.MONOLIX.STIFF                 = TRUE,
						               algOpt.MONOLIX.M4                 = FALSE,
						               
                           algOpt.NLMIXR.method               = "SAEM",
                           algOpt.NLMIXR.control              = NULL,
                           verbose                            = TRUE
) {
  if (!is_IQRnlmeEst(est))
    stopIQR("Input argument 'est' needs to be of class IQRnlmeEst")
  estInputOriginal__ <- est
  if (!is.character(projectPath))
    stopIQR("projectPath argument needs to be a character string with a absolute (avoid) or relative (better) path definition")
  est$projectPath <- projectPath
  if (!FLAGanalytic) est$linearModel$isLinear <- FALSE
  if (!(tool %in% c("NONMEM","MONOLIX","NLMIXR")))
    stopIQR("Input argument 'tools' needs to be 'NONMEM' or 'MONOLIX' or 'NLMIXR'")
  if (tool=="NONMEM") {
    if (!(algOpt.NONMEM.METHOD %in% c('FO','FOCE','FOCEI','SAEM','BAYES'))) {
      stopIQR("Input argument 'algOpt.NONMEM.METHOD' needs to be 'FO','FOCE','FOCEI','SAEM', or 'BAYES' it tool='NONMEM'")
    }
  }
  if (!algOpt.NONMEM.COVSTEP_MATRIX %in% c("S","R","RSR"))
    stopIQR("algOpt.NONMEM.COVSTEP_MATRIX should either be 'S', 'R', or 'RSR'")
  loadSetupOptions_IQRtools()
  if (toupper(tool) == "NONMEM") {
    if (is.null(toolVersion)) {
      toolVersion <- names(.PATH_SYSTEM_NONMEM)[1]
    } else {
      if (!(toolVersion %in% names(.PATH_SYSTEM_NONMEM))) {
        stopIQR("Selected toolVersion argument not listed in setup_options_IQRtools.R")
      }
    }
  }
  if (toupper(tool) == "MONOLIX") {
    if (is.null(toolVersion)) {
      toolVersion <- names(.PATH_SYSTEM_MONOLIX)[1]
    } else {
      if (!(toolVersion %in% names(.PATH_SYSTEM_MONOLIX))) {
        stopIQR("Selected toolVersion argument not listed in setup_options_IQRtools.R")
      }
    }
  }
  if (toupper(tool) == "NLMIXR") {
    if (!is.null(toolVersion)) {
      warningIQR("toolVersion argument is ignored for NLMIXR")
    }
  }
  if (tool=="NLMIXR") {
    if (!is_installed_NLMIXR()) {
      stopIQR("NLMIXR package is not installed")
    }
    loadSetupOptions_IQRtools()
    if (!as.character(aux_version("nlmixr")) %in% .VERSION_SUPPORTED_NLMIXR) {
      stopIQR(paste0("The currently supported versions of NLMIXR are: [",paste0(.VERSION_SUPPORTED_NLMIXR,collapse = ","),"].\n  But a different one (",aux_version("nlmixr"),") is installed on the system"))
    }
    if (!toupper(algOpt.NLMIXR.method) %in% c("SAEM","NLME","FOCEI")) {
      stopIQR("For NLMIXR the algOpt.NLMIXR.method argument needs to be set tp 'SAEM', 'NLME', or 'FOCEI'")
      if (aux_version("nlmixr") < "1.0.0.7" & algOpt.NLMIXR.method=="FOCEI") {
        stopIQR("The installed version of NLMIXR does not handle the FOCEI method yet. Update your NLMIXR installation!")
      }
    }
    if (!is.null(algOpt.NLMIXR.control)) {
      algOpt.NLMIXR.control <- deparse(substitute(algOpt.NLMIXR.control))
    } else {
      if (toupper(algOpt.NLMIXR.method) == "SAEM") algOpt.NLMIXR.control <- "nlmixr::saemControl()"
      if (toupper(algOpt.NLMIXR.method) == "NLME") algOpt.NLMIXR.control <- "nlmixr::nlmeControl()"
      if (toupper(algOpt.NLMIXR.method) == "FOCEI") algOpt.NLMIXR.control <- "nlmixr::foceiControl()"
    }
  }
  if (any(est$modelSpec$IOVestimate!=0)) {
    if (toupper(tool) != "NONMEM") stopIQR("IOVestimate not all 0 => IOV estimation is available for NONMEM only")
    if (!"OCC" %in% names(est$data$dataModeling)) stopIQR("IOVestimate not all 0 but dataset does not contain OCC column")
    OCC <- est$data$dataModeling$OCC
    if (!is.numeric(OCC)) stopIQR("OCC column in dataset has to be numeric if IOV to be estimated")
    if (!all(OCC==round(OCC))) stopIQR("OCC column does contain non-integer values")
    if (length(unique(OCC)) < 2) stopIQR("Not more than 1 unique entry in OCC column. IOV cannot be estimated (revise OCC column or IOVestimate setting)")
  }
  if (any(grepl("event",sapply(est$modelSpec$errorModel, function (x) x[1])))) {
    if (tool != "MONOLIX") {
      stopIQR("Joint longitudinal / TTE modeling only supported with MONOLIX at the moment")
      if (!grepl("2018",toolVersion)) {
        stopIQR("Joint longitudinal / TTE modeling only supported with MONOLIX 2018R1 at the moment")
      }
    }
  }
  if (multiTestN > 1) {
    POPvalues0_sampled__ <- t(replicate(est$modelSpec$POPvalues0,n=multiTestN))
    ix_normal_sampled__ <- which(est$modelSpec$IIVdistribution=="N" & est$modelSpec$POPestimate==1)
    for (k__ in seq_along(ix_normal_sampled__)) {
      pv__    <- POPvalues0_sampled__[,ix_normal_sampled__[k__]]
      noise__ <- stats::rnorm(mean=0,sd=multiTestSD,n=multiTestN)
      pvsampled__ <- pv__+noise__
      POPvalues0_sampled__[,ix_normal_sampled__[k__]] <- pvsampled__
    }
    ix_lognormal_sampled__ <- which(est$modelSpec$IIVdistribution=="L" & est$modelSpec$POPestimate==1)
    for (k__ in seq_along(ix_lognormal_sampled__)) {
      pv__    <- log(POPvalues0_sampled__[,ix_lognormal_sampled__[k__]])
      noise__ <- stats::rnorm(mean=0,sd=multiTestSD,n=multiTestN)
      pvsampled__ <- pv__+noise__
      POPvalues0_sampled__[,ix_lognormal_sampled__[k__]] <- exp(pvsampled__)
    }
    ix_logitnormal_sampled__ <- which(est$modelSpec$IIVdistribution=="G" & est$modelSpec$POPestimate==1)
    for (k__ in seq_along(ix_logitnormal_sampled__)) {
      pv__    <- POPvalues0_sampled__[,ix_logitnormal_sampled__[k__]]
      pv__    <- logit(pv__)
      noise__ <- stats::rnorm(mean=0,sd=multiTestSD,n=multiTestN)
      pvsampled__ <- pv__+noise__
      POPvalues0_sampled__[,ix_logitnormal_sampled__[k__]] <- inv_logit(pvsampled__)
    }
    aux_rmdir(est$projectPath)
    estProjectPathBase__ <- est$projectPath
    output__ <- list()
    for (k__ in 1:multiTestN) {
      est$modelSpec$POPvalues0 <- POPvalues0_sampled__[k__,]
      est$projectPath <- paste0(estProjectPathBase__,"/MODEL_",aux_preFillChar(k__,nchar(as.character(multiTestN)),"0"))
      proj__ <- IQRnlmeProject(est                 = est,
                               projectPath         = est$projectPath,
                               comment             = comment,
                               tool                  = tool,
                               toolVersion           = toolVersion,
                               FLAGanalytic          = FLAGanalytic,
                               keepProjectFolder     = keepProjectFolder,
                               algOpt.SEED               = algOpt.SEED,
                               algOpt.K1                 = algOpt.K1,
                               algOpt.K2                 = algOpt.K2,
                               algOpt.NRCHAINS           = algOpt.NRCHAINS,
                               algOpt.NONMEM.METHOD             = algOpt.NONMEM.METHOD,
                               algOpt.NONMEM.MAXEVAL            = algOpt.NONMEM.MAXEVAL,
                               algOpt.NONMEM.SIGDIGITS          = algOpt.NONMEM.SIGDIGITS,
                               algOpt.NONMEM.PRINT              = algOpt.NONMEM.PRINT,
                               algOpt.NONMEM.COVSTEP_MATRIX     = algOpt.NONMEM.COVSTEP_MATRIX,
                               algOpt.NONMEM.ADVAN7             = algOpt.NONMEM.ADVAN7,
                               algOpt.NONMEM.N1                 = algOpt.NONMEM.N1,
                               algOpt.NONMEM.TOL                = algOpt.NONMEM.TOL,
                               algOpt.NONMEM.SIGL               = algOpt.NONMEM.SIGL,
                               algOpt.NONMEM.M4                 = algOpt.NONMEM.M4,
	   						               algOpt.NONMEM.FOCEIOFV           = algOpt.NONMEM.FOCEIOFV,
                               algOpt.NONMEM.IMPORTANCESAMPLING = algOpt.NONMEM.IMPORTANCESAMPLING,
                               algOpt.NONMEM.IMP_ITERATIONS     = algOpt.NONMEM.IMP_ITERATIONS,
                               algOpt.NONMEM.ITS                = algOpt.NONMEM.ITS,
                               algOpt.NONMEM.ITS_ITERATIONS     = algOpt.NONMEM.ITS_ITERATIONS,
                               algOpt.NONMEM.WRES               = algOpt.NONMEM.WRES,
                               algOpt.NONMEM.PRED               = algOpt.NONMEM.PRED,
                               algOpt.NONMEM.RES                = algOpt.NONMEM.RES,
                               algOpt.MONOLIX.individualParameters  = algOpt.MONOLIX.individualParameters,
                               algOpt.MONOLIX.indivMCMClength       = algOpt.MONOLIX.indivMCMClength,
                               algOpt.MONOLIX.indivNsim             = algOpt.MONOLIX.indivNsim,
                               algOpt.MONOLIX.indivRatio            = algOpt.MONOLIX.indivRatio,
                               algOpt.MONOLIX.logLikelihood         = algOpt.MONOLIX.logLikelihood,
                               algOpt.MONOLIX.fim                   = algOpt.MONOLIX.fim,
                               algOpt.MONOLIX.variability           = algOpt.MONOLIX.variability,
                               algOpt.MONOLIX.startTime             = algOpt.MONOLIX.startTime,
                               algOpt.MONOLIX.STIFF                 = algOpt.MONOLIX.STIFF,
	   						               algOpt.MONOLIX.M4                    = algOpt.MONOLIX.M4,
                               algOpt.NLMIXR.method                 = algOpt.NLMIXR.method,
                               algOpt.NLMIXR.control                = algOpt.NLMIXR.control,
                               verbose                              = verbose
      )
      output__[[length(output__)+1]] <- proj__
    }
    attr(output__,"class") <- c("IQRnlmeProjectMulti", attr(output__,"class"))
    return(output__)
  }
  oldpath__ <- getwd()
  if (!keepProjectFolder) aux_rmdir(est$projectPath)
  tryCatch({
    aux_mkdir(est$projectPath)
    setwd(est$projectPath)
  }, error = function (err) {
    aux_rmdir(est$projectPath)
    aux_mkdir(est$projectPath)
    setwd(est$projectPath)
  })
  aux_rmdir("RESULTS")
  aux_rmdir("RESULTSORIG")
  aux_mkdir("RESULTS")
  aux_mkdir("RESULTSORIG")
  setwd(oldpath__)
  if (est$data$FLAGdataAsDataFrame) {
    x__ <- IQRloadCSVdata(est$data$datafile)
    newfilepath__ <- file.path(est$projectPath,"datadf.csv")
    IQRoutputCSV(x__,newfilepath__)
    est$data$datafile = newfilepath__
  }
  oldpath__ <- getwd()
  setwd(est$projectPath)
  path__ <- getwd()
  if (nchar(path__) != nchar(aux_strrep(path__," ",""))) {
    setwd(oldpath__)
    aux_rmdir(est$projectPath)
    if (allowed_spaces_IQR()) {
      stopIQR("The absolute path to the project contains spaces. This is not allowed (thanks to NONMEM)")
    } else {
      warningIQR("The absolute path to the project contains spaces. If you plan to use NONMEM - then it will not work!")
    }
  }
  setwd(oldpath__)
  oldpath__ <- getwd()
  setwd(est$projectPath)
  absPathProject__ <- getwd()
  setwd(oldpath__)
  setwd(aux_fileparts(est$data$datafile)$pathname)
  absPathData__ <- getwd()
  setwd(oldpath__)
  fromFolder__ <- absPathProject__
  toFolder__ <- absPathData__
  relPathData <- aux_getRelPath(fromFolder__,toFolder__)
  est$data$relPathFromProject <- relPathData
  est$data$fileName <- paste0(aux_fileparts(est$data$datafile)$filename,aux_fileparts(est$data$datafile)$fileext)
  if (tool=="MONOLIX" | (tool=="NONMEM" & algOpt.NONMEM.METHOD=="SAEM") | (tool=="NLMIXR" & algOpt.NONMEM.METHOD=="SAEM")) {
    datasetContents__ <- IQRloadCSVdata(est$data$datafile)
    NSUBJECTS__ <- length(unique(datasetContents__$ID))
    if (is.na(algOpt.NRCHAINS)) {
      algOpt.NRCHAINS <- ceiling(50/NSUBJECTS__)
    } else {
      if (NSUBJECTS__*algOpt.NRCHAINS < 50) {
        warningIQR("Number of subjects in the dataset is low. You might want to increase the algOpt$NRCHAINS argument.")
      }
    }
  }
  est$algorithmSpec <- list(
    SEED                  = algOpt.SEED,
    K1                    = algOpt.K1,
    K2                    = algOpt.K2,
    NRCHAINS              = algOpt.NRCHAINS,
    METHOD                = algOpt.NONMEM.METHOD,
    MAXEVAL               = algOpt.NONMEM.MAXEVAL,
    SIGDIGITS             = algOpt.NONMEM.SIGDIGITS,
    PRINT                 = algOpt.NONMEM.PRINT,
    COVSTEP_MATRIX        = algOpt.NONMEM.COVSTEP_MATRIX,
    ADVAN7                = algOpt.NONMEM.ADVAN7,
    N1                    = algOpt.NONMEM.N1,
	  TOL                   = algOpt.NONMEM.TOL,
    SIGL                  = algOpt.NONMEM.SIGL,
    M4                    = algOpt.NONMEM.M4,
    FOCEIOFV              = algOpt.NONMEM.FOCEIOFV,
	  IMPORTANCESAMPLING    = algOpt.NONMEM.IMPORTANCESAMPLING,
    IMP_ITERATIONS        = algOpt.NONMEM.IMP_ITERATIONS,
    ITS                   = algOpt.NONMEM.ITS,
    ITS_ITERATIONS        = algOpt.NONMEM.ITS_ITERATIONS,
    algOpt.NONMEM.WRES    = algOpt.NONMEM.WRES,
    algOpt.NONMEM.PRED    = algOpt.NONMEM.PRED,
    algOpt.NONMEM.RES     = algOpt.NONMEM.RES,
    individualParameters  = algOpt.MONOLIX.individualParameters,
    indivMCMClength       = algOpt.MONOLIX.indivMCMClength,
    indivNsim             = algOpt.MONOLIX.indivNsim,
    indivRatio            = algOpt.MONOLIX.indivRatio,
    logLikelihood         = algOpt.MONOLIX.logLikelihood,
    fim                   = algOpt.MONOLIX.fim,
    variability           = algOpt.MONOLIX.variability,
    startTime             = algOpt.MONOLIX.startTime,
    STIFF                 = algOpt.MONOLIX.STIFF,
    M4.MONOLIX            = algOpt.MONOLIX.M4,
    nlmixr.method         = algOpt.NLMIXR.method,
    nlmixr.control        = algOpt.NLMIXR.control
  )
  if (tool=="NONMEM") {
    genIQRnlmeNONMEMproject(est=est,toolVersion=toolVersion,comment=comment,verbose=verbose)
  }
  if (tool=="MONOLIX") {
    genIQRnlmeMONOLIXproject(est=est,toolVersion=toolVersion,comment=comment,verbose=verbose)
  }
  if (tool=="NLMIXR") {
    genIQRnlmeNLMIXRproject(est=est,comment=comment,verbose=verbose)
  }
  text__ <- export_IQRmodel(est$model)
  aux_filewrite(text__,paste0(est$projectPath,"/model.txt"))
  estInputOriginalrmADDR__ <- estInputOriginal__
  attr(estInputOriginalrmADDR__$model, "DLLpath.IQRmodel") <- NULL
  attr(estInputOriginalrmADDR__$model, "DLLname.IQRmodel") <- NULL
  attr(estInputOriginalrmADDR__$model, "address.IQRmodel") <- NULL
  attr(estInputOriginalrmADDR__$modelInfo$model, "DLLpath.IQRmodel") <- NULL
  attr(estInputOriginalrmADDR__$modelInfo$model, "DLLname.IQRmodel") <- NULL
  attr(estInputOriginalrmADDR__$modelInfo$model, "address.IQRmodel") <- NULL
  estObject__ <- estInputOriginalrmADDR__
  saveRDS(object = estObject__,file=paste0(est$projectPath,"/project.est"))
  output__ <- as_IQRnlmeProject(est$projectPath)
  return(output__)
}
#'@export
hasrun_IQRnlmeProject <- function(object) {
  return(file.exists(paste0(object,"/RESULTS/project_results.txt")))
}
#'@export
getModel_IQRnlmeProject <- function(projectPath)
{
  if (!is_IQRnlmeProject(projectPath))
    stopIQR("Given path is not an IQRnlmeProject folder")
  out__ <- IQRmodel(paste0(projectPath,"/model.txt"))
  out__
}
#'@export
getEst_IQRnlmeProject <- function(projectPath)
{
  if (!is_IQRnlmeProject(projectPath))
    stopIQR("Given path is not an IQRnlmeProject folder")
  out__ <- readRDS(paste0(projectPath,"/project.est"))
  out__
}
#'@export
getIndivParameters_IQRnlmeProject <- function(projectPath, FLAGcovariate = FALSE)
{
  if (!is_IQRnlmeProject(projectPath))
    stopIQR("Given path is not an IQRnlmeProject folder")
  if (!hasrun_IQRnlmeProject(projectPath))
    stopIQR("Project was not (probably) not run yet. No individual parameters available.")
  dataINDIV__ <- IQRloadCSVdata(paste0(projectPath,"/RESULTS/project_indiv.csv"))
  if (FLAGcovariate)
    out__ <- dataINDIV__
  else
    out__ <- dataINDIV__[,c("ID",attr(dataINDIV__,"paramNames"),"USUBJID")]
  out__
}
#'@export
getIndivPredictions_IQRnlmeProject <- function(projectPath)
{
  if (!is_IQRnlmeProject(projectPath))
    stopIQR("Given path is not an IQRnlmeProject folder")
  if (!hasrun_IQRnlmeProject(projectPath))
    stopIQR("Project was not (probably) not run yet. No individual parameters available.")
  if (!file.exists(paste0(projectPath,"/RESULTS/project_pred.csv"))) return(NULL)
  dataPRED__ <- IQRloadCSVdata(paste0(projectPath,"/RESULTS/project_pred.csv"))
  dataPRED__
}
#'@export
getETAs_IQRnlmeProject <- function(projectPath, FLAGcovariate = TRUE)
{
  if (!is_IQRnlmeProject(projectPath))
    stopIQR("Given path is not an IQRnlmeProject folder")
  if (!hasrun_IQRnlmeProject(projectPath))
    stopIQR("Project was not (probably) not run yet. No etas available.")
  dataETA__ <- IQRloadCSVdata(paste0(projectPath,"/RESULTS/project_eta.csv"))
  if (FLAGcovariate)
    out__ <- dataETA__
  else
    out__ <- dataETA__[,c("ID",paste0("ETA_",attr(dataETA__,"paramNames")))]
  out__
}
#'@export
getPopParameters_IQRnlmeProject <- function(projectPath, IndCovariates = NULL,verbose=FALSE)
{
  if (!is_IQRnlmeProject(projectPath))
    stopIQR("Given path is not an IQRnlmeProject folder")
  if (!hasrun_IQRnlmeProject(projectPath))
    stopIQR("Project was not (probably) not run yet. No individual parameters available.")
  if (is.null(IndCovariates)) {
    out__  <- sample_IQRnlmeProject(projectPath, Nsamples=2, FLAG_SAMPLE=0,verbose = verbose)$popParamValues
  } else {
    out__  <- sample_IQRnlmeProject(projectPath, Nsamples=dim(IndCovariates)[1], FLAG_SAMPLE=3, covariates = IndCovariates,verbose = verbose)$popParamValues
  }
  out__
}
#'@export
getObsPred_IQRnlmeProject <- function(projectPath)
{
  if (!is_IQRnlmeProject(projectPath))
    stopIQR("Given path is not an IQRnlmeProject folder")
  if (!hasrun_IQRnlmeProject(projectPath))
    stopIQR("Project was not (probably) not run yet. No individual parameters available.")
  data__ <- IQRloadCSVdata(paste0(projectPath,"/RESULTS/project_pred.csv"))
  out__  <- data__[, c("ID", "TIME", "TAD", "YTYPE", "DV", "CENS", "IPRED", "XPRED")]
  out__
}
#'@export
getData_IQRnlmeProject <- function (projectPath,FLAGdataGeneral=FALSE) {
  if (!is_IQRnlmeProject(projectPath)) {
    stopIQR("Provided projectPath does not point to an IQRnlmeProject")
  }
  dataPath__ <- parseNLMEprojectHeader(projectPath)$DATA
  oldpath__ <- getwd()
  setwd(projectPath)
  data__ <- IQRloadCSVdata(dataPath__)
  setwd(oldpath__)
  if (FLAGdataGeneral) {
    class(data__) <- c("IQRdataGENERAL",class(data__))
    attributes(data__)$obsNAMES <- gsub(" ",":::",attributes(data__)$obsNAMES)
    attributes(data__)$doseNAMES <- gsub(" ",":::",attributes(data__)$doseNAMES)
  }
  return(data__)
}
#'@export
getResults_IQRnlmeProject <- function (projectPath,FLAG_SAMPLE=FALSE,verbose=TRUE) {
  if (!is_IQRnlmeProject(projectPath)) stopIQR("Provides projectPath argument does not point to an NLME project")
  x <- parseNLMEresults(projectPath)
  y <- x$rawParameterInfo
  y$objectivefunction <- x$objectivefunction
  y$additional <- sampleNLMEpopulationParameters(x,FLAG_SAMPLE,verbose)
  return(y)
}
#'@export
getHeader_IQRnlmeProject <- function (projectPath) {
  parseNLMEprojectHeader(projectPath)
}
#'@export
eigenvalues_IQRnlmeProject <- function(projectPath,
                                       Nsamples=NULL,
                                       FLAGiiv=TRUE,
                                       covariates=NULL) {
  if (!is_IQRnlmeProject(projectPath)) {
    stopIQR("Provided projectPath does not point to an IQRnlmeProject")
  }
  model__ <- IQRmodel(paste0(projectPath,"/model.txt"))
  Jacobian__ <- attributes(model__)$dfdx.IQRmodel$jacobian
  if (is.null(Nsamples)) {
    para__ <- sample_IQRnlmeProject(projectPath)$popParamValues
    para__ <- as.data.frame(t(para__))
  } else {
    if (FLAGiiv) {
      para__ <- sample_IQRnlmeProject(projectPath,FLAG_SAMPLE=0,Nsamples=Nsamples,covariates=covariates)$indParamValues
    } else {
      para__ <- sample_IQRnlmeProject(projectPath,FLAG_SAMPLE=2,Nsamples=Nsamples)$popParamValues
    }
  }
  sapply(attributes(model__)$dfdp.IQRmodel$paramnames, function (x__) {
    eval(parse(text=paste0(x__,"<<-NA")))
  })
  sapply(attributes(model__)$dfdx.IQRmodel$statenames, function (x__) {
    eval(parse(text=paste0(x__,"<<-NA")))
  })
  eValues__ <- data.frame(do.call(rbind,lapply(1:nrow(para__), function (row__) {
    pars <- as.vector(para__[row__,])
    txt <- paste0("matrix(c(", paste0(Jacobian__, collapse = ", "), "), ", nrow(Jacobian__), ", ", ncol(Jacobian__), ")")
    JacobianNumeric__ <- with(as.list(pars), eval(parse(text = txt)))
    eigenValues__ <- tryCatch({
      eigen(JacobianNumeric__)$values
    }, error=function (msg) {NA})
    eigenValues__
  })))
  names(eValues__) <- paste0("EV",1:ncol(eValues__))
  return(eValues__)
}
#'@export
run_IQRtteProjectMulti <- function (projectPath,
                                    pathname=NULL,
                                    ncores=1,
                                    Nparallel=1,
                                    FLAGrerun=FALSE,
                                    FLAGgof=TRUE) {
  if (!is_IQRtteProjectMulti(projectPath))
    stopIQR("provided projectPath is not an IQRtteProjectMulti object")
  if (Nparallel==1) {
    cat(sprintf("run_IQRtteProjectMulti: Running %d models\n",length(projectPath)))
  } else {
    cat(sprintf("Running %d models, %d in parallel at the same time (output suppressed)\n",length(projectPath),Nparallel))
  }
  if (!FLAGrerun) cat("(Projects are only run if not run yet)\n")
  PASS_COMPLIANCEINFO_LOCAL_ENVIR__ <- globalenv()$COMPLIANCE_MODE_SCRIPT_NAME
  if (Nparallel > 1) {
    cluster__ <- parallel::makeCluster(Nparallel)
    doParallel::registerDoParallel(cluster__)
    parallel::clusterCall(cl=cluster__,function (x__) .libPaths(x__), .libPaths())
    parallel::clusterExport(cluster__,envir=environment(),varlist=ls())
    "%dopar%" <- foreach::"%dopar%"
  } else {
    DLLloaded__ <- FALSE
    "%dopar%" <- foreach::"%do%"
  }
  .packages = c("IQRtools")
  foreach::foreach (k__=1:length(projectPath), .packages=.packages, .inorder=TRUE) %dopar% {
    e__ <- globalenv()
    e__$COMPLIANCE_MODE_SCRIPT_NAME <- PASS_COMPLIANCEINFO_LOCAL_ENVIR__
    out <- try(
      proj__ <- run_IQRtteProject(projectPath=projectPath[[k__]],
                                  ncores=ncores,
                                  FLAGrerun=FLAGrerun,
                                  FLAGgof=FLAGgof)
      , silent = FALSE)
    if (inherits(out, "try-error")) {
      message("An error was encountered in run_IQRnlmeProjec(). Continuing anyway.")
      return()
    }
    out
  }
  if (Nparallel > 1) {
    parallel::stopCluster(cluster__)
    doParallel::stopImplicitCluster()
  }
  loadSetupOptions_IQRtools()
  if (!is.null(pathname)) {
    summary.IQRnlmeProjectMulti(as_IQRnlmeProjectMulti(projectPath),pathname=pathname,FLAGreport=TRUE,order=.NLME_ORDER_CRITERION)
  }
  return(as_IQRtteProjectMulti(projectPath))
}
#'@export
print.IQRtteProjectMulti <- function(x, ...) {
  cat("IQRtteProjectMulti object\n")
  cat("\n")
  cat(sprintf("  The object contains N=%d IQRtteProjects\n",length(x)))
  cat(sprintf("  %d out of these %d have been run already",sum(sapply(x,function(xxx__) hasrun_IQRnlmeProject(xxx__))),length(x)))
}
is_IQRtteProjectMulti <- function (input) {
  methods::is(input,"IQRtteProjectMulti")
}
#'@export
as_IQRtteProjectMulti <- function (input, FLAGrecursive=FALSE) {
  if (is_IQRtteProjectMulti(input)) {
    return(input)
  }
  output__ <- list()
  if ("character" %in% class(input)) {
    for (k__ in seq_along(input)) {
      if (!dir.exists(input[k__]))
        stopIQR("provided path does not exist.")
      if (is_IQRtteProject(input[k__])) {
        output__[[length(output__)+1]] <- as_IQRtteProject(input[k__])
      } else {
        dirs__ <- list.dirs(input[k__],recursive=FLAGrecursive)
        dirs__ <- dirs__[!grepl(".Internals",dirs__)]
        lapply(dirs__,function(x) {if (is_IQRtteProject(x)) {
          output__[[length(output__)+1]] <<- as_IQRtteProject(x) }
        })
      }
    }
  } else {
    if (all(is_IQRtteProjectMulti(input))) {
      output__ <- input
    } else {
      if (all(is_IQRtteProject(input))) {
        output__ <- input
      } else {
        stopIQR("argument 'input' of incorrect type")
      }
    }
  }
  names(output__) <- unclass(output__)
  attr(output__,"class") <- c("IQRtteProjectMulti","IQRnlmeProjectMulti")
  return(output__)
}
#'@export
plotVPC_IQRtteProject <- function (projectPath,logX=FALSE,logY=FALSE,filename=NULL) {
  if (!is_IQRtteProject(projectPath)) {
    warningIQR("Provided project is not an IQRtteProject")
    return (NULL)
  }
  if (!hasrun_IQRnlmeProject(projectPath)) {
    warningIQR("Provided project has not been run")
    return (NULL)
  }
  data <- getData_IQRnlmeProject(projectPath)
  timeunit <- data$TIMEUNIT[1]
  name <- data$NAME[data$YTYPE==1][1]
  fileCurves <- paste0(projectPath,"/RESULTSORIG/ChartsData/VisualPredictiveCheck/Event_theoreticalCurves.txt")
  fileCurvesEmpirical <- paste0(projectPath,"/RESULTSORIG/ChartsData/VisualPredictiveCheck/Event_empiricalCurves.txt")
  if (!file.exists(fileCurves)) stopIQR("No VPC - Lixoft changes things from version to version ... hard to keep up with French inovation ;)")
  fileCensored <- paste0(projectPath,"/RESULTSORIG/ChartsData/VisualPredictiveCheck/Event_censored.txt")
  curves <- NULL
  censored <- NULL
  if (file.exists(fileCurves)) curves <- utils::read.csv(fileCurves)
  if (file.exists(fileCurvesEmpirical)) curvesemp <- utils::read.csv(fileCurvesEmpirical)
  if (file.exists(fileCensored)) censored <- utils::read.csv(fileCensored)
  if (is.null(curves) | is.null(censored)) {
    warningIQR(paste0("Could not plot the VPC for this model. Data seem not to be available: ",projectPath))
    return(NULL)
  }
  nC <- names(curves)
  survFctCols <- nC[grepl("survivalFunction_p",nC)]
  sFBounds <- as.numeric(aux_strrep(survFctCols,"survivalFunction_p",""))
  p <- IQRggplot() +
    geom_ribbon(data=curves,aes_string(x="time",ymin=survFctCols[1],ymax=survFctCols[2]),alpha=0.2,fill="steelblue") +
    geom_line(data=curvesemp,aes_string(x="time",y="survivalFunction")) +
    geom_point(data=censored,aes_string(x="time",y="values"),color="red") +
    geom_line(data=curves,aes_string(x="time",y="survivalFunction_median"),linetype="dashed") +
    xlab(paste0("Time [",timeunit,"]")) +
    ylab(paste0(name, " [fraction]")) +
    ggtitle(label="Visual Predictive Check",subtitle=paste0("Survival curves: Empirical, simulated median and ",(sFBounds[2]-sFBounds[1]),"% prediction interval\nRed dots indicate censoring\nModel: ",projectPath))
  if (logX) p <- p + scale_x_log10()
  if (logY) p <- p + scale_y_log10()
  attr(p,"plotData") <- list(
    curves = curves,
    censored = censored
  )
  if (!is.null(filename)) {
    IQRoutputPDF(p,filename=filename)
    return(NULL)
  }
  p
}
#'@export
print.IQRtteProject <- function(x, ...) {
  if (file.exists(paste0(x,"/RESULTS/project_results.txt"))) {
    text__ <- aux_fileread(paste0(x,"/RESULTS/project_results.txt"))
    cat(text__)
    cat(paste0("\nIQRtteProject: ",x,"\n\n"))
  } else {
    cat(paste0("IQRtteProject: ",x,"\n"))
    cat("Project has not been run yet (most likely)\n\n")
  }
}
#'@export
plot.IQRtteProject <- function(x, ..., CORR_THRESHOLD=0.3,pathname=NULL) {
  if (!is_IQRtteProject(x)) {
    stopIQR("Please check if you are in the right working directory")
  }
  if (!hasrun_IQRnlmeProject(x)) {
    cat(paste0("IQRtteProject: ",x,"\n"))
    cat("Project has not been run yet (most likely)\n\n")
    return()
  }
  output__ <- list()
  cat(paste0("Generation of general GoF plots in the RESULTS folder of project: ",x,"\n"))
  basefilename__ <- paste0(x, '/RESULTS/GOF_GENERAL/')
  tryCatch({
    output__$GENERAL$ETA <- plotETA_IQRnlmeProject(
      x,
      filename={
        out <- NULL
        if (!is.null(pathname)) out <- paste0(basefilename__, '01_Random_Effects')
        out
      },
      CORR_THRESHOLD=CORR_THRESHOLD
    )
  }, error = function(e) {
    warningIQR(paste0("Problem with ETA plots.\n",e))
  })
  tryCatch({
    output__$GENERAL$ETACOV <- plotETACOV_IQRnlmeProject(
      x,
      filename={
        out <- NULL
        if (!is.null(pathname)) out <- paste0(basefilename__, '02_ETAs_vs_COVs')
        out
      },
      CORR_THRESHOLD=CORR_THRESHOLD
    )
  }, error = function(e) {
    warningIQR(paste0("Problem with ETA/COV plots.\n",e))
  })
  tryCatch({
    output__$GENERAL$COVEFFECT <- covariateEffect_IQRnlmeProject(
      x,
      filename={
        out <- NULL
        if (!is.null(pathname)) out <- paste0(basefilename__, '03_COV_Impact_Parameters')
        out
      },
      Nsamples=1e5,
      ClinicalRelevanceLow=0.8,
      ClinicalRelevanceHigh=1.2
    )
  }, error = function(e) {
    warningIQR(paste0("Problem with Covariate Effect Forest plots.\n",e))
  })
  basefilename__ <- paste0(x, '/RESULTS/')
  output__$VPC <- plotVPC_IQRtteProject(
    x,
    filename={
      out <- NULL
      if (!is.null(pathname)) out <- paste0(basefilename__, 'VPC.pdf')
      out
    }
  )
  output__$VPClog <- plotVPC_IQRtteProject(
    x,
    filename={
      out <- NULL
      if (!is.null(pathname)) out <- paste0(basefilename__, 'VPC_logY.pdf')
      out
    },
    logY=TRUE
  )
  if (is.null(pathname)) {
    return(output__)
  }
}
#'@export
run_IQRtteProject <- function (projectPath,
                               ncores=1,
                               FLAGrerun=FALSE,
                               FLAGgof=TRUE) {
  if (!is_IQRtteProject(projectPath))
    stopIQR("Provided project is not an IQRtteProject object")
  if (!hasrun_IQRnlmeProject(projectPath) | FLAGrerun) {
    run_IQRnlmeProject(
      projectPath = projectPath,
      ncores = ncores,
      FLAGrerun = FLAGrerun,
      FLAGgof = FALSE  
    )
  }
  if (FLAGgof) {
    tryCatch({
      summary.IQRnlmeProject(projectPath,FLAGreport=TRUE,filename=paste0(projectPath,"/project_parameters_table.txt"))
    }, error = function(e) {
      warningIQR("Problem with generation of summary table. Please check if model run had issues.")
    })
    tryCatch({
      plot.IQRtteProject(projectPath,CORR_THRESHOLD=0.3,pathname = projectPath)
    }, error = function(e) {
      warningIQR("Problem with generation of diagnostics. Please check if model run had issues.")
    })
  }
  return(as_IQRtteProject(projectPath))
}
#'@export
as_IQRtteProject <- function (projectPath) {
  if (!is_IQRtteProject(projectPath))
    stopIQR("Provided path does not point to an IQRtteProject")
  output__ <- projectPath
  attr(output__,"class") <- c("IQRtteProject","IQRnlmeProject")
  oldpath__ <- getwd()
  setwd(projectPath)
  absPathIQRtteProject__ <- getwd()
  setwd(oldpath__)
  attr(output__,"absProjectPath") <- absPathIQRtteProject__
  dataPathRel__ <- parseNLMEprojectHeader(projectPath)$DATA
  dataFileInfo__ <- aux_fileparts(dataPathRel__)
  dataFileName__ <- paste0(dataFileInfo__$filename,dataFileInfo__$fileext)
  oldpath__ <- getwd()
  setwd(projectPath)
  if (!dir.exists(dataFileInfo__$pathname)) {
    setwd(oldpath__)
    stopIQR("Could not find the dataset that the model use")
  }
  setwd(dataFileInfo__$pathname)
  absPathData__ <- getwd()
  setwd(oldpath__)
  absDataPath__ <- paste0(absPathData__,"/",dataFileName__)
  attr(output__,"absDataPath") <- absDataPath__
  return(output__)
}
#'@export
is_IQRtteProject <- function (projectPath) {
  if (!file.exists(paste0(projectPath,'/','project.mlxtran'))) return(FALSE)
  x <- parseMONOLIXprojectHeader(projectPath)
  if (is.null(x$ERRORMODELS)) return(TRUE)
  return(FALSE)
}
#'@export
IQRtteProject <- function (model           = "Weibull",
                           comment         = "",
                           repeated        = FALSE,
                           delay           = FALSE,
                           modelSpec       = NULL,
                           data            = data,
                           projectPath     = NULL,
                           toolVersion     = NULL,
                           algOpt.SEED     = 123456,
                           algOpt.K1       = 500,
                           algOpt.K2       = 200,
                           algOpt.NRCHAINS = 1,
                           algOpt.individualParameters = "ConditionalMode",
                           algOpt.indivMCMClength   = 50,
                           algOpt.indivNsim         = 10,
                           algOpt.indivRatio        = 0.05,
                           algOpt.variability = "FirstStage") {
  loadSetupOptions_IQRtools()
  if (is.null(toolVersion)) {
    toolVersion <- names(.PATH_SYSTEM_MONOLIX)[1]
  } else {
    if (!(toolVersion %in% names(.PATH_SYSTEM_MONOLIX))) {
      stopIQR("Selected toolVersion argument not in .PATH_SYSTEM_NONMEM list in setup_options_IQRtools.R")
    }
  }
  if (grepl("2016R1",toolVersion)) {
    stopIQR("MONOLIX 2016R1 is not supported for TTE modeling. Please use 2018R1 or above")
  }
  acceptedModels__ <- c("Weibull","Exponential","Gompertz","Log-logistic","Uniform","Gamma","Generalized-Gamma")
  if (!model %in% acceptedModels__) {
    stopIQR(paste0("model input argument is not accepted. Possible values: ",paste0(acceptedModels__,collapse=", ")))
  }
  if (delay) {
    model <- paste0(model,"_delay")
  }
  modelStruct <- switch (model,
                         "Weibull" = list(
                           description = "Weibull model for time-to-event data\nTe is the scale parameter (characteristic time), and p is the shape parameter.\nInitialization: Te = time at which survival S=0.4, p = 1 - 4",
                           parameters  = c("Te","p"),
                           hazard      = "h = p/Te * (t/Te)^(p-1)",
                           repeated    = repeated
                         ),
                         "Weibull_delay" = list(
                           description = "Weibull model with delay for time-to-event data\nTe is the scale parameter (characteristic time), p is the shape parameter, and del the delay.\nInitialization: del = delay before the survival starts to decrease, Te = time at which survival S=0.4 minus delay, p = 1 - 4",
                           parameters  = c("Te","p","del"),
                           hazard      = "if t<del\nh = 0\nelse\nh = p/Te * ((t-del)/Te)^(p-1)\nend",
                           repeated    = repeated
                         ),
                         "Exponential" = list(
                           description = "Exponential model for time-to-event data.\nTe is the scale parameter (characteristic time).\nInitialization: Te = time at which survival S=0.4",
                           parameters  = c("Te"),
                           hazard      = "h = 1/Te",
                           repeated    = repeated
                         ),
                         "Exponential_delay" = list(
                           description = "Exponential model with delay for time-to-event data.\nTe is the scale parameter (characteristic time).\nInitialization: del = delay before survival start to decrease,\nTe = (time at which survival S=0.4) minus delay",
                           parameters  = c("Te","del"),
                           hazard      = "if t<del\nh = 0\nelse\nh = 1/Te\nend",
                           repeated    = repeated
                         ),
                         "Gompertz" = list(
                           description = "Gompertz model for time-to-event data.\nTe is the scale parameter (characteristic time) and k is the shape parameter.\nInitialization: Te = time at which survival S=0.5, k = 0.01 - 1",
                           parameters  = c("Te","k"),
                           hazard      = "; re-parameterization\nTeprime = Te / log(1+log(2)/k)\n\n; hazard\nh = k/Teprime * exp(t/Teprime)",
                           repeated    = repeated
                         ),
                         "Gompertz_delay" = list(
                           description = "Gompertz model with delay for time-to-event data.\nTe is the scale parameter (characteristic time), k is the shape parameter, and del the delay.\nInitialization: del = delay before survival start to decrease,\nTe = (time at which survival S=0.5) minus delay, k = 0.01 - 1",
                           parameters  = c("Te","k","del"),
                           hazard      = "; re-parameterization\nTeprime = Te / log(1+log(2)/k)\n\n; hazard\nif t<del\nh = 0\nelse\nh = k/Teprime * exp((t-del)/Teprime)\nend",
                           repeated    = repeated
                         ),
                         "Log-logistic" = list(
                           description = "Log-logistic model for time-to-event data.\nTe is the scale parameter (characteristic time) and s is the shape parameter.\nInitialization: Te = time at which survival S=0.5, s = 1-4",
                           parameters  = c("Te","s"),
                           hazard      = "h = s/Te * (t/Te)^(s-1) / (1+(t/Te)^s)",
                           repeated    = repeated
                         ),
                         "Log-logistic_delay" = list(
                           description = "Log-logistic model with delay for time-to-event data.\nTe is the scale parameter (characteristic time), s is the shape parameter, and del the delay.\nInitialization: del = delay before survival start to decrease,\nTe = (time at which survival S=0.5) minus delay, s = 1 - 4",
                           parameters  = c("Te","s","del"),
                           hazard      = "if t<del\nh = 0\nelse\nh = s/Te * ((t-del)/Te)^(s-1) / (1+((t-del)/Te)^s)\nend",
                           repeated    = repeated
                         ),
                         "Uniform" = list(
                           description = "Uniform model for time-to-event data.\nTe is the scale parameter (characteristic time).\nInitialization: Te = time at which survival S=0",
                           parameters  = c("Te"),
                           hazard      = "; saturation to prevent negative values for the hazard:\nt_sat = min(t, Te-1e-5)\nh = 1/(Te-t_sat)",
                           repeated    = repeated
                         ),
                         "Uniform_delay" = list(
                           description = "Uniform model with delay for time-to-event data.\nTe is the scale parameter (characteristic time), s is the shape parameter, and del the delay.\nInitialization: del = delay before survival start to decrease,\nTe = time at which survival S=0 minus delay",
                           parameters  = c("Te","del"),
                           hazard      = "; saturation to prevent negative values for the hazard:\nt_sat = min(t, Te+del-1e-5)\nif t<del\nh = 0\nelse\nh = 1/(Te-(t_sat-del))\nend",
                           repeated    = repeated
                         ),
                         "Gamma" = list(
                           description = "Gamma model for time-to-event data.\nTe is the scale parameter (characteristic time) and alpha is the shape parameter.\nInitialization: Te = time at which survival S=0.4, alpha = 1 - 10",
                           parameters  = c("Te","alpha"),
                           hazard      = "; calculation of the incomplete gamma function via integration\nt_0 = 0\nincompleteGamma_0 = 0\nddt_incompleteGamma = alpha/Te * (alpha*t/Te)^(alpha-1) * exp(-(alpha*t/Te))\n; hazard\nh = alpha/Te * (alpha*t/Te)^(alpha-1)*exp(-(alpha*t/Te)) / (exp(gammaln(alpha)) - incompleteGamma)\n; saturation to prevent h to go to negative values:\nhsat = max(h,0)",
                           repeated    = repeated
                         ),
                         "Gamma_delay" = list(
                           description = "Gamma model with delay for time-to-event data.\nTe is the scale parameter (characteristic time), alpha is the shape parameter and del the delay.\nInitialization: del = delay before survival start to decrease,\nTe = (time at which survival S=0.4) minus delay,\nalpha = 1 - 10",
                           parameters  = c("Te","alpha","del"),
                           hazard      = "; calculation of the incomplete gamma function via integration\nt_0 = 0\nincompleteGamma_0 = 0\nif t<del\nig = 0\nelse\nig = alpha/Te * (alpha*(t-del)/Te)^(alpha-1) * exp(-(alpha*(t-del)/Te))\nend\nddt_incompleteGamma = ig\n\n; hazard\nif t<del\nh = 0\nelse\nh = alpha/Te * (alpha*(t-del)/Te)^(alpha-1)*exp(-(alpha*(t-del)/Te)) / (exp(gammaln(alpha)) - incompleteGamma)\nend\n; saturation to prevent h to go to negative values:\nhsat = max(h,0)",
                           repeated    = repeated
                         ),
                         "Generalized-Gamma" = list(
                           description = "Generalized-Gamma model for time-to-event data.\nTe is the scale parameter (characteristic time), p and alpha are shape parameters.\nInitialization: Te = time at which survival S=0.4,\nalpha = 1 - 10, p = 1 - 4",
                           parameters  = c("Te","alpha","p"),
                           hazard      = "; re-parameterization\nTeprime = Te * exp(gammaln(alpha/p) - gammaln((alpha+1)/p))\n\n; calculation of the incomplete gamma function via integration\nt_0 = 0\nincompleteGamma_0 = 0\nddt_incompleteGamma = p/Teprime * (t/Teprime)^(alpha-1) * exp(-(t/Teprime)^p) \n\n; hazard\nh = p/Teprime * (t/Teprime)^(alpha-1)*exp(-(t/Teprime)^p)  / (exp(gammaln(alpha/p)) - incompleteGamma)\n\n; saturation to prevent h to go to negative values:\nhsat = max(h,0)",
                           repeated    = repeated
                         ),
                         "Generalized-Gamma_delay" = list(
                           description = "Generalized-Gamma model with delay for time-to-event data.\nTe is the scale parameter (characteristic time), p and alpha are shape parameters, and del is the delay.\nInitialization: del = delay before survival starts to decrease,\nTe = (time at which survival S=0.4) minus delay,\nalpha = 1 - 10, p = 1 - 4",
                           parameters  = c("Te","alpha","p","del"),
                           hazard      = "; re-parameterization\nTeprime = Te * exp(gammaln(alpha/p) - gammaln((alpha+1)/p))\n\n; calculation of the incomplete gamma function via integration\nt_0 = 0\nincompleteGamma_0 = 0\nif t<del\nig = 0\nelse\nig = p/Teprime * ((t-del)/Teprime)^(alpha-1) * exp(-((t-del)/Teprime)^p)\nend\nddt_incompleteGamma = ig\n\n; hazard\nif t<del\nh = 0\nelse\nh = p/Teprime * ((t-del)/Teprime)^(alpha-1)*exp(-((t-del)/Teprime)^p)  / (exp(gammaln(alpha/p)) - incompleteGamma)\nend\n; saturation to prevent h to go to negative values:\nhsat = max(h,0)",
                           repeated    = repeated
                         )
  )
  modelInfo <- structure(vector(mode = "list", length=2), names = c("param_est","model"))
  modelInfo$model$outputs <- "OUTPUT1"
  modelInfo$param_est <- structure(vector(mode = "list", length=length(modelStruct$parameters)))
  for (k in seq_along(modelStruct$parameters)) {
    modelInfo$param_est[[k]]$name <- modelStruct$parameters[k]
    modelInfo$param_est[[k]]$value0 <- 1
  }
  modelSpec <- checkHandleDefaultTTEmodelSpec(modelInfo,modelSpec,data)
  data <- checkHandleDataTTE(data,modelSpec)
  algorithmSpec <- list(
    SEED                 = algOpt.SEED,
    K1                   = algOpt.K1,
    K2                   = algOpt.K2,
    NRCHAINS             = algOpt.NRCHAINS,
    individualParameters = toupper(algOpt.individualParameters),
    indivMCMClength      = algOpt.indivMCMClength,
    indivNsim            = algOpt.indivNsim,
    indivRatio           = algOpt.indivRatio,
    variability          = algOpt.variability
  )
  genIQRtteMONOLIXproject(projectPath,modelStruct,modelSpec,modelInfo,data,algorithmSpec,toolVersion,comment)
  output__ <- as_IQRtteProject(projectPath)
  return(output__)
}
checkHandleDefaultTTEmodelSpec <- function(modelInfo,modelSpec,data) {
  if (is.null(modelSpec$POPestimate)) {
    modelSpec$POPestimate <- rep(1,length(modelInfo$param_est))
    names(modelSpec$POPestimate) <- sapply(modelInfo$param_est,function(x) x$name)
  }
  if (length(modelInfo$param_est) != length(modelSpec$POPestimate)) {
    stopIQR('Please make sure POPestimate is of same length as number of parameters to be estimated.')
  }
  if (is.null(modelSpec$POPvalues0)) {
    modelSpec$POPvalues0 <- sapply(modelInfo$param_est,function(x) x$value0)
    names(modelSpec$POPvalues0) <- sapply(modelInfo$param_est,function(x) x$name)
  }
  if (length(modelInfo$param_est) != length(modelSpec$POPvalues0)) {
    stopIQR('Please make sure POPvalues0 is of same length as number of parameters to be estimated.')
  }
  if (is.null(modelSpec$IIVdistribution)) {
    modelSpec$IIVdistribution <- rep("L",length(modelInfo$param_est))
    names(modelSpec$IIVdistribution) <- sapply(modelInfo$param_est,function(x) x$name)
  }
  if (length(modelInfo$param_est) != length(modelSpec$IIVdistribution)) {
    stopIQR('Please make sure IIVdistribution is of same length as number of parameters to be estimated.')
  }
  if (length(setdiff(modelSpec$IIVdistribution,c("L","N","G"))) > 0) {
    stopIQR('Please make sure that only "N", "L", or "G" appear in the "IIVdistribution" variable.')
  }
  if (is.null(modelSpec$IIVestimate)) {
    modelSpec$IIVestimate <- rep(1,length(modelInfo$param_est))
    names(modelSpec$IIVestimate) <- sapply(modelInfo$param_est,function(x) x$name)
  }
  if (length(modelInfo$param_est) != length(modelSpec$IIVestimate)) {
    stopIQR('Please make sure IIVestimate is of same length as number of parameters to be estimated.')
  }
  if (is.null(modelSpec$IIVvalues0)) {
    modelSpec$IIVvalues0 <- rep(0.5,length(modelInfo$param_est))
    names(modelSpec$IIVvalues0) <- sapply(modelInfo$param_est,function(x) x$name)
  }
  if (length(modelInfo$param_est) != length(modelSpec$IIVvalues0)) {
    stopIQR('Please make sure IIVvalues0 is of same length as number of parameters to be estimated.')
  }
  if (is.null(modelSpec$covariateModel) & !is.null(modelSpec$covariateModelValues)) {
    stopIQR('If you define covariateModelValues, you also need to define the covariateModel.')
  }
  if (is.null(modelSpec$covariateModelValues) & !is.null(modelSpec$covariateModel)) {
    modelSpec$covariateModelValues <- list()
    for (k__ in seq_along(modelSpec$covariateModel)) {
      modelSpec$covariateModelValues[[names(modelSpec$covariateModel)[k__]]] <- rep(0.1,length(modelSpec$covariateModel[[k__]]))
      names(modelSpec$covariateModelValues[[names(modelSpec$covariateModel)[k__]]]) <- modelSpec$covariateModel[[k__]]
    }
  }
  if (length(modelSpec$covariateModel) != length(modelSpec$covariateModelValues)) {
    stopIQR('Number of elements in covariateModel and covariateModelValues needs to match.')
  }
  for (k__ in seq_along(modelSpec$covariateModel)) {
    if (length(modelSpec$covariateModel[[k__]]) != length(modelSpec$covariateModelValues[[k__]])) {
      stopIQR('Length of single elements in covariateModel and covariateModelValues needs to match.')
    }
  }
  for (k__ in seq_along(modelSpec$covariateModelValues)) {
    if (length(which(modelSpec$covariateModelValues[[k__]]==0)) > 0) {
      stopIQR('Initial guess for at least one covariate coefficient is 0. Not allowed for NONMEM!')
    }
  }
  if (is.null(modelSpec$covariateModel) & !is.null(modelSpec$COVestimate)) {
    stopIQR('If you define COVestimate, you also need to define the covariateModel.')
  }
  if (is.null(modelSpec$COVestimate) & !is.null(modelSpec$covariateModel)) {
    modelSpec$COVestimate <- list()
    for (k__ in seq_along(modelSpec$covariateModel)) {
      modelSpec$COVestimate[[names(modelSpec$covariateModel)[k__]]] <- rep(1,length(modelSpec$covariateModel[[k__]]))
      names(modelSpec$COVestimate[[names(modelSpec$covariateModel)[k__]]]) <- modelSpec$covariateModel[[k__]]
    }
  }
  if (length(modelSpec$covariateModel) != length(modelSpec$COVestimate)) {
    stopIQR('Number of elements in covariateModel and COVestimate needs to match.')
  }
  for (k__ in seq_along(modelSpec$covariateModel)) {
    if (length(modelSpec$covariateModel[[k__]]) != length(modelSpec$COVestimate[[k__]])) {
      stopIQR('Length of single elements in covariateModel and COVestimate needs to match.')
    }
  }
  if (is.null(modelSpec$covarianceModel)) modelSpec$covarianceModel = "diagonal"
  if (all(modelSpec$covarianceModel != "diagonal")) {
    param_est_noIIV <- unlist(sapply(modelInfo$param_est, function (x) {
      if (modelSpec$IIVestimate[x$name]==1) {
        return(NULL)
      }
      x$name
    }))
    if (length(intersect(param_est_noIIV,aux_explode(paste(modelSpec$covarianceModel,collapse=","))))>0) {
      stopIQR('Please make sure none of the parameters for which NO IIV is estimated (IIVestimate=0) is used in the covarianceModel settings.');
    }
    if (length(setdiff(aux_explode(paste(modelSpec$covarianceModel,collapse=",")), sapply(modelInfo$param_est,function(x) x$name))) > 0) {
      stopIQR('Please make sure that covarianceModel only contains parameter names that are set to <estimate> in the model.');
    }
  }
  if (length(modelSpec$covariateModel) > 0) {
    if (all(names(modelSpec$covariateModel) != names(modelSpec$covariateModelValues))) {
      stopIQR('Check naming of covariateModel and covariateModelValues.');
    }
    if (all(names(modelSpec$covariateModel) != names(modelSpec$COVestimate))) {
      stopIQR('Check naming of covariateModel and COVestimate');
    }
    if (length(setdiff(names(modelSpec$covariateModel),sapply(modelInfo$param_est,function(x) x$name))) > 0) {
      stopIQR('Please make sure that all parameters for which covariates are defined are defined by <estimate> in the model.');
    }
    covcatNamesData__  <- c(data$covNames, data$catNames)
    covcatNamesModel__ <- unique(unlist(modelSpec$covariateModel))
    if (length(setdiff(covcatNamesModel__,covcatNamesData__)) > 0) {
      stopIQR('Please make sure that all covariates, defined in covariateModel, are defined in the dataset\n   This error might be due to a categorical covariate having only a single category.')
    }
  }
  model_reg_names__ <- sapply(modelInfo$param_reg, function(x) x$name)
  if (length(data$regNames) != length(model_reg_names__)) {
    stopIQR('Different numbers of regression parameters in model and in dataset.')
  }
  if (length(model_reg_names__) > 0 & any(model_reg_names__ != data$regNames)) {
    stopIQR('Names and/or ordering of regression parameters in the model and dataset are not identical.')
  }
  modelParamEstNamesOrder__   <- sapply(modelInfo$param_est, function(x) x$name)
  originalOrderPOPvalues0__   <- names(modelSpec$POPvalues0)
  modelSpec$POPvalues0        <- modelSpec$POPvalues0[modelParamEstNamesOrder__]
  modelSpec$POPestimate       <- modelSpec$POPestimate[modelParamEstNamesOrder__]
  modelSpec$IIVvalues0        <- modelSpec$IIVvalues0[modelParamEstNamesOrder__]
  modelSpec$IIVestimate       <- modelSpec$IIVestimate[modelParamEstNamesOrder__]
  modelSpec$IIVdistribution   <- modelSpec$IIVdistribution[modelParamEstNamesOrder__]
  return(modelSpec)
}
checkHandleDataTTE <- function (data,modelSpec) {
  if (length(setdiff(names(data),c("datafile", "covNames","catNames","regressorNames"))) > 0)
    stopIQR('Data input argument wrongly defined (needs to contain the element "datafile" and can contain the elements "covNames", "catNames", "regressorNames")')
  if (length(setdiff(c("datafile"),names(data))) > 0)
    stopIQR("Data input argument wrongly defined (needs to contain the element 'datafile')")
  if(!file.exists(data$datafile))
    stopIQR("Trouble loading the data file. Please check if data$datafile has been defined correctly")
  data$dataModeling <- IQRloadCSVdata(data$datafile)
  if (!all(data$regressorNames %in% names(data$dataModeling))) {
    stopIQR("Not all regressorNames are available in the dataset")
  }
  if (!all(data$covNames %in% names(data$dataModeling))) {
    stopIQR("Not all covNames are available in the dataset")
  }
  if (!all(data$catNames %in% names(data$dataModeling))) {
    stopIQR("Not all catNames are available in the dataset")
  }
  headerInfo__     <- getHeaderIdent_IQRnlmeData(data$dataModeling,data$covNames,data$catNames,data$regressorNames)
  data$regNames <- data$regressorNames
  data$headerIdent <- headerInfo__$headerIdent
  data$headerIdentVector <- headerInfo__$headerIdentVector
  if (!is.null(data$covNames)) {
    covsAllIDs__ <- do.call(rbind,lapply(split(data$dataModeling,data$dataModeling$ID), function(x) x[1,data$covNames,drop=FALSE] ))
    covariateMedianValues__ <- sapply(data$covNames, function(x) stats::median(as.numeric(covsAllIDs__[[x]]),na.rm=TRUE))
  } else {
    covariateMedianValues__ <- NULL
  }
  if (!is.null(data$catNames)) {
    catsAllIDs__ <- as.data.frame(do.call(rbind,lapply(split(data$dataModeling,data$dataModeling$ID), function(x) x[1,data$catNames] )))
    if (length(data$catNames)==1) names(catsAllIDs__) <- data$catNames
    catValues <- lapply(data$catNames, function(x) sort(unique(as.numeric(catsAllIDs__[[x]]))))
    names(catValues) <- data$catNames
    if (sum(as.numeric(is.na(unlist(catValues)))) > 0)
      stopIQR("dataset contains undefined (NA) categorical covariates. Please impute")
    if (sum(as.numeric(is.nan(unlist(data$dataModeling$catValues)))) > 0)
      stopIQR("dataset contains undefined (NaN) categorical covariates. Please impute")
    covariateCATreference <- sapply(catValues, function(x) min(x))
  } else {
    catValues <- NULL
    covariateCATreference <- NULL
  }
  data$catValues <- catValues
  data$covariateCATreference <- covariateCATreference
  data$covariateMedianValues <- covariateMedianValues__
  if (!is.null(data$covNames)) {
    for (k__ in seq_along(modelSpec$COVcentering)) {
      ix__ <- aux_strmatch(searchString=names(modelSpec$COVcentering[k__]),inputVec=names(data$covariateMedianValues))
      data$covariateMedianValues[ix__] <- modelSpec$COVcentering[k__]
    }
  }
  dummy__ <- lapply(data$catValues, function (x__) {
    if (any(as.integer(x__) != x__))
      stopIQR("Not all categorical covariates have integer-only categories! This is not allowed.")
  })
  if (!is.null(data$catNames)) {
    for (k__ in seq_along(modelSpec$COVcentering)) {
      ix__ <- aux_strmatch(searchString=names(modelSpec$COVcentering[k__]),inputVec=names(data$covariateCATreference))
      data$covariateCATreference[ix__] <- modelSpec$COVcentering[k__]
    }
  }
  data
}
#'@export
sample_GPF <- function(input,
                       Nsamples    = NULL,
                       FLAG_SAMPLE = 0,
                       covariates  = NULL,
                       FLAGid      = FALSE,
                       verbose     = TRUE) {
  if (FLAG_SAMPLE==2) {
    stopIQR("FLAG_SAMPLE=2 is currently not supported in the same manner as for sample_IQRnlmeProject()")
  }
  if (FLAG_SAMPLE > 6 & FLAG_SAMPLE < 0) {
    stopIQR("FLAG_SAMPLE should be between 0 and 6. Values of 5 and 6 are mainly reserved for internal purposes and should not be used by the normal user.")
  }
  if (is.character(input)) {
    if (!file.exists(input)) stopIQR("input provided as character string but not pointing to a file")
  }
  if (!is.character(input)) {
    if (!is_GPF(input)) stopIQR("input is not a GPF object")
  }
  if (is.null(Nsamples) & is.null(covariates)) {
    stopIQR("Please provide either Nsamples or covariates argument")
  }
  if (is.null(Nsamples)) {
    Nsamples <- nrow(covariates)
  }
  Npop <- 1
  if (FLAG_SAMPLE==2) {
    Npop <- Nsamples
  }
  if (verbose) {
    results <- sampleIndParamValues(
      spec = input,
      data = covariates,
      Nsamples = Nsamples,
      Npop = Npop,
      FLAG_SAMPLE = FLAG_SAMPLE
    )
  } else {
    results <- suppressWarnings(
      suppressMessages(
        results <- sampleIndParamValues(
          spec = input,
          data = covariates,
          Nsamples = Nsamples,
          Npop = Npop,
          FLAG_SAMPLE = FLAG_SAMPLE
        )
      )
    )
  }
  sampledData               <- results$sampledData
  popParamValues       <- results$popParamValues
  typicalIndParamValues    <- results$typicalIndParamValues
  indParamValues       <- results$indParamValues
  if ("ID.POP" %in% names(sampledData) & !"ID" %in% names(sampledData)) {
    sampledData$ID <- sampledData$ID.POP
  }
  if ("ID.POP" %in% names(popParamValues) & !"ID" %in% names(popParamValues)) {
    popParamValues$ID <- popParamValues$ID.POP
  }
  if ("ID.POP" %in% names(typicalIndParamValues) & !"ID" %in% names(typicalIndParamValues)) {
    typicalIndParamValues$ID <- typicalIndParamValues$ID.POP
  }
  if ("ID.POP" %in% names(indParamValues) & !"ID" %in% names(indParamValues)) {
    indParamValues$ID <- indParamValues$ID.POP
  }
  sampledData$ID.POP <- NULL
  popParamValues$ID.POP <- NULL
  typicalIndParamValues$ID.POP <- NULL
  indParamValues$ID.POP <- NULL
  if (!FLAGid) {
    sampledData$ID <- NULL
    popParamValues$ID <- NULL
    typicalIndParamValues$ID <- NULL
    indParamValues$ID <- NULL
  }
  if (FLAG_SAMPLE %in% c(0,1)) {
    output__                                 <- list()
    output__$FLAG_SAMPLE                     <- FLAG_SAMPLE
    output__$Nsamples                        <- Nsamples
    output__$covariatesSampled               <- sampledData
    output__$popParamValues                  <- popParamValues
    output__$typicalIndParamValues           <- NULL
    output__$indParamValues                  <- indParamValues
  }
  if (FLAG_SAMPLE %in% c(3,4)) {
    output__                                 <- list()
    output__$FLAG_SAMPLE                     <- FLAG_SAMPLE
    output__$Nsamples                        <- Nsamples
    output__$covariatesSampled               <- sampledData
    output__$popParamValues                  <- typicalIndParamValues
    output__$typicalIndParamValues           <- NULL
    output__$indParamValues                  <- NULL
  }
  if (FLAG_SAMPLE %in% c(5,6)) {
    output__                                 <- list()
    output__$FLAG_SAMPLE                     <- FLAG_SAMPLE
    output__$Nsamples                        <- Nsamples
    output__$covariatesSampled               <- sampledData
    output__$popParamValues                  <- popParamValues
    output__$typicalIndParamValues           <- typicalIndParamValues
    output__$indParamValues                  <- indParamValues
  }
  output__
}
#'@export
#'@importFrom data.table setnames
#'@importFrom utils packageVersion
GPF <- function(filename, estimates, uncertainty_correlation = data.frame()) {
  if(missing(estimates) || is.null(estimates)) {
    if(is.character(filename) && file.exists(filename)) {
      gpf <- load_GPF(filename)
    } else {
      stop("GPF:: When estimates is missing or NULL, filename should point to an existing file.")
    }
  } else {
    estimates               <- as.data.table(estimates)
    uncertainty_correlation <- as.data.table(uncertainty_correlation)
    nm_required <- c("PARAMETER",	"TYPE",	"VALUE",	"VALUE.RSE.PERCENT",	"IIV",	"IIV.RSE.PERCENT",
                     "TRANSFORMATION",	"UNIT",	"COV.FORMULA",	"NAME",	"COV.REFERENCE",	"COMMENT")
    if (packageVersion("data.table")<"1.12.2"){
      vecOldNamesPresent <- c("FORMULA", "REFERENCE") %in% names(estimates)
      if(sum(vecOldNamesPresent) > 0) {
        data.table::setnames(estimates, c("FORMULA", "REFERENCE")[vecOldNamesPresent], c("COV.FORMULA", "COV.REFERENCE")[vecOldNamesPresent])
      }
    }else{
      data.table::setnames(estimates, c("FORMULA", "REFERENCE"), c("COV.FORMULA", "COV.REFERENCE"), skip_absent = TRUE)
    }
    if(!'VALUE.RSE.PERCENT' %in% names(estimates) && 'VALUE.RSE' %in% names(estimates)) {
      names(estimates)[names(estimates) == 'VALUE.RSE'] <- 'VALUE.RSE.PERCENT'
    }
    if(!'IIV.RSE.PERCENT' %in% names(estimates) && 'IIV.RSE' %in% names(estimates)) {
      names(estimates)[names(estimates) == 'IIV.RSE'] <- 'IIV.RSE.PERCENT'
    }
    if(length(setdiff(nm_required, names(estimates)))){
      stopIQR("Columns \033[32m", paste0(setdiff(nm_required, names(estimates)), collapse = ", "),
              "\033[39m not available in estimates sheet.")
    }
    if (nrow(uncertainty_correlation)==0){
      uncertainty_correlation <- cbind(data.table(PARAMETER = estimates$PARAMETER),
                                       as.data.table(diag(nrow(estimates))))
    }else if (nrow(uncertainty_correlation)!=(length(uncertainty_correlation) - 1)) {
      stopIQR("CORRELATIONVALUES is not square - uncertainty_correlation must data.frame(PARAMETER, CORRELATIONVALUES...)
          If reading from a file, did you load the GPF-file with `load_GPF`?")
    }
    estimates$PARAMETER         <- as.character(estimates$PARAMETER)
    estimates$TYPE              <- as.character(estimates$TYPE)
    estimates$VALUE             <- as.numeric(estimates$VALUE)
    estimates$VALUE.RSE.PERCENT <- as.numeric(estimates$VALUE.RSE.PERCENT)
    estimates$IIV               <- as.numeric(estimates$IIV)
    estimates$IIV.RSE.PERCENT   <- as.numeric(estimates$IIV.RSE.PERCENT)
    estimates$TRANSFORMATION    <- as.character(estimates$TRANSFORMATION)
    estimates$UNIT              <- as.character(estimates$UNIT)
    estimates$COV.FORMULA           <- as.character(estimates$COV.FORMULA)
    estimates$NAME              <- as.character(estimates$NAME)
    estimates$COV.REFERENCE         <- as.numeric(estimates$COV.REFERENCE)
    estimates$COMMENT           <- as.character(estimates$COMMENT)
    uncertainty_correlation <- setNames(uncertainty_correlation, c("PARAMETER", uncertainty_correlation[[1]]))
    gpf <- structure(list(estimates = estimates,
                          uncertainty_correlation = uncertainty_correlation),
                     class = "GPF")
  }
  pgpf <- try(parse_GPF(gpf), silent = TRUE)
  if(inherits(pgpf, "try-error")) {
    warningIQR("Errors during parsing of the estimates or uncertainty_correlation sheets:",
               pgpf,
               "Returning unparsed GPF object.")
    gpf
  } else {
    pgpf
  }
}
#'@export
is_GPF <- function(x) {
  inherits(x, "GPF")
}
#'@export
load_GPF <- function(x) {
  if (is_GPF(x))
    return(x)
  if (is.data.frame(x)){
    GPF <- GPF(filename = NULL, estimates = x, uncertainty_correlation = data.frame())
    return(GPF)
  }
  if (is.character(x)) {
    if(endsWith(x, ".xlsx") || endsWith(x, ".xls")) {
      GPF <- read_GPFFromXLS(x)
      return(GPF)
    } else if(endsWith(x, ".csv")) {
      GPF <- read_GPFFromCSV(x)
      return(GPF)
    } else if (is_IQRnlmeProject(x)){
      GPF <- generate_GPFFromIQRnlmeProject(x, filename = NULL)
      return(GPF)
    } else {
      stopIQR(paste0(
        "load_GPF:: Unrecognized filetype ",
        "(only .csv, .xlsx and .xls files and IQRnlmeProject directories are supported"))
    }
  }
  stopIQR(class(x), " not supported or the filename does not point to an xls a csv or a NLME/SYS-project.")
}
#'@importFrom writexl write_xlsx
#'@export
export_GPF <- function(GPF, filename) {
  if (!(endsWith(filename, ".xlsx") || endsWith(filename, ".xls")))
    stopIQR("filename should end in either .xlsx or .xls.\nCurrent filename: ", filename)
  aux_mkdir(dirname(filename))
  orderedColumnsInEstimates <- c("PARAMETER",	"TYPE",	"VALUE",	"VALUE.RSE.PERCENT",	"IIV",	"IIV.RSE.PERCENT",
                                 "TRANSFORMATION",	"UNIT",	"COV.FORMULA",	"NAME",	"COV.REFERENCE",	"COMMENT")
  if (packageVersion("data.table")<"1.12.2"){
    vecOldNamesPresent <- c("FORMULA", "REFERENCE") %in% names(GPF$estimates)
    if(sum(vecOldNamesPresent) > 0) {
      data.table::setnames(
        GPF$estimates,
        c("FORMULA", "REFERENCE")[vecOldNamesPresent],
        c("COV.FORMULA", "COV.REFERENCE")[vecOldNamesPresent])
    }
  } else {
    data.table::setnames(
      GPF$estimates,
      c("FORMULA", "REFERENCE"),
      c("COV.FORMULA", "COV.REFERENCE"),
      skip_absent = TRUE)
  }
  writexl::write_xlsx(
    list(estimates = GPF$estimates[, orderedColumnsInEstimates, with = FALSE],
         uncertainty_correlation = GPF$uncertainty_correlation),
    path = filename,
    col_names = TRUE,
    format_headers = FALSE)
  GPF(filename = filename, estimates = GPF$estimates, uncertainty_correlation = GPF$uncertainty_correlation)
}
read_GPFFromXLS <- function(filename) {
  if(!is.character(filename) &&
     file.exists(filename)  &&
     (endsWith(filename, ".xlsx") || endsWith(filename, ".xls"))) {
    stopIQR(
      paste0("Argument filename should denote an .xlsx or .xls file. ",
             "Check that this file (", filename, ") exists."))
  }
  estimates <- suppressMessages(suppressWarnings(
    readxl::read_excel(path = filename, sheet = "estimates")
  ))
  uncertainty_cor       <- suppressMessages(suppressWarnings(
    readxl::read_excel(path = filename, sheet = "uncertainty_correlation",
                       col_names = TRUE)
  ))
  if(nrow(uncertainty_cor) == ncol(uncertainty_cor) - 2L) {
    uncertainty_cor       <- suppressMessages(suppressWarnings(
      readxl::read_excel(path = filename, sheet = "uncertainty_correlation",
                         col_names = FALSE)
    ))
  }
  GPF(filename = filename,
      estimates = estimates,
      uncertainty_correlation = uncertainty_cor)
}
read_GPFFromCSV <- function(filename) {
  if(!is.character(filename) &&
     file.exists(filename)  && endsWith(filename, ".csv") ) {
    stopIQR(
      paste0("Argument filename should denote an .csv file. ",
             "Check that this file (", filename, ") exists."))
  }
  estimates <- IQRloadCSVdata(filename = filename)
  uncertainty_cor <- data.frame()
  GPF(filename = filename,
      estimates = estimates,
      uncertainty_correlation = uncertainty_cor)
}
#'@export
#'@importFrom data.table data.table rbindlist
generate_GPFfromIQRmodel <- function(model, filename = NULL) {
  if (is.character(model)) model <- IQRmodel(model)
  est <- lapply(model$parameters, function(p) {
    data.table::data.table(
      TYPE = "MODEL PARAMETER",
      VALUE = p$value,
      VALUE.RSE.PERCENT = 0,
      IIV = 0,
      IIV.RSE.PERCENT = 0,
      TRANSFORMATION = ifelse(p$value > 0 , "L", "N"),
      UNIT = ifelse(!is.null(p$unittype), p$unittype, NA),
      FORMULA = NA,
      NAME = ifelse(!is.null(p$notes), p$notes, NA),
      REFERENCE = NA,
      COMMENT = NA
    )
  })
  est <- data.table::rbindlist(est, idcol = "PARAMETER")
  est <- est[grep("INPUT", PARAMETER, invert = TRUE)]
  xls <- GPF(filename, est, data.frame())
  if (!is.null(filename)) {
    export_GPF(xls, filename)
  }
  xls
}
#'@export
#'@importFrom data.table data.table as.data.table setnames copy data.table rbindlist
generate_GPFFromIQRnlmeEst <- function(est, filename = NULL) {
  VALUE.RSE.PERCENT <- IIV <- info <- TRANSFORMATION <- NOTES <- COVINFO <-
    VALUE0 <- CATEGORY <- ISCAT <- COVPARTRAFO <- ISCOV <- IIV.RSE.PERCENT <-
    COV.FORMULA <- COV.REFERENCE <- PARAMETER_ORIG <- NULL
  m   <- est$model
  modelSpec__ <- est[["modelSpec"]]
  pars__ <- modelSpec__[["POPvalues0"]]
  omegas__ <- modelSpec__[["IIVvalues0"]]
  trafos__ <- modelSpec__[["IIVdistribution"]]
  cormodel__ <- modelSpec__$covarianceModel
  if (!is.null(cormodel__) & cormodel__[1] != "diagonal") {
    blocks__ <- lapply(cormodel__, function(bl) {
      p__ <- strsplit(bl, ",")[[1]]
      combinations__ <- combn(p__, 2)
      apply(combinations__, 2, function(v__) paste0("corr(", v__[1], ",", v__[2], ")"))
    })
    blocks__ <- unlist(blocks__)
    cormodel__ <- rep(0, length(blocks__))
    names(cormodel__) <- blocks__
  } else {
    cormodel__ <- NULL
  }
  covvalues__ <- modelSpec__[["covariateModelValues"]]
  catlevels__ <- est$data$catValues
  catref__    <- est$data$covariateCATreference
  for (n__ in names(catlevels__)) catlevels__[[n__]] <- setdiff(catlevels__[[n__]], catref__[[n__]])
  betapars__ <- unlist(lapply(seq_along(covvalues__), function(i__) {
    par__ <- names(covvalues__)[i__]
    cov__ <- names(covvalues__[[i__]])
    is_cat__ <- cov__ %in% names(catlevels__)
    unlist(unlist(lapply(seq_along(cov__), function(j__) {
      if (is_cat__[j__]) {
        betaname__ <- paste0("beta_", par__, "(", cov__[j__], "_", catlevels__[[cov__[j__]]], ")")
        betavalue__ <- rep(covvalues__[[i__]][[j__]], length(betaname__))
      } else {
        betaname__ <- paste0("beta_", par__, "(", cov__[j__], ")")
        betavalue__ <- covvalues__[[i__]][[j__]]
      }
      names(betavalue__) <- betaname__
      return(betavalue__)
    })))
  }))
  errmodel__ <- modelSpec__[["errorModel"]]
  errpars__ <- unlist(lapply(seq_along(errmodel__), function(i__) {
    output__ <- sub("^OUTPUT", "", names(errmodel__)[i__])
    if (errmodel__[[i__]][1] == "abs") errpars__ <- stats::setNames(as.numeric(errmodel__[[i__]][2]), paste0("error_ADD", output__))
    if (errmodel__[[i__]][1] == "rel") errpars__ <- stats::setNames(as.numeric(errmodel__[[i__]][2]), paste0("error_PROP", output__))
    if (errmodel__[[i__]][1] == "absrel") errpars__ <- stats::setNames(as.numeric(errmodel__[[i__]][2:3]), paste0(c("error_ADD", "error_PROP"), output__))
    errpars__
  }))
  allpars__ <- c(pars__, cormodel__, betapars__, errpars__)
  estimates__ <- data.frame(
    PARAMETER = names(allpars__),
    VALUE = as.numeric(allpars__),
    VALUE.RSE.PERCENT = 0,
    IIV = 0,
    IIV.RSE.PERCENT = 0,
    TRANSFORMATION = NA
  )
  estimates__[["IIV"]][match(names(omegas__), estimates__[["PARAMETER"]])] <- omegas__
  estimates__[["TRANSFORMATION"]][match(names(pars__), estimates__[["PARAMETER"]])] <- "N"
  estimates__[["TRANSFORMATION"]][match(names(trafos__), estimates__[["PARAMETER"]])] <- trafos__
  estimates <- data.table::data.table(imputeTYPEcol_GPF(estimates__))
  parnotes <- lapply(m$parameters, function(x) if(length(x$notes)) data.table::data.table(NOTES = x$notes) else NULL)
  parnotes <- data.table::rbindlist(parnotes, idcol = "PARAMETER")
  if (nrow(parnotes)) {
    parnotes[,`:=`(UNIT = gsub(".*\\((.*)\\)$", "\\1", NOTES),
                   NAME = gsub("\\((.*)\\)$", "", NOTES))]
    estimates <- parnotes[estimates, on = "PARAMETER"]
  } else {
    warningIQR("No parameter units present in the IQRmodel. Please add them manually to the GPF.")
    estimates[,`:=`(UNIT = NA, NAME = NA)]
  }
  estimates[grep("^beta_", PARAMETER),`:=`(COVPAR  = gsub("beta_(\\w+)\\((.*)\\)", "\\1", PARAMETER))] 
  covtrafo <- estimates[,list(COVPAR = PARAMETER, COVPARTRAFO = TRANSFORMATION)]
  covtrafo <- covtrafo[!grepl("^beta_", COVPAR)]
  estimates <- covtrafo[estimates, on = c("COVPAR")]
  estimates[grep("^beta_", PARAMETER),`:=`(COVINFO  = gsub("beta_(\\w+)\\((.*)\\)", "\\2", PARAMETER))] 
  estimates[grep("^beta_", PARAMETER),`:=`(COVNAME  = gsub("([^_]+)_?(.*)", "\\1", COVINFO))] 
  estimates[grep("^beta_", PARAMETER),`:=`(CATEGORY = gsub("([^_]+)_?(.*)", "\\2", COVINFO))] 
  pars0 <- lapply(m$parameters, function(x) data.table::data.table(VALUE0 = x$value))
  pars0 <- data.table::rbindlist(pars0, idcol = "PARAMETER")
  pars0 <- merge(pars0,estimates, by.x = "PARAMETER", by.y = "COVPAR")
  pars0 <- pars0[,list(PARAMETER, VALUE0)]
  pars0 <- unique(pars0)
  pars0 <- pars0 [!estimates, on = "PARAMETER"]
  pars0[,`:=`(TRANSFORMATION = ifelse(VALUE0 > 0, "L", "N"), IIV = 0, IIV.RSE.PERCENT = 0, VALUE.RSE.PERCENT = 0)]
  pars0 <- data.table::data.table(imputeTYPEcol_GPF(pars0))
  idx <- which(is.na(estimates$COVPARTRAFO) & estimates$COVPAR %in% pars0$PARAMETER)
  if (length(idx) > 0) estimates$COVPARTRAFO[idx] <- pars0$TRANSFORMATION[match(estimates$COVPAR[idx], pars0$PARAMETER)]
  data.table::setnames(pars0, "VALUE0", "VALUE")
  estimates <- data.table::rbindlist(list(estimates, pars0), use.names = TRUE, fill = TRUE)
  covnm <- unique(estimates$COVNAME)
  covnm <- covnm[!is.na(covnm)]
  ref <- unlist(do.call(c,unname(est$data[c("covariateCATreference", "covariateMedianValues")])))[covnm]
  if (length(ref) > 0) {
    ref <- data.table::data.table(COVNAME = names(ref), COV.REFERENCE = ref)
    estimates <- ref[estimates, on = "COVNAME"]
  } else {
    estimates[,`:=`(COV.REFERENCE = NA)]
  }
  estimates[,`:=`(ISCAT = FALSE, ISCOV = FALSE)]
  estimates[grep("^beta_", PARAMETER),`:=`(ISCAT = nchar(CATEGORY)>0, ISCOV = nchar(CATEGORY) == 0)]
  estimates[ISCAT & COVPARTRAFO == "N" ,`:=`(COV.FORMULA = "X=X_ref + Beta")]
  estimates[ISCAT & COVPARTRAFO == "L" ,`:=`(COV.FORMULA = "X=X_ref * exp(Beta)")]
  estimates[ISCAT & COVPARTRAFO == "G" ,`:=`(COV.FORMULA = "X=X_ref * exp(Beta)/(1-X_ref+X_ref*exp(Beta))")]
  estimates[ISCOV & COVPARTRAFO == "N" ,`:=`(COV.FORMULA = paste0("X=X_ref + Beta*log(",COVNAME,"/REF)"))]
  estimates[ISCOV & COVPARTRAFO == "L" ,`:=`(COV.FORMULA = paste0("X=X_ref * (",COVNAME,"/REF)^Beta"))]
  estimates[ISCOV & COVPARTRAFO == "G" ,`:=`(COV.FORMULA = paste0("X=X_ref * (",COVNAME,"/REF)^Beta/(1-X_ref+X_ref*(",COVNAME,"/REF)^Beta)"))]
  estimates <- estimates[,list(PARAMETER,
                               TYPE = factor(TYPE, levels = c("MODEL PARAMETER", "IIV CORRELATION", "CONTINUOUS COVARIATE", "CATEGORICAL COVARIATE", "RELATIVE ERROR", "ADDITIVE ERROR")),
                               VALUE,	VALUE.RSE.PERCENT,	IIV,	IIV.RSE.PERCENT,
                               TRANSFORMATION, UNIT, COV.FORMULA, NAME, COV.REFERENCE, COMMENT = NA)]
  estimates <- estimates[order(TYPE)]
  GPF <- GPF(filename = filename,
             estimates = estimates)
  if (!is.null(filename))
    export_GPF(GPF = GPF, filename = filename)
  GPF
}
#'@export
#'@importFrom data.table data.table as.data.table setnames copy data.table rbindlist
generate_GPFFromIQRnlmeProject <- function(projectPath, filename = NULL) {
  VALUE.RSE.PERCENT <- IIV <- info <- TRANSFORMATION <- NOTES <- COVINFO <-
    VALUE0 <- CATEGORY <- ISCAT <- COVPARTRAFO <- ISCOV <- IIV.RSE.PERCENT <-
    COV.FORMULA <- COV.REFERENCE <- PARAMETER_ORIG <- NULL
  res <- eval(parse(file.path(projectPath, "RESULTS", "project_results.x")))
  est <- readRDS(file.path(projectPath, "project.est"))
  m   <- IQRmodel(file.path(projectPath, "model.txt"), FLAGsim = FALSE)
  estimates <- generate_GPFFromIQRnlmeEst(est)$estimates
  sanitizeInfo <- function(x) as.data.frame(x, stringsAsFactors = FALSE)[, intersect(names(x), c("names", "values", "rse"))]
  result <- rbind(
    sanitizeInfo(res$rawParameterInfo$fixedEffects),
    sanitizeInfo(res$rawParameterInfo$randomEffects),
    sanitizeInfo(res$rawParameterInfo$correlation),
    sanitizeInfo(res$rawParameterInfo$covariate),
    sanitizeInfo(res$rawParameterInfo$errorParameter)
  )
  result$names <- sub("==", "_", result$names)
  idx__ <- match(estimates$PARAMETER, result$names)
  estimates$VALUE <- result$values[idx__]
  estimates$VALUE.RSE.PERCENT <- result$rse[idx__]
  estimates$VALUE.RSE.PERCENT[is.na(estimates$VALUE.RSE.PERCENT)] <- 0
  idx__ <- match(paste0("omega(", estimates$PARAMETER, ")"), result$names)
  estimates$IIV <- result$values[idx__]
  estimates$IIV.RSE.PERCENT <- result$rse[idx__]
  estimates$IIV[is.na(estimates$IIV)] <- 0
  estimates$IIV.RSE.PERCENT[is.na(estimates$IIV.RSE.PERCENT)] <- 0
  uc <- res$parameters$correlationmatrix
  if (is_NONMEM_IQRnlmeProject(projectPath)) {
    ucnames <- res$parameters$names
    ucnames <- gsub("omega2", "omega",ucnames)
    ucnames[grepl("omega.*,.*", ucnames)] <- gsub("^omega", "corr", grep("omega.*,.*", ucnames, value = TRUE))
    dimnames(uc) <- list(ucnames,ucnames)
  }
  dimnames(uc) <- lapply(1:2, function(x) gsub("==", "_", rownames(uc))) 
  keepPars_uc <- c(setNames(estimates$VALUE.RSE.PERCENT, estimates$PARAMETER),
                   setNames(estimates$IIV.RSE.PERCENT, paste0("omega(",estimates$PARAMETER, ")")))
  keepPars_uc <- keepPars_uc[keepPars_uc != 0]
  if (length(keepPars_uc)){
    uc <- uc[names(keepPars_uc), names(keepPars_uc), drop = FALSE]
    uc[upper.tri(uc)] <- NA
    uc <- data.table::as.data.table(uc, keep.rownames = "PARAMETER")
  } else {uc <- data.frame()}
  GPF <- GPF(filename = filename,
             estimates = estimates,
             uncertainty_correlation = uc)
  if (!is.null(filename))
    export_GPF(GPF = GPF, filename = filename)
  GPF
}
getNamesAllParameters <- function(obj) {
  pgpf <- parse_GPF(obj)
  c(getNamesModelParameters(pgpf),
    getNamesIIVParameters(pgpf),
    getNamesIIVCorrParameters(pgpf),
    getNamesCovariateParameters(pgpf),
    getNamesErrorParameters(pgpf))
}
getNamesModelParameters <- function(obj) {
  pgpf <- parse_GPF(obj)
  if(length(pgpf$p.MODEL) > 0) {
    names(pgpf$p.MODEL)
  } else {
    character(0L)
  }
}
getNamesCovariateParameters <- function(obj) {
  pgpf <- parse_GPF(obj)
  if(length(pgpf$p.COVRT) > 0) {
    names(pgpf$p.COVRT)
  } else {
    character(0L)
  }
}
getNamesCovariates <- function(obj, FLAGunique = TRUE, FLAGparamNames = !FLAGunique) {
  pgpf <- parse_GPF(obj)
  res <- pgpf$p.COVRT.COVRTNAME
  if(FLAGunique) {
    res <- unique(res)
  } else if(FLAGparamNames) {
    names(res) <- pgpf$p.COVRT.PARAMNAME
  }
  res
}
getNamesIIVParameters <- function(obj) {
  pgpf <- parse_GPF(obj)
  if(length(pgpf$p.MODEL.IIV) > 0) {
    paste0("omega(", names(pgpf$p.MODEL.IIV), ")")
  } else {
    character(0)
  }
}
getNamesIIVCorrParameters <- function(obj) {
  pgpf <- parse_GPF(obj)
  if(length(pgpf$p.MODEL.IIVcor) > 0) {
    names(pgpf$p.MODEL.IIVcor)
  } else {
    character(0L)
  }
}
getParamTransformationTypes <- function(obj) {
  pgpf <- specifyParamSampling(obj = obj)
  transfTypes <- character(0L)
  if(length(pgpf$p.MODEL) > 0) {
    transfTypes <- c(transfTypes, pgpf$p.MODEL.TRANSF)
  }
  if(length(pgpf$p.MODEL.IIV) > 0) {
    transfTypes <- c(transfTypes,
                     structure(rep("L", length(pgpf$p.MODEL.IIV)),
                               names = paste0("omega(", names(pgpf$p.MODEL.IIV), ")"))
    )
  }
  if(length(pgpf$p.MODEL.IIVcor) > 0) {
    transfTypes <- c(transfTypes,
                     structure(rep("N", length(pgpf$p.MODEL.IIVcor)),
                               names = names(pgpf$p.MODEL.IIVcor)))
  }
  if(length(pgpf$p.COVRT) > 0) {
    transfTypes <- c(transfTypes, pgpf$p.COVRT.TRANSF)
  }
  if(length(pgpf$p.ERR) > 0) {
    transfTypes <- c(
      transfTypes,
      structure(rep("L", length(pgpf$p.ERR)),
                names = names(pgpf$p.ERR))
    )
  }
  transfTypes
}
getNamesErrorParameters <- function(obj) {
  pgpf <- parse_GPF(obj)
  if(length(pgpf$p.ERR) > 0) {
    names(pgpf$p.ERR)
  } else {
    character(0L)
  }
}
getCovMatrixUncertainty <- function(obj) {
  pgpf <- parse_GPF(obj)
  pgpf$p.UNCERT.COV
}
getCorMatrixUncertainty <- function(obj) {
  pgpf <- parse_GPF(obj)
  pgpf$p.UNCERT.COR
}
getParamEstimates <- function(obj, Npop = 1L) {
  pgpf <- parse_GPF(obj = obj)
  estimateValues <- data.frame(ID.POP = seq_len(Npop))
  if(length(pgpf$p.MODEL) > 0) {
    estimateValues <- cbind(
      estimateValues,
      as.data.frame(as.list(pgpf$p.MODEL), check.names = FALSE)
    )
  }
  if(length(pgpf$p.MODEL.IIV) > 0) {
    estimateValues <- cbind(
      estimateValues,
      as.data.frame(as.list(pgpf$p.MODEL.IIV),
                    col.names = paste0("omega(", names(pgpf$p.MODEL.IIV), ")"),
                    check.names = FALSE)
    )
  }
  if(length(pgpf$p.MODEL.IIVcor) > 0) {
    estimateValues <- cbind(
      estimateValues,
      as.data.frame(as.list(pgpf$p.MODEL.IIVcor), check.names = FALSE)
    )
  }
  if(length(pgpf$p.COVRT) > 0) {
    estimateValues <- cbind(
      estimateValues,
      as.data.frame(as.list(pgpf$p.COVRT), check.names = FALSE)
    )
  }
  if(length(pgpf$p.ERR) > 0) {
    estimateValues <- cbind(
      estimateValues,
      as.data.frame(as.list(pgpf$p.ERR), check.names = FALSE)
    )
  }
  estimateValues
}
getCovMatrixIIV <- function(
  obj,
  iivPopParamValues = getParamEstimates(obj),
  FLAGcheckPDCovMatrix = TRUE,
  FLAGreturnCorrMatrix = FALSE,
  FLAGcheckPDCorrMatrix = FLAGcheckPDCovMatrix) {
  pgpf = parse_GPF(obj)
  names <- c(getNamesIIVParameters(pgpf),
             getNamesIIVCorrParameters(pgpf))
  if(is.data.frame(iivPopParamValues) ||
     (is.matrix(iivPopParamValues) && is.numeric(iivPopParamValues))) {
    if(!all(names %in% colnames(iivPopParamValues))) {
      stopIQR("getCovMatrixIIV:: some cov-parameters are missing in iivPopParamValues: ",
              toString(names[!names %in% colnames(iivPopParamValues)]))
    }
    iivPopParamValues <- unlist(iivPopParamValues[1, c(getNamesIIVParameters(pgpf),
                                                       getNamesIIVCorrParameters(pgpf))])
  } else if(is.vector(iivPopParamValues) && is.numeric(iivPopParamValues)) {
    if(!all(names %in% names(iivPopParamValues))) {
      stopIQR("getCovMatrixIIV:: some cov-parameters are missing in iivPopParamValues: ",
              toString(names[!names %in% names(iivPopParamValues)]))
    }
    iivPopParamValues <- unlist(iivPopParamValues[c(getNamesIIVParameters(pgpf),
                                                    getNamesIIVCorrParameters(pgpf))])
  } else {
    stopIQR("getCovMatrixIIV:: iivPopParamValues should either be a data.frame or a matrix or named vector.")
  }
  corr <- diag(rep(1, length(getNamesIIVParameters(pgpf))))
  dimnames(corr) <- list(getNamesModelParameters(pgpf), getNamesModelParameters(pgpf))
  for (corrXY in getNamesIIVCorrParameters(pgpf)) {
    tmp <- extractParamNamesFromIIVCorrParamName(corrXY)
    corr[tmp[1], tmp[2]] <- corr[tmp[2], tmp[1]] <- iivPopParamValues[corrXY]
  }
  cov <-
    diag(unlist(iivPopParamValues)[paste0("omega(", getNamesModelParameters(pgpf), ")")],
         nrow = length(getNamesModelParameters(pgpf))) %*%
    corr %*%
    diag(unlist(iivPopParamValues)[paste0("omega(", getNamesModelParameters(pgpf), ")")],
         nrow = length(getNamesModelParameters(pgpf)))
  if(FLAGcheckPDCovMatrix) {
    cov <- adjustMatrixToPDMatrix(cov)
  }
  if(is.matrix(cov)) {
    colnames(cov) <- rownames(cov) <- getNamesModelParameters(pgpf)
  }
  if(FLAGreturnCorrMatrix) {
    if(FLAGcheckPDCorrMatrix) {
      if(FLAGcheckPDCovMatrix && is.matrix(cov)) {
        posDiag <- diag(cov) > 0
        if( any(posDiag) ) {
          corr[posDiag, posDiag] <- suppressWarnings( cov2cor(cov[posDiag, posDiag, drop = FALSE]) )
        }
      } else {
        corr <- adjustMatrixToPDMatrix(corr)
      }
    }
    list(cov = cov, corr = corr)
  } else {
    cov
  }
}
#'@export
select_FromGPF <- function(obj, parameters = NULL, covariates = NULL, FLAGdropErrParameters = TRUE, filename = NULL) {
  COV.FORMULA <- PARAMETER_ORIG <- NULL
  gpf <- if(!is_GPF(obj)) {
    GPF(obj)
  } else {
    obj
  }
  if (FLAGdropErrParameters & length(gpf$estimates[TYPE %in% c("ADDITIVE ERROR", "RELATIVE ERROR", "EXPONENTIAL ERROR"), PARAMETER])>0) {
    parDrop <- gpf$estimates[TYPE %in% c("ADDITIVE ERROR", "RELATIVE ERROR", "EXPONENTIAL ERROR"), PARAMETER]
    gpf$estimates <- gpf$estimates[!PARAMETER %in% parDrop]
    parDrop <- intersect(parDrop, names(gpf$uncertainty_correlation)) 
    if (length(parDrop)) {
      gpf$uncertainty_correlation <- gpf$uncertainty_correlation[!PARAMETER %in% parDrop]
      gpf$uncertainty_correlation[, (parDrop) := NULL]
    }
  }
  gpf$estimates[,`:=`(PARAMETER_ORIG = PARAMETER)]
  cov_select <- covariates
  if (!length(cov_select)) {
    cov_select <- grep("^beta_", gpf$estimates$PARAMETER, value = TRUE)
    cov_select <- gsub(".*\\((\\w+)\\)", "\\1", cov_select) 
    cov_select <- gsub("([^_]+).*", "\\1", cov_select) 
    cov_select <- unique(cov_select)
  }
  cov_select <- fill_names(cov_select)
  indPars_select <- parameters
  if (!length(indPars_select)) {
    indPars_select <- grep("^(beta_|corr\\()", gpf$estimates$PARAMETER, value = TRUE, invert = TRUE)
  }
  indPars_select <- fill_names(indPars_select)
  par_regex <- paste0("^(", paste0(indPars_select, collapse = "|"), ")$")
  cov_regex <- paste0("beta_(",paste0(indPars_select, collapse = "|"), ")\\(",
                      "(",paste0(cov_select, collapse = "|"), ")(\\b|_)") 
  cor_regex <- paste0("corr\\(\\b(",paste0(indPars_select, collapse = "|"), ")\\b,\\b(",
                      paste0(indPars_select, collapse = "|"), ")\\b")
  filter_regex <- paste0(c(par_regex, cov_regex, cor_regex), collapse = "|")
  gpf$estimates <- gpf$estimates[grep(filter_regex, PARAMETER)]
  to_replace <- c(cov_select, indPars_select)
  to_replace <- fill_names(to_replace)
  for (.y in names(to_replace))
    gpf$estimates[grep(paste0("(\\b|_)", to_replace[.y], "(\\b|_)"), PARAMETER_ORIG),
                  `:=`(PARAMETER = gsub(paste0("(\\b|_)", to_replace[.y], "(\\b|_)"), paste0("\\1",.y, "\\2"), PARAMETER), 
                       COV.FORMULA   = gsub(paste0("(\\b|_)", to_replace[.y], "(\\b|_)"), paste0("\\1",.y, "\\2"), COV.FORMULA))]
  omega_reg <- paste0("^omega\\((", paste0(indPars_select, collapse = "|"), ")\\)$")
  uc_filter_regex <- paste0(c(par_regex, cov_regex, cor_regex, omega_reg), collapse = "|")
  uc_keep <- grep(uc_filter_regex, gpf$uncertainty_correlation$PARAMETER, value = TRUE)
  gpf$uncertainty_correlation <- gpf$uncertainty_correlation[PARAMETER %in% uc_keep, .SD, .SDcols = uc_keep]
  uc_names <- setNames(nm = names(gpf$uncertainty_correlation))
  for(i in seq_along(uc_names))
    for (.y in names(to_replace))
      uc_names[i] <- gsub(paste0("(\\b|_)", to_replace[.y], "(\\b|_)"), paste0("\\1",.y, "\\2"), uc_names[i])
  data.table::setnames(gpf$uncertainty_correlation, names(uc_names), uc_names)
  gpf$uncertainty_correlation <- data.table(PARAMETER = names(gpf$uncertainty_correlation), gpf$uncertainty_correlation)
  validGPF <- GPF(filename = filename,
                estimates = gpf$estimates,
                uncertainty_correlation = gpf$uncertainty_correlation)
  if (!is.null(filename))
    export_GPF(GPF = validGPF, filename = filename)
  validGPF
}
GPFprojectInfo <- function(projectPath,
                           indPars_select = NULL, 
                           popPars_select = NULL, 
                           cov_select     = NULL  
) {
  list(projectPath     = projectPath,
       indPars_select  = indPars_select,
       popPars_select  = popPars_select,
       cov_select      = cov_select)
}
#'@export
generate_GPFFromProjectInfo <- function(projectInfo, filename = NULL, FLAGdropErrParams = TRUE) {
  .Deprecated("select_FromGPF")
  COV.FORMULA <- PARAMETER_ORIG <- NULL
  xls       <- load_GPF(projectInfo$projectPath)
  estimates <- data.table(xls$estimates)
  uc        <- data.table(xls$uncertainty_correlation)
  if (FLAGdropErrParams & length(estimates[TYPE %in% c("ADDITIVE ERROR", "RELATIVE ERROR", "EXPONENTIAL ERROR"), PARAMETER])>0) {
    parDrop <- estimates[TYPE %in% c("ADDITIVE ERROR", "RELATIVE ERROR", "EXPONENTIAL ERROR"), PARAMETER]
    estimates <- estimates[!PARAMETER %in% parDrop]
    parDrop <- intersect(parDrop, names(uc)) 
    if (length(parDrop)) {
      uc <- uc[!PARAMETER %in% parDrop]
      uc[,(parDrop) := NULL]
    }
  }
  estimates[,`:=`(PARAMETER_ORIG = PARAMETER, COV.FORMULA_ORIG = COV.FORMULA, PROJECTPATH = projectInfo$projectPath)]
  if (!is.null(projectInfo$popPars_select)){
    PARAMETERCOV <- grep("beta_", estimates$PARAMETER_ORIG, value = TRUE)
    check_popPars_covariates <- vapply(projectInfo$popPars_select, function(pp) any(grepl(pp, PARAMETERCOV)), FALSE)
    if (any(check_popPars_covariates)) stopIQR("Copied popPar ", projectInfo$popPars_select[check_popPars_covariates], " is affected by a covariate.\n",
                                               "This functionality is not yet implemented.\n")
  }
  cov_select <- projectInfo$cov_select
  if (!length(cov_select)) {
    cov_select <- grep("^beta_", estimates$PARAMETER, value = TRUE)
    cov_select <- gsub(".*\\((\\w+)\\)", "\\1", cov_select) 
    cov_select <- gsub("([^_]+).*", "\\1", cov_select) 
    cov_select <- unique(cov_select)
  }
  cov_select <- fill_names(cov_select)
  indPars_select <- projectInfo$indPars_select
  if (!length(indPars_select)) {
    indPars_select <- grep("^(beta_|corr\\()", estimates$PARAMETER, value = TRUE, invert = TRUE)
  }
  indPars_select <- fill_names(indPars_select)
  par_regex <- paste0("^(", paste0(indPars_select, collapse = "|"), ")$")
  cov_regex <- paste0("beta_(",paste0(indPars_select, collapse = "|"), ")\\(",
                      "(",paste0(cov_select, collapse = "|"), ")(\\b|_)") 
  cor_regex <- paste0("corr\\(\\b(",paste0(indPars_select, collapse = "|"), ")\\b,\\b(",
                      paste0(indPars_select, collapse = "|"), ")\\b")
  filter_regex <- paste0(c(par_regex, cov_regex, cor_regex), collapse = "|")
  estimates <- estimates[grep(filter_regex, PARAMETER)]
  to_replace <- c(cov_select, indPars_select)
  to_replace <- fill_names(to_replace)
  for (.y in names(to_replace))
    estimates[grep(paste0("(\\b|_)", to_replace[.y], "(\\b|_)"), PARAMETER_ORIG),
              `:=`(PARAMETER = gsub(paste0("(\\b|_)", to_replace[.y], "(\\b|_)"), paste0("\\1",.y, "\\2"), PARAMETER), 
                   COV.FORMULA   = gsub(paste0("(\\b|_)", to_replace[.y], "(\\b|_)"), paste0("\\1",.y, "\\2"), COV.FORMULA))]
  omega_reg <- paste0("^omega\\((", paste0(indPars_select, collapse = "|"), ")\\)$")
  uc_filter_regex <- paste0(c(par_regex, cov_regex, cor_regex, omega_reg), collapse = "|")
  uc_keep <- grep(uc_filter_regex, uc$PARAMETER, value = TRUE)
  uc <- uc[PARAMETER %in% uc_keep, .SD, .SDcols = uc_keep]
  uc_names <- setNames(nm = names(uc))
  for(i in seq_along(uc_names))
    for (.y in names(to_replace))
      uc_names[i] <- gsub(paste0("(\\b|_)", to_replace[.y], "(\\b|_)"), paste0("\\1",.y, "\\2"), uc_names[i])
  data.table::setnames(uc, names(uc_names), uc_names)
  uc <- data.table(PARAMETER = names(uc), uc)
  GPF <- GPF(filename = filename,
             estimates = estimates,
             uncertainty_correlation = uc)
  if (!is.null(filename))
    export_GPF(GPF = GPF, filename = filename)
  GPF
}
#'@importFrom data.table rbindlist as.data.table
combineGPF <- function(GPFlist, filename = NULL){
  parnames <- lapply(GPFlist, function(xls) xls$estimates$PARAMETER)
  parnames <- unlist(parnames)
  dupes <- parnames[duplicated(parnames)]
  if (length(dupes))
    stopIQR("Duplicated parameter names across projects: \033[32m", paste0(dupes, collapse = ","),"\033[39m\n",
            "Please fix this via the *_select arguments in GPFprojectInfo.")
  estimates <- data.table::rbindlist(lapply(GPFlist, function(xls) xls$estimates), use.names = TRUE, fill = TRUE)
  uc <- do.call(blockMatrixDiagonal, lapply(GPFlist, function(xls){
    out           <- as.matrix(data.table(xls$uncertainty_correlation))
    rownames(out) <- out[,"PARAMETER"]
    out           <- out[,(colnames(out) != c("PARAMETER")),drop=FALSE]
    out
  }))
  uc[upper.tri(uc)] <- NA
  uc <- as.data.table(uc, keep.rownames = "PARAMETER")
  GPF <- GPF(filename = filename,
             estimates = estimates,
             uncertainty_correlation = uc)
  if (!is.null(filename))
    export_GPF(GPF = GPF, filename = filename)
  GPF
}
#'@export
generate_GPFFromProjectInfoList <- function(projectInfoList, filename = NULL, FLAGdropErrParams = TRUE) {
  GPFlist <- lapply(projectInfoList, function(p) generate_GPFFromProjectInfo(projectInfo = p, filename = NULL, FLAGdropErrParams = FLAGdropErrParams))
  combineGPF(GPFlist = GPFlist, filename = filename)
}
#'@importFrom data.table data.table
imputeTYPEcol_GPF <- function(estimates) {
  estimates <- data.table::data.table(estimates)
  estimates[,`:=`(TYPE = "MODEL PARAMETER")]
  estimates[grep("^corr", PARAMETER),`:=`(TYPE = "IIV CORRELATION")]
  estimates[grep("^beta_.*\\([^_]+\\)", PARAMETER),`:=`(TYPE = "CONTINUOUS COVARIATE")]
  estimates[grep("^beta_.*\\(.+_.+\\)", PARAMETER),`:=`(TYPE = "CATEGORICAL COVARIATE")]
  estimates[grep("error_PROP", PARAMETER),`:=`(TYPE = "RELATIVE ERROR")]
  estimates[grep("error_ADD", PARAMETER),`:=`(TYPE = "ADDITIVE ERROR")]
  estimates[grep("error_EXP", PARAMETER),`:=`(TYPE = "EXPONENTIAL ERROR")]
  as.data.frame(estimates)
}
specifyParamSampling <- function(obj,
                                 Nsamples    = if(is_IQRnlmeParamSpec(obj)) obj$Nsamples else 1L,
                                 Npop        = if(is_IQRnlmeParamSpec(obj)) obj$Npop else if(FLAG_SAMPLE==2) Nsamples else 1L,
                                 FLAG_SAMPLE = 0,
                                 data        = NULL) {
  if(is.character(obj) || is_GPF(obj)) {
    obj <- parse_GPF(obj)
  }
  force(Nsamples)
  force(Npop)
  if(is_GPF(obj)) {
    class(obj) <- unique(c("IQRnlmeParamSpec", class(obj)))
    obj$Nsamples       <- Nsamples
    obj$Npop           <- Npop
    obj$FLAG_SAMPLE    <- FLAG_SAMPLE
    obj$data           <- data
    obj
  } else {
    stopIQR(
      paste0(
        "Argument obj should be an .xls or .xlsx file or a GPF object, or ",
        "an IQRnlmeParamSpec object, but is of class ",
        toString(class(obj))
      )
    )
  }
}
#'@export
is_IQRnlmeParamSpec <- function(x) {
  inherits(x, "IQRnlmeParamSpec")
}
#'@importFrom stats plogis qlogis
sampleParamFromUncertainty <- function(spec,
                                       Npop = if(is_IQRnlmeParamSpec(spec)) spec$Npop else 1L) {
  spec <- specifyParamSampling(obj = spec, Npop = Npop)
  p.MODEL.NEW                  <- data.frame(matrix(NA, nrow = spec$Npop, ncol = length(spec$p.MODEL)))
  colnames(p.MODEL.NEW)        <- getNamesModelParameters(spec)
  p.MODEL.IIV.NEW              <- data.frame(matrix(NA, nrow = spec$Npop, ncol = length(spec$p.MODEL)))
  colnames(p.MODEL.IIV.NEW)    <- getNamesIIVParameters(spec)
  p.MODEL.IIVcor.NEW           <- data.frame(matrix(NA, nrow = spec$Npop, ncol = length(spec$p.MODEL.IIVcor)))
  colnames(p.MODEL.IIVcor.NEW) <- getNamesIIVCorrParameters(spec)
  p.COVRT.NEW                  <- data.frame(matrix(NA, nrow = spec$Npop, ncol = length(spec$p.COVRT)))
  colnames(p.COVRT.NEW)        <- getNamesCovariateParameters(spec)
  p.ERR.NEW                    <- data.frame(matrix(NA, nrow = spec$Npop, ncol = length(spec$p.ERR)))
  colnames(p.ERR.NEW)          <- getNamesErrorParameters(spec)
  for (k in seq_len(spec$Npop)) {
    validIIVcorMatrix <- FALSE
    trials <- 0
    maxTrials <- 100
    while (!validIIVcorMatrix & trials < maxTrials) {
      trials <- trials+1
      epsilon <- rep(0.0, length(spec$p.UNCERT.SE))
      notZeroEpsilon <- diag(spec$p.UNCERT.COV) > 0
      if(sum(notZeroEpsilon) > 0) {
        epsilon[notZeroEpsilon] <- MASS::mvrnorm(
          n = 1,
          mu = rep(0.0, sum(notZeroEpsilon)),
          Sigma = spec$p.UNCERT.COV[notZeroEpsilon, notZeroEpsilon, drop = FALSE])
      }
      p.MODEL.NEW[k,spec$idx_mpar_norm]    <- spec$p.MODEL[spec$idx_mpar_norm] + epsilon[spec$idx_mpar_norm]
      p.MODEL.NEW[k,spec$idx_mpar_lognorm] <- spec$p.MODEL[spec$idx_mpar_lognorm]*exp(epsilon[spec$idx_mpar_lognorm])
      p.MODEL.NEW[k,spec$idx_mpar_logit]   <- plogis(qlogis(spec$p.MODEL[spec$idx_mpar_logit]) + epsilon[spec$idx_mpar_logit])
      p.MODEL.IIV.NEW[k,] <- spec$p.MODEL.IIV*exp(epsilon[spec$idx_iiv])
      p.MODEL.IIVcor.NEW[k,] <- spec$p.MODEL.IIVcor + epsilon[spec$idx_iivcor]
      if(length(spec$p.COVRT) > 0) {
        p.COVRT.NEW[k,spec$idx_covrt_norm] <-
          spec$p.COVRT[spec$idx_covrt_norm] + epsilon[spec$off_covrt + spec$idx_covrt_norm]
        p.COVRT.NEW[k,spec$idx_covrt_lognorm] <-
          spec$p.COVRT[spec$idx_covrt_lognorm]*exp(epsilon[spec$off_covrt + spec$idx_covrt_lognorm])
        p.COVRT.NEW[k,spec$idx_covrt_logit] <-
          plogis( qlogis(spec$p.COVRT[spec$idx_covrt_logit]) + epsilon[spec$off_covrt + spec$idx_covrt_logit] )
      }
      p.ERR.NEW[k,spec$idx_err_lognorm] <-
        spec$p.ERR[spec$idx_err_lognorm] * exp(epsilon[spec$off_err + spec$idx_err_lognorm])
      listCovCorr <- getCovMatrixIIV(
        spec,
        iivPopParamValues = cbind(p.MODEL.IIV.NEW[k,, drop=FALSE], p.MODEL.IIVcor.NEW[k,, drop = FALSE]),
        FLAGcheckPDCovMatrix = TRUE,
        FLAGreturnCorrMatrix = TRUE,
        FLAGcheckPDCorrMatrix = FALSE)
      corr <- listCovCorr$corr
      cov <- listCovCorr$cov
      if (is.matrix(cov)) {
        cov[abs(cov)<1e-9] <- 0
        eigV <- eigen(cov)$values
        if ( all(eigV >= 0) ) {
          posDiag <- diag(cov) > 0
          if( any(posDiag) ) {
            corr[posDiag, posDiag] <- suppressWarnings( cov2cor(cov[posDiag, posDiag, drop = FALSE]) )
            for (corrName in getNamesIIVCorrParameters(spec)) {
              tmp <- extractParamNamesFromIIVCorrParamName(corrName)
              p.MODEL.IIVcor.NEW[k,corrName] <-  corr[tmp[1], tmp[2]]
            }
          }
          validIIVcorMatrix <- TRUE
        }
      }
    }
    if (!validIIVcorMatrix) {
      stopIQR("Sampling positive definite IIV covariance matrix from uncertainty failed.")
    }
  }
  cbind(
    data.frame(ID.POP = seq_len(spec$Npop)),
    p.MODEL.NEW,
    p.MODEL.IIV.NEW,
    p.MODEL.IIVcor.NEW,
    p.COVRT.NEW,
    p.ERR.NEW
  )
}
#'@importFrom stats rnorm
sampleRandomEffects <- function(spec,
                                iivPopParamValues,
                                Nsamples = if(is_IQRnlmeParamSpec(spec)) spec$Nsamples else 1) {
  spec <- specifyParamSampling(obj = spec,
                               Nsamples = Nsamples)
  list2env(spec, environment())
  Npop <- nrow(iivPopParamValues)
  dfETA           <- data.frame(matrix(NA, nrow = Npop * spec$Nsamples, ncol = 2 + length(spec$p.MODEL)))
  colnames(dfETA) <- c("ID.POP", "ID", getNamesModelParameters(spec))
  dfETA$ID.POP <- rep(iivPopParamValues$ID.POP, each = spec$Nsamples)
  dfETA$ID     <- rep(seq_len(spec$Nsamples), Npop)
  if (length(spec$p.MODEL.IIVcor)==0) {
    matETA <- matrix(rnorm(Npop * spec$Nsamples * length(spec$p.MODEL)),
                     nrow = Npop * spec$Nsamples,
                     ncol = length(spec$p.MODEL))
    for(iPop in seq_len(Npop)) {
      IIV.POP <- as.double(iivPopParamValues[iPop, getNamesIIVParameters(spec)])
      matETA[(iPop - 1)*spec$Nsamples + seq_len(spec$Nsamples), ] <-
        t(apply(matETA[(iPop - 1)*spec$Nsamples + seq_len(spec$Nsamples), , drop = FALSE],
                1,
                function(row) row * IIV.POP))
    }
  } else {
    matETA <- matrix(0.0,
                     nrow = Npop * spec$Nsamples,
                     ncol = length(spec$p.MODEL))
    for(iPop in seq_len(Npop)) {
      IIVcovariance <- getCovMatrixIIV(spec, iivPopParamValues = iivPopParamValues, FLAGcheckPDCovMatrix = FALSE)
      notZeroVariance <- (diag(IIVcovariance) != 0.0)
      if(sum(notZeroVariance) > 0) {
        matETA[(iPop - 1)*spec$Nsamples + seq_len(spec$Nsamples), notZeroVariance] <- MASS::mvrnorm(
          n = spec$Nsamples,
          mu = rep(0.0, sum(notZeroVariance)),
          Sigma = IIVcovariance[notZeroVariance, notZeroVariance, drop = FALSE])
      }
    }
  }
  dfETA[, -(1:2)] <- matETA
  dfETA
}
sampleIDs <- function(data, Nsamples) {
  if(!is.data.frame(data)) {
    stopIQR("Argument data must be a data.frame.")
  }
  if (nrow(data) < Nsamples) {
    sampData <- data[sample(nrow(data), Nsamples, replace=TRUE), , drop=FALSE]
  } else if (nrow(data)==Nsamples){
    sampData <- data
  } else {
    sampData <- data[sample(nrow(data), Nsamples, replace=FALSE), , drop=FALSE]
  }
  if (is.matrix(sampData)) {
    sampData <- as.data.frame(sampData)
  }
  if ("ID" %in% names(sampData)) {
    if("ID0" %in% names(sampData)) {
      stopIQR(paste0(
        "data already has columns ID and ID0. Not overwriting column ID0. ",
        "To avoid this error, please rename column ID0 in the original data."))
    }
    sampData$ID0 <- sampData$ID
  }
  rownames(sampData) <- NULL
  sampData$ID <- seq_len(Nsamples)
  sampData
}
calcTypicalIndParamValues <- function(spec,
                                      referencePopParamValues,
                                      data,
                                      doCartesian = TRUE) {
  if(!is.data.frame(referencePopParamValues)) {
    stopIQR("Argument referencePopParamValues should be a data.frame.")
  }
  if(!is.data.frame(data)) {
    stopIQR("Argument data should be a data.frame.")
  }
  if(!is.logical(doCartesian)) {
    stopIQR("Argument doCartesian should be a logical (TRUE or FALSE).")
  }
  if(doCartesian == FALSE && nrow(data) != nrow(referencePopParamValues)) {
    stopIQR("When doCartesian is set to FALSE datareferencePopParamValues should have the same number of rows.")
  }
  Nsamples <- nrow(data)
  Npop <- nrow(referencePopParamValues)
  spec <- specifyParamSampling(obj = spec, Nsamples = Nsamples)
  dtData <- data.table::as.data.table(data)
  dtRefParValues <- data.table::as.data.table(referencePopParamValues)
  dtTypicalParValues <- if(doCartesian) {
    data.table::rbindlist(
      lapply(
        seq_len(nrow(dtRefParValues)),
        function(iPop) {
          cbind(dtRefParValues[iPop,], dtData)
        })
    )
  } else {
    cbind(dtRefParValues, dtData)
  }
  for (k in seq_along(spec$p.COVRT)) {
    if (spec$p.COVRT.COVRTNAME[k] %in% names(data)) {
      if (spec$p.COVRT.CONTINUOUS[k]) {
        idx_Modify <- rep(TRUE, nrow(dtTypicalParValues))
      } else {
        idx_Modify <- dtTypicalParValues[[ spec$p.COVRT.COVRTNAME[k] ]] == spec$p.COVRT.CATVALUE[k]
      }
      .formulaTextToApply <- spec$p.COVRT.FORM[k] 
      dtTypicalParValues[idx_Modify, eval(parse(text=.formulaTextToApply))]
    } else {
      warningIQR(
        paste0(
          "The covariate '", spec$p.COVRT.COVRTNAME[k],
          "' is not defined in the argument 'data', therefore, it will be ignored.")
      )
    }
  }
  as.data.frame(dtTypicalParValues[, c("ID.POP", "ID", getNamesModelParameters(spec)), with = FALSE])
}
calcIndParamValues <- function(spec,
                               typicalIndParamValues,
                               randomEffects) {
  spec <- specifyParamSampling(obj = spec)
  if(!is.data.frame(typicalIndParamValues)) {
    stopIQR("Argument typicalIndParamValues should be a data.frame.")
  }
  if(!is.data.frame(randomEffects)) {
    stopIQR("Argument randomEffects should be a data.frame.")
  }
  if(!setequal(names(typicalIndParamValues), names(randomEffects))) {
    stopIQR(
      paste0("The data.frame arguments typicalIndParamValues and randomEffects",
             "should have the same columns."))
  }
  if(nrow(typicalIndParamValues) != nrow(randomEffects)) {
    stopIQR(
      paste0("Tahe data.frame arguments typicalIndParamValues and randomEffects",
             "should have the same numbers of rows.")
    )
  }
  indParValuesNormal <- transformParamToNormal(spec, typicalIndParamValues)
  for(name in setdiff(names(indParValuesNormal), c("ID.POP", "ID"))) {
    indParValuesNormal[[name]] <- indParValuesNormal[[name]] + randomEffects[[name]]
  }
  untransformParamFromNormal(spec, indParValuesNormal)
}
transformParamToNormal <- function(spec,
                                   values,
                                   columnNames = setdiff(names(values), c("ID.POP", "ID"))) {
  spec <- specifyParamSampling(obj = spec)
  if(!is.data.frame(values)) {
    stopIQR(paste0("Argument values should be a data.frame."))
  }
  TRANSF_LETTER <- getParamTransformationTypes(spec)
  TRANSF_FUN <- list("N" = identity,
                     "L" = log,
                     "G" = qlogis
  )
  if(length(setdiff(columnNames, names(TRANSF_LETTER)))) {
    stopIQR(
      paste0(
        "All columns in values should be among ",
        toString(names(TRANSF_LETTER)), " but the following are not: ",
        toString(setdiff(columnNames, names(TRANSF_LETTER)))))
  }
  for(name in columnNames) {
    values[[name]] <- TRANSF_FUN[[TRANSF_LETTER[name]]](values[[name]])
  }
  values
}
untransformParamFromNormal <- function(spec,
                                       values,
                                       columnNames = setdiff(names(values), c("ID.POP", "ID"))) {
  spec <- specifyParamSampling(obj = spec)
  if(!is.data.frame(values)) {
    stopIQR(paste0("Argument values should be a data.frame."))
  }
  TRANSF_LETTER <- getParamTransformationTypes(spec)
  UNTRANSF_FUN <- list("N" = identity,
                       "L" = exp,
                       "G" = plogis
  )
  if(length(setdiff(columnNames, names(TRANSF_LETTER)))) {
    stopIQR(
      paste0(
        "All columns in values should be among ",
        toString(names(TRANSF_LETTER)), " but the following are not: ",
        toString(setdiff(columnNames, names(TRANSF_LETTER)))))
  }
  for(name in columnNames) {
    values[[name]] <- UNTRANSF_FUN[[TRANSF_LETTER[name]]](values[[name]])
  }
  values
}
#'@export
sampleIndParamValues <- function(spec,
                                 data        = NULL,
                                 Nsamples    = 1,
                                 Npop        = if(FLAG_SAMPLE==2) Nsamples else 1L,
                                 FLAG_SAMPLE = 0) {
  spec <- specifyParamSampling(obj      = spec,
                               data     = data,
                               Nsamples = Nsamples,
                               Npop     = Npop,
                               FLAG_SAMPLE = FLAG_SAMPLE)
  sampledData    <- NULL
  popParamValues <- NULL
  typicalIndParamValues <- NULL
  randomEffects         <- NULL
  indParamValues        <- NULL
  if (FLAG_SAMPLE==0 || FLAG_SAMPLE==7){
    popParamValues <- getParamEstimates(spec)
    sampledData <- if(!is.null(data)) sampleIDs(data, spec$Nsamples) else NULL
    typicalIndParamValues <- if(!is.null(data)) {
      calcTypicalIndParamValues(spec, popParamValues, sampledData)
    } else {
      cbind(ID.POP = popParamValues[, "ID.POP"],
            data.frame(ID = seq_len(spec$Nsamples), row.names = NULL),
            popParamValues[, getNamesModelParameters(spec), drop = FALSE])
    }
    randomEffects <- sampleRandomEffects(spec, popParamValues)
    indParamValues <- calcIndParamValues(spec, typicalIndParamValues, randomEffects)
  }
  if (FLAG_SAMPLE==1 || FLAG_SAMPLE==8){
    popParamValues <- sampleParamFromUncertainty(spec, Npop = 1L)
    sampledData <- if(!is.null(data)) sampleIDs(data, spec$Nsamples) else NULL
    typicalIndParamValues <- if(!is.null(data)) {
      calcTypicalIndParamValues(spec, popParamValues, sampledData)
    } else {
      cbind(ID.POP = popParamValues[, "ID.POP"],
            data.frame(ID = seq_len(spec$Nsamples), row.names = NULL), 
            popParamValues[, getNamesModelParameters(spec), drop = FALSE])
    }
    randomEffects <- sampleRandomEffects(spec, popParamValues)
    indParamValues <- calcIndParamValues(spec, typicalIndParamValues, randomEffects)
  }
  if (FLAG_SAMPLE==2){
    popParamValues <- sampleParamFromUncertainty(spec, Npop = spec$Npop)
    sampledData <- NULL
    typicalIndParamValues <- NULL
    randomEffects <- NULL
    indParamValues <- NULL
  }
  if (FLAG_SAMPLE==3){
    popParamValues <- getParamEstimates(spec)
    sampledData <- if(!is.null(data)) sampleIDs(data, spec$Nsamples) else NULL
    typicalIndParamValues <- if(!is.null(data)) {
      calcTypicalIndParamValues(spec, popParamValues, sampledData)
    } else {
      cbind(ID.POP = popParamValues[, "ID.POP"],
            data.frame(ID = seq_len(spec$Nsamples), row.names = NULL),
            popParamValues[, getNamesModelParameters(spec), drop = FALSE])
    }
    randomEffects <- NULL
    indParamValues <- NULL
  }
  if (FLAG_SAMPLE==4){
    popParamValues <- sampleParamFromUncertainty(spec, Npop = 1L)
    sampledData <- if(!is.null(data)) sampleIDs(data, spec$Nsamples) else NULL
    typicalIndParamValues <- if(!is.null(data)) {
      calcTypicalIndParamValues(spec, popParamValues, sampledData)
    } else {
      cbind(ID.POP = popParamValues[, "ID.POP"],
            data.frame(ID = seq_len(spec$Nsamples), row.names = NULL),
            popParamValues[, getNamesModelParameters(spec), drop = FALSE])
    }
    randomEffects <- NULL
    indParamValues <- NULL
  }
  if (FLAG_SAMPLE==5){
    popParamValues <- getParamEstimates(spec)
    sampledData <- if(!is.null(data)) sampleIDs(data, spec$Nsamples) else NULL
    typicalIndParamValues <- if(!is.null(data)) {
      calcTypicalIndParamValues(spec, popParamValues, sampledData)
    } else {
      cbind(ID.POP = popParamValues[, "ID.POP"],
            data.frame(ID = seq_len(spec$Nsamples), row.names = NULL),
            popParamValues[, getNamesModelParameters(spec), drop = FALSE])
    }
    randomEffects <- sampleRandomEffects(spec, popParamValues)
    indParamValues <- calcIndParamValues(spec, typicalIndParamValues, randomEffects)
  }
  if (FLAG_SAMPLE==6){
    popParamValues <- sampleParamFromUncertainty(spec, Npop = 1L)
    sampledData <- if(!is.null(data)) sampleIDs(data, spec$Nsamples) else NULL
    typicalIndParamValues <- if(!is.null(data)) {
      calcTypicalIndParamValues(spec, popParamValues, sampledData)
    } else {
      cbind(ID.POP = popParamValues[, "ID.POP"],
            data.frame(ID = seq_len(spec$Nsamples), row.names = NULL),
            popParamValues[, getNamesModelParameters(spec), drop = FALSE])
    }
    randomEffects <- sampleRandomEffects(spec, popParamValues)
    indParamValues <- calcIndParamValues(spec, typicalIndParamValues, randomEffects)
  }
  if (FLAG_SAMPLE==7){
    stopIQR("sampleIndParamValues: FLAG_SAMPLE=7 not supported since post-hoc ETAs are not available in the GPF.")
  }
  if (FLAG_SAMPLE==8){
    stopIQR("sampleIndParamValues: FLAG_SAMPLE=78 not supported since post-hoc ETAs are not available in the GPF.")
  }
  if(getOption("debug.sample_MMVmalariaFunction", FALSE)) {
    out <- c(out, as.list(environment()))
  } else {
    out <- list(sampledData           = sampledData,
                popParamValues        = popParamValues,
                typicalIndParamValues = typicalIndParamValues,
                randomEffects         = randomEffects,
                indParamValues        = indParamValues,
                FLAG_SAMPLE           = FLAG_SAMPLE,
                Nsamples              = spec$Nsamples)
  }
  return(out)
}
#'@importFrom fpc bhattacharyya.dist
#'@importFrom fpc bhattacharyya.dist
#'@importFrom utils combn
#'@importFrom stats cov t.test
detectSampleDiscrepancy <- function(
  obj,
  spec = specifyParamSampling(obj),
  testSample = sampleParamFromUncertainty(spec, Npop = Npop*Ntests),
  targetMuNormal = unlist(transformParamToNormal(spec, getParamEstimates(spec))[1, getNamesAllParameters(spec)]),
  targetSigmaNormal = getCovMatrixUncertainty(spec),
  targetSample = untransformParamFromNormal(
    spec, as.data.frame(MASS::mvrnorm(
      Npop * Ntests,
      mu = targetMuNormal,
      Sigma = targetSigmaNormal))),
  Npop = 200, Ntests = 5,
  tAlpha = 0.01,
  FLAGverbose = FALSE) {
  Sample <- estimatedValue <- textPVal <- Value1 <- Value2 <-
    if(!is_IQRnlmeParamSpec(spec)) {
      stopIQR("detectSampleDiscrepancy:: spec should be a IQRnlmeParamSpec object.")
    }
  if(!(
    is.vector(targetMuNormal) && is.numeric(targetMuNormal) &&
    is.matrix(targetSigmaNormal) && is.numeric(targetSigmaNormal) &&
    ncol(targetSigmaNormal) == nrow(targetSigmaNormal) &&
    ncol(targetSigmaNormal) == length(targetMuNormal) &&
    identical(names(targetMuNormal), colnames(targetSigmaNormal)) &&
    identical(names(targetMuNormal), rownames(targetSigmaNormal)) ) ) {
    stopIQR("detectSampleDiscrepancy:: targetMuNormal should be a named numeric vector, targetSigmaNormal should be square numeric matrix",
            " of dimension length(targetMuNormal) and the names of targetMuNormal should be identical to the row- and column-names in targetSigmaNormal.")
  }
  namesCommon <- setdiff(intersect(colnames(testSample), colnames(targetSample)), c("ID.POP", "ID"))
  if(!all(namesCommon %in% colnames(targetSigmaNormal))) {
    warningIQR("detectSampleDiscrepancy:: some of the column names in testSample and targetSample not found in colnames(targetSigmaNormal):",
               toString(namesCommon[!(namesCommon %in% colnames(targetSigmaNormal))]))
  }
  if(!(is.data.frame(testSample) && is.data.frame(targetSample) && nrow(testSample) == nrow(targetSample))) {
    stopIQR("detectSampleDiscrepancy:: testSample and targetSample should be data.frame's of the same number of rows.")
  }
  names <- intersect(namesCommon, colnames(targetSigmaNormal))
  if(!all(sapply(names, function(n) is.numeric(testSample[[n]]) && is.numeric(targetSample[[n]])))) {
    stopIQR("detectSampleDiscrepancy:: found non-numeric parameter columns in testSample and/or targetSample:",
            toString(names[!sapply(names, function(n) is.numeric(testSample[[n]]) && is.numeric(targetSample[[n]]))]))
  }
  namesConst <- intersect(colnames(targetSigmaNormal)[which(diag(targetSigmaNormal) == 0)], names)
  namesVar <- setdiff(names, namesConst)
  namesVarPairs <- combn(namesVar, 2)
  Npop <- nrow(testSample) %/% Ntests
  idx <- seq_len(Npop * Ntests)
  listIdxChunks <- split(idx, ceiling(idx/Npop))
  if(FLAGverbose) {
    cat("detectSampleDiscrepancy: Checking parameters\n",
        "constant:", toString(namesConst), ";\n",
        "variable:", toString(namesVar), ";\n",
        length(namesVarPairs), "variable pairs;\n",
        "Npop=", Npop, ";\n",
        "Ntests=", Ntests, ";\n",
        "tAlpha=", tAlpha, ".\n")
  }
  sampBoth <- do.call(
    rbind,
    c(lapply(names(testSample[, names, drop=FALSE]), function(name) {
      data.frame(Parameter = name, Sample = "test", Value = testSample[[name]])
    }),
    lapply(names(targetSample[, names, drop=FALSE]), function(name) {
      data.frame(Parameter = name, Sample = "target", Value = targetSample[[name]])
    })
    ))
  calcParamBhattacharyyaDist <- function(samp, paramNames, FLAGTransformToNormal = TRUE) {
    if(FLAGTransformToNormal) {
      sampNormal <- transformParamToNormal(spec, samp[, paramNames, drop = FALSE])
    } else {
      sampNormal <- samp[, paramNames, drop = FALSE]
    }
    muSamp <- colMeans(sampNormal)
    SigmaSamp <- cov(sampNormal)
    b <- try(fpc::bhattacharyya.dist(
      muSamp,
      targetMuNormal[paramNames],
      SigmaSamp,
      targetSigmaNormal[paramNames, paramNames, drop = FALSE]),
      silent = TRUE)
    b
  }
  listBSingleParams <- sapply(namesVar, function(name) {
    sapply(listIdxChunks, function(idx) {
      c(
        btestSample = calcParamBhattacharyyaDist(testSample[idx,], name),
        btargetSample = calcParamBhattacharyyaDist(targetSample[idx,], name)
      )
    })
  }, USE.NAMES = TRUE, simplify = FALSE)
  pValsBSingleParams <- sapply(names(listBSingleParams), function(name) {
    tt <- try(t.test(listBSingleParams[[name]][1,], listBSingleParams[[name]][2, ]), silent = TRUE)
    if(!inherits(tt, "try-error")) {
      tt$p.value
    } else {
      NA_real_
    }
  }, USE.NAMES = TRUE, simplify = TRUE)
  detectedSingleParams <- names(pValsBSingleParams)[!is.na(pValsBSingleParams) & pValsBSingleParams < tAlpha/length(pValsBSingleParams)]
  if(length(detectedSingleParams) > 0) {
    histogramsDetectedSingleParams <- IQRggplot(
      data = sampBoth[sampBoth$Parameter %in% detectedSingleParams,]) +
      ggplot2::geom_histogram(
        ggplot2::aes(x = Value, colour = Sample, fill = Sample),
        alpha=0.2, position="identity", bins = 50) +
      ggplot2::geom_vline(
        data = data.frame(
          Parameter = detectedSingleParams,
          estimatedValue = t(getParamEstimates(spec))[detectedSingleParams,]
        ),
        ggplot2::aes(xintercept = estimatedValue)) +
      ggplot2::geom_label(
        data = data.frame(
          Parameter = detectedSingleParams,
          textPVal = paste0("p=", format.pval(pValsBSingleParams[detectedSingleParams], digits = 3))),
        ggplot2::aes(label = textPVal, x = Inf, y = Inf),
        label.size = 0,
        hjust = 1, vjust = 1) +
      ggplot2::xlab(NULL) +
      ggplot2::facet_wrap(ggplot2::vars(Parameter))
  } else {
    histogramsDetectedSingleParams <- NULL
  }
  listBPairParams <- list()
  namePairs <- combn(namesVar, 2)
  for(iPair in seq_len(ncol(namePairs))) {
    listBPairParams[[paste0(namePairs[1,iPair], ";", namePairs[2,iPair])]] <-
      sapply(listIdxChunks, function(idx) {
        c(
          btestSample = calcParamBhattacharyyaDist(testSample[idx,], namePairs[, iPair]),
          btargetSample = calcParamBhattacharyyaDist(targetSample[idx,], namePairs[, iPair])
        )
      })
  }
  pValsBPairParams <- sapply(names(listBPairParams), function(name) {
    tt <- try(t.test(listBPairParams[[name]][1,], listBPairParams[[name]][2, ]), silent = TRUE)
    if(!inherits(tt, "try-error")) {
      tt$p.value
    } else {
      NA_real_
    }
  }, USE.NAMES = TRUE, simplify = TRUE)
  detectedPairParams <- names(pValsBPairParams)[!is.na(pValsBPairParams) & pValsBPairParams < tAlpha/length(pValsBPairParams)]
  if(length(detectedPairParams) > 0) {
    dataForDensplots <- data.table::rbindlist(lapply(
      detectedPairParams, function(namePair) {
        paramNames <- strsplit(namePair, split = ";")[[1]]
        data.table::data.table(
          Value1 = c(testSample[[paramNames[1]]], targetSample[[paramNames[1]]]),
          Value2 = c(testSample[[paramNames[2]]], targetSample[[paramNames[2]]]),
          Param1 = paramNames[1],
          Param2 = paramNames[2],
          textPVal = c(paste0("p=", format.pval(pValsBPairParams[namePair], digits = 3)),
                       rep(NA_character_, nrow(testSample) + nrow(targetSample) - 1L)),
          Sample = c(rep("test", nrow(testSample)), rep("target", nrow(targetSample)))
        )
      }))
    densplotsDetectedPairParams <- IQRggplot(data = dataForDensplots) +
      ggplot2::geom_density_2d(
        ggplot2::aes(x = Value1, y = Value2, colour = Sample),
        position="identity", bins = 5) +
      ggplot2::geom_text(ggplot2::aes(label = textPVal, x = Inf, y = Inf), hjust = 1, vjust = 1) +
      ggplot2::xlab(NULL) + ggplot2::ylab(NULL) +
      ggplot2::facet_grid(Param2~Param1, scales = "free")
  } else {
    densplotsDetectedPairParams <- NULL
  }
  list(
    names = names,
    namesConst = namesConst,
    namesVar = namesVar,
    namesVarPairs = namesVarPairs,
    tAlpha = tAlpha,
    testSample = testSample,
    targetSample = targetSample,
    targetMuNormal = targetMuNormal,
    targetSigmaNormal = targetSigmaNormal,
    listBSingleParams = listBSingleParams,
    pValsBSingleParams = pValsBSingleParams,
    detectedSingleParams = detectedSingleParams,
    NApValsSingleParms = names(pValsBSingleParams)[is.na(pValsBSingleParams)],
    histogramsDetectedSingleParams = histogramsDetectedSingleParams,
    listBPairParams = listBPairParams,
    pValsBPairParams = pValsBPairParams,
    detectedPairParams = detectedPairParams,
    NApValsPairParms = names(pValsBPairParams)[is.na(pValsBPairParams)],
    densplotsDetectedPairParams = densplotsDetectedPairParams
  )
}
adjustMatrixToPDMatrix <- function(x,
                                   corr = FALSE) {
  X__ <- x
  e__ <- eigen(X__)
  eV__ <- e__$values
  if (min(eV__) > 0) return(X__)
  if (min(eV__) < -1e-3) {
    return("failed")
  }
  eV__[eV__<0] <- 0
  Xout__ <- e__$vectors %*% diag(eV__) %*% ginv(e__$vectors)
  if (corr) diag(Xout__) <- 1
  return(Xout__)
}
extractParamNamesFromIIVCorrParamName <- function(corrString) {
  namesSepComma <- gsub("corr(", "", gsub(")$", "", corrString), fixed = TRUE)
  parnames      <- aux_explode(namesSepComma)
  parnames
}
fill_names <- function(nm) {
  if (!length(names(nm))) nm <- setNames(nm = nm)
  names(nm)[nchar(names(nm)) == 0] <- nm[nchar(names(nm)) == 0]
  nm
}
#'@importFrom data.table data.table rbindlist
#'@importFrom stats cov2cor
addIIVCov_toGPF <- function(iivCOV, gpf){
  iivMAT <- as.matrix(iivCOV, rownames = "PARAMETER")
  iivCOV <- data.table(PARAMETER = rownames(iivMAT), IIV = sqrt(diag(iivMAT)))
  icorr <- cov2cor(iivMAT)
  icorr <- icorr[lower.tri(icorr)]
  corrnm <- outer(rownames(iivMAT), colnames(iivMAT), paste, sep = ",")
  corrnm <- paste0("corr(", corrnm[lower.tri(corrnm)], ")")
  dcorr <- data.table(PARAMETER = corrnm, VALUE = icorr)
  iivCOV <- data.table::rbindlist(list(iivCOV, dcorr), use.names = TRUE, fill = TRUE)
  iivCOV[,`:=`(PARAMETER = gsub("n", "tv", PARAMETER))]
  iivCOV <- split(iivCOV, is.na(iivCOV$IIV))
  icorr <- iivCOV$`TRUE`
  icorr[,`:=`(IIV = NULL)]
  icorr[,`:=`(TYPE = "IIV CORRELATION",
              FORMULA = "",
              NAME = "",
              REFERENCE = "")]
  iivCOV <- iivCOV$`FALSE`
  iivCOV[,`:=`(VALUE = NULL)]
  estimates <- data.table(gpf$estimates)
  estimates[,`:=`(IIV = NULL)]
  estimates <- data.table::rbindlist(list(estimates, icorr), use.names = TRUE, fill = TRUE)
  estimates <- iivCOV[estimates, on = c("PARAMETER")]
  gpf$estimates <- as.data.frame(estimates)
  gpf
}
blockMatrixDiagonal <- function(...){
  matrixList<-list(...)
  if (!all(vapply(matrixList, function(x) dim(x)[1] == dim(x)[2], TRUE)))
    stopIQR("Not all matrices supplied are square-matrices")
  rownm_exist <- vapply(matrixList, function(x) is.null(rownames(x)), FALSE)
  colnm_exist <- vapply(matrixList, function(x) is.null(colnames(x)), FALSE)
  all_or_none <- function(x) all(x) | !any(x)
  if (!all_or_none(rownm_exist)) stopIQR("Either all matrices or no matrix can have rownames")
  if (!all_or_none(colnm_exist)) stopIQR("Either all matrices or no matrix can have colnames")
  dimensions <- vapply(matrixList,FUN=function(x) dim(x)[1], 1)
  finalDimension<-sum(dimensions)
  finalMatrix<-matrix(0,nrow=finalDimension,ncol=finalDimension)
  index<-1
  for(k in 1:length(dimensions)){
    finalMatrix[index:(index+dimensions[k]-1),index:(index+dimensions[k]-1)]<-matrixList[[k]]
    index<-index+dimensions[k]
  }
  finalMatrix <- `rownames<-`(finalMatrix, do.call(c, lapply(matrixList, rownames)))
  finalMatrix <- `colnames<-`(finalMatrix, do.call(c, lapply(matrixList, colnames)))
  finalMatrix
}
#'@export
bootstrap_IQRnlmeProject <- function(projectPath,
                                    bootstrapPath = 'bootstrap',
                                    Nsamples = 200,
                                    group = NULL,
                                    FLAGanalysisOnly = FALSE,
                                    FLAGgenerateModelsOnly = FALSE,
                                    Nparallel = 1,
                                    ncores = 1,
                                    SIGDIG = 4,
                                    FLAGreturnOutput = FALSE,
                                    FLAGremoveRESULTSORIG = FALSE) {
  if (!is_IQRnlmeProject(projectPath))
    stopIQR("Provided 'projectPath' does not point to an NLME project")
  projectHeader__ <- parseNLMEprojectHeader(projectPath)
  TOOL__          <- projectHeader__$TOOL
  if (!FLAGanalysisOnly) {
    aux_rmdir(bootstrapPath)
    aux_mkdir(bootstrapPath)
    duplicate_IQRnlmeProject(projectPath,paste0(bootstrapPath,"/TEMPLATE"))
    projectHeaderTemplate__ <- parseNLMEprojectHeader(paste0(bootstrapPath,"/TEMPLATE"))
    rmFiles__ <- list.files(paste0(bootstrapPath,"/TEMPLATE"),pattern = "*.pdf")
    for (k__ in seq(rmFiles__)) {
      unlink(paste0(bootstrapPath,"/TEMPLATE/",rmFiles__[k__]))
    }
    aux_rmdir(paste0(bootstrapPath,"/TEMPLATE/RESULTS"))
    aux_mkdir(paste0(paste0(bootstrapPath,"/TEMPLATE"),"/RESULTS"))
    aux_rmdir(paste0(bootstrapPath,"/TEMPLATE/RESULTSORIG"))
    aux_mkdir(paste0(paste0(bootstrapPath,"/TEMPLATE"),"/RESULTSORIG"))
    unlink(paste0(bootstrapPath,"/TEMPLATE/project_parameters_table.txt"))
    unlink(paste0(bootstrapPath,"/TEMPLATE/project_parameters_table.txt.log"))
    file__ <- NULL
    if (TOOL__ == "MONOLIX") {
      file__ <- "project.mlxtran"
    }
    if (TOOL__ == "NONMEM") {
      file__ <- "project.nmctl"
    }
    if (TOOL__ == "NLMIXR") {
      file__ <- "project_NLMIXR.R"
    }
    if (is.null(file__)) stopIQR("Unknown NLME project")
    content__ <- aux_fileread(paste0(bootstrapPath,"/TEMPLATE/",file__))
    content__ <- aux_strrep(content__,projectHeaderTemplate__$DATA,'./data.csv')
    IQRoutputFile(content__,paste0(bootstrapPath,"/TEMPLATE/",file__))
    oldpath__ <- getwd()
    setwd(projectPath)
    dataCSV__ <- IQRloadCSVdata(projectHeader__$DATA)
    setwd(oldpath__)
    if (!is.null(group)) {
      if (!all(group %in% names(dataCSV__)))
        stopIQR('The specified "group" element(s) is(are) not present as column in the dataset.')
    }
    FLAGaddedGroupCol__ <- FALSE
    if (length(group) > 1) {
      stratColName__ <- paste0(group,collapse = "_")
      stratColContent__ <- do.call(function(...) paste(..., sep = "_"), dataCSV__[, group])
      dataCSV__[[stratColName__]] <- stratColContent__
      group <- stratColName__
      FLAGaddedGroupCol__ <- TRUE
    }
    oldpath__ <- getwd()
    setwd(paste0(bootstrapPath, '/TEMPLATE'))
    for (k__ in 1:Nsamples) {
      modelpath__ <- sprintf('../MODEL_%s',aux_preFillChar(k__,nchar(as.character(Nsamples)),'0'))
      aux_mkdir(modelpath__)
      file.copy(from=".", to=modelpath__,recursive=TRUE)
      if (is.null(group)) {
        allIDs__ <- unique(dataCSV__$ID)
        sampledIDs__ <- sample(allIDs__,size=length(allIDs__),replace=TRUE)
        splitData__ <- split(dataCSV__,dataCSV__$ID)
        dataNew__ <- do.call(rbind,lapply(seq_along(sampledIDs__), function (x__) {
          datak__ <- splitData__[[as.character(sampledIDs__[x__])]]
          datak__$ID <- x__
          datak__
        }))
      } else {
        ID_GROUP__ <- unique(dataCSV__[,c("ID",group)])
        categories__ <- unique(ID_GROUP__[,2])
        Norig__ <- sapply(categories__,function(x__) sum(ID_GROUP__[,2]==x__))
        Nsamples_Group__ <- round(Norig__/sum(Norig__)*nrow(ID_GROUP__))
        offsetID__ <- 0
        dataNew__ <- do.call(rbind,lapply(seq_along(categories__), function (kcat__) {
          cat__ <- categories__[kcat__]
          IDs_group__ <- ID_GROUP__$ID[ID_GROUP__[,2]==cat__]
          if (length(IDs_group__) > 1) {
            sampledIDs_group__ <- sample(IDs_group__,size=Nsamples_Group__[kcat__],replace=TRUE)
          } else {
            sampledIDs_group__ <- IDs_group__
          }
          dataGroup__ <- dataCSV__[dataCSV__[[group]]==cat__,]
          splitData_group__ <- split(dataGroup__,dataGroup__$ID)
          dataNew_group__ <- do.call(rbind,lapply(seq_along(sampledIDs_group__), function (x__) {
            datak__ <- splitData_group__[[as.character(sampledIDs_group__[x__])]]
            datak__$ID <- x__
            datak__
          }))
          dataNew_group__$ID <- dataNew_group__$ID + offsetID__
          offsetID__ <<- offsetID__ + length(unique(dataNew_group__$ID))
          dataNew_group__
        }))
      }
      if (FLAGaddedGroupCol__) {
        dataNew__[[group]] <- NULL
      }
      IQRsaveCSVdata(dataNew__,paste0(modelpath__, '/data.csv'))
    }
    setwd(oldpath__)
    aux_rmdir(paste0(bootstrapPath, '/TEMPLATE'))
    if (!FLAGgenerateModelsOnly) {
      run_IQRnlmeProjectMulti(projectPath=as_IQRnlmeProjectMulti(bootstrapPath),
                              pathname=bootstrapPath,
                              ncores=ncores,
                              Nparallel=Nparallel,
                              FLAGgof=FALSE,
                              FLAGremoveRESULTSORIG = FLAGremoveRESULTSORIG)
    }
  }
  if (!FLAGgenerateModelsOnly) {
    REFERENCE__           <- parseNLMEresults(projectPath)
    fef_names__           <- REFERENCE__$rawParameterInfo$fixedEffects$names
    ref_names__           <- REFERENCE__$rawParameterInfo$randomEffects$names
    cor_names__           <- REFERENCE__$rawParameterInfo$correlation$names
    cov_names__           <- REFERENCE__$rawParameterInfo$covariate$names
    err_names__           <- REFERENCE__$rawParameterInfo$errorParameter$names
    fef_value_nominal__   <- REFERENCE__$rawParameterInfo$fixedEffects$values
    ref_value_nominal__   <- REFERENCE__$rawParameterInfo$randomEffects$values
    cor_value_nominal__   <- REFERENCE__$rawParameterInfo$correlation$values
    cov_value_nominal__   <- REFERENCE__$rawParameterInfo$covariate$values
    err_value_nominal__   <- REFERENCE__$rawParameterInfo$errorParameter$values
    fef_stderr_nominal__  <- REFERENCE__$rawParameterInfo$fixedEffects$stderr
    ref_stderr_nominal__  <- REFERENCE__$rawParameterInfo$randomEffects$stderr
    cor_stderr_nominal__  <- REFERENCE__$rawParameterInfo$correlation$stderr
    cov_stderr_nominal__  <- REFERENCE__$rawParameterInfo$covariate$stderr
    err_stderr_nominal__  <- REFERENCE__$rawParameterInfo$errorParameter$stderr
    RESULTS__             <- parseSelectedProjectFolderResults(as_IQRnlmeProjectMulti(bootstrapPath))
    fef_value_resampled__ <- matrix(NA,nrow=length(RESULTS__),ncol=length(fef_value_nominal__))
    ref_value_resampled__ <- matrix(NA,nrow=length(RESULTS__),ncol=length(ref_value_nominal__))
    cor_value_resampled__ <- matrix(NA,nrow=length(RESULTS__),ncol=length(cor_value_nominal__))
    cov_value_resampled__ <- matrix(NA,nrow=length(RESULTS__),ncol=length(cov_value_nominal__))
    err_value_resampled__ <- matrix(NA,nrow=length(RESULTS__),ncol=length(err_value_nominal__))
    dummy__ <- lapply(seq_along(RESULTS__), function (kk__) {
      x__ <- RESULTS__[[kk__]]
      ri__ <- x__$rawParameterInfo
      if (!is.null(ri__)) {
        if (!is.null(ri__$fixedEffects)) fef_value_resampled__[kk__,] <<- ri__$fixedEffects$values
        if (!is.null(ri__$randomEffects)) ref_value_resampled__[kk__,] <<- ri__$randomEffects$values
        if (!is.null(ri__$correlation)) cor_value_resampled__[kk__,] <<- ri__$correlation$values
        if (!is.null(ri__$covariate)) cov_value_resampled__[kk__,] <<- ri__$covariate$values
        if (!is.null(ri__$errorParameter)) err_value_resampled__[kk__,] <<- ri__$errorParameter$values
      }
    })
    ix_not_crashed        <- sapply(RESULTS__, function(xxx__) !is.na(xxx__$OBJ))
    fef_value_resampled__  <- fef_value_resampled__[ix_not_crashed,]
    ref_value_resampled__  <- ref_value_resampled__[ix_not_crashed,]
    cor_value_resampled__  <- cor_value_resampled__[ix_not_crashed,]
    cov_value_resampled__  <- cov_value_resampled__[ix_not_crashed,]
    err_value_resampled__  <- err_value_resampled__[ix_not_crashed,]
    NSAMPLES_NOT_CRASHED__ <- nrow(fef_value_resampled__)
    df_fef__  <- as.data.frame(fef_value_resampled__)
    names(df_fef__) <- fef_names__
    df_ref__  <- as.data.frame(ref_value_resampled__)
    names(df_ref__) <- ref_names__
    df_cor__  <- as.data.frame(cor_value_resampled__)
    names(df_cor__) <- cor_names__
    df_cov__  <- as.data.frame(cov_value_resampled__)
    names(df_cov__) <- cov_names__
    df_err__  <- as.data.frame(err_value_resampled__)
    names(df_err__) <- err_names__
    dataPlot__ <- data.frame()
    if (ncol(df_fef__) > 0) {
      dataPlotk__ <- cbind(PARAM = "Fixed Effects",
                           tidyr::gather(df_fef__,NAME,VALUE),
                           NRPARAM = ncol(df_fef__))
      dataPlot__ <- rbind(dataPlot__,dataPlotk__)
    }
    if (ncol(df_ref__) > 0) {
      dataPlotk__ <- cbind(PARAM = "Random Effects",
                           tidyr::gather(df_ref__,NAME,VALUE),
                           NRPARAM = ncol(df_ref__))
      dataPlot__ <- rbind(dataPlot__,dataPlotk__)
    }
    if (ncol(df_cor__) > 0) {
      dataPlotk__ <- cbind(PARAM = "Correlations",
                           tidyr::gather(df_cor__,NAME,VALUE),
                           NRPARAM = ncol(df_cor__))
      dataPlot__ <- rbind(dataPlot__,dataPlotk__)
    }
    if (ncol(df_cov__) > 0) {
      dataPlotk__ <- cbind(PARAM = "Covariates",
                           tidyr::gather(df_cov__,NAME,VALUE),
                           NRPARAM = ncol(df_cov__))
      dataPlot__ <- rbind(dataPlot__,dataPlotk__)
    }
    if (ncol(df_err__) > 0) {
      dataPlotk__ <- cbind(PARAM = "Error Model",
                           tidyr::gather(df_err__,NAME,VALUE),
                           NRPARAM = ncol(df_err__))
      dataPlot__ <- rbind(dataPlot__,dataPlotk__)
    }
    dataPlot__ <- do.call(rbind,lapply(split(dataPlot__,dataPlot__$PARAM), function (aa__) {
      do.call(rbind,lapply(split(aa__,aa__$NAME), function (bb__) {
        bb__$MEDIAN <- stats::median(bb__$VALUE,na.rm=TRUE)
        bb__$Q05 <- stats::quantile(bb__$VALUE,0.05,na.rm=TRUE)
        bb__$Q95 <- stats::quantile(bb__$VALUE,0.95,na.rm=TRUE)
        bb__
      }))
    }))
    dataPlotLines__ <- unique(dataPlot__[,c("PARAM","NAME","MEDIAN","Q05","Q95")])
    dataPlotLines__ <- cbind(dataPlotLines__, TYPE="Bootstrap median and\n95% confidence interval")
    NOMINAL <- c(fef_value_nominal__,ref_value_nominal__,cor_value_nominal__,cov_value_nominal__,err_value_nominal__)
    STDERR  <- c(fef_stderr_nominal__,ref_stderr_nominal__,cor_stderr_nominal__,cov_stderr_nominal__,err_stderr_nominal__)
    dataPlotLinesRef__ <- data.frame(
      PARAM = dataPlotLines__$PARAM,
      NAME = c(fef_names__,ref_names__,cor_names__,cov_names__,err_names__),
      MEDIAN = NOMINAL,
      Q05 = NOMINAL - 1.96*STDERR,
      Q95 = NOMINAL + 1.96*STDERR,
      TYPE = "Population mean and\n95% confidence interval\nfor reference model"
    )
    dataPlotLines__ <- rbind(dataPlotLines__,dataPlotLinesRef__)
    rownames(dataPlotLines__) <- NULL
    NBINS__ <- ceiling(max(NSAMPLES_NOT_CRASHED__/50,10))
    plotData__ <- split(dataPlot__,dataPlot__$PARAM)
    plotLines__ <- split(dataPlotLines__,dataPlotLines__$PARAM)
    plots__ <- list()
    for (k__ in seq_along(plotData__)) {
      ncols__ <- ceiling(sqrt(plotData__[[k__]]$NRPARAM[1]))
      nrows__ <- ceiling(plotData__[[k__]]$NRPARAM[1]/ncols__)
      p__ <- IQRggplot() +
        geom_histogram(data=plotData__[[k__]],aes_string(x="VALUE"),bins=NBINS__,fill="darkgrey") +
        facet_wrap(~NAME,scales="free",nrow=nrows__,ncol=ncols__)
      p__ <- p__ +
        geom_vline(data=plotLines__[[k__]],aes_string(xintercept="MEDIAN",linetype="TYPE",color="TYPE"),size=1) +
        geom_vline(data=plotLines__[[k__]],aes_string(xintercept="Q05",linetype="TYPE",color="TYPE"),size=1) +
        geom_vline(data=plotLines__[[k__]],aes_string(xintercept="Q95",linetype="TYPE",color="TYPE"),size=1) +
        scale_color_IQRtools()
      p__ <- p__ +
        theme(legend.position="bottom",
              legend.background=element_rect(linetype="solid",color="black"),
              legend.title=element_blank()) +
        ylab(label=NULL) +
        xlab(label="Estimates of parameter values") +
        ggtitle(label=plotData__[[k__]]$PARAM[1],subtitle=sprintf("Bootstrap results (N=%d fits successful)",NSAMPLES_NOT_CRASHED__))
      attr(p__,"plotData") <- list(
        hist = plotData__[[k__]],
        lines = plotLines__[[k__]]
      )
      plots__[[as.character(plotData__[[k__]]$PARAM[1])]] <- p__
    }
    xtitle__ <- 'Bootstrap results'
    xfooter__ <- sprintf('N=%d bootstrap samples were evaluable (objective function different from "NA").<br>Number of significant digits: %d',NSAMPLES_NOT_CRASHED__,SIGDIG)
    parameter__ <- unique(dataPlotLines__$NAME)
    valuesModel__ <- c()
    valuesBootstrap__ <- c()
    CImodel__ <- c()
    CIbootstrap__ <- c()
    for (k__ in seq_along(parameter__)) {
      x__ <- dataPlotLines__[dataPlotLines__$NAME==parameter__[k__],]
      ix_bt__ <- which(grepl("Bootstrap",x__$TYPE))
      ix_model__ <- which(grepl("model",x__$TYPE))
      valuesModel__ <- c(valuesModel__, as.character(signif(x__$MEDIAN[ix_model__],digits=SIGDIG)))
      valuesBootstrap__ <- c(valuesBootstrap__, as.character(signif(x__$MEDIAN[ix_bt__],digits=SIGDIG)))
      CImodel__ <- c(CImodel__, paste0("[",signif(x__$Q05[ix_model__],SIGDIG),",",signif(x__$Q95[ix_model__],SIGDIG),"]"))
      CIbootstrap__ <- c(CIbootstrap__, paste0("[",signif(x__$Q05[ix_bt__],SIGDIG),",",signif(x__$Q95[ix_bt__],SIGDIG),"]"))
    }
    xtable__ <- data.frame(
      "Parameter" = parameter__,
      "Model estimate" = valuesModel__,
      "Bootstrap median" = valuesBootstrap__,
      "Model 95% CI" = CImodel__,
      "Bootstrap 95% CI" = CIbootstrap__
    )
    names(xtable__) <- c("Parameter","Model estimate","Bootstrap median","Model 95% CI","Bootstrap 95% CI")
    plotList <- aux_extractObjects(plots__, "ggplot")
    IQRoutputPDF(gr = plotList,filename = paste0(bootstrapPath,"/","results_bootstrap"))
    IQRoutputTable(xtable=xtable__,xfooter=xfooter__,xtitle=xtitle__,
                   filename=paste0(bootstrapPath,"/results_bootstrap.txt"),
                   report=TRUE)
    if (!FLAGreturnOutput) return()
    output__ <- list(
      plots = plots__,
      table = IQRoutputTable(xtable=xtable__,xfooter=xfooter__,xtitle=xtitle__)
    )
    return(output__)
  }
}
#'@export
informationContent_IQRnlmeProject <- function(projectPath,
                                              ...,
                                              sampling=NULL,
                                              output=NULL,
                                              dosing=NULL,
                                              pertSize=10,
                                              filename=NULL,
                                              verbose=TRUE) {
  if (!is_IQRnlmeProject(projectPath))
    stopIQR("Provided 'projectPath' does not point to an NLME project")
  model__ <- IQRmodel(paste0(projectPath,"/","model.txt"))
  if (is.null(output)) output <- names(model__$outputs)
  if (length(setdiff(output,names(model__$outputs))) > 0)
    stopIQR("output argument contains names that are no OUTPUT* elements in the model")
  if (is_IQRdosing(dosing)) dosing <- list(dosing)
  if (!is.list(sampling)) sampling <- list(sampling)
  if (length(dosing) != length(sampling))
    stopIQR('Number of provided dosing scenarios and number of provided sampling scenarios do not match.')
  parameters__ <- sample_IQRnlmeProject(projectPath,Nsamples=2,FLAG_SAMPLE=0,verbose = verbose)$popParamValues
  modelparamnames__ <- names(model__$parameters)
  if (length(setdiff(names(parameters__),modelparamnames__)) > 0)
    stopIQR('Parameters provided in the fit results ("projectFolder") need to be present in the structural model ("model").');
  parameters__[grepl("INPUT[0-9]+duration",names(parameters__)) & abs(parameters__)<1e-10] <- 1e-10
  parameters__[grepl("Tlag[0-9]+",names(parameters__)) & abs(parameters__)<1e-10] <- 0
  outputNominal__ <- data.frame()
  for (k__ in seq_along(dosing)) {
    x__ <- rbind(outputNominal__,
                 sim_IQRmodel(model__,
                              simtime=sampling[[k__]],
                              dosingTable=dosing[[k__]],
                              parameters=parameters__,
                              FLAGoutputsOnly=TRUE,
                              ...))
    outputNominal__ <- rbind(outputNominal__, tidyr::gather(x__,NAME,VALUE,-TIME))
    outputNominal__ <- outputNominal__[outputNominal__$NAME %in% output,]
  }
  outputPert__ <- list()
  for (k__ in seq_along(parameters__)) {
    parametersPert__      <- parameters__
    parametersPert__[k__] <- parametersPert__[k__]*(1+pertSize/100)
    outputPertK__ <- data.frame()
    for (k2__ in seq_along(dosing)) {
      x__ <- sim_IQRmodel(model__,
                          simtime=sampling[[k2__]],
                          dosingTable=dosing[[k2__]],
                          parameters=parametersPert__,
                          FLAGoutputsOnly=TRUE,
                          ...)
      outputPertK__ <- rbind(outputPertK__, tidyr::gather(x__,NAME,VALUE,-TIME))
      outputPertK__ <- outputPertK__[outputPertK__$NAME %in% output,]
    }
    outputPert__[[names(parameters__)[k__]]] <- outputPertK__$VALUE
  }
  outputPert__ <- as.data.frame(outputPert__)
  outputNominalExpanded__ <- do.call(cbind, replicate(length(parameters__), as.matrix(outputNominal__$VALUE), simplify=FALSE))
  Sn__ <- (as.matrix(outputPert__) - outputNominalExpanded__)/outputNominalExpanded__/pertSize*100
  medianSensitivity__ <- apply(abs(Sn__),2,median,na.rm=TRUE)
  medianSensitivity__ <- data.frame(
    PARAMETER = names(medianSensitivity__),
    NORM_SENS = unname(medianSensitivity__)
  )
  p <- IQRggplot(medianSensitivity__,aes_string(x="PARAMETER",y="NORM_SENS")) +
    geom_bar(stat="identity") +
    ylab("Normalized Sensitivity") +
    xlab("Parameter") +
    ggtitle("Information content in selected dosing / sampling schedule",subtitle=paste0(output,collapse=","))
  attr(p,"plotData") <- medianSensitivity__
  if (!is.null(filename)) {
    IQRoutputPDF(gr=p,filename=filename)
    return()
  }
  return(p)
}
#'@export
scm_IQRnlmeProject <- function(projectPath,
                               out_dir,
                               relations,
                               p_lev = 0.01,
                               pp_fun = NULL,
                               verbose = TRUE,
                               clean = TRUE,
                               gof = FALSE,
                               Nparallel = 1,
                               nlme = TRUE,
                               ...) {
  if (missing(projectPath)) stop("Argument `projectPath` required.", call. = FALSE)
  if (missing(out_dir)) stop("Argument `out_dir` required.", call. = FALSE)
  if (!is.numeric(p_lev) || p_lev < 0 || p_lev > 1) stop("Argument `p_lev` must be numeric between 0 and 1.", call. = FALSE)
  proj_obj <- getEst_IQRnlmeProject(as_IQRnlmeProject(projectPath))
  dosing <- proj_obj$dosingInfo[c("types", "lagTimes", "TK0times")]
  names(dosing) <- c("type", "Tlag", "Tk0")
  dosing <- purrr::transpose(dosing)
  dosing <- purrr::map(.x = dosing, .f = unlist)
  elipsis <- list(...) 
  header <- getHeader_IQRnlmeProject(projectPath)
  proj_args <- list(
    tool = header$TOOL,
    toolVersion = header$TOOLVERSION
  )
  if (header$TOOL == "NONMEM") {
    methods <- unlist(strsplit(header$METHOD, ","))
    proj_args <- c(
      proj_args,
      list(
        algOpt.NONMEM.METHOD = intersect(methods, c("FO", "FOCE", "FOCEI", "SAEM", "BAYES")),
        algOpt.NONMEM.ITS = any(methods == "ITS"),
        algOpt.NONMEM.IMPORTANCESAMPLING = any(methods == "IMP")
      )
    )
  } else if (header$TOOL == "NLMIXR") {
    methods <- unlist(strsplit(header$METHOD, ","))
    proj_args <- c(
      proj_args,
      list(
        algOpt.NLMIXR.method = intersect(methods, c("SAEM", "NLME", "FOCEI"))
      )
    )
  }
  if (clean) {
    if (dir.exists(out_dir)) aux_rmdir(out_dir)
    aux_mkdir(out_dir)
  }
  if (!"included" %in% colnames(relations)) relations$included <- FALSE
  if (length(setdiff(
    c(
      "Incl. in stage", "Reference OFV", "OFV", "dDF",
      "dOFV", "Target dOFV", "p-value"
    ),
    colnames(relations)
  )) > 0) {
    relations[, setdiff(
      c(
        "Incl. in stage", "Reference OFV", "OFV", "dDF",
        "dOFV", "Target dOFV", "p-value"
      ),
      colnames(relations)
    )] <- NA_real_
  }
  stage <- list.dirs(out_dir)
  stage <- stringr::str_remove(stage, pattern = stringr::fixed(out_dir))
  stage <- stringr::str_remove(stage, pattern = stringr::fixed(.Platform$file.sep))
  stage <- stringr::str_extract(stage, pattern = "^\\d+(?=_)")
  stage <- as.numeric(stage)
  stage <- ifelse(all(is.na(stage)), 1, max(stage, na.rm = TRUE) + 1)
  if (stage == 1) {
    message("------------------------------------------------------------------------------------------------")
    message(" NOTE: the SCM function is experimental and may be unstable, carefully evaluate the results!")
    message(" WARNING: check the help of the ... argument regarding the input of parameters for IQRnlmeProject")
    message("------------------------------------------------------------------------------------------------\n")
  }
  if (all(relations$included)) {
    message("No more covariate-parameter relationships left to be tested.")
    scm_final_summary(out_dir, relations, stage, p_lev)
    return(NULL)
  }
  stage_dir <- stringr::str_pad(stage, width = 2, pad = "0")
  stage_dir <- file.path(out_dir, paste0(stage_dir, "_scm_forward_selection_stage_", stage_dir))
  aux_mkdir(stage_dir)
  imp <- filter(relations, !included)
  imp <- purrr::transpose(imp)
  purrr::walk(
    .x = imp, .f = function(rel, dosing, proj_obj, pp_fun, stage_dir) {
      if (rel$cont) {
        covNames <- rel$cov
        catNames <- center_val <- NULL
      } else {
        covNames <- NULL
        catNames <- rel$cov
        center_val <- case_when(
          rel$cov == "TUMGRP" ~ 2,
          rel$cov == "SEXF" ~ 1,
          TRUE ~ NA_real_
        )
        if (is.na(center_val)) center_val <- NULL
      }
      x <- proj_obj$modelSpec
      x <- addCov_modelSpec(
        modelSpec = x,
        parname = rel$prm,
        covname = rel$cov,
        value = ifelse(is.null(rel$value), yes = 0.001, no = rel$value),
        center = center_val,
        estimate = 1
      )
      if (!is.null(x[["PriorVarCovariateModelValues"]])) {
        x[["PriorVarCovariateModelValues"]][[rel$prm]][rel$cov] <- 1
      }
      if (!nlme) {
        x <- IQRsysEst(
          modelSpec = x,
          model = proj_obj$model,
          dosing = dosing,
          data = data_IQRest(
            datafile = proj_obj$data$dataModeling,
            covNames = union(covNames, proj_obj$data$covNames),
            catNames = union(catNames, proj_obj$data$catNames),
            regressorNames = proj_obj$data$regNames
          )
        )
      } else {
        x <- IQRnlmeEst(
          modelSpec = x,
          model = proj_obj$model,
          dosing = dosing,
          data = data_IQRest(
            datafile = proj_obj$data$datafile,
            covNames = union(covNames, proj_obj$data$covNames),
            catNames = union(catNames, proj_obj$data$catNames),
            regressorNames = proj_obj$data$regNames
          )
        )
      }
      if (!nlme) {
        x <- IQRsysProject(
          est = x,
          projectPath = file.path(stage_dir, paste0("MODEL_", rel$cov, "_on_", rel$prm)),
          ...
        )
      } else {
        final_args <- c(
          list(
            est = x,
            projectPath = file.path(stage_dir, paste0("MODEL_", rel$cov, "_on_", rel$prm))
          ),
          elipsis,
          proj_args[!names(proj_args) %in% names(elipsis)]
        )
        x <- do.call(IQRnlmeProject, final_args)
      }
      if (!is.null(pp_fun)) {
        pp_fun(x)
      } else {
        x
      }
    },
    dosing = dosing, proj_obj = proj_obj, pp_fun = pp_fun, stage_dir = stage_dir
  )
  if (verbose) {
    message("------------------------------------------------------------------------------------------------")
    message(
      " Initiating stage ", stage, ", testing ", nrow(relations[!relations$included, ]),
      " parameter-covariate relationships."
    )
    message("------------------------------------------------------------------------------------------------")
  }
  if (!nlme) {
    run_IQRsysProjectMulti(
      projectPath = as_IQRsysProjectMulti(stage_dir),
      ncores = 1,
      Nparallel = Nparallel,
      FLAGgof = gof
    )
  } else {
    run_IQRnlmeProjectMulti(
      projectPath = as_IQRnlmeProjectMulti(stage_dir),
      ncores = 1,
      Nparallel = Nparallel,
      FLAGgof = gof
    )
  }
  stage_results <- as_IQRnlmeProjectMulti(c(projectPath, stage_dir))
  stage_results <- getResults_IQRnlmeProjectMulti(stage_results)
  stage_results <- purrr::imap(
    .x = stage_results,
    .f = function(x, y) {
      tibble::tibble(
        Path = y,
        Model = basename(y),
        OFV = x$OBJ,
        dDF = sum(
          length(x$projectHeader$BETACOVNAMES[x$projectHeader$BETACOVNAMES != ""]),
          length(x$projectHeader$BETACATNAMES[x$projectHeader$BETACATNAMES != ""])
        ),
        `Run failed` = ifelse(x$FAILED, "Yes", "No")
      )
    }
  )
  stage_results <- bind_rows(stage_results)
  stage_results <- mutate(
    .data = stage_results,
    `Reference OFV` = first(OFV),
    dOFV = OFV - first(OFV),
    `Target dOFV` = -stats::qchisq(1 - p_lev, dDF),
    `p-value` = stats::pchisq(-1*dOFV, dDF, lower.tail = FALSE),
    Signif = dOFV < `Target dOFV`
  )
  stage_results <- slice(stage_results, -1)
  stage_results <- mutate(stage_results, Rank = rank(`p-value`))
  stage_results <- arrange(stage_results, Rank)
  stage_results <- mutate_at(
    .tbl = stage_results,
    .vars = vars(OFV, dOFV, `Reference OFV`, `Target dOFV`),
    .funs = ~ round(., digits = 1)
  )
  stage_results <- mutate(stage_results, `p-value` = signif(`p-value`, digits = 3))
  stage_results <- select(
    stage_results,
    Path, Rank, Model, `Reference OFV`, OFV, `Run failed`, dDF,
    dOFV, `Target dOFV`, `p-value`, Signif
  )
  stage_results_tbl <- select(stage_results, -1)
  stage_results_tbl <- mutate(stage_results_tbl, Signif = ifelse(Signif, "Yes", "No"))
  IQRoutputTable(
    xtable = stage_results_tbl,
    xfooter = paste0(
      "Using a significance level of ", p_lev,
      ". OFV: objective function value, dDF: difference of degrees of freedom with the reference model. Models are sorted by decreasing p-value."
    ),
    filename = paste0(stage_dir, "_scm_log.txt"),
    verbose = FALSE
  )
  if (any(stage_results$Signif)) {
    best_mod <- slice(stage_results, 1)
    projectPath <- pull(best_mod, "Path")
    if (verbose) {
      tmp_msg <- basename(projectPath)
      tmp_msg <- stringr::str_remove(tmp_msg, "^MODEL_")
      tmp_msg <- stringr::str_replace_all(tmp_msg, "_", " ")
      message("------------------------------------------------------------------------------------------------")
      message("Including ", tmp_msg)
      message("------------------------------------------------------------------------------------------------")
    }
    relations <- mutate(
      relations,
      included         = ifelse(paste0("MODEL_", cov, "_on_", prm) == basename(projectPath), TRUE, included),
      `Incl. in stage` = ifelse(paste0("MODEL_", cov, "_on_", prm) == basename(projectPath), stage, `Incl. in stage`),
      `Reference OFV`  = ifelse(paste0("MODEL_", cov, "_on_", prm) == basename(projectPath), pull(best_mod, "Reference OFV"), `Reference OFV`),
      OFV              = ifelse(paste0("MODEL_", cov, "_on_", prm) == basename(projectPath), pull(best_mod, "OFV"), OFV),
      dDF              = ifelse(paste0("MODEL_", cov, "_on_", prm) == basename(projectPath), pull(best_mod, "dDF"), dDF),
      dOFV             = ifelse(paste0("MODEL_", cov, "_on_", prm) == basename(projectPath), pull(best_mod, "dOFV"), dOFV),
      `Target dOFV`    = ifelse(paste0("MODEL_", cov, "_on_", prm) == basename(projectPath), pull(best_mod, "Target dOFV"), `Target dOFV`),
      `p-value`        = ifelse(paste0("MODEL_", cov, "_on_", prm) == basename(projectPath), pull(best_mod, "p-value"), `p-value`)
    )
    scm_IQRnlmeProject(
      projectPath = projectPath, out_dir = out_dir, relations = relations,
      p_lev = p_lev, pp_fun = pp_fun, verbose = verbose, clean = FALSE,
      gof = gof, Nparallel = Nparallel, nlme = nlme, ...
    )
  } else {
    if (verbose) {
      message("------------------------------------------------------------------------------------------------")
      message(" SCM completed!")
      message("------------------------------------------------------------------------------------------------")
    }
    scm_final_summary(out_dir, relations, stage, p_lev)
  }
}
scm_final_summary <- function(out_dir, relations, stage, p_lev) {
  relations <- filter(relations, included)
  relations <- select(relations, Covariate = cov, `Model parameter` = prm, `Incl. in stage`:`p-value`)
  relations <- arrange(relations, `Incl. in stage`)
  relations <- tidyr::replace_na(relations, list(`Incl. in stage` = "Pre-included"))
  relations <- mutate_all(relations, .funs = ~ tidyr::replace_na(., "-"))
  IQRoutputTable(
    xtable = relations,
    xfooter = paste0(
      "Using a significance level of ", p_lev,
      ". OFV: objective function value, dDF: difference of degrees of freedom with the reference model."
    ),
    filename = file.path(out_dir, paste0(
      stringr::str_pad(stage + 1, width = 2, pad = "0"),
      "_final_scm_log.txt"
    )),
    verbose = FALSE
  )
}
getcovariateInfo_VPCnlme <- function(modelsSample,modelSampleSimulate,dataVPC) {
  allcovs__ <- unlist(unname(sapply(c(modelsSample,modelSampleSimulate), function (nlmemodel__) {
    x__ <- parseNLMEprojectHeader(nlmemodel__)$COVARIATESUSED
    if (length(x__)==1) {
      if (nchar(x__) == 0) return(NULL)
    }
    x__
  })))
  allcovs__ <- paste0(allcovs__,collapse=",")
  allcovs__ <- aux_explode(allcovs__)
  missingCovs__ <- setdiff(allcovs__,names(dataVPC))
  if (length(missingCovs__) > 0) {
    stopIQR(paste0("The following covariates are defined in the models but information is not available in the dataset: ",paste0(missingCovs__,collapse=", ")))
  }
  if (length(allcovs__)==0) allcovs__ <- NULL
  return(allcovs__)
}
checkRemoveNoObservationSubjects_VPCnlme <- function(dataVPC) {
  noObsID__ <- unlist(sapply(split(dataVPC,dataVPC$ID), function (d__) {
    if (length(which(d__$EVID==0 & d__$MDV==0))==0) {
      text__ <- paste0("Subject 'USUBJID=",d__$USUBJID[1],"' does not have any observations in the data. For the VPC this subject was removed\n")
      cat(text__)
      return(d__$ID[1])
    }
    return(NULL)
  }))
  dataUpdate__ <- dataVPC[!(dataVPC$ID %in% noObsID__),]
  return(dataUpdate__)
}
checkNoDosesSubjects_VPCnlme <- function(dataVPC) {
  dataUpdate__ <- do.call(rbind,lapply(split(dataVPC,dataVPC$ID), function (d__) {
    if (length(which(d__$EVID==1))==0) {
      row <- d__[1,]
      delta <- row$TIMEPOS-row$TIME
      row$DV <- 0
      row$EVID <- 1
      row$MDV <- 1
      row$YTYPE <- NA
      row$ADM <- 1
      row$AMT <- 0
      row$NAME <- "DOSE 0 added"
      if ("TINF" %in% names(row)) row$TINF <- 0
      if ("RATE" %in% names(row)) row$RATE <- 0
      if ("ADDL" %in% names(row)) row$ADDL <- NA
      if ("II" %in% names(row)) row$II <- NA
      if ("BASE" %in% names(row)) row$BASE <- 0
      if ("SCREEN" %in% names(row)) row$SCREEN <- 0
      if ("TAD" %in% names(row)) row$TAD <- 0
      d__ <- rbind(d__,row)
      a__ <- attributes(d__)
      d__ <- dplyr::arrange(d__,c(ID,TIME))
      attributes(d__) <- a__
      text__ <- paste0("Subject 'USUBJID=",d__$USUBJID[1],"' does not have any doses in the data. For the VPC a dose of 0 amount was imputed at the time of the first event\n")
      cat(text__)
    }
    d__
  }))
  return(dataUpdate__)
}
getDoseDataCols_VPCnlme <- function(dataVPC) {
  dataCols__ <- names(dataVPC)
  if (!("EVID" %in% dataCols__)) {
    stopIQR("'EVID' column is missing in the dataVPC")
  }
  dataColsDose__ <- c("ID", "TIME", "AMT", "ADM")
  if (!all(dataColsDose__ %in% dataCols__)) {
    stopIQR("Columns 'ID', 'TIME', 'AMT', and 'ADM' need to be present in the dataset")
  }
  if ("TINF" %in% dataCols__) {
    dataColsDose__ <- c(dataColsDose__,"TINF")
  } else {
    if ("RATE" %in% dataCols__) {
      dataColsDose__ <- c(dataColsDose__,"RATE")
    } else {
    }
  }
  if (!any(c("II","ADDL") %in% dataCols__)) {
  } else {
    if (!all(c("II","ADDL") %in% dataCols__)) {
      stopIQR("Columns 'ADDL' and 'II' need both to be present in the dataset if one is present")
    } else {
      dataColsDose__ <- c(dataColsDose__,"ADDL","II")
    }
  }
  return(dataColsDose__)
}
#'@export
vpc_IQRnlmeProject <- function(
  project,
  dataVPC = NULL,
  Ntrials,
  ABSORPTION0names = NULL,
  modelsSample = NULL,
  FLAGpreparePC = FALSE,
  simtimeOption = c("obs", "simTFD", "simTAD")[1],
  simtimeN = 1000,
  simtimeMax = NULL,
  FLAGindivSimtimeMax = FALSE,
  FLAGaddResidualNoise = TRUE,
  FLAGsampleUncertainty = TRUE,
  FLAGlogOutput = FALSE,
  factorMult = NULL,
  ncores = 1,
  seed = NULL,
  FLAGkeepParameters = FALSE,
  opt_initstep = 0,
  opt_abstol = 1e-6,
  opt_reltol = 1e-6,
  opt_maxstep = 0,
  opt_minstep = 0,
  par_lower = NULL,
  par_upper = NULL,
  FLAGfixDoseOverlap = TRUE
) {
  createDataVPC_IQRnlmeProject(
    project=project,
    dataVPC=dataVPC,
    Ntrials=Ntrials,
    ABSORPTION0names = ABSORPTION0names,
    modelsSample = modelsSample,
    FLAGpreparePC = FLAGpreparePC,
    simtimeOption = simtimeOption,
    simtimeN = simtimeN,
    simtimeMax = simtimeMax,
    FLAGindivSimtimeMax = FLAGindivSimtimeMax,
    FLAGaddResidualNoise = FLAGaddResidualNoise,
    FLAGsampleUncertainty = FLAGsampleUncertainty,
    FLAGlogOutput = FLAGlogOutput,
    factorMult = factorMult,
    ncores = ncores,
    seed = seed,
    FLAGkeepParameters = FLAGkeepParameters,
    opt_initstep = opt_initstep,
    opt_abstol = opt_abstol,
    opt_reltol = opt_reltol,
    opt_maxstep = opt_maxstep,
    opt_minstep = opt_minstep,
    par_lower = par_lower,
    par_upper = par_upper,
    FLAGfixDoseOverlap = FLAGfixDoseOverlap
  )
}
#'@export
IQRpopEDdb <- function(model, design, modelSpec, transform_pop = FALSE, ...) {
  checkPackage_IQRtools("PopED","0.4.0")
  m__ <- length(design[["groupsize"]])
  groupsize__ <- unlist(design[["groupsize"]])
  design__ <- lapply(design, function(d) {
    if (length(d) == 1) {
      stats::setNames(rep(d, m__), names(groupsize__))
    } else {
      if (length(d) != m__) {
        stopIQR("Error in design", d, "\nLength should be either 1 or number of groups.")
      } else {
        d.names__ <- names(d)
        if (is.null(d.names__)) d.names__ <- names(groupsize__)
        d.names__[d.names__ == ""] <- names(groupsize__)[d.names__ == ""]
        names(d) <- d.names__
      }
    }
    return(d)
  })
  time__ <- lapply(design[["time"]], function(g) {
    stats::setNames(
      object = unlist(g[sort(names(g))]),
      nm = unlist(lapply(seq_along(g), function(i) rep(names(g)[i], length(g[[i]]))))
    )
  })
  model_switch__ <- lapply(time__, function(t) {
    as.numeric(as.factor(names(t)))
  })
  xt__ <- time__ 
  parameter_names__ <- names(modelSpec[["POPvalues0"]])
  data__ <- list()
  data__[["covNames"]] <- unique(unlist(modelSpec[["covariateModel"]]))
  modelInfo__ <- basicmodelparsing(model, parameter_names__, NULL)
  modelSpec__ <- checkHandleDefaultNLMEmodelSpec(modelInfo__, modelSpec, data__)
  a__.dosing <- lapply(design__[["dosing"]], function(x) unlist(as.data.frame(x)))
  a__ <- a__.dosing
  bpop__.structural <- modelSpec__[["POPvalues0"]]
  bpop__ <- bpop__.structural
  distr__ <- modelSpec__[["IIVdistribution"]]
  if (transform_pop) {
    bpop__[distr__ == "L"] <- log(bpop__[distr__ == "L"])
    bpop__[distr__ == "G"] <- logit(bpop__[distr__ == "G"])
  }
  sfg <- function(x, a, bpop, b, bocc) {
    if (length(bpop) != length(bpop__)) bpop[seq_along(bpop__)] <- bpop
    if (length(b) != length(bpop__)) b[seq_along(bpop__)] <- b
    if (length(a) != length(a__[[1]])) a[seq_along(a__[[1]])] <- a__[[1]]
    parameters <- stats::setNames(bpop[seq_along(bpop__)], parameter_names__)
    covariates <- stats::setNames(a[seq_along(a__[[1]])], names(a__[[1]]))
    if (!transform_pop) {
      parameters[distr__ == "N"] <- parameters[distr__ == "N"]
      parameters[distr__ == "L"] <- log(parameters[distr__ == "L"])
      parameters[distr__ == "G"] <- logit(parameters[distr__ == "G"])
    }
    parameters[distr__ == "N"] <- parameters[distr__ == "N"] + b[distr__ == "N"]
    parameters[distr__ == "L"] <- exp(parameters[distr__ == "L"]  + b[distr__ == "L"])
    parameters[distr__ == "G"] <- inv_logit(parameters[distr__ == "G"] + b[distr__ == "G"])
    out <- c(parameters, covariates)
    return(out)
  }
  ff <- function(model_switch, xt, parameters, poped.db) {
    keys__ <- c("TIME", "ADM", "AMT", "TINF")
    doseInformation__ <- stats::setNames(
      object = lapply(keys__, function(w) {
        parameters[grepl(paste0(w, "[[:digit:]]*"), names(parameters))]
      }),
      nm = keys__
    )
    doseInformation__[["ADM"]] <- round(doseInformation__[["ADM"]])
    dosing__ <- do.call("IQRdosing", doseInformation__)
    parameters__ <- parameters[names(bpop__)]
    simu__ <- sim_IQRmodel(model,
                           simtime = unique(xt),
                           parameters = parameters__,
                           dosingTable = dosing__,
                           FLAGoutputsOnly = TRUE)
    simu__.time <- simu__[[1]]
    simu__.output <- simu__[-1]
    y.list <- lapply(unique(model_switch), function(n) {
      simu__.output[[n]][match(xt[model_switch == n], simu__.time)]
    })
    y <- model_switch
    for (n in unique(model_switch)) {
      y[model_switch == n] <- y.list[[n]]
    }
    out <- list(y = y, poped.db = poped.db)
    return(out)
  }
  errmodels__ <- modelSpec__[["errorModel"]]
  outputs__ <- seq_along(errmodels__)
  feps <- function(model_switch, xt, parameters, epsi, poped.db){
    returnArgs <- ff(model_switch, xt, parameters, poped.db)
    y <- returnArgs[[1]]
    poped.db <- returnArgs[[2]]
    sigma_y.list <- lapply(unique(model_switch), function(n) {
      y*(1 + epsi[, 2*(n-1)+1]) + epsi[, 2*(n-1)+2]
    })
    sigma_y <- model_switch
    for (n in unique(model_switch)) {
      sel <- model_switch == n
      sigma_y[sel] <- sigma_y.list[[n]][sel]
    }
    out <- list(y = sigma_y, poped.db = poped.db )
    return(out)
  }
  notfixed_bpop__ <- modelSpec__[["POPestimate"]]
  notfixed_d__ <- modelSpec__[["IIVestimate"]] == 1
  d__ <- modelSpec[["IIVvalues0"]]
  sigma__ <- do.call(c, lapply(errmodels__, function(erm__) {
    type__ <- erm__[1]
    epsi__ <- as.numeric(erm__[-1])
    switch(type__,
           absrel = c(epsi__[2], epsi__[1]),
           abs = c(0, epsi__[1]),
           rel = c(epsi__[1], 0))
  }))
  poped.db <- PopED::create.poped.database(
    ff_fun = ff,
    fError_fun = feps,
    fg_fun = sfg,
    groupsize = groupsize__,
    m = length(groupsize__),
    xt = xt__,
    model_switch = model_switch__,
    a = a__,
    bpop = bpop__[parameter_names__],
    notfixed_bpop = notfixed_bpop__[parameter_names__],
    d = d__[parameter_names__]^2,
    notfixed_d = notfixed_d__[parameter_names__],
    sigma = sigma__,
    notfixed_sigma = rep(0, length(sigma__)),
    nbpop = length(bpop__),
    NumRanEff = length(d__),
    NumDocc = 0,
    NumOcc = 0,
    ...
  )
  poped.db[["IQRdesign"]] <- design
  poped.db[["IQRmodel"]] <- model
  poped.db[["IQRmodelSpec"]] <- modelSpec
  class(poped.db) <- c("IQRpopEDdb")
  return(poped.db)
}
#'@export
sim_IQRpopEDdb <- function(db, simtime = NULL, IPRED = FALSE, DV = FALSE) {
  minxt__ <- min(db[["design"]][["xt"]])
  maxxt__ <- max(db[["design"]][["xt"]])
  num_points__ <- NULL
  if (!is.null(simtime)) {
    minxt__ <- min(simtime)
    maxxt__ <- max(simtime)
    num_points__ <- length(simtime)
  }
  out1__ <- PopED::model_prediction(db,
                                  IPRED = IPRED,
                                  DV = DV,
                                  include_a = FALSE,
                                  model_minxt = minxt__,
                                  model_maxxt = maxxt__,
                                  model_num_points = num_points__)
  out1__[["Observed"]] <- sapply(1:nrow(out1__), function(i) {
    Group__ <- out1__[i, "Group"]
    Time__ <- out1__[i, "Time"]
    Time__ %in% db[["design"]][["xt"]][Group__, ]
  })
  Model__ <- names(db[["IQRmodel"]][["outputs"]])
  Group__ <- names(db[["IQRdesign"]][["groupsize"]])
  levels(out1__[["Model"]]) <- Model__
  levels(out1__[["Group"]]) <- Group__
  if (!"ID" %in% colnames(out1__))
    out1__[["ID"]] <- NA
  class(out1__) <- c("sim_IQRpopEDdb", "data.frame")
  return(out1__)
}
#'@export
evaluate_IQRpopEDdb <- function(db) {
  out__ <- PopED::evaluate_design(db)
  modelSpec__ <- db[["IQRmodelSpec"]]
  estimate__ <- with(modelSpec__, c(names(POPvalues0)[POPestimate == 1], paste0("omega(", names(POPvalues0)[IIVestimate == 1], ")")))
  names(out__[["rse"]]) <- colnames(out__[["fim"]]) <- rownames(out__[["fim"]]) <- estimate__
  out__[["se"]] <- sqrt(diag(solve(out__[["fim"]])))
  pars__ <- stats::setNames(
    c(modelSpec__[["POPvalues0"]], modelSpec__[["IIVvalues0"]]),
    c(names(modelSpec__[["POPvalues0"]]), paste0("omega(", names(modelSpec__[["IIVvalues0"]]), ")"))
  )
  errpars <- unlist(lapply(seq_along(modelSpec__[["errorModel"]]), function(YTYPE) {
    errm <- modelSpec__[["errorModel"]][[YTYPE]]
    switch(errm[1],
           absrel = stats::setNames(as.numeric(errm[2:3]), paste0("error_", c("ADD", "PROP"), YTYPE)),
           abs = stats::setNames(as.numeric(errm[2]), paste0("error_", c("ADD"), YTYPE)),
           rel = stats::setNames(as.numeric(errm[2]), paste0("error_", c("PROP"), YTYPE)))
  }))
  out__[["estimated"]] <- pars__[estimate__]
  out__[["fixed"]] <- c(pars__[setdiff(names(pars__), estimate__)], errpars)
  out__[["A"]] <- sum(diag(out__[["fim"]]))
  out__[["E"]] <- min(eigen(out__[["fim"]])$value)
  out__[["D"]] <- out__[["ofv"]]
  out__ <- out__[c("D", "A", "E", "fim", "estimated", "se", "rse", "fixed")]
  class(out__) <- c("eval_IQRpopEDdb", "list")
  return(out__)
}
#'@export
print.eval_IQRpopEDdb <- function(x, ...) {
  pars.all__ <- c(x[["estimated"]], x[["fixed"]])
  se.all__ <- c(x[["se"]], stats::setNames(rep(NA, length(x[["fixed"]])), names(x[["fixed"]])))
  partable__ <- function(pars__, se__) {
    data <- data.frame(`Parameter` = names(pars__),
                       `Value` = pars__,
                       `SE` = se__)
    IQRtable(
      data = data,
      stat = statSE(data[["Value"]], data[["SE"]]),
      `Parameter` = "Parameter",
      `Value` = "value",
      `SE` = "se",
      `RSE [%]` = "rse%"
    )
  }
  T0 <- as_IQRtable(
    data.frame(
      Criterion = c("D = log(|FIM|)", "A = tr(FIM)", "E = min(EV)"),
      Value = format_GUM(c(x[["D"]], x[["A"]], x[["E"]]), se = "1%", justify = "r")
    )
  )
  pars__ <- pars.all__[!grepl("^omega\\(", names(pars.all__)) & !grepl("^error_", names(pars.all__))]
  se__ <- se.all__[!grepl("^omega\\(", names(se.all__)) & !grepl("^error_", names(se.all__))]
  T1 <- partable__(pars__, se__)
  pars__ <- pars.all__[grepl("^omega\\(", names(pars.all__))]
  se__ <- se.all__[grepl("^omega\\(", names(se.all__))]
  T2 <- partable__(pars__, se__)
  pars__ <- pars.all__[grepl("^error_", names(pars.all__))]
  se__ <- se.all__[grepl("^error_", names(se.all__))]
  T3 <- partable__(pars__, se__)
  pattern__ <-
    "**Optimality criteria** | T0 |
                             |    |
     **Fixed effects**       | T1 |
                             |    |
     **Random effects**      | T2 |
                             |    |
     **Error parameters**    | T3 |"
  mytable__ <- compose_IQRtable(T0 = T0, T1 = T1, T2 = T2, T3 = T3, pattern = pattern__)
  myfooter__ <- "|FIM| (Determinant of the Fisher Information Matrix),\ntr(FIM) (Trace of the FIM), EV (Eigen values of the FIM)"
  print(mytable__)
  cat("\n")
  cat(myfooter__)
  invisible()
}
#'@export
plot.sim_IQRpopEDdb <- function(x, ...) {
  out__ <- x
  keep__ <- match(c("ID", "Time", "Group", "Model", "Observed"), colnames(out__))
  timenames__ <- colnames(out__)[keep__]
  allnames__ <- colnames(out__)[-keep__]
  times__ <- out__[, keep__]
  ntimes__ <- nrow(out__)
  values__ <- unlist(out__[, allnames__])
  outlong__ <- data.frame(times__,
                        Name = factor(rep(allnames__, each = ntimes__), levels = allnames__),
                        Value = as.numeric(values__))
  colnames(outlong__)[1:length(keep__)] <- timenames__
  data__ <- outlong__[outlong__[["Observed"]] & outlong__[["Name"]] == "PRED", ]
  pred__ <- outlong__[outlong__[["Name"]] %in% "PRED", ]
  ipred__ <- outlong__[outlong__[["Name"]] %in% "IPRED", ]
  dv__ <- outlong__[outlong__[["Observed"]] & outlong__[["Name"]] == "DV", ]
  myplot__ <- IQRggplot(pred__, aes_string(x = "Time", y = "Value", color = "Group")) +
    facet_wrap(~Model, scales = "free")
  if (nrow(ipred__) > 0) {
    ipred__ <- split(ipred__, list(ipred__[["Model"]], ipred__[["Group"]], ipred__[["Time"]]), drop = TRUE)
    ipred__ <- lapply(ipred__, function(x) {
      x[["Lower"]] <- stats::quantile(x[["Value"]], probs = 0.05)
      x[["Upper"]] <- stats::quantile(x[["Value"]], probs = 0.95)
      x <- x[1,]
      return(x)
    })
    ipred__ <- do.call(rbind, ipred__)
    myplot__ <- myplot__ +
      geom_ribbon(data = ipred__, aes_string(ymin = "Lower", ymax = "Upper", fill = "Group"), alpha = .3, lty = 0)
  }
  myplot__ <- myplot__ +
    geom_line() +
    geom_point(data = data__)
  if (nrow(dv__) > 0) {
    myplot__ <- myplot__ +
      geom_point(data = dv__, pch = 4)
  }
  return(myplot__)
}
#'@export
getPars_IQRmodel <- function(model, ..., parameters = NULL, FLAGverbose = TRUE) {
  args__ <- list(...)
  if (!is.null(names(args__)))
    warningIQR("Arguments passed via ... to getPars_IQRmodel() are expected to be unnamed. Names were removed.")
  if (!all(sapply(args__, is.character)))
    warningIQR("Found non-character arguments passed via ... to getPars_IQRmodel(). Will be ignored.")
  if (!all(sapply(args__, length) == 1))
    warningIQR("Found arguments of length > 1 passed via ... to getPars_IQRmodel(). Only the first element will be used.")
  names(args__) <- NULL
  args__ <- lapply(args__, function(x__) x__[[1]])
  args__ <- lapply(args__, function(x__) {
    if (!is.character(x__)) return(NULL) else return(x__)
  })
  if (!is.null(parameters)) {
    if (!is.character(parameters))
      stopIQR("Argument parameters must be character.")
    names(parameters) <- NULL
    parameters__ <- as.list(parameters)
    args__ <- c(args__, parameters__)
  }
  params__ <- args__
  if (length(params__)==0) params__ <- names(model$parameters)
  iaparams__ <- names(model$initalAssignments)
  params__ <- setdiff(params__,iaparams__)
  if (!all(params__ %in% names(model$parameters)))
    stopIQR("Not all provided parameters are present in the model")
  tab__ <- do.call(rbind,lapply(params__, function (p__) {
    data.frame(
      Parameter = p__,
      Value = model$parameters[[p__]]$value,
      Information = ifelse (is.null(model$parameters[[p__]]$notes),"-",model$parameters[[p__]]$notes),
      stringsAsFactors = FALSE
    )
  }))
  if (FLAGverbose) {
    print(IQRoutputTable(
      xtable = tab__,
      xtitle = "Model parameters"
    ))
  }
  pars__ <- tab__$Value
  names(pars__) <- tab__$Parameter
  invisible(pars__)
}
#'@export
setPars_IQRmodel <- function(model, ..., parameters = NULL, FLAGverbose = FALSE) {
  args__ <- list(...)
  if (length(args__) > 0 && (is.null(names(args__)) || any(names(args__) == "")))
    stopIQR("All arguments passed via ... to setPars_IQRmodel() must be named.")
  if (!all(sapply(args__, is.numeric)))
    stopIQR("Arguments passed via ... to setPars_IQRmodel() must be numeric.")
  if (!is.null(parameters) && !is.numeric(parameters))
    stopIQR("Parameters argument must be numeric or NULL.")
  if (!is_IQRmodel(model)) stopIQR("model is not an IQRmodel object")
  argsparam__ <- unlist(args__)
  if (!is.null(parameters) & length(argsparam__)>0) {
    if (length(intersect(names(argsparam__), names(parameters))) > 0)
      stopIQR("Same parameters provided via '...' and 'parameters' argument.")
  }
  params__ <- c(argsparam__,parameters)
  if (!all(names(params__) %in% names(model$parameters)))
    stopIQR("Not all provided parameters are present in the model")
  for (p__ in names(params__)) {
    model$parameters[[p__]]$value <- params__[p__]
  }
  getPars_IQRmodel(model,parameters = names(params__),FLAGverbose = FLAGverbose)
  invisible(model)
}
#'@export
addRelations_IQRmodel <- function(model, variables, notes = NULL, regenerateModel = TRUE, verbose = TRUE) {
  parameterRelations__ <- variables
  symbols__ <- getSymbols(parameterRelations__)
  newpars__ <- setdiff(symbols__,
                       c(names(model$variables), names(model$parameters),
                         names(parameterRelations__),
                         names(model$states)))
  for (n__ in rev(names(parameterRelations__))) {
    newElement__ <- structure(list(
      list(
        formula = parameterRelations__[[n__]], type = NULL, compartment = NULL, unittype = NULL, notes = notes[[n__]]
      )), names = n__)
    if (n__ %in% names(model$variables)) {
      if (verbose) cat("Redefining existing variable:", crayon::blue(paste(n__, "=", parameterRelations__[[n__]])), "\n")
      model$variables[n__] <- newElement__
    } else {
      if (verbose) cat("Adding variable to top of list:", crayon::blue(paste(n__, "=", parameterRelations__[[n__]])), "\n")
      model$variables <- c(newElement__, model$variables)
    }
  }
  for (n__ in newpars__) {
    if (verbose) cat("Adding new parameter:", crayon::blue(paste(n__, "=", 0)), "\n")
    model$parameters <- c(model$parameters, structure(list(
      list(
        value = 0, type = NULL, compartment = NULL, unittype = NULL, notes = NULL
      )), names = n__))
  }
  oldpars__ <- intersect(names(model$parameters), names(parameterRelations__))
  if (verbose) cat("Removing unused parameters from model:", crayon::red(paste(oldpars__, collapse = ", ")), "\n")
  model$parameters <- model$parameters[setdiff(names(model$parameters), oldpars__)]
  if (regenerateModel) model <- regenerate_IQRmodel(model, FLAGsim = TRUE, FLAGsym = FALSE)
  return(model)
}
#'@export
replaceTerms_IQRmodel <- function(model, terms, regenerateModel = FALSE, fixed = TRUE, verbose = TRUE) {
  iterator__ <- as.list(structure(seq_along(model$states), names = names(model$states)))
  model$states <- lapply(iterator__, function(i__) {
    mystate__ <- model$states[[i__]]
    mystatename__ <- names(model$states)[i__]
    for (i in 1:length(terms)) {
      if (grepl(names(terms)[i], mystate__$ODE, fixed = fixed)) {
        printeq_prior__ <- crayon::red(paste0("d/dt(", mystatename__, ") = ",  gsub(names(terms)[i], crayon::bold(names(terms)[i]), mystate__$ODE, fixed = fixed)))
        printeq_post__ <- crayon::blue(paste0("d/dt(", mystatename__, ") = ",  gsub(names(terms)[i], crayon::bold(terms[i]), mystate__$ODE, fixed = fixed)))
        mystate__$ODE <- gsub(names(terms)[i], terms[[i]], mystate__$ODE, fixed = fixed)
        if (verbose) {
          cat("Remove equation: ", printeq_prior__, "\n")
          cat("Add equation:    ", printeq_post__, "\n")
        }
      }
    }
    mystate__
  })
  symbols__ <- getSymbols(terms)
  newpars__ <- setdiff(symbols__, c(names(model$variables), names(model$parameters), names(model$states)))
  for (n__ in newpars__) {
    if (verbose) cat("Adding new parameter:", crayon::blue(paste(n__, "=", 0)), "\n")
    model$parameters <- c(model$parameters, structure(list(
      list(
        value = 0, type = NULL, compartment = NULL, unittype = NULL, notes = NULL
      )), names = n__))
  }
  if (regenerateModel) model <- regenerate_IQRmodel(model, FLAGsim = TRUE, FLAGsym = FALSE)
  return(model)
}
#'@export
addOutputs_IQRmodel <- function(model, outputs, notes = NULL,regenerateModel=TRUE) {
  name_exists <- intersect(names(outputs), names(model$variables))
  if (length(name_exists))
    warningIQR("The following variables already exist in the model and will be replaced: ", paste(name_exists, collapse = ", "))
  for (n in names(outputs)) {
    if (is.null(notes[n]) || is.na(notes[n]))
      mynote <- NULL
    else
      mynote <- as.character(notes[n])
    model$variables[[n]] <- list(
      formula = as.character(outputs[n]),
      type = NULL,
      compartment = NULL,
      unittype = NULL,
      notes = mynote
    )
    if (grepl("^OUTPUT", n)) {
      model$outputs[[n]] <- list(
        formula = as.character(outputs[n]),
        notes = mynote,
        varindex = match(n, names(model$variables))
      )
    }
  }
  if (regenerateModel) model <- regenerate_IQRmodel(model,FLAGsim = TRUE,FLAGsym = FALSE)
  return(model)
}
#'@export
sensitivity_IQRmodel <- function (
  model,
  simtime,
  dosingTable = NULL,
  sensparams = NULL,
  sensoutput = NULL,
  sensmetricFct = NULL,
  sensopt.abspert = NULL,
  sensopt.relpert = 0.01,
  title = NULL,
  orderAlpha = FALSE,
  plotTrajectories = FALSE
) {
  if (!is_IQRmodel(model)) stopIQR("model not an IQRmodel")
  paramNominal__ <- getPars_IQRmodel(model,FLAGverbose = FALSE)
  if (is.null(sensparams)) {
    sensparams <- names(paramNominal__)
  }
  sensparams <- sensparams[!grepl("Tlag[0-9]*",sensparams)]
  sensparams <- sensparams[!grepl("INPUT[0-9]*",sensparams)]
  if (is.null(sensoutput)) {
    sensoutput <- names(model$outputs)
    if (is.null(sensoutput))
      stopIQR("No OUTPUTs present in the model, please define with 'sensoutput' which states, variables or reactions you would like to assess in the analysis")
  }
  if (!all(sensoutput %in% c(names(model$states),names(model$variables),names(model$reactions))))
    stopIQR("sensoutput contains elements that are neither states, variable or reactions in the model")
  if (!all(sensparams %in% names(model$parameters))) stopIQR("sensparams contains elements that are no parameters in the model")
  if (length(simtime)<=2) stopIQR("simtime should have at least 3 elements")
  if (!is.null(sensopt.abspert)) {
    if (!all(names(sensopt.abspert) %in% sensparams))
      stopIQR("sensopt.abspert contains names which are not in sensparams")
  }
  if (is.data.frame(dosingTable) | is.null(dosingTable)) dosingTable <- list(dosingTable)
  if (!is.list(simtime)) {
    simtime <- rep(list(simtime),length(dosingTable))
  }
  sim_nominal <- do.call(rbind,lapply(1:length(dosingTable), function (k) {
    res <- sim_IQRmodel(model,
                        dosingTable = dosingTable[[k]],
                        simtime=simtime[[k]],
                        parameters = paramNominal__)
    cbind(DOSING=k,res[,c("TIME",sensoutput)])
  }))
  sim_perturbed <- lapply(seq_along(sensparams), function (k) {
    sensparam__ <- sensparams[k]
    paramNominalk__ <- paramNominal__[sensparam__]
    paramPertk__ <- paramNominalk__*(1+sensopt.relpert)
    if (sensparam__ %in% names(sensopt.abspert)) {
      paramPertk__ <- paramPertk__ + sensopt.abspert
    }
    paramPert__ <- paramNominal__
    paramPert__[sensparam__] <- paramPertk__
    do.call(rbind,lapply(1:length(dosingTable), function (k2) {
      res <- sim_IQRmodel(model,
                          dosingTable = dosingTable[[k2]],
                          simtime=simtime[[k2]],
                          parameters = paramPert__)
      cbind(DOSING=k2,paramNominal=unname(paramNominalk__),paramPerturbed=unname(paramPertk__),res[,c("TIME",sensoutput)])
    }))
  })
  names(sim_perturbed) <- sensparams
  plotSensitivitySimulations <- function(dosingnames,sim_nominal,sim_perturbed) {
    nominal <- tidyr::gather(sim_nominal,NAME,VALUE,-DOSING,-TIME)
    lapply(seq_along(sim_perturbed), function (k) {
      sp <- sim_perturbed[[k]]
      pname <- names(sim_perturbed)[k]
      p_nom <- sp$paramNominal[1]
      p_pert <- sp$paramPerturbed[1]
      perturbed <- tidyr::gather(sp,NAME,VALUE,-DOSING,-paramNominal,-paramPerturbed,-TIME)
      title <- paste0("Simulations for parameter: ",pname)
      subtitle <- paste0("Blue: ",p_nom," (nominal)\nRed: ",p_pert," (perturbed)")
      IQRggplot() +
        geom_line(data=nominal,aes(x=TIME,y=VALUE,group=NAME),color="#0000aa") +
        geom_point(data=nominal,aes(x=TIME,y=VALUE,group=NAME),color="#0000aa") +
        geom_line(data=perturbed,aes(x=TIME,y=VALUE,group=NAME),color="#aa0000",linetype="dashed") +
        geom_point(data=perturbed,aes(x=TIME,y=VALUE,group=NAME),shape=2,color="#aa0000") +
        facet_wrap(.~NAME,scales="free",ncol = 2) +
        ggtitle(label = title,subtitle = subtitle)
    })
  }
  if (plotTrajectories) {
    Trajectories <- plotSensitivitySimulations(names(dosingTable),sim_nominal,sim_perturbed)
  } else {
    Trajectories <- NULL
  }
  sensmetricFct_Default <- function (p_nom,p_pert,y_nom,y_pert) {
    y_pert <- y_pert$VALUE
    y_nom <- y_nom$VALUE
    delta_p <- p_pert - p_nom
    delta_y <- y_pert - y_nom
    dpp <- delta_p/p_nom
    dyy <- delta_y/y_nom
    sens_norm <- dyy / dpp
    mean(abs(sens_norm))
  }
  defaultMetric <- FALSE
  xlabDefault <- "Normalized sensitivity (custom metric)"
  if (is.null(sensmetricFct)) {
    sensmetricFct <- sensmetricFct_Default
    defaultMetric <- TRUE
    xlabDefault <- "Normalized sensitivity (default metric)"
  }
  res <- unlist(lapply(sim_perturbed, function (sp) {
    p_nom <- sp$paramNominal[1]
    p_pert <- sp$paramPerturbed[2]
    perturbed <- tidyr::gather(sp,NAME,VALUE,-DOSING,-paramNominal,-paramPerturbed,-TIME)
    nominal <- tidyr::gather(sim_nominal,NAME,VALUE,-DOSING,-TIME)
    x <- sensmetricFct(p_nom = p_nom,p_pert = p_pert,y_nom = nominal, y_pert = perturbed)
    if (!is.numeric(x)) stopIQR("Output of sensitivity metric function is not numeric")
    if (length(x) != 1) {
      warningIQR("Output of sensitivity metric function is not a scalar. Using mean of absolute values for analysis")
      x <- mean(abs(x))
    }
    x
  }))
  sensitivityResults <- data.frame(
    Parameter   = names(res),
    Sensitivity = unname(res),
    stringsAsFactors = FALSE
  )
  sensitivityResults$origParameters <- sensitivityResults$Parameter
  sensitivityResults$Parameter[is.na(sensitivityResults$Sensitivity)] <- paste0(sensitivityResults$Parameter[is.na(sensitivityResults$Sensitivity)]," (*)")
  sensitivityResults$Sign <- sign(sensitivityResults$Sensitivity)
  sensitivityResults$Sign[is.na(sensitivityResults$Sign)] <- 0
  sensitivityResults <- dplyr::arrange(sensitivityResults,abs(Sensitivity))
  if (orderAlpha) sensitivityResults <- dplyr::arrange(sensitivityResults,desc(Parameter))
  sensitivityResults$Parameter <- factor(sensitivityResults$Parameter,levels=sensitivityResults$Parameter)
  sensitivityResults$Sign <- factor(sensitivityResults$Sign,levels=c(1,-1,0))
  sensitivityResults$Sensitivity[is.na(sensitivityResults$Sensitivity)] <- 0
  p <- IQRggplot(sensitivityResults,aes(x = Parameter, y = Sensitivity, fill = Sign)) +
    geom_bar(lty = 0, stat = "identity", position = "dodge") +
    coord_flip() +
    geom_hline(yintercept = 0, lty = 2) +
    ylab("Sensitivity Metric") +
    xlab(NULL) +
    theme(legend.position = "none") +
    ggtitle(ifelse(is.null(title),"Sensitivity Analysis",title),
            "(*) Sensitivity has NA/Nan value due to 0 perturbation or 0 nominal value")
  if (!any(sensitivityResults$Sign==-1)) {
    p <- p + scale_fill_manual(values=c("#444488","#444488"))
  } else {
    p <- p + scale_fill_manual(values=c("#448844","#884444","#444488"))
  }
  sensitivityResults <- dplyr::arrange(sensitivityResults,desc(abs(Sensitivity)))
  if (orderAlpha) sensitivityResults <- dplyr::arrange(sensitivityResults,Parameter)
  sensitivityResults$Sign <- NULL
  sensitivityResults$Parameter <- as.character(sensitivityResults$Parameter)
  nom <- sim_nominal
  pert <- sim_perturbed
  sensDiffMatrix <- as.matrix(do.call(cbind,lapply(pert,function (p) {
    nx <- tidyr::gather(nom,NAME,VALUE,-TIME,-DOSING)[,c("NAME","VALUE")]
    px <- tidyr::gather(p,NAME,VALUE,-TIME,-DOSING,-paramNominal,-paramPerturbed)[,c("NAME","VALUE")]
    delta <- px$VALUE-nx$VALUE
    delta
  })))
  cormat <- suppressWarnings(cor(sensDiffMatrix))
  paramOrder <- dplyr::arrange(sensitivityResults,desc(abs(Sensitivity)))$origParameters
  if (orderAlpha) paramOrder <- sort(sensitivityResults$origParameters)
  cormat <- cormat[paramOrder,paramOrder]
  cormat[lower.tri(cormat)] <- NA
  melted_cormat <- reshape2::melt(cormat, na.rm = TRUE)
  pcorr <- IQRggplot(data = melted_cormat, aes(Var2, Var1, fill = value))+
    geom_tile(color = "white")+
    scale_fill_gradient2(low = "blue", high = "red", mid = "white",
                         midpoint = 0, limit = c(-1,1), space = "Lab",
                         name="Pearson\nCorrelation") +
    theme_minimal()+
    theme(axis.text.x = element_text(angle = 45, vjust = 1,
                                     size = 12, hjust = 1))+
    coord_fixed() +
    xlab(NULL) +
    ylab(NULL)+
    ggtitle("Parameter correlations",subtitle = "Determined based on correlation of delta sensitivity trajectories")
  out <- list(
    plot = p,
    sensitivty = sensitivityResults,
    plotCorrelation = pcorr,
    trajectories = Trajectories
  )
  class(out) <- c("IQRsensitivity",class(out))
  out
}
#'@export
print.IQRsensitivity <- function (x,...) {
  print(x$plot)
}
#'@export
exportVirtualSubjects_IQRnlmeProject <- function(
  projectPath,
  pathname,
  FLAGoverwrite = FALSE,
  Nsamples = NULL,
  covariates = NULL,
  FLAGuncertainty = FALSE,
  FLAGss = TRUE,
  comment = NULL,
  timeSS = 10000,
  opt_abstol = 1e-6,
  opt_reltol = 1e-6
) {
  if (FLAGuncertainty) {
    FLAG_SAMPLE <- 8 
  } else {
    FLAG_SAMPLE <- 7 
  }
  if (is.null(Nsamples)) {
    indivParam <- getIndivParameters_IQRnlmeProject(projectPath)
    indivParam$ID <- NULL
    indivParam$USUBJID <- NULL
  } else {
    indivParam <- sample_IQRnlmeProject(input = projectPath,
                          Nsamples = Nsamples,
                          covariates = covariates,
                          FLAG_SAMPLE = FLAG_SAMPLE,
                          verbose = FALSE)$indParamValues
  }
  paramNamesEst <- names(indivParam)
  model <- getModel_IQRnlmeProject(projectPath)
  paramDefault <- sapply(model$parameters, function (x) x$value)
  ICsDefault <- sapply(model$states, function(x) x$IC)
  paramIA <- names(model$initalAssignments)
  allRes <- do.call(cbind,lapply(1:nrow(indivParam), function (kindiv) {
    parami <- indivParam[kindiv,]
    paramAllIndiv <- paramDefault
    paramAllIndiv[names(parami)] <- as.numeric(unname(parami))
    ICsIndiv <- attr(model,"nonNumICs.IQRmodel")(paramAllIndiv,ICsDefault,0)$ICs
    if (FLAGss) {
      paramAllIndivSim <- paramAllIndiv[!names(paramAllIndiv) %in% paramIA]
      simresSS <- sim_IQRmodel(model,
                               simtime=timeSS,
                               IC = ICsIndiv,
                               parameters = paramAllIndivSim,
                               opt_abstol = opt_abstol,
                               opt_reltol = opt_reltol)
      ICsIndiv <- unlist(unclass(simresSS[nrow(simresSS),names(model$states)]))
    }
    data.frame(c(ICsIndiv,paramAllIndiv))
  }))
  names(allRes) <- paste0("VS",1:ncol(allRes))
  elementNames <- rownames(allRes)
  TYPE <- rep("Parameter",nrow(allRes))
  TYPE[1:length(ICsDefault)] <- "State"
  ix <- elementNames %in% paramNamesEst
  TYPE[ix] <- paste0(TYPE[ix]," (individual)")
  INFO <- sapply(elementNames, function (x) {
    out <- model$states[[x]]$notes
    if (is.null(out)) out <- model$parameters[[x]]$notes
    if (is.null(out)) return(NA)
    out
  })
  VStable <- cbind(NAME=elementNames,TYPE=TYPE,INFO=INFO,allRes)
  VStable <- VStable[!grepl("INPUT[0-9]+",VStable$NAME),]
  VStable <- VStable[!VStable$NAME %in% paramIA,]
  VStable <- arrange(VStable,desc(TYPE),NAME)
  if (dir.exists(pathname) & !FLAGoverwrite) {
    stopIQR("Chosen output pathname already exists.")
  }
  aux_rmdir(pathname)
  aux_mkdir(pathname)
  modelfile <-
    export_IQRmodel(model,file.path(pathname,"model.txt"))
  IQRsaveCSVdata(VStable,filename=file.path(pathname,"VirtualSubjects.csv"))
  if (!is.null(comment))  aux_filewrite(comment,filename = file.path(pathname,"VirtualSubjects.csv.info"))
  return(invisible(NULL))
}
#'@export
importVariant_IQRmodel <- function (pathname,variantname) {
  if (!dir.exists(pathname)) stop ("pathname does not exist")
  modelfile <- file.path(pathname,"model.txt")
  variantname <- aux_fileparts(variantname)$filename
  variantfile <- file.path(pathname,paste0(gsub(".csv","",variantname,fixed = TRUE),".csv"))
  if (!file.exists(modelfile)) stop ("model.txt does not exist in provided pathname")
  if (!file.exists(variantfile)) stop ("variant file does not exist in provided pathname")
  model <- IQRmodel(modelfile,FLAGsim = FALSE)
  variant <- IQRloadCSVdata(variantfile)
  if (nrow(variant)==0) {
    message("Variant did not contain any information - Generic model returned")
    return(model)
  }
  if (!all(c("NAME","VALUE") %in% names(variant))) {
    stopIQR("Variant file need to contain columns NAME, TYPE, INFO, and VALUE")
  }
  if (!"TYPE" %in% names(variant)) {
    variant$TYPE <- NA
    for (k in 1:nrow(variant)) {
      name <- variant$NAME[k]
      if (name %in% names(model$states)) variant$TYPE[k] <- "State"
      if (name %in% names(model$parameters)) variant$TYPE[k] <- "Parameter"
    }
  }
  if (!"INFO" %in% names(variant)) {
    variant$INFO <- NA
    for (k in 1:nrow(variant)) {
      name <- variant$NAME[k]
      if (name %in% names(model$states)) {
        notes <- model$states[[name]]$notes
        notes <- ifelse(is.null(notes),"",notes)
        variant$INFO[k] <- notes
      }
      if (name %in% names(model$parameters)) {
        notes <- model$parameters[[name]]$notes
        notes <- ifelse(is.null(notes),"",notes)
        variant$INFO[k] <- notes
      }
    }
  }
  ix <- !variant$NAME[variant$TYPE=="State"] %in% names(model$states)
  if (any(ix)) {
    stopIQR(paste("The following variant elements are flaged as State but not present in the model as states:\n",paste(variant$NAME[ix],collapse=", ")))
  }
  ix <- !variant$NAME[variant$TYPE=="Parameter"] %in% names(model$parameters)
  if (any(ix)) {
    stopIQR(paste("The following variant elements are flaged as Parameter but not present in the model as parameters:\n",paste(variant$NAME[ix],collapse=", ")))
  }
  if (!all(variant$TYPE %in% c(NA,"State","Parameter"))) stopIQR("TYPE column needs to contain either 'State' or 'Parameter'")
  if (any(is.na(variant$TYPE))) {
    message(paste("The variant contains the following elements that are not present in the model
as states or parameters. These are ignored during import:\n",paste(variant$NAME[is.na(variant$TYPE)],collapse=", ")))
    variant <- variant[!is.na(variant$TYPE),]
  }
  varS <- variant[variant$TYPE=="State",]
  if (nrow(varS) > 0) {
    for (k in 1:nrow(varS)) {
      if (!varS$NAME[k] %in% names(model$states)) stopIQR("Variant state not in model")
      model$states[[varS$NAME[k]]]$IC <- as.numeric(varS$VALUE[k])
      notes <- varS$INFO[k]
      if (notes %in% c(NA,"NA")) notes <- NULL
      model$states[[varS$NAME[k]]]$notes <- notes
    }
  }
  varP <- variant[variant$TYPE=="Parameter",]
  if (nrow(varP) > 0) {
    for (k in 1:nrow(varP)) {
      if (!varP$NAME[k] %in% names(model$parameters)) stopIQR("Variant parameter not in model")
      model$parameters[[varP$NAME[k]]]$value <- as.numeric(varP$VALUE[k])
      notes <- varP$INFO[k]
      if (notes %in% c(NA,"NA")) notes <- NULL
      model$parameters[[varP$NAME[k]]]$notes <- notes
    }
  }
  x <- paste0(tempfileIQR(),".txt")
  export_IQRmodel(model,filename =x)
  model <- IQRmodel(x)
  model$name <- paste0(model$name," (Variant: ",variantname,")")
  unlink(x)
  return(model)
}
#'@export
exportVariant_IQRmodel <- function(model,
                                   pathname,
                                   parameters=NULL,
                                   FLAGss=TRUE,
                                   comment=NULL,
                                   variantname="default",
                                   timeSS=10000,
                                   opt_abstol = 1e-6,
                                   opt_reltol = 1e-6) {
  if (is.character(model)) {
    if (file.exists(model)) {
      model <- IQRmodel(model)
    } else {
      stopIQR("model file not found")
    }
  }
  if (!is_IQRmodel(model)) stopIQR("model is not an IQRmodel")
  orig_model <- model
  if (!is.null(parameters)) model <- setParameters_IQRmodel(model,parameters)
  if (FLAGss) {
    simresSS <- sim_IQRmodel(model,simtime=timeSS,opt_abstol = opt_abstol,opt_reltol = opt_reltol)
    SSstates <- unlist(unclass(simresSS[nrow(simresSS),names(model$states)]))
    xx__ <- sapply(names(SSstates), function (nS) {
      ss__ <- SSstates[nS]
      if (ss__ < 0 & ss__ > -1e-15) ss__ <- 0
      model$states[[nS]]$IC <<- ss__
    })
  }
  sI <- do.call(rbind,lapply(seq_along(model$states), function (k) {
    s <- model$states[[k]]
    out <- data.frame(
      NAME = names(model$states[k]),
      TYPE = "State",
      INFO = ifelse (is.null(s$notes),"NA",s$notes),
      VALUE = s$IC,
      stringsAsFactors = FALSE
    )
  }))
  rownames(sI) <- NULL
  pI <- do.call(rbind,lapply(seq_along(model$parameters), function (k) {
    s <- model$parameters[[k]]
    out <- data.frame(
      NAME = names(model$parameters[k]),
      TYPE = "Parameter",
      INFO = ifelse (is.null(s$notes),"NA",s$notes),
      VALUE = s$value,
      stringsAsFactors = FALSE
    )
  }))
  rownames(pI) <- NULL
  allI <- rbind(sI,pI)
  aux_mkdir(pathname)
  modelfile <- file.path(pathname,"model.txt")
  if (file.exists(modelfile)) {
    model_there <- IQRmodel(modelfile,FLAGsim = FALSE)
    model_there$name <- NULL  
    model_there$notes <- NULL  
    x <- sapply(names(model_there$states), function (n) model_there$states[[n]]$IC <<- 0)
    x <- sapply(names(model_there$parameters), function (n) model_there$parameters[[n]]$value <<- 0)
    x <- sapply(names(model$states), function (n) model$states[[n]]$IC <<- 0)
    x <- sapply(names(model$parameters), function (n) model$parameters[[n]]$value <<- 0)
    model$name <- NULL  
    model$notes <- NULL  
    if (export_IQRmodel(model) != export_IQRmodel(model_there)) {
      stopIQR("The pathname already contains a model.txt file with a different structure\n  Parameterization variants cannot be used in the same folder for different structural model")
    }
  }
  export_IQRmodel(orig_model,modelfile)
  filename <- gsub("\\W","_",gsub(".csv","_",variantname,fixed = TRUE))
  IQRsaveCSVdata(allI,filename=file.path(pathname,filename))
  if (!is.null(comment))  aux_filewrite(comment,filename = paste0(file.path(pathname,gsub("\\W","_",variantname)),".csv.info"))
}
#'@export
simbio_CSV2namedVector <- function (filename) {
  if (!file.exists(filename)) stopIQR("File to load does not exist")
  d <- IQRloadCSVdata(filename)
  if (ncol(d)<2) stopIQR("File does not contain at least 2 columns")
  if (any(!is.numeric(d[[2]]))) stopIQR("Second element in file need to be numeric")
  values <- d[[2]]
  names(values) <- d[[1]]
  return(values)
}
#'@export
simbio_updateParamIC_IQRmodel <- function (model,filename) {
  if (!is_IQRmodel(model)) stopIQR("Provided 'model' argument does not contain an IQRmodel")
  if (!file.exists(filename)) stopIQR("File to load does not exist")
  d <- IQRloadCSVdata(filename)
  if (ncol(d)<2) stopIQR("File does not contain at least 2 columns")
  if (any(!is.numeric(d[[2]]))) stopIQR("Second element in file need to be numeric")
  values <- d[[2]]
  names(values) <- d[[1]]
  names(values) <- gsub("\\<[^\\.]+\\.","",names(values))
  modelupdated <- model
  paramNames <- intersect(names(modelupdated$parameters),names(values))
  dummy <- sapply(paramNames, function (p) {
    modelupdated$parameters[[p]]$value <<- values[[p]]
  })
  stateNames <- intersect(names(modelupdated$states),names(values))
  dummy <- sapply(stateNames, function (s) {
    modelupdated$states[[s]]$IC <<- as.character(values[[s]])
  })
  return(modelupdated)
}
#'@export
offsetTIME_IQRsysData <- function (data,offset) {
  message("Offsetting the time in datasets might require the use of SIMOPT.hmax
in the call to IQRsysProject() to ensure numerical viability of the simulation.")
  do.call(rbind,lapply(split(data,data$USUBJID), function (d) {
    row <- d[1,]
    row$NAME <- "Dummy:::Dose"
    row$TIME <- min(d$TIME)-offset
    row$TIMEPOS <- min(d$TIMEPOS)-offset
    row$AMT <- 0
    row$ADM <- 1
    row$MDV <- 1
    row$EVID <- 1
    row$CENS <- 0
    row$TINF <- 0
    row$RATE <- 0
    row$ADDL <- 0
    row$II <- 0
    rbind(row,d)
  }))
}
#'@export
spmIIV_IQRsysProject <- function (
  path,
  model,
  dosing,
  data,
  POPvalues0,
  SPM_IIVvalues0 = NULL,
  IIVvalues0 = NULL,
  errorModel = NULL,
  ncores = 1,
  Nparallel = 1,
  FLAGclean = TRUE,
  SIMOPT.nauxtimes = 0,
  SIMOPT.hmax = NULL,
  SIMOPT.atol = 1e-6,
  SIMOPT.rtol = 1e-6
) {
  aux_rmdir(path)
  if (is.null(SPM_IIVvalues0)) {
    SPM_IIVvalues0 <- rep(0.5,length(POPvalues0))
    names(SPM_IIVvalues0) = names(POPvalues0)
  }
  IIVvalues0_current <- IIVvalues0
  SPM_IIVvalues0_test <- SPM_IIVvalues0
  Iteration <- 1
  resultsALL <- data.frame()
  while (length(SPM_IIVvalues0_test) > 0) {
    pathModels <- paste0(path,"/",aux_preFillChar(Iteration,3,"0"),"_Iteration")
    pM <- lapply(seq_along(SPM_IIVvalues0_test), function (k) {
      IIvalues0Use <- c(
        IIVvalues0_current,
        SPM_IIVvalues0_test[k]
      )
      IIVestimateUse <- rep(2,length(IIvalues0Use))
      names(IIVestimateUse) <- names(IIvalues0Use)
      modelSpec <- modelSpec_IQRsysEst(
        POPvalues0 = POPvalues0,
        IIVvalues0 = IIvalues0Use,
        IIVestimate = IIVestimateUse,
        errorModel = errorModel
      )
      est <- IQRsysEst(model,dosing,data,modelSpec)
      projectPath <- paste0(pathModels,"/MODEL",aux_preFillChar(k,3,"0"),"_",names(SPM_IIVvalues0_test)[k])
      proj <- IQRsysProject(est,
                            projectPath = projectPath,
                            SIMOPT.cores=ncores,
                            opt.nfits=1,
                            SIMOPT.nauxtimes = SIMOPT.nauxtimes,
                            SIMOPT.hmax = SIMOPT.hmax,
                            SIMOPT.atol = SIMOPT.atol,
                            SIMOPT.rtol = SIMOPT.rtol)
      proj
    })
    run <- FALSE
    count <- 0
    while(!run) {
      count <- count + 1
      if (count==10) stopIQR("Some real error ...")
      run <- tryCatch({
        run_IQRsysProjectMulti(pM,FLAGgof = FALSE,ncores = 1,Nparallel = Nparallel)
        TRUE
      }, error=function(err) {return(FALSE)})
    }
    results <- do.call(rbind,lapply(seq_along(pM), function (k) {
      p <- pM[[k]]
      res <- tryCatch({
        x <- suppressWarnings(parseNLMEresults(p))
        list(
          OBJ = x$objectivefunction$OBJ,
          RSE = x$rawParameterInfo$fixedEffects$rse[x$rawParameterInfo$fixedEffects$names==names(SPM_IIVvalues0_test)[k]]
        )
      },error=function(err) {
        list(
          OBJ = NA,
          RSE = Inf
        )
      })
      data.frame(
        ParameterIIV = names(SPM_IIVvalues0_test)[k],
        RSEfixedeffect = res$RSE,
        OBJ = res$OBJ,
        stringsAsFactors = FALSE
      )
    }))
    results[,2:3] <- round(results[,2:3],2)
    IQRoutputTable(dplyr::arrange(results,OBJ),xtitle="Results from this run",filename = paste0(pathModels,"/results.txt"))
    results <- dplyr::arrange(results,OBJ)
    resultsALL <- rbind(
      resultsALL,
      cbind(Iteration=Iteration,results[1,])
    )
    addParam <- results$Parameter[1]
    IIVvalues0_current <- c(IIVvalues0_current, SPM_IIVvalues0_test[addParam])
    SPM_IIVvalues0_test <- SPM_IIVvalues0_test[names(SPM_IIVvalues0_test)!=addParam]
    if (length(SPM_IIVvalues0_test)==0) break;
    print(IQRoutputTable(resultsALL,xtitle="Current status of SPM algorithm for individual parameters / random effects"))
    Iteration <- Iteration + 1
  }
  tab <- IQRoutputTable(resultsALL,xtitle="Results of SPM algorithm for individual parameters / random effects",report=TRUE)
  IQRoutputTable(object = tab,report = TRUE,filename = paste0(path,"/results.txt"))
  x <- SPM_IIVvalues0[names(SPM_IIVvalues0) %in% resultsALL$Parameter]
  x <- x[resultsALL$Parameter]
  print(tab)
  cat("\n\n")
  cat(paste0(paste0(names(x)," = ",x),collapse=",\n"))
  if (FLAGclean) {
    x <- list.dirs(path=path,full.names = TRUE,recursive = TRUE)
    dirRemove <- x[grepl("Iteration/MODEL[0-9a-zA-Z_]+/*$",x)]
    unlink(dirRemove,recursive = TRUE,force = TRUE)
  }
  list(
    results = tab,
    param = x
  )
}
#'@export
spm_IQRsysProject <- function (
  path,
  model,
  dosing,
  data,
  SPM_POPvalues0,
  POPvalues0 = NULL,
  errorModel = NULL,
  ncores = 1,
  Nparallel = 1,
  RSEmax = 50,
  RSEmaxRemove = 100,
  FLAGclean = TRUE,
  SIMOPT.nauxtimes = 0,
  SIMOPT.hmax = NULL,
  SIMOPT.atol = 1e-6,
  SIMOPT.rtol = 1e-6
) {
  aux_rmdir(path)
  POPvalues0_current <- POPvalues0
  SPM_POPvalues0_test <- SPM_POPvalues0
  Iteration <- 1
  resultsALL <- data.frame()
  while (length(SPM_POPvalues0_test) > 0) {
    pathModels <- paste0(path,"/",aux_preFillChar(Iteration,3,"0"),"_Iteration")
    pM <- lapply(seq_along(SPM_POPvalues0_test), function (k) {
      modelSpec <- modelSpec_IQRsysEst(
        POPvalues0 = c(
          POPvalues0_current,
          SPM_POPvalues0_test[k]
        ),
        errorModel = errorModel
      )
      est <- IQRsysEst(model,dosing,data,modelSpec)
      projectPath <- paste0(pathModels,"/MODEL",aux_preFillChar(k,3,"0"),"_",names(SPM_POPvalues0_test)[k])
      proj <- IQRsysProject(est,
                            projectPath = projectPath,
                            SIMOPT.cores=ncores,
                            opt.nfits=1,
                            SIMOPT.nauxtimes = SIMOPT.nauxtimes,
                            SIMOPT.hmax=SIMOPT.hmax,
                            SIMOPT.atol = SIMOPT.atol,
                            SIMOPT.rtol = SIMOPT.rtol)
      proj
    })
    run <- FALSE
    count <- 0
    while(!run) {
      count <- count + 1
      if (count==10) stopIQR("Some real error ...")
      run <- tryCatch({
        run_IQRsysProjectMulti(pM,FLAGgof = FALSE,ncores = 1,Nparallel = Nparallel)
        TRUE
      }, error=function(err) {return(FALSE)})
    }
    results <- do.call(rbind,lapply(seq_along(pM), function (k) {
      p <- pM[[k]]
      res <- tryCatch({
        x <- suppressWarnings(parseNLMEresults(p))
        list(
          OBJ = x$objectivefunction$OBJ,
          RSE = x$rawParameterInfo$fixedEffects$rse[x$rawParameterInfo$fixedEffects$names==names(SPM_POPvalues0_test)[k]]
        )
      },error=function(err) {
        list(
          OBJ = NA,
          RSE = Inf
        )
      })
      data.frame(
        Parameter = names(SPM_POPvalues0_test)[k],
        RSE = res$RSE,
        OBJ = res$OBJ,
        stringsAsFactors = FALSE
      )
    }))
    results[,2:3] <- round(results[,2:3],2)
    IQRoutputTable(dplyr::arrange(results,OBJ),xtitle="Results from this run",filename = paste0(pathModels,"/results.txt"))
    paramAboveRSEmax <- results$Parameter[results$RSE>RSEmaxRemove]
    results <- results[results$RSE<=RSEmax,]
    if (nrow(results)==0) break;
    results <- dplyr::arrange(results,OBJ)
    resultsALL <- rbind(
      resultsALL,
      cbind(Iteration=Iteration,results[1,])
    )
    addParam <- results$Parameter[1]
    POPvalues0_current <- c(POPvalues0_current, SPM_POPvalues0_test[addParam])
    SPM_POPvalues0_test <- SPM_POPvalues0_test[names(SPM_POPvalues0_test)!=addParam]
    SPM_POPvalues0_test <- SPM_POPvalues0_test[!names(SPM_POPvalues0_test) %in% paramAboveRSEmax]
    if (length(SPM_POPvalues0_test)==0) break;
    print(IQRoutputTable(resultsALL,xtitle="Current status of SPM algorithm for mean parameters / fixed effects"))
    Iteration <- Iteration + 1
  }
  tab <- IQRoutputTable(resultsALL,xtitle="Results of SPM algorithm for mean parameters / fixed effects",report=TRUE)
  IQRoutputTable(object = tab,report = TRUE,filename = paste0(path,"/results.txt"))
  x <- SPM_POPvalues0[names(SPM_POPvalues0) %in% resultsALL$Parameter]
  x <- x[resultsALL$Parameter]
  print(tab)
  cat("\n\n")
  cat(paste0(paste0(names(x)," = ",x),collapse=",\n"))
  if (FLAGclean) {
    x <- list.dirs(path=path,full.names = TRUE,recursive = TRUE)
    dirRemove <- x[grepl("Iteration/MODEL[0-9a-zA-Z_]+/*$",x)]
    unlink(dirRemove,recursive = TRUE,force = TRUE)
  }
  list(
    results = tab,
    param = x
  )
}
#'@export
getEmpiricalETACovarianceMatrix_IQRsysProject <- function (projectPath) {
  ETAinfo <- getETAs_IQRnlmeProject(projectPath,FLAGcovariate = FALSE)
  ETAinfo$ID <- NULL
  mEta <- as.matrix(ETAinfo)
  empiricalCov <- stats::cov(mEta)
  empiricalCov
}
#'@export
sim_IQRvirtualSubjects <- function(VPpath,
                                   output,
                                   simtime,
                                   dosingTable=NULL,
                                   problow=0.1,
                                   probhigh=0.9,
                                   FLAGindiv=TRUE) {
  model <- IQRmodel(file.path(VPpath,"model.txt"))
  VP <- IQRloadCSVdata(file.path(VPpath,"VirtualSubjects.csv"))
  elements <- VP$NAME
  type <- VP$TYPE
  values <- VP[,grepl("\\<VS[0-9]+",names(VP))]
  Nsubjects <- ncol(values)
  ixStates <- which(type=="State")
  ixParameters <- which(grepl("\\<Parameter",type))
  namesStates <- elements[ixStates]
  namesParameters <- elements[ixParameters]
  res <- do.call(rbind,lapply(1:Nsubjects, function (k) {
    ICs <- values[ixStates,k]
    names(ICs) <- namesStates
    params <- values[ixParameters,k]
    names(params) <- namesParameters
    simres <- sim_IQRmodel(
      model=model,
      simtime=simtime,
      IC=ICs,
      parameters = params,
      dosingTable = dosingTable
    )
    out <- cbind(ID=k,simres[,c("TIME",output)])
    out
  }))
  plotIndiv <- tidyr::gather(res,NAME,VALUE,-TIME,-ID)
  dN <- res[,c("ID","TIME",output)]
  dWide <- tidyr::spread(data = dN,key=ID,value=output)
  TIME <- dWide$TIME
  dWide$TIME <- NULL
  x <- as.matrix(dWide)
  median <- apply(x,1,median,na.rm=TRUE)
  qlow <- apply(x,1,quantile,probs=problow,na.rm=TRUE)
  qhigh <- apply(x,1,quantile,probs=probhigh,na.rm=TRUE)
  stats <- tidyr::gather(data.frame(
    TIME = TIME,
    Median = median,
    Qlow = qlow,
    Qhigh = qhigh
  ),NAME,VALUE,-TIME)
  stats$NAME[stats$NAME=="Qlow"] <- paste0(100*problow,"th Percentile")
  stats$NAME[stats$NAME=="Qhigh"] <- paste0(100*probhigh,"th Percentile")
  p <- IQRggplot(data=plotIndiv[plotIndiv$NAME==output,])
  if (FLAGindiv) p <- p + geom_line(aes(x=TIME,y=VALUE,group=ID),color="grey",alpha=0.3)
  p <- p + geom_line(data = stats, aes(x=TIME,y=VALUE,linetype=NAME),color="#C5000B") +
    scale_linetype_manual("",values=c("dashed","dashed","solid")) +
    xlab("Time") +
    ylab(output)
  list(
    plot = p,
    simdata = res
  )
}
#'@export
"+.IQRrmd" <- function (a,b) {
  out__ <- paste0(a,b)
  class(out__) <- "IQRrmd"
  return(out__)
}
#'@export
print.IQRrmd <- function (x, ...) {
  cat(x)
  cat("\n\nIQRrmd object")
}
#'@export
export_IQRrmd <- function (rmdDoc, filename) {
  filename <- paste0(aux_strrep(filename,".rmd",""),".rmd")
  aux_filewrite(paste0(rmdDoc),filename)
}
#'@export
rmdEMPTY <- function() {
  out__ <- ""
  class(out__) <- "IQRrmd"
  return (out__)
}
#'@export
rmdLINEBREAK <- function() {
  out__ <- "\n"
  class(out__) <- "IQRrmd"
  return (out__)
}
#'@export
rmdPARAGRAPH <- function() {
  out__ <- "\n\n"
  class(out__) <- "IQRrmd"
  return (out__)
}
#'@export
rmdEMPTY <- function() {
  out__ <- ""
  class(out__) <- "IQRrmd"
  return (out__)
}
#'@export
rmdTITLE <- function(template="DefaultStyle.rmdt",
                     title="Default Title",
                     subtitle="Default Subtitle",
                     date=format(Sys.Date(),"%d-%b-%Y")) {
  out__ <-              "=====\n"
  out__ <- paste0(out__,"TITLE:    ",title,"\n")
  out__ <- paste0(out__,"SUBTITLE: ",subtitle,"\n")
  out__ <- paste0(out__,"DATE:     ",date,"\n")
  out__ <- paste0(out__,"TEMPLATE: ",template,"\n")
  out__ <- paste0(out__,"=====\n\n")
  class(out__) <- "IQRrmd"
  return(out__)
}
#'@export
rmdNEWPAGE <- function() {
  out__ <- "\n!NEWPAGE\n"
  class(out__) <- "IQRrmd"
  return (out__)
}
#'@export
rmdAPPROVALS <- function() {
  out__ <- "\n!APPROVALS\n"
  class(out__) <- "IQRrmd"
  return (out__)
}
#'@export
rmdNOINTRO <- function() {
  out__ <- "\n!NOINTRO\n"
  class(out__) <- "IQRrmd"
  return (out__)
}
#'@export
rmdLANDSCAPE <- function() {
  out__ <- "\n!LANDSCAPE\n"
  class(out__) <- "IQRrmd"
  return (out__)
}
#'@export
rmdPORTRAIT <- function() {
  out__ <- "\n!PORTRAIT\n"
  class(out__) <- "IQRrmd"
  return (out__)
}
#'@export
rmdSECTION <- function(title="Section Title",label=NULL,level=1,numbered=TRUE) {
  out__ <- paste0("\n\n",paste0(rep("#",level),collapse=""))
  if (!numbered)
    out__ <- paste0(out__,"*")
  out__ <- paste0(out__," ",title)
  if (!is.null(label))
    out__ <- paste0(out__," {#",label,"}")
  out__ <- paste0(out__,"\n")
  class(out__) <- "IQRrmd"
  return(out__)
}
#'@export
rmdURL <- function(url="http://www.intiquan.com",caption=NULL) {
  out__ <- "!URL"
  if (!is.null(caption))
    out__ <- paste0(out__,"[",caption,"]")
  out__ <- paste0(out__,"(",url,")")
  class(out__) <- "IQRrmd"
  return (out__)
}
#'@export
rmdCOMMENT <- function(comment="some comment",author=NULL) {
  out__ <- "!COM"
  if (!is.null(author))
    out__ <- paste0(out__,"[author:",author,"]")
  out__ <- paste0(out__,"{",comment,"}")
  class(out__) <- "IQRrmd"
  return (out__)
}
#'@export
rmdTXT <- function(file,caption=NULL,fontsize=10,style="CODE",label=NULL) {
  out__ <- "\n!TXT"
  if (!is.null(c(caption,style,label))) {
    opttext__ <- ""
    if (!is.null(caption))
      opttext__ <- paste0(opttext__,"caption:",caption,",")
    if (!is.null(style))
      opttext__ <- paste0(opttext__,"style:",style,"(",fontsize,"),")
    if (!is.null(label))
      opttext__ <- paste0(opttext__,"label:",label,",")
    if (substr(opttext__,nchar(opttext__),nchar(opttext__))==",") opttext__ <- substr(opttext__,1,nchar(opttext__)-1)
    out__ <- paste0(out__,"[",opttext__,"]")
  }
  out__ <- paste0(out__,"(",file,")\n")
  class(out__) <- "IQRrmd"
  return (out__)
}
#'@export
rmdTABLE <- function(file,caption=NULL,fontsize=10,label=NULL,
                     ignoreCaption=FALSE,
                     valueTable=FALSE) {
  out__ <- "\n!TAB"
  if (!is.null(c(caption,fontsize,label,ignoreCaption,valueTable))) {
    opttext__ <- ""
    if (!is.null(caption))
      opttext__ <- paste0(opttext__,"caption:",caption,",")
    if (!is.null(fontsize))
      opttext__ <- paste0(opttext__,"size:",fontsize,",")
    if (!is.null(label))
      opttext__ <- paste0(opttext__,"label:",label,",")
    if (ignoreCaption) {
      opttext__ <- paste0(opttext__,"ignoreCaption:true,")
    } else {
      opttext__ <- paste0(opttext__,"ignoreCaption:false,")
    }
    if (valueTable) {
      opttext__ <- paste0(opttext__,"valueTable:true,")
    } else {
      opttext__ <- paste0(opttext__,"valueTable:false,")
    }
    if (substr(opttext__,nchar(opttext__),nchar(opttext__))==",") opttext__ <- substr(opttext__,1,nchar(opttext__)-1)
    out__ <- paste0(out__,"[",opttext__,"]")
  }
  out__ <- paste0(out__,"(",file,")\n")
  class(out__) <- "IQRrmd"
  return (out__)
}
#'@export
rmdTABLEDF <- function(df,caption=NULL,fontsize=10,label=NULL,ignoreCaption=FALSE,valueTable=FALSE,footertext=NULL) {
  out__ <- "\n!TABINLINE["
  if (!is.null(caption))
    out__ <- paste0(out__,"caption:",caption,",")
  if (!is.null(fontsize))
    out__ <- paste0(out__,"size:",fontsize,",")
  if (!is.null(label))
    out__ <- paste0(out__,"label:",label,",")
  if (ignoreCaption) {
    out__ <- paste0(out__,"ignoreCaption:true,")
  } else {
    out__ <- paste0(out__,"ignoreCaption:false,")
  }
  if (valueTable) {
    out__ <- paste0(out__,"valueTable:true")
  } else {
    out__ <- paste0(out__,"valueTable:false")
  }
  out__ <- paste0(out__,"]")
  out__
  headerNames__ <- names(df)
  dfchar__ <- data.frame(
    lapply(df, function (x__) {
      out__ <- as.character(x__)
      out__[is.na(out__)] <- "NA"
      out__ <- gsub(pattern="\n",replacement="",x=out__)
      out__ <- gsub(pattern="\r",replacement="",x=out__)
      out__
    })
    ,stringsAsFactors=FALSE
  )
  ncharCol__ <- sapply(1:ncol(dfchar__), function (y__) max(nchar(headerNames__[y__]),max(nchar(dfchar__[[y__]]))))
  headerExp__ <- sapply(seq_along(headerNames__), function(k__) aux_postFillChar(value2postfill=headerNames__[k__],lengthString=ncharCol__[k__],fillChar=" ") )
  headerLine__ <- sapply(headerExp__, function (x__) paste0(rep("-",nchar(x__)),collapse=""))
  headerOut__ <- paste0("| ",
                        paste(headerExp__,collapse = " | "),
                        " |\n",
                        "| ",
                        paste(headerLine__,collapse = " | "),
                        " |\n")
  textContent__ <- paste0(sapply(1:nrow(dfchar__), function (nrow__) {
    textExp__ <- sapply(seq_along(headerNames__), function(k__) aux_postFillChar(value2postfill=dfchar__[nrow__,k__],lengthString=ncharCol__[k__],fillChar=" ") )
    textOut__ <- paste0("| ",
                        paste(textExp__,collapse = " | "),
                        " |\n")
  }),collapse="")
  tableOut__ <- paste0("\n",headerOut__,textContent__)
  if (!is.null(footertext)) {
    footertext <- gsub("\n","<br>",footertext)
    tableOut__ <- paste0(tableOut__,"{",footertext,"}")
  }
  out__ <- paste0(out__,tableOut__)
  class(out__) <- "IQRrmd"
  return (out__)
}
#'@export
rmdFIGURE <- function(file,
                      caption=NULL,label=NULL,
                      legend=NULL,
                      pages=NULL,
                      scale=100, crop=TRUE,
                      repeatLegend=TRUE,
                      ignoreCaption=FALSE) {
  out__ <- "\n!FIG"
  if (!is.null(c(caption,label,legend,pages,scale,crop,repeatLegend,ignoreCaption))) {
    opttext__ <- ""
    if (!is.null(caption))
      opttext__ <- paste0(opttext__,"caption:",caption,",")
    if (!is.null(label))
      opttext__ <- paste0(opttext__,"label:",label,",")
    if (!is.null(pages))
      opttext__ <- paste0(opttext__,"pages:",pages,",")
    if (!is.null(scale))
      opttext__ <- paste0(opttext__,"scale:",scale,",")
    if (crop) {
      opttext__ <- paste0(opttext__,"crop:true,")
    } else {
      opttext__ <- paste0(opttext__,"crop:false,")
    }
    if (ignoreCaption) {
      opttext__ <- paste0(opttext__,"ignoreCaption:true,")
    } else {
      opttext__ <- paste0(opttext__,"ignoreCaption:false,")
    }
    if (repeatLegend) {
      opttext__ <- paste0(opttext__,"repeatLegend:true,")
    } else {
      opttext__ <- paste0(opttext__,"repeatLegend:false,")
    }
    if (substr(opttext__,nchar(opttext__),nchar(opttext__))==",") opttext__ <- substr(opttext__,1,nchar(opttext__)-1)
    out__ <- paste0(out__,"[",opttext__,"]")
  }
  out__ <- paste0(out__,"(",file,")")
  if (!is.null(legend))
    out__ <- paste0(out__,"\n{\n",gsub("\n","  \n",legend),"\n}")
  out__ <- paste0(out__,"\n")
  class(out__) <- "IQRrmd"
  return (out__)
}
#'@export
rmdPDF <- function(file,pages=NULL,scale=100,crop=TRUE) {
  out__ <- "\n!PDF"
  if (!is.null(c(pages,scale,crop))) {
    opttext__ <- ""
    if (!is.null(pages))
      opttext__ <- paste0(opttext__,"pages:",pages,",")
    if (!is.null(scale))
      opttext__ <- paste0(opttext__,"scale:",scale,",")
    if (crop) {
      opttext__ <- paste0(opttext__,"crop:true,")
    } else {
      opttext__ <- paste0(opttext__,"crop:false,")
    }
    if (substr(opttext__,nchar(opttext__),nchar(opttext__))==",") opttext__ <- substr(opttext__,1,nchar(opttext__)-1)
    out__ <- paste0(out__,"[",opttext__,"]")
  }
  out__ <- paste0(out__,"(",file,")")
  out__ <- paste0(out__,"\n")
  class(out__) <- "IQRrmd"
  return (out__)
}
#'@export
rmdSECref <- function(label,caption=NULL) {
  out__ <- " @SEC"
  if (!is.null(caption))
    out__ <- paste0(out__,"[",caption,"]")
  out__ <- paste0(out__,"(",label,")")
  class(out__) <- "IQRrmd"
  return (out__)
}
#'@export
rmdTXTref <- function(label,caption=NULL) {
  out__ <- " @TXT"
  if (!is.null(caption))
    out__ <- paste0(out__,"[",caption,"]")
  out__ <- paste0(out__,"(",label,")")
  class(out__) <- "IQRrmd"
  return (out__)
}
#'@export
rmdFIGref <- function(label,caption=NULL) {
  out__ <- " @FIG"
  if (!is.null(caption))
    out__ <- paste0(out__,"[",caption,"]")
  out__ <- paste0(out__,"(",label,")")
  class(out__) <- "IQRrmd"
  return (out__)
}
#'@export
rmdTABref <- function(label,caption=NULL) {
  out__ <- " @TAB"
  if (!is.null(caption))
    out__ <- paste0(out__,"[",caption,"]")
  out__ <- paste0(out__,"(",label,") ")
  class(out__) <- "IQRrmd"
  return (out__)
}
#'@export
rmdVALref <- function(labelTable,row=NULL,col=NULL,labelValue=NULL) {
  if (!is.null(labelValue)) {
    out__ <- paste0(" @VAL[",labelValue,"](",labelTable,") ")
  } else {
    out__ <- paste0(" @VAL[",row,",",col,"](",labelTable,") ")
  }
  class(out__) <- "IQRrmd"
  return (out__)
}
#'@export
rmdTEXTSTYLE <- function(text,color=NULL,size=NULL,style=NULL) {
  if (is.null(color) & is.null(size) & is.null(style)) {
    out__ <- text
  } else {
    out__ <- "!TEXTSTYLE["
    x1__ <- NULL
    x2__ <- NULL
    x3__ <- NULL
    if (!is.null(color)) x1__ <- paste0("color=",color)
    if (!is.null(size)) x2__ <- paste0("size=",size)
    if (!is.null(style)) x3__ <- paste0("style=",style)
    out__ <- paste0(out__,paste0(c(x1__,x2__,x3__),collapse = ","),"](",text,")")
  }
  class(out__) <- "IQRrmd"
  return (out__)
}
#'@export
IQReport <- function(RMDfilePath){
  if (!has_IQReport_executable())
    stopIQR("The IQReport executable has not been installed.\nYou can obtain IQReport from here: http://www.intiquan.com/iqreport-the-reporting-solution/")
  RMDfilePath <- paste0(aux_strrep(RMDfilePath,".rmd",""),".rmd")
  if (!file.exists(RMDfilePath))
    stopIQR("The provided RMDfilePath argument does not point to an '.rmd' file (case sensitive)")
  if (grepl("~",RMDfilePath,fixed = TRUE))
    stopIQR("The use of '~' in path names is not allowed. Please use a relative path instead!")
  if (grepl(":",RMDfilePath,fixed = TRUE))
    stopIQR("The use of ':' in path names is not allowed. Please use a relative path instead!")
  if (.Platform$OS.type=="windows") {
    oldpath <- getwd()
    fp      <- aux_fileparts(RMDfilePath)
    setwd(fp$pathname)
    RMDfilePathAbsolute <- paste0(getwd(),"/",fp$filename,fp$fileext)
    setwd(oldpath)
    callIQReport <- paste0(.PATH_IQRreport,' "',RMDfilePathAbsolute,'"')
    oldpath <- getwd()
    setwd(aux_fileparts(.PATH_IQRreport)$pathname)
    system(callIQReport)
    setwd(oldpath)
  } else {
    system(paste0("IQReport.sh ",RMDfilePath))
  }
  aux_rmdir("tmp")
  unlink("*.rmd.bak")
}
#'@export
has_IQReport_executable <- function(){
  loadSetupOptions_IQRtools()
  if (file.exists(.PATH_IQRreport)) return(TRUE)
  return(FALSE)
}
#'@export
IQRcoxRegression <- function (
  data,
  TIMEcol,
  CENScol,
  PREDcol         = NULL,
  IDcol           = "ID",
  PREDinteraction = NULL,
  PREDval         = NULL,
  RHSformula      = NULL,
  ci.level        = 0.95,
  xlab            = NULL,
  ylab            = NULL,
  pathname        = NULL,
  FLAGreport      = TRUE,
  SIGNIF          = 4
) {
  data__ <- data
  if (!is.null(RHSformula)) {
    if (!("formula" %in% class(RHSformula))) {
      if (strtrim(RHSformula,1) != "~") RHSformula <- paste0("~", RHSformula)
      RHSformula <- stats::as.formula(RHSformula)
    }
    if (length(RHSformula) > 2) stopIQR("Only RHS of formula should given.")
    PREDcol <- all.vars(RHSformula[[length(RHSformula)]])
    PREDinteractionTerms__ <- setdiff(attr(stats::terms(RHSformula), "term.labels"), PREDcol)
  }
  if (!TIMEcol %in% names(data__)) stopIQR("The TIMEcol column is not present in the data")
  if (!CENScol %in% names(data__)) stopIQR("The CENScol column is not present in the data")
  if (!all(sort(unique(data__[[CENScol]])) == c(0,1))) stopIQR("The CENScol column does not contain only 0s and 1s")
  idxNAvar <- is.na(data__[[TIMEcol]]) | is.na(data__[[CENScol]])
  if (any(idxNAvar)) { 
    warningIQR(paste0(sum(idxNAvar)," subjects have NA values for the event time or type."))
  }
  if (!all(PREDcol %in% names(data__))) stopIQR("One or more PREDcol columns are not present in the data")
  if ("Intercept" %in% c(PREDcol,TIMEcol, CENScol)) stopIQR("'Intercept' is not allowed to be used as predictor, time, or censoring name.")
  PREDcolCAT <- PREDcol[sapply(data__[,PREDcol, drop = FALSE], class) %in% c("factor","character")]
  CATval__ <- do.call(rbind,lapply(PREDcolCAT, function(xx__) {
    out__ <- data.frame(
      PREDcol = xx__,
      category = levels(factor(data__[[xx__]])),
      stringsAsFactors = FALSE
    )
    out__ <- within(out__, {
      label0 <- paste0(PREDcol,category)
      label1 <- paste0(PREDcol,"=",category,"")
    })
    out__
  }))
  if (is.null(RHSformula)) {
    if (!is.null(PREDinteraction)) {
      PREDinteraction <- lapply(as.list(PREDinteraction), function(x) trimws(aux_explode(x, separator = ",")))
      if (!all(unlist(PREDinteraction) %in% PREDcol)) stopIQR("Interaction given for unknown predictors.")
      PREDinteractionTerms__ <- c(); lfd <- 0
      for (k__ in seq_along(PREDinteraction)) {
        nk__ <- length(PREDinteraction[[k__]])
        for (kk__ in 1:(nk__-1)) {
          for (kkk__ in (kk__+1):nk__) {
            lfd <- lfd+1
            PREDinteractionTerms__[lfd] <- paste0(PREDinteraction[[k__]][kk__], ":" , PREDinteraction[[k__]][kkk__])
          }
        }
      }
    } else {
      PREDinteractionTerms__ <- NULL
    }
  }
  if (!IDcol %in% names(data__)) {
    data__$ID <- 1:nrow(data__)
    IDcol <- "ID"
  }
  if (!is.null(PREDval)) {
    names(PREDval) <- gsub(",",":",names(PREDval), fixed = TRUE)
    idxInvalid__ <- !(names(PREDval) %in% c(PREDcol, PREDinteractionTerms__, "Intercept"))
    if (any(idxInvalid__)) {
      warningIQR(paste0("'",names(PREDval)[idxInvalid__], "'", collapse = ", "), " are no valid predictor terms. Input will be ignored.\nIn case values for interaction terms should be fixed, they need to be given in the same order as in PREDinteraction or in the given formula.")
      PREDval <- PREDval[!idxInvalid__]
    }
  }
  if (!is.null(xlab)) {
    if (length(xlab) != length(PREDcol))
      stopIQR("Number of given x-axis labels need to correspond to number of predictor variables.")
    names(xlab) <- PREDcol
  } else {
    xlab <- structure(PREDcol, names = PREDcol)
  }
  if (is.null(ylab)) ylab <- paste0("Survival")
  if (ci.level <= 0 | ci.level >= 1) { stopIQR("Confidence levels needs to be between 0 and 1.")
  } else {
    CIlabel <- paste0("CI",c("lb", "ub"),ci.level*100)
    CIrangeLabel <- paste0(ci.level*100, "% CI")
    CIfact <- stats::qnorm(1-(1-ci.level)/2)
  }
  if (!is.numeric(SIGNIF)) {warningIQR("Given number of siginificant digits (SIGNIF) not numerical. Default will be used (4)"); SIGNIF = 4}
  if (is.null(RHSformula) | !is.null(PREDval)) {
    RHSterms0__ <- c(PREDcol, PREDinteractionTerms__)
    RHSterms__ <- RHSterms0__
    if (!is.null(PREDval)){
      for (kfix in names(PREDval)) {
        if (kfix == "Intercept") {
          RHSterms__ <- c(RHSterms__, paste0("offset(", PREDval[[kfix]], "*Intercept)"))
        } else {
          idxFixed <- RHSterms__ == kfix
          RHSterms__[idxFixed] <- paste0("offset(", PREDval[[kfix]], "*", gsub(":","*",RHSterms__[idxFixed], fixed = TRUE), ")")
        }
      }
    }
    RHS0__ <- paste0(RHSterms0__, collapse = "+")
    RHS__ <- paste0(RHSterms__, collapse = "+")
  } else {
    RHS0__ <- gsub("~","",deparse(RHSformula))
    RHS__ <- RHS0__
  }
  if (RHS__ == "") stopIQR("No predictor variable.")
  formula0__ <- paste0("COX~",RHS0__)
  formula__ <- paste0("COX~",RHS__)
  data__$COX <- survival::Surv(time = data__[[TIMEcol]], event = 1-data__[[CENScol]])
  funCall__ <- paste0("fit <- survival::coxph(",formula__,", data=data__, x=TRUE, y=TRUE)")
  eval(parse(text=funCall__))
  fitsummary__ <- summary(fit, conf.int = ci.level)
  phtest__ <- survival::cox.zph(fit,transform = "km",global=TRUE)
  if (nrow(phtest__$table) == 1) {
    phtest__$table <- phtest__$table[c(1,1),]
    rownames(phtest__$table) <- c(rownames(phtest__$table)[1], "GLOBAL")
  }
  estimates__ <- data.frame(
    Parameter = names(fit$coefficients),
    Value     = exp(fit$coefficients),
    CI.lower = fitsummary__$conf.int[,3],
    CI.upper = fitsummary__$conf.int[,4],
    Pvalue   = fitsummary__$coefficients[,5],
    stringsAsFactors = FALSE
  )
  if (!(is.null(PREDval)|length(PREDval)==0)) {
    fixed__ <- data.frame(
      Parameter = names(PREDval),
      Value     = PREDval,
      CI.lower = NA,
      CI.upper = NA,
      Pvalue   = NA,
      stringsAsFactors = FALSE
    )
    estimates__ <- rbind(estimates__, fixed__)
  }
  objval__ <- data.frame(Parameter = c("GLOBAL"), OBJ = -2*logLik(fit), DF = fitsummary__$logtest[["df"]], DeltaOBJ = -2*diff(fit$loglik), stringsAsFactors = FALSE)
  phtestres__ <- data.frame(Parameter = rownames(phtest__$table), "p_PH" = phtest__$table[,"p"], stringsAsFactors = FALSE)
  estimates__ <- dplyr::left_join(estimates__, phtestres__, by = "Parameter")
  objval__ <- dplyr::left_join(objval__, phtestres__, by = "Parameter")
  for (k in seq_along(CATval__$label0)) {
    estimates__$Parameter <- gsub(CATval__$label0[k],CATval__$label1[k],estimates__$Parameter)
  }
  names(estimates__) <- c("Parameter", "Value", CIlabel, "P_value", "P_value_PH")
  names(objval__) <- c("Parameter", "OBJ", "DF", "DeltaOBJ", "P_value_PH")
  plotList__ <- plot_IQRcoxRegression(
    fit,
    xlab = xlab,
    ylab = ylab,
    ci.level = ci.level,
    filename = NULL
  )
  esttable__ <- estimates__ 
  esttable__ <- dplyr::mutate_if(esttable__, is.numeric, function(x) signif(x, SIGNIF))
  esttable__ <- format(data.frame(lapply(esttable__,function (x) as.character(x)),stringsAsFactors = FALSE),justify="left")
  esttable__ <- data.frame(lapply(esttable__, function(x) {x[grepl("^NA$", trimws(x))] <- "-"; x} ))
  colLB__ <- grep("CIlb", names(esttable__))
  colUB__ <- grep("CIub", names(esttable__))
  CIrange <- paste0("[", esttable__[[colLB__]],", ", esttable__[[colUB__]], "]")
  CIrange[esttable__[[colLB__]] == "-"] <- "-"
  esttable__[[colLB__]] <- CIrange
  names(esttable__)[colLB__] <- CIrangeLabel
  esttable__[[colUB__]] <- NULL
  objvalADD__ <- objval__
  objvalADD__ <- dplyr::mutate_if(objvalADD__, is.numeric, function(x) signif(x, SIGNIF))
  objvalADD__ <- dplyr::mutate(objvalADD__, Parameter = "")
  esttable__ <- rbind(esttable__, rep("",ncol(esttable__)))
  esttable__ <- rbind(esttable__, gsub("Parameter","**Metrics**",names(objval__)))
  esttable__ <- rbind(esttable__, unlist(objvalADD__))
  xtitle__ <- paste0("Estimates for Cox proportional hazards regression model")
  xfooter__ <- paste0("Model: ",formula0__, "\nImplemented as: ", funCall__)
  for (k in PREDcolCAT) {
    refCatk__ <- levels(factor(data__[[k]]))[1]
    xfooter__ <- paste0(xfooter__, paste0("\nReference category for ", k, ": ", refCatk__))
  }
  xfooter__ <- paste0(xfooter__, "\nValue: Hazard ratio estimate for predictor. OBJ: -2*log-likelihood, DeltaOBJ: OBJ difference to null model. P_value: statistical significance of predictor variable. P-value_PH: p-value for testing proportional hazard assumption (valid assumption if >0.05, value in OBJ row is global value).")
  xfooter__ <- paste0(xfooter__, "\nValues rounded to ", SIGNIF, " significant digits.")
  table__ <- IQRoutputTable(esttable__, xtitle = xtitle__, xfooter = xfooter__, filename = NULL, report = FLAGreport)
  out__ <- table__
  attr(out__, "estimates") <- estimates__
  attr(out__, "metrics") <- objval__
  attr(out__, "fit") <- fit
  attr(out__, "formula") <- formula0__
  attr(out__, "plots") <- plotList__
  class(out__) <- c("IQRcoxRegression", class(out__))
  if (!is.null(pathname)) {
    export_IQRcoxRegression(out__, pathname, FLAGreport = FLAGreport)
  }
  out__
}
#'@export
summary_IQRcoxRegression <- function(x,
                                          basemodel   = NULL,
                                          FLAGorder   = FALSE,
                                          filename    = NULL,
                                          SIGNIF      = 4,
                                          FLAGreport  =TRUE,
                                          FLAGformula = FALSE,
                                          title       = NULL,
                                          footerAdd   = NULL) {
  idxFolder__ <- !sapply(lapply(x, class), function(yy) "IQRcoxRegression" %in% yy)
  if (any(idxFolder__)) {
    idxFolder__ <- which(idxFolder__)
    for (k in idxFolder__) {
      if (!is.character(x[[k]]) | length(x[[k]]) != 1) stopIQR("For elements not being an IQRcoxRegression object, path to a project folder needs to be given.")
      x[[k]] <- import_IQRcoxRegression(x[[k]])
    }
  }
  modelNames__ <- names(x)
  if (is.null(modelNames__)) {modelNames__ <- paste0("Model_", sprintf("%.2d",seq_along(x))); names(x) <- modelNames__}
  esttables__ <- lapply(x, function(x__) attr(x__, "estimates"))
  estobj__    <- lapply(x, function(x__) attr(x__, "metrics"))
  estsumm__   <- lapply(x, function(x__) summary(attr(x__, "fit")))
  ci.level <- sapply(x, function(x__) gsub("% CI","",grep("CI", names(x__$xtable), value = TRUE), fixed = TRUE))
  if (length(unique(ci.level)) != 1) {
    warningIQR("Confidence level for models are not same.")
    ci.level <- NA
  } else {
    ci.level <- ci.level[1]
  }
  reformat <- function(x__) {
    val__ <- paste0(signif(x__[,"Value"], SIGNIF), " (",
                    signif(x__[,grep("^CIlb",names(x__))], SIGNIF), ",",
                    signif(x__[,grep("^CIub",names(x__))], SIGNIF),")")
    val__ <- gsub(" (NA,NA)","",val__, fixed = TRUE)
    pval__ <- x__[,"P_value"]; pval__[is.na(pval__)] <- 1
    pars__ <- x__[,"Parameter"]
    idxSIG1 <- pval__ < 0.05; val__ <- ifelse(idxSIG1, paste0(val__, "*"), val__)
    idxSIG2 <- pval__ < 0.01; val__ <- ifelse(idxSIG2, paste0(val__, "*"), val__)
    idxSIG3 <- pval__ < 0.001; val__ <- ifelse(idxSIG3, paste0(val__, "*"), val__)
    y__ <- data.frame(t(val__), stringsAsFactors = FALSE); names(y__) <- pars__
    y__
  }
  table__ <- do.call(dplyr::bind_rows, lapply(esttables__, reformat))
  table__$Model <- modelNames__
  table__[is.na(table__)] <- "-"
  metrics__ <- dplyr::bind_rows(estobj__, .id = "Model")
  metrics__ <- dplyr::mutate(metrics__, Parameter = NULL, )
  table__   <- dplyr::left_join(table__, metrics__, by = "Model")
  table__   <- dplyr::mutate(table__,
                             OBJ = signif(OBJ, SIGNIF), DeltaOBJ = signif(DeltaOBJ, SIGNIF), P_value_PH = signif(P_value_PH, SIGNIF))
  FLAGbase <- FALSE
  if (!is.null(basemodel)) {
    if (is.numeric(basemodel)) {
      idxbase__ <- basemodel
      namebase__ <- table__$Model[idxbase__]    } else {
      namebase__ <- basemodel
      idxbase__ <- which(table__$Model == namebase__)
    }
    if (length(idxbase__) == 0) warningIQR("Base model could not be identified by given name.")
    else {
      FLAGbase <- TRUE
      objall__ <- sapply(estsumm__, function(xx__) -2*xx__$loglik[2])
      OBJbase__ <- objall__[idxbase__]
      DFbase__ <- table__$DF[idxbase__]
      table__$DeltaOBJ <- signif(objall__ - OBJbase__, SIGNIF)
      table__$DeltaDF  <- table__$DF  - DFbase__
      table__$DeltaOBJ[idxbase__] <- "(base)"
      table__$DeltaDF[idxbase__] <- "(base)"
    }
  }
  if (FLAGorder) {
    table__ <- table__[order(table__[["OBJ"]]),]
  }
  idxModel__ <- which(names(table__) == "Model")
  idxOBJ__ <- which(names(table__) %in% c("OBJ", "DF","DeltaOBJ", "DeltaDF", "P_value_PH"))
  idxCore__ <- which(!names(table__) %in% c("Model","OBJ", "DF","DeltaOBJ", "DeltaDF", "P_value_PH"))
  table__ <- table__[,c(idxModel__, idxOBJ__, idxCore__)]
  if (FLAGformula)
    table__$Formula <- sapply(x, function(x__) attr(x__,"formula"))
  if (is.null(title))
    title__ <- "Comparison of Cov proportional hazard regression models"
  footer__ <- paste0("Estimates with ",ci.level,"%-confidence intervals\nSignificance: * <0.05, ** <0.01, *** <0.001\n",
                     "Values rounded to ",SIGNIF, " digits.\nOBJ: -2*log-likelihood; DF: Degrees of freedom; P_value_PH: global test for proportional hazards (valid assumption if >0.05); ")
  if (FLAGbase) {
    footer__ <- paste0(footer__, "DeltaOBJ: OBJ difference to base model; DeltaDF: DF difference to base model.")
  } else {
    footer__ <- paste0(footer__, "DeltaOBJ: OBJ difference to respective null model.")
  }
  if (FLAGorder)
    footer__ <- paste0(footer__, "\nModels ordered by objective function value.")
  if (!is.null(footerAdd))
    footer__ <- paste0(footer__, "\n", footerAdd)
  if (!is.null(filename)) {
    filename <- paste0(aux_strrep(filename,".txt",""),".txt")
    IQRoutputTable(xtable=table__,xfooter=footer__,xtitle=title__,report=FLAGreport,filename=filename)
    return(invisible(NULL))
  }
  output__ <- IQRoutputTable(xtable=table__,xfooter=footer__,xtitle=title__,report=FLAGreport)
  output__
}
#'@export
export_IQRcoxRegression <- function(obj, pathname, FLAGreport = TRUE) {
  if (!("IQRcoxRegression" %in% class(obj))) stopIQR("Input object is no IQRcoxRegression object.")
  filename__ <- file.path(pathname, "parameters_table.txt")
  table__ <- IQRoutputTable(obj$xtable, xtitle = obj$xtitle, xfooter = obj$xfooter, filename = filename__, report = FLAGreport, na.string = "-")
  filename__ <- file.path(pathname, "estimates.csv")
  IQRoutputCSV(attr(obj,"estimates"), filename = filename__)
  filename__ <- file.path(pathname, "DiagnosticPlots.pdf")
  IQRoutputPDF(attr(obj,"plots"), filename = filename__)
  filename__ <- file.path(pathname, "fittedModel.rds")
  saveRDS(attr(obj,"fit"), file = filename__)
  filename__ <- file.path(pathname, "fittedProject.rds")
  saveRDS(obj, file = filename__)
  return(invisible(NULL))
}
#'@export
import_IQRcoxRegression <- function(pathname) {
  filename__ <- file.path(pathname, "fittedProject.rds")
  if (!file.exists(filename__)) stopIQR("Given folder does not seem to contain IQRcoxRegression object.")
  obj__ <- readRDS(filename__)
  if (!("IQRcoxRegression" %in% class(obj__))) stopIQR("Object loaded is no IQRcoxRegression object.")
  return(obj__)
}
#'@export
plot_IQRcoxRegression <- function(
  fit,
  xlab = NULL,
  ylab = NULL,
  ci.level = 0.95,
  filename = NULL
) {
  inclass__ <- class(fit)
  if (!any(c("coxph", "IQRcoxRegression") %in% inclass__)) stopIQR("Input needs to be IQRcoxRegression or coxph object.")
  if ("IQRcoxRegression" %in% inclass__) {
    fit__ <- attr(fit, "fit")
  } else {
    fit__ <- fit
  }
  if (ci.level <= 0 | ci.level >= 1) { stopIQR("Confidence levels needs to be between 0 and 1.")
  } else {
    CIlabel <- paste0(ci.level*100, "%-CI")
  }
  if (is.null(xlab)) xlab = "Time"
  if (is.null(ylab)) ylab = "Survival"
  kmObs <- survival::survfit(fit$y~1)
  dataObs <- with(kmObs, data.frame(TIME = time, SURV = surv, LB = lower, UB = upper, which = "observed") )
  kmFit <- survival::survfit(fit)
  dataFit <- with(kmFit, data.frame(TIME = time, SURV = surv, LB = lower, UB = upper, which = "predicted") )
  dataPlot <- rbind(dataObs, dataFit)
  dataPlot <- plyr::ddply(dataPlot, ~which, function(dat) {
    datAdd <- dat[1:(nrow(dat)-1),]
    datAdd$TIME <- dat$TIME[2:nrow(dat)]
    out <- rbind(dat, datAdd)
    out <- dplyr::arrange(out, TIME, desc(SURV))
    out
  })
  dataPlotObs <- dplyr::filter(dataPlot, which == "observed")
  dataPlotObs <- tidyr::gather(dataPlotObs, key = "what", value = "value", SURV, LB, UB)
  dataPlotFit <- dplyr::filter(dataPlot, which == "predicted")
  pObsPred <- IQRggplot(dataPlotObs, aes(TIME)) +
    geom_line(aes(y=value, linetype=what)) +
    geom_line(data=dataPlotFit, aes(y=SURV), color = "firebrick", linetype = 4) +
    geom_ribbon(data=dataPlotFit, aes(ymin=LB,ymax=UB), alpha = 0.3, fill = "firebrick") +
    scale_linetype_manual(values=c("SURV"=1,"LB"=2,"UB"=2)) +
    theme(legend.position = "none") +
    labs(x=xlab, y=ylab, title = "Predicted and observed survival",
         caption = paste0("Black lines: KM curve of observations with ", CIlabel, "\nRed line and area: Predicted median and ", CIlabel))
  residuals__ <- data.frame(Deviance = stats::residuals(fit))
  pDevHist <- IQRggplot(residuals__, aes(Deviance)) + geom_histogram()
  plotList__ <- list(ObsPred = pObsPred, DevianceHistogramm = pDevHist)
  if (!is.null(filename)) {
    IQRoutputPDF(plotList__, filename = filename, onefile = TRUE)
    return(invisible(NULL))
  }
  plotList__
}
#'@export
IQRtable <- function(data, stat, ...) {
  stat.char__ <- deparse(substitute(stat))
  stat.fn__ <- with(data, eval(parse(text = stat.char__)))
  keywords.stat__ <- attr(stat.fn__, "keywords")
  keywords.data__ <- setdiff(names(data), keywords.stat__)
  keywords__ <- c(keywords.data__, keywords.stat__)
  keywords__ <- keywords__[order(nchar(keywords__), decreasing = TRUE)]
  output__ <- lapply(list(...), function(o) rep(o, nrow(data)))
  output__ <- lapply(output__, function(output.column__) {
    used__ <- sapply(keywords__, function(k) grepl(k, output.column__[1]))
    if (!any(used__)) return(output.column__)
    for (k in keywords__[used__]) {
      replacement__ <- NULL
      if (k %in% keywords.stat__) replacement__ <- stat.fn__(k)
      if (k %in% keywords.data__) replacement__ <- data[[k]]
      if (length(replacement__) > 0)
        output.column__ <- sapply(seq_along(output.column__), function(i) gsub(k, replacement__[i], output.column__[i]))
    }
    return(output.column__)
  })
  header__ <- matrix(names(output__), nrow = 1)
  body__ <- do.call(cbind, output__)
  table__ <- rbind(header__, body__)
  as_IQRtable(table__)
}
#'@export
as_IQRtable <- function(x) {
  UseMethod("as_IQRtable", x)
}
#'@export
as_IQRtable.IQRtable <- function(x) x
#'@export
as_IQRtable.matrix <- function(x) {
  dims__ <- dim(x)
  out__ <- matrix(as.character(x), dims__[1], dims__[2])
  colnames(out__) <- rownames(out__) <- NULL
  class(out__) <- c("IQRtable", "matrix")
  return(out__)
}
#'@export
as_IQRtable.data.frame <- function(x) {
  out__ <- rbind(
    names(x),
    as.matrix(as.data.frame(lapply(x, as.character)))
  )
  rownames(out__) <- colnames(out__) <- NULL
  class(out__) <- c("IQRtable", "matrix")
  return(out__)
}
#'@export
as_IQRtable.character <- function(x) {
  out__ <- as.matrix(x, nrow = 1)
  as_IQRtable.matrix(out__)
}
#'@export
as_IQRtable.numeric <- function(x) {
  as_IQRtable.character(as.character(x))
}
#'@export
is_IQRtable <- function(x) {
  inherits(x, "IQRtable")
}
#'@export
"[.IQRtable" <- function(x, i, j, drop = FALSE) {
  x__ <- unclass(x)
  x__[i, j, drop = drop]
}
#'@export
print.IQRtable <- function(x, ...) {
  tmp__ <- as.data.frame(x)
  outputTable__ <- IQRoutputTable(tmp__, report = FALSE)
  cat(text_IQRoutputTable(outputTable__))
}
#'@export
as.data.frame.IQRtable <- function(x, row.names = NULL, optional = FALSE, ..., header = TRUE) {
  x__ <- as.matrix(unclass(x))
  if (header) {
    myheader__ <- x__[1,]
    x__ <- x__[-1, , drop = FALSE]
  } else {
    myheader__ <- rep("", ncol(x__))
  }
  out__ <- as.data.frame(x__, row.names = row.names, optional = optional, ...)
  colnames(out__) <- myheader__
  out__
}
#'@export
compose_IQRtable <- function(..., pattern, just = "tl") {
  tables__ <- list(...)
  if (length(tables__) == 1 & is.list(tables__[[1]])) tables__ <- tables__[[1]]
  tables__ <- lapply(tables__, as_IQRtable)
  rows__ <- strsplit(pattern, "\n")[[1]]
  nrows__ <- length(rows__)
  ncols__ <- unique(sapply(rows__, function(myrow__) length(strsplit(myrow__, "|", fixed = TRUE)[[1]])))
  if (length(ncols__) > 1)
    stopIQR("The number of columns is not uniquely defined. Check missing white space.")
  cells__ <- lapply(rows__, function(myrow__) {
    cells__ <- trimws(strsplit(myrow__, "|", fixed = TRUE)[[1]])
    lapply(cells__, function(mycell__) {
      if (mycell__ == "") return(matrix("", nrow = 1, ncol = 1))
      if (mycell__ %in% names(tables__)) return(tables__[[mycell__]])
      if (any(sapply(names(tables__), function(X) grepl(X, mycell__)))) return(with(tables__, eval(parse(text = mycell__))))
      return(matrix(mycell__, nrow = 1, ncol = 1))
    })
  })
  cells__ <- lapply(seq_len(nrows__), function(i) {
    myrow__ <- cells__[[i]]
    height__ <- max(sapply(myrow__, nrow))
    lapply(myrow__, function(mycell__) {
      grow(mycell__, height__, ncol(mycell__), just)
    })
  })
  cells__ <- lapply(seq_len(ncols__), function(j) {
    mycol__ <- lapply(cells__, function(myrow__) myrow__[[j]])
    width__ <- max(sapply(mycol__, ncol))
    lapply(mycol__, function(mycell__) {
      grow(mycell__, nrow(mycell__), width__, just)
    })
  })
  out__ <- Reduce("cbind", lapply(cells__, function(mycol__) Reduce("rbind", mycol__)))
  as_IQRtable(out__)
}
#'@export
composeByRule_IQRtable <- function(..., rule, just = "tl") {
  args__ <- list(...)
  if (length(args__) == 1 & is.list(args__[[1]])) args__ <- args__[[1]]
  out__ <- args__[[1]]
  if (length(args__) > 1) {
    for (i in 2:length(args__)) {
      x <- out__
      y <- args__[[i]]
      out__ <- compose_IQRtable(x = x, y = y, pattern = rule, just = just)
    }
  }
  as_IQRtable(out__)
}
#'@export
cjoin_IQRtable <- function(..., na.char = "--") {
  args__ <- list(...)
  if (length(args__) == 1 & is.list(args__[[1]])) args__ <- args__[[1]]
  args__ <- lapply(args__, unclass)
  out__ <- as.data.frame(args__[[1]], stringsAsFactors = FALSE)
  if (length(args__) > 1) {
    for (i in 2:length(args__)) {
      x__ <- out__
      y__ <- as.data.frame(args__[[i]], stringsAsFactors = FALSE)
      empty1__ <- which(x__[[1]] %in% "")
      empty2__ <- which(y__[[1]] %in% "")
      if (length(empty1__) > 0)
        x__[[1]][empty1__] <- paste0(".fillempty", 1:length(empty1__))
      if (length(empty2__) > 0)
        y__[[1]][empty2__] <- paste0(".fillempty", 1:length(empty2__))
      out__ <- dplyr::full_join(x__, y__, by = "V1")
    }
  }
  out__ <- as.matrix(out__)
  out__[grepl(".fillempty", out__)] <- ""
  out__[is.na(out__)] <- na.char
  as_IQRtable(out__)
}
#'@export
rjoin_IQRtable <- function(..., na.char = "--") {
  args__ <- list(...)
  if (length(args__) == 1 & is.list(args__[[1]])) args__ <- args__[[1]]
  args__ <- lapply(args__, unclass)
  args__ <- lapply(args__, t)
  args__[["na.char"]] <- na.char
  out__ <- do.call(cjoin_IQRtable, args__)
  t(out__)
}
#'@export
statSE <- function(value, se = 10, digits = NA) {
  na.chars__ <- c(".", "-")
  tmp__ <- data.frame(value, se)
  tmp__ <- lapply(tmp__, function(mycol__) {
    for (myna.char in na.chars__) mycol__[mycol__ %in% myna.char] <- NA
    utils::type.convert(as.character(mycol__))
  })
  value__ <- tmp__[[1]]
  se__ <- tmp__[[2]]
  rse__ <- abs(se__/value__)
  se_rse__ <- rse__^2
  myformat__ <- function(x, ...) {
    if (length(digits) != length(x)) digits <- rep_len(digits, length(x))
    ifelse(is.na(digits), format_GUM(x, ...), sapply(seq_along(x), function(i__) {
      myval__ <- x[i__]
      if (is.na(myval__)) return("--")
      format(x[i__], digits = digits[i__])
    }))
  }
  outfn <- function(char) {
    if (char == "value") {
      return(trimws(myformat__(value__, se__)))
    }
    if (char == "se") {
      return(trimws(myformat__(se__)))
    }
    if (char == "rse") {
      return(trimws(myformat__(rse__, se_rse__)))
    }
    if (char == "rse%") {
      return(paste0(trimws(myformat__(100*rse__, 100*se_rse__)), "%"))
    }
    if (any(char == paste0("lower.", 1:99))) {
      x <- utils::type.convert(strsplit(char, ".", fixed = TRUE)[[1]][2])
      lower__ <- stats::qnorm(0.5 - x/200, mean = value__, sd = se__)
      return(trimws(myformat__(lower__, se__)))
    }
    if (any(char == paste0("upper.", 1:99))) {
      x <- utils::type.convert(strsplit(char, ".", fixed = TRUE)[[1]][2])
      upper__ <- stats::qnorm(0.5 + x/200, mean = value__, sd = se__)
      return(trimws(myformat__(upper__, se__)))
    }
    stopIQR("Keyword not recognized")
  }
  keywords__ <-  c("value", "se",  "rse", "rse%", paste0("lower.", 1:99), paste0("upper.", 1:99))
  attr(outfn, "keywords") <- keywords__
  return(outfn)
}
#'@export
statCI <- function(value, lower, upper, CL = 0.95, digits = NA) {
  na.chars__ <- c(".", "-")
  tmp__ <- data.frame(value, lower, upper)
  tmp__ <- lapply(tmp__, function(mycol__) {
    for (myna.char in na.chars__) mycol__[mycol__ %in% myna.char] <- NA
    utils::type.convert(as.character(mycol__))
  })
  value__ <- tmp__[[1]]
  lower <- tmp__[[2]]
  upper <- tmp__[[3]]
  se.right__ <- sapply(seq_along(value__), function(i) {
    q.right__ <- function(sd) upper[i] - stats::qnorm(0.5 + CL/2, mean = value__[i], sd = sd)
    tol__ <- min(1e-3*abs(value__[i]), .Machine$double.eps^0.25)
    myroot__ <- try(stats::uniroot(q.right__, lower = .Machine$double.eps, upper = .Machine$double.xmax/2, tol = tol__)[["root"]], silent = TRUE)
    if (inherits(myroot__, "try-error"))
      return(NA)
    myroot__
  })
  se.left__ <- sapply(seq_along(value__), function(i) {
    q.left__ <- function(sd) lower[i] - stats::qnorm(0.5 - CL/2, mean = value__[i], sd = sd)
    tol__ <- min(1e-3*abs(value__[i]), .Machine$double.eps^0.25)
    myroot__ <- try(stats::uniroot(q.left__, lower = .Machine$double.eps, upper = .Machine$double.xmax/2, tol = tol__)[["root"]], silent = TRUE)
    if (inherits(myroot__, "try-error"))
      return(NA)
    myroot__
  })
  se__ <- apply(cbind(se.left__, se.right__), 1, mean)
  rse__ <- abs(apply(cbind(se.left__, se.right__), 1, mean)/value__)
  se_rse__ <- rse__^2
  myformat__ <- function(x, ...) {
    if (length(digits) != length(x)) digits <- rep_len(digits, length(x))
    ifelse(is.na(digits), format_GUM(x, ...), sapply(seq_along(x), function(i__) {
      myval__ <- x[i__]
      if (is.na(myval__)) return("--")
      format(x[i__], digits = digits[i__])
    }))
  }
  outfn <- function(char) {
    if (char == "value") {
      return(trimws(myformat__(value__, pmin(se.left__, se.right__, na.rm = TRUE))))
    }
    if (char == "se") {
      return(trimws(myformat__(se__)))
    }
    if (char == "rse") {
      return(trimws(myformat__(rse__, se_rse__)))
    }
    if (char == "rse%") {
      rse__ <- abs(se__/value__)
      se_rse__ <- rse__^2
      return(paste0(trimws(myformat__(100*rse__, 100*se_rse__)), "%"))
    }
    if (any(char == paste0("lower.", 1:99))) {
      x <- utils::type.convert(strsplit(char, ".", fixed = TRUE)[[1]][2])
      lower__ <- stats::qnorm(0.5 - x/200, mean = value__, sd = se.left__)
      return(trimws(myformat__(lower__, se.left__)))
    }
    if (any(char == paste0("upper.", 1:99))) {
      x <- utils::type.convert(strsplit(char, ".", fixed = TRUE)[[1]][2])
      upper__ <- stats::qnorm(0.5 + x/200, mean = value__, sd = se.right__)
      return(trimws(myformat__(upper__, se.right__)))
    }
    stopIQR("keyword not recognized")
  }
  keywords__ <-  c("value", "se",  "rse", "rse%", paste0("lower.", 1:99), paste0("upper.", 1:99))
  attr(outfn, "keywords") <- keywords__
  return(outfn)
}
grow <- function(M, nrow, ncol, just = "tl", fillWith = "") {
  hjust__ <- ifelse(grepl("r", just), "r", "l")
  vjust__ <- ifelse(grepl("b", just), "b", "t")
  n__ <- nrow(M)
  m__ <- ncol(M)
  nrow__ <- max(nrow, n__)
  ncol__ <- max(ncol, m__)
  out__ <- switch(hjust__,
                l = cbind(M, matrix(fillWith, nrow = n__, ncol = ncol__ - m__)),
                r = cbind(matrix(fillWith, nrow = n__, ncol = ncol__ - m__), M))
  out__ <- switch(vjust__,
                t = rbind(out__, matrix(fillWith, nrow = nrow__ - n__, ncol = ncol(out__))),
                b = rbind(matrix(fillWith, nrow = nrow__ - n__, ncol = ncol(out__)), out__))
  out__
}
#'@export
compare_IQRmodel_IQRsysModel_simulation <- function (
  model,
  simtime = NULL,
  dosingTable = NULL,
  parameters = NULL,
  filename = NULL,
  absTol = 1e-12,
  relTol = 1e-12
) {
  if (!is.null(simtime)) {
    if (length(simtime)==1) simtime <- seq(0,simtime,1)
  }
  if (!is_IQRmodel(model)) {
    if (is.character(model)) {
      if (file.exists(model)) {
        model <- IQRmodel(model)
      } else {
        stopIQR("Provided model argument could not be found as file")
      }
    } else {
      stopIQR("Incorrect model argument is not an IQRmodel")
    }
  }
  if (is.null(simtime)) {
    message("simtime not defined. simtime=seq(0,20,1) will be used for comparison.")
    simtime <- seq(0,20,1)
  }
  if (length(model$outputs) == 0) {
    stopIQR("Model requires at least one OUTPUT")
  }
  resIQR <- sim_IQRmodel(model=model,simtime=simtime,dosingTable=dosingTable,parameters=parameters,opt_abstol = absTol,opt_reltol = relTol)
  sysmodel <- tryCatch({
    IQRsysModel(model=model,dosing=dosingTable)
  }, error = function(err) {
    NULL
  })
  if (is.null(sysmodel)) {
    message("Generation of IQRsysModel failed")
    return(list(message="Generation of IQRsysModel failed",
                maxRelDiffStates = NA,
                maxRelDiffOutputs = NA,
                resIQRstates = NA,
                resSYSstates = NA,
                resIQRoutputs = NA,
                resSYSoutputs = NA))
  }
  sysmodel <- sim_IQRsysModel(sysModel = sysmodel,simtime = simtime,parameters = parameters,FLAGoutputsOnly = FALSE,SIMOPT.atol = absTol,SIMOPT.rtol = relTol)
  resSYS <- sysmodel$prediction[[1]]
  resSYS <- data.frame(
    TIME = resSYS$time,
    NAME = resSYS$name,
    VALUE = resSYS$value,
    stringsAsFactors = FALSE
  )
  resSYS <- tidyr::spread(resSYS,NAME,VALUE)
  resIQRstates <- resIQR[,c("TIME",names(model$states))]
  resIQRoutputs <- resIQR[,grepl("TIME|OUTPUT",names(resIQR))]
  resSYSstates <- resSYS[,c("TIME",names(model$states))]
  resSYSoutputs <- resSYS[,grepl("TIME|OUTPUT",names(resSYS))]
  resIQRstates <- resIQRstates[,c("TIME",setdiff(sort(names(resIQRstates)),"TIME"))]
  resSYSstates <- resSYSstates[,c("TIME",setdiff(sort(names(resSYSstates)),"TIME"))]
  resIQRoutputs <- resIQRoutputs[,c("TIME",setdiff(sort(names(resIQRoutputs)),"TIME"))]
  resSYSoutputs <- resSYSoutputs[,c("TIME",setdiff(sort(names(resSYSoutputs)),"TIME"))]
  if (any(names(resIQRstates) != names(resSYSstates))) stopIQR("State names in results are not identical")
  if (any(names(resIQRoutputs) != names(resSYSoutputs))) stopIQR("Output names in results are not identical (if model did not have an output it was added in the same manner)")
  diff <- resIQRstates-resSYSstates
  denominator <- resIQRstates
  denominator[resIQRstates==0] <- 1
  denominator[resSYSstates==0] <- 1
  relDiff <- diff/denominator
  maxRelDiffStates <- max(relDiff)
  diff <- resIQRoutputs-resSYSoutputs
  denominator <- resIQRoutputs
  denominator[resIQRoutputs==0] <- 1
  denominator[resSYSoutputs==0] <- 1
  relDiff <- diff/denominator
  maxRelDiffOutputs <- max(relDiff)
  if (!is.null(filename)) {
    plotsOutputs <- lapply(names(resIQRoutputs), function (refname) {
      compare <- rbind(
        cbind(TYPE="IQRmodel",resIQRoutputs[,c("TIME",refname)]),
        cbind(TYPE="IQRsysModel",resSYSoutputs[,c("TIME",refname)])
      )
      IQRggplot(compare,aes_string(x="TIME",y=refname,color="TYPE",linetype="TYPE")) +
        geom_line(size=1) +
        coord_cartesian(ylim=c(min(compare[[refname]])-0.1,max(compare[[refname]]+0.1))) +
        scale_color_IQRtools()
    })
    plotsStates <- lapply(names(resIQRstates), function (refname) {
      compare <- rbind(
        cbind(TYPE="IQRmodel",resIQRstates[,c("TIME",refname)]),
        cbind(TYPE="IQRsysModel",resSYSstates[,c("TIME",refname)])
      )
      IQRggplot(compare,aes_string(x="TIME",y=refname,color="TYPE",linetype="TYPE")) +
        geom_line(size=1) +
        coord_cartesian(ylim=c(min(compare[[refname]])-0.001,max(compare[[refname]]+0.001))) +
        scale_color_IQRtools()
    })
    plotList <- c(plotsOutputs,plotsStates)
    IQRoutputFigure(x = plotList,filename=filename,
                    opt.pagesize = list(scale=2,nrow=3,ncol=3),
                    opt.layout = list(legend.option = "common"))
  }
  list(message="Comparison done",
       maxRelDiffStates = maxRelDiffStates,
       maxRelDiffOutputs=maxRelDiffOutputs,
       resIQRstates = resIQRstates,
       resSYSstates = resSYSstates,
       resIQRoutputs = resIQRoutputs,
       resSYSoutputs = resSYSoutputs)
}
#'@import ggplot2
#'@useDynLib IQRtools, .registration = TRUE
NULL
#'@export
loadSetupOptions_IQRtools <- function() {
  .ALLOW_USER_SETTINGS_FILE = F
  IQRTOOLS_OVERRIDE_SETTING_COMPLIANCE_MODE = F
  if (.ALLOW_USER_SETTINGS_FILE) {
    home__ <- Sys.getenv("HOME")
    file__ <- paste0(home__,"/setup_options_IQRtools.R")
    if (file.exists(file__)) {
      source(file__)
    }
  }
}
.onAttach <- function(libname, pkgname) {
  showStartupMessage()
}
.onLoad <- function(libname, pkgname) {
}
.onUnload <- function(libpath) {
  if ("IQRtools" %in% names(getLoadedDLLs())) {
    library.dynam.unload("IQRtools", libpath)
  }
}
globalVariables(c("exportpath","allowMONOLIXgui","atrcontents","x","k__","IQRTOOLS_OVERRIDE_SETTING_COMPLIANCE_MODE",
                  "var", "VALUE",
                  "ITERATION", "TYPE", "NAME", "XNAME", "XVALUE", "YNAME", "YVALUE",  "ID", "X",
                  "High.Correlation", "CORR_INFO", "minX", "textY",  "ST", "Y", "SHOW_CORR", "DV",
                  "CENS", "Stratification", "loess",  "TIME", "XPRED", "slope", "int", "DV.IPRED.PRED",
                  ".PATH_SYSTEM_NONMEM",  ".PATH_SYSTEM_NONMEM_PARALLEL", "sd", "se", "nDataXbinwidth",
                  "INPUTS",  ".COMPLIANCE_MODE", "k", "is.zero", "TIME_DOSE_EFFECT_START",
                  "TINF", "CONDITION", "CONVERGED", "COVNAME", "COVVAL",  "INDEX",
                  "ITERATIONS", "OFV", "PARAMETERS", "PRED", "Var1", "Var2",  "WRES", "value",
                  "par", "AMT", "INPUT", "ADM", "proflist", "data",  "catInfo",
                  ".MODEL_MAX_DESIRED_PARAMETERNAME_LENGTH", ".MODEL_MAX_DESIRED_REACTIONNAME_LENGTH",
                  ".MODEL_MAX_DESIRED_STATENAME_LENGTH", ".MODEL_MAX_DESIRED_VARIABLENAME_LENGTH",
                  ".PATH_IQRreport", ".MAX_NUMBER_IQRMODEL_DLLS_LOADED", ".NLME_ORDER_CRITERION",
                  ".PATH_IQRsbml", ".ALLOW_USER_SETTINGS_FILE","meanX", "meanY", "IXGDF", "IGNORE",
                  "USUBJID",  "CENTER",
                  "SUBJECT", "INDNAME", "IND", "COMPOUND", "STUDY", "STUDYN",  "STUDYDES",
                  "PART", "EXTENS", "TRTNAME", "TRT", "TRTNAMER", "TRTR",  "VISIT", "VISNAME",
                  "BASE", "SCREEN", "TIMEUNIT", "DATEDAY",  "DATETIME", "NT", "DURATION",
                  "TYPENAME", "VALUETXT", "UNIT",  "ULOQ", "LLOQ", "ROUTE", "II", "ADDL",
                  "AE", "AEGRADE", "AESER", "AEDRGREL", "COMMENT", "TIMEPOS",
                  "EVID", "MDV", "RATE",  "YTYPE", "TAD", "DOSE", "doseNAMES", "obsNAMES",
                  "covInfo", "imputeInfo",  "methodBLLOQ",
                  ".ALLOW_UNDERSCORES_IN_PARAMETER_NAMES", "DVcolName", "IPREDcolName",
                  "IWREScolName", ".PATH_SYSTEM_MONOLIX",
                  "QUANTILE", ".RESERVED_WORD_IQRMODELS", "TIME2", "XPREDcolName", "XWREScolName",
                  "obsNames", "startTime","COLOR","MAX","MIN",
                  "MEDIAN","Q05","Q95","PARAMETER","NORM_SENS","ID_PARAMETERS",
                  "TIME.VARYING","CNAME","CVALUE","CNAME.x","CVALUE.x","CNAME.y","CVALUE.y",
                  "pos.x","pos.y","NAME.x","UNIT.x","corr","p.value","timeMin__","valueMax__","N","COLNAME",
                  "TIMEdos", "doseRecords", "yend", "ystart", "CORR","PARAMNAME","values",
                  ".VERSION_SUPPORTED_NLMIXR",
                  "LNo.x", "LNo.y", "labelDos", "lower", "p.value.small", "upper","pvalResult",
                  "BLOQ","regressorNames",
                  "resFit", "fit", "Pvalue", "Fraction", "Freq", "category",
                  "Residuals", "Pred", "fitted.values",
                  "forcings", "obj", "constr_fit", "startpars", "opt.iterlim", "lower_omega", "parframes",
                  "bestfit", "hypothesis", "bestfit", "lower_omega", "fixed_on_lower", "parametername",
                  "parametervalue", "spread", "sigma", "bloq", "parametertask",
                  "time", "condition", "belongs_to", "base_par", "name",
                  "estimated", "lloq", "lower95_parametervalue_linear", "parametervalue_linear",
                  "pred_indiv", "pred_pop", "printname", "res_indiv", "res_pop", "sigma_linear",
                  "upper95_parametervalue_linear", "wres_indiv", "wres_pop", "Condition", "pars",
                  "fixed_on_upper", "index", "optimum", "optimum, -2LL", "parameter",
                  "parvalue", "converged", "trafo",
                  "kkk__",
                  "Statistic", "GROUP", "DU", "DVari", "DVgeo", "VALUEari", "VALUEgeo",
                  "LAMZ", "PROFTIME", "slopePoints", "LABEL", "isBLQ", "b0",
                  "block", "TPRED", "TPRED0", "IPRED", "Value", "Percentile", "intmax", "intmin",
                  "maxTIME", "maxValue", "START", "Trial", "PERIODGRP",
                  "failed", "all_failed", "n_failed", "partial_failed",
                  "Index", "Value", "Parameter", "Obj", "Task", "Iteration",
                  ".OUTPUTFOLDER_SLIDES",
                  "Parameters",
                  "opt.layout", "opt.page","content","title","subtitle","footer","filename","plotdata","width","height",
                  "logLik","ROWID",".N",".SD","scaleWidth","scaleHeight","res","scaleWidth","scaleHeight",
                  "plotGrid",".RDS_FILES_OUTPUT","file.edit","val",
                  "STRAT","IQRoutputPlot","SURV","LB","UB","what","residuals","Deviance","DOSING.",
                  "paramNominal","paramPerturbed","DOSING","Sensitivity","Sign","cor","OBJ","DeltaOBJ",
                  "P_value_PH","MEDIAN.VALUE","LOW","HIGH",".LIBPATHS_FIRSTONLY",".PATH_LICENSE_FILE",
                  "TIMEtinfStart",
                  "atrPath","COVPAR","defineInfo","destination","note","path","rmdPath","setkey",
                  "xptInfo","xptPath",
                  ".PATH_IQRsbmlOut","OBSERVATION.NAME","TOTAL.OBSERVATIONS",".ALLOW_SPACES_IN_PATH",
                  "FREQPLOT","FREQPLOTCI025","FREQPLOTCI975","Naesubjects","ORDERTAB","PLOTSTRAT","PLOTX","Path","Rank",
				          "Reference OFV","Run failed","Signif","Target","dOFV","dDF","Target dOFV","included","prm","p-value",
				          "Model", "Incl. in stage","Nae","TEND"
                  ))
